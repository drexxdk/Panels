if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.userAgent.match(/Trident\/7\./)) {
    document.documentElement.classList.add('browser-not-supported');
    document.getElementsByTagName("body")[0].innerHTML =
`<main>
<h1>Internet Explorer is not supported</h1>
<p>You're using a web browser we don't support.<br />
Try one of these options to have a better experience on layoutr.</p>
<ul>
<li>Open Microsoft Edge</li>
<li><a href="https://www.google.com/chrome/">Download Google Chrome</a></li>
<li><a href="https://www.mozilla.org/firefox">Download Mozilla Firefox</a></li>
</ul>
</main>`;
    throw 'browser-not-supported';
}
/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (C, e) { "use strict"; var t = [], E = C.document, r = Object.getPrototypeOf, s = t.slice, g = t.concat, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == typeof e && "number" != typeof e.nodeType }, x = function (e) { return null != e && e === e.window }, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e } var f = "3.4.1", k = function (e, t) { return new k.fn.init(e, t) }, p = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; function d(e) { var t = !!e && "length" in e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e) } k.fn = k.prototype = { jquery: f, constructor: k, length: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = k.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return k.each(this, e) }, map: function (n) { return this.pushStack(k.map(this, function (e, t) { return n.call(e, t, e) })) }, slice: function () { return this.pushStack(s.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: u, sort: t.sort, splice: t.splice }, k.extend = k.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (k.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || k.isPlainObject(n) ? n : {}, i = !1, a[t] = k.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, k.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t) { b(e, { nonce: t && t.nonce }) }, each: function (e, t) { var n, r = 0; if (d(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, trim: function (e) { return null == e ? "" : (e + "").replace(p, "") }, makeArray: function (e, t) { var n = t || []; return null != e && (d(Object(e)) ? k.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (d(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g.apply([], a) }, guid: 1, support: y }), "function" == typeof Symbol && (k.fn[Symbol.iterator] = t[Symbol.iterator]), k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { n["[object " + t + "]"] = t.toLowerCase() }); var h = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, k = "sizzle" + 1 * new Date, m = n.document, S = 0, r = 0, p = ue(), x = ue(), N = ue(), A = ue(), D = function (e, t) { return e === t && (l = !0), 0 }, j = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", $ = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", F = new RegExp(M + "+", "g"), B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp($), V = new RegExp("^" + I + "$"), G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + $), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"), ne = function (e, t, n) { var r = "0x" + t - 65536; return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, oe = function () { T() }, ae = be(function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" }); try { H.apply(t = O.call(m.childNodes), m.childNodes), t[m.childNodes.length].nodeType } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && ((e ? e.ownerDocument || e : m) !== C && T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n } if (d.qsa && !A[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && U.test(t)) { (s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = k), o = (l = h(t)).length; while (o--) l[o] = "#" + s + " " + xe(l[o]); c = l.join(","), f = ee.test(t) && ye(e.parentNode) || e } try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { A(t, !0) } finally { s === k && e.removeAttribute("id") } } } return g(t.replace(B, "$1"), e, n, r) } function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n } } function le(e) { return e[k] = !0, e } function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function fe(e, t) { var n = e.split("|"), r = n.length; while (r--) b.attrHandle[n[r]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function de(t) { return function (e) { return "input" === e.nodeName.toLowerCase() && e.type === t } } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n } } function ge(t) { return function (e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t } } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n])) }) }) } function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML") }, T = se.setDocument = function (e) { var t, n, r = e ? e.ownerDocument || e : m; return r !== C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), m !== C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.attributes = ce(function (e) { return e.className = "i", !e.getAttribute("className") }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = k, !C.getElementsByName || !C.getElementsByName(k).length }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : [] } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { a.appendChild(e).innerHTML = "<a id='" + k + "'></a><select id='" + k + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + k + "-]").length || v.push("~="), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + k + "+*").length || v.push(".#.+[+~]") }), ce(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = C.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:") })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", $) }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, D = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e === C || e.ownerDocument === m && y(m, e) ? -1 : t === C || t.ownerDocument === m && y(m, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e === C ? -1 : t === C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] === m ? -1 : s[r] === m ? 1 : 0 }), C }, se.matches = function (e, t) { return se(e, null, null, t) }, se.matchesSelector = function (e, t) { if ((e.ownerDocument || e) !== C && T(e), d.matchesSelector && E && !A[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { A(t, !0) } return 0 < se(t, C, null, [e]).length }, se.contains = function (e, t) { return (e.ownerDocument || e) !== C && T(e), y(e, t) }, se.attr = function (e, t) { (e.ownerDocument || e) !== C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && j.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }, se.escape = function (e) { return (e + "").replace(re, ie) }, se.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(D), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) } return u = null, e }, o = se.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else while (t = e[r++]) n += o(t); return n }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = p[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && p(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(F, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")) } }, CHILD: function (h, e, t, g, v) { var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e; return 1 === g && 0 === v ? function (e) { return !!e.parentNode } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = "only" === h && !u && "nextSibling" } return !0 } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [S, s, d]; break } } else if (p && (d = s = (r = (i = (o = (a = e)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [S, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g } } }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e); return a[k] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]) }) : function (e) { return a(e, 0, t) }) : a } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace(B, "$1")); return s[k] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = !(t[a] = i)) }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() } }), has: le(function (t) { return function (e) { return 0 < se(t, e).length } }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t) } }), lang: le(function (n) { return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-") } while ((e = e.parentNode) && 1 === e.nodeType); return !1 } }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === a }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !b.pseudos.empty(e) }, header: function (e) { return J.test(e.nodeName) }, input: function (e) { return Q.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ve(function () { return [0] }), last: ve(function (e, t) { return [t - 1] }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n] }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e }), gt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1 } : function (e, t, n) { var r, i, o, a = [S, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0 } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[k] || (e[k] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === S && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1 } } function we(i) { return 1 < i.length ? function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0 } : i[0] } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Ce(d, h, g, v, y, e) { return v && !v[k] && (v = Ce(v)), y && !y[k] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n }(h || "*", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a)) } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r) } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a)) } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p) }) } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) { return e === i }, a, !0), l = be(function (e) { return -1 < P(i, e) }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[k]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace(B, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)) } c.push(t) } return we(c) } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + " "]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace(B, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? se.error(e) : x(e, s).slice(0) }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = N[e + " "]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[k] ? i.push(a) : o.push(a); (a = N(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = S += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t === C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument === C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break } i && (S = h) } m && ((o = !s && o) && u-- , e && c.push(o)) } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f) } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r) } return i && (S = h, w = p), c }, m ? le(r) : r))).selector = e } return a }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length) } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n }, d.sortStable = k.split("").sort(D).join("") === k, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")) }), ce(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || fe("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || fe("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function (e) { return null == e.getAttribute("disabled") }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), se }(C); k.find = h, k.expr = h.selectors, k.expr[":"] = k.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k.contains = h.contains, k.escapeSelector = h.escape; var T = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && k(e).is(n)) break; r.push(e) } return r }, S = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, N = k.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, n, r) { return m(n) ? k.grep(e, function (e, t) { return !!n.call(e, t, e) !== r }) : n.nodeType ? k.grep(e, function (e) { return e === n !== r }) : "string" != typeof n ? k.grep(e, function (e) { return -1 < i.call(n, e) !== r }) : k.filter(n, e, r) } k.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? k.find.matchesSelector(r, e) ? [r] : [] : k.find.matches(e, k.grep(t, function (e) { return 1 === e.nodeType })) }, k.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(k(e).filter(function () { for (t = 0; t < r; t++)if (k.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)k.find(e, i[t], n); return 1 < r ? k.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(j(this, e || [], !1)) }, not: function (e) { return this.pushStack(j(this, e || [], !0)) }, is: function (e) { return !!j(this, "string" == typeof e && N.test(e) ? k(e) : e || [], !1).length } }); var q, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (k.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || q, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : L.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof k ? t[0] : t, k.merge(this, k.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), D.test(r[1]) && k.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(k) : k.makeArray(e, this) }).prototype = k.fn, q = k(E); var H = /^(?:parents|prev(?:Until|All))/, O = { children: !0, contents: !0, next: !0, prev: !0 }; function P(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } k.fn.extend({ has: function (e) { var t = k(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (k.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && k(e); if (!N.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && k.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(1 < o.length ? k.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? i.call(k(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(k.uniqueSort(k.merge(this.get(), k(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), k.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return T(e, "parentNode") }, parentsUntil: function (e, t, n) { return T(e, "parentNode", n) }, next: function (e) { return P(e, "nextSibling") }, prev: function (e) { return P(e, "previousSibling") }, nextAll: function (e) { return T(e, "nextSibling") }, prevAll: function (e) { return T(e, "previousSibling") }, nextUntil: function (e, t, n) { return T(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return T(e, "previousSibling", n) }, siblings: function (e) { return S((e.parentNode || {}).firstChild, e) }, children: function (e) { return S(e.firstChild) }, contents: function (e) { return "undefined" != typeof e.contentDocument ? e.contentDocument : (A(e, "template") && (e = e.content || e), k.merge([], e.childNodes)) } }, function (r, i) { k.fn[r] = function (e, t) { var n = k.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = k.filter(t, n)), 1 < this.length && (O[r] || k.uniqueSort(n), H.test(r) && n.reverse()), this.pushStack(n) } }); var R = /[^\x20\t\r\n\f]+/g; function M(e) { return e } function I(e) { throw e } function W(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } k.Callbacks = function (r) { var e, n; r = "string" == typeof r ? (e = r, n = {}, k.each(e.match(R) || [], function (e, t) { n[t] = !0 }), n) : k.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) } r.memory || (t = !1), i = !1, a && (s = t ? [] : "") }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { k.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function () { return k.each(arguments, function (e, t) { var n; while (-1 < (n = k.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function (e) { return e ? -1 < k.inArray(e, s) : 0 < s.length }, empty: function () { return s && (s = []), this }, disable: function () { return a = u = [], s = t = "", this }, disabled: function () { return !s }, lock: function () { return a = u = [], t || i || (s = t = ""), this }, locked: function () { return !!a }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function () { return f.fireWith(this, arguments), this }, fired: function () { return !!o } }; return f }, k.extend({ Deferred: function (e) { var o = [["notify", "progress", k.Callbacks("memory"), k.Callbacks("memory"), 2], ["resolve", "done", k.Callbacks("once memory"), k.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", k.Callbacks("once memory"), k.Callbacks("once memory"), 1, "rejected"]], i = "pending", a = { state: function () { return i }, always: function () { return s.done(arguments).fail(arguments), this }, "catch": function (e) { return a.then(null, e) }, pipe: function () { var i = arguments; return k.Deferred(function (r) { k.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments) }) }), i = null }).promise() }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (!(i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, M, s), l(u, o, I, s)) : (u++ , t.call(e, l(u, o, M, s), l(u, o, I, s), l(u, o, M, o.notifyWith))) : (a !== M && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)) } }, t = s ? e : function () { try { e() } catch (e) { k.Deferred.exceptionHook && k.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== I && (n = void 0, r = [e]), o.rejectWith(n, r)) } }; i ? t() : (k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook()), C.setTimeout(t)) } } return k.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : M, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : M)), o[2][3].add(l(0, e, m(n) ? n : I)) }).promise() }, promise: function (e) { return null != e ? k.extend(e, a) : a } }, s = {}; return k.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this }, s[t[0] + "With"] = n.fireWith }), a.promise(s), e && e.call(s, s), s }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = k.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i) } }; if (n <= 1 && (W(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) W(i[t], a(t), o.reject); return o.promise() } }); var $ = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; k.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && $.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, k.readyException = function (e) { C.setTimeout(function () { throw e }) }; var F = k.Deferred(); function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), k.ready() } k.fn.ready = function (e) { return F.then(e)["catch"](function (e) { k.readyException(e) }), this }, k.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --k.readyWait : k.isReady) || (k.isReady = !0) !== e && 0 < --k.readyWait || F.resolveWith(E, [k]) } }), k.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(k.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B)); var _ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === w(n)) for (s in i = !0, n) _(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(k(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, z = /^-ms-/, U = /-([a-z])/g; function X(e, t) { return t.toUpperCase() } function V(e) { return e.replace(z, "ms-").replace(U, X) } var G = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function Y() { this.expando = k.expando + Y.uid++ } Y.uid = 1, Y.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, G(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[V(t)] = n; else for (r in t) i[V(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][V(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(V) : (t = V(t)) in r ? [t] : t.match(R) || []).length; while (n--) delete r[t[n]] } (void 0 === t || k.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !k.isEmptyObject(t) } }; var Q = new Y, J = new Y, K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Z = /[A-Z]/g; function ee(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(Z, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : K.test(i) ? JSON.parse(i) : i) } catch (e) { } J.set(e, t, n) } else n = void 0; return n } k.extend({ hasData: function (e) { return J.hasData(e) || Q.hasData(e) }, data: function (e, t, n) { return J.access(e, t, n) }, removeData: function (e, t) { J.remove(e, t) }, _data: function (e, t, n) { return Q.access(e, t, n) }, _removeData: function (e, t) { Q.remove(e, t) } }), k.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = J.get(o), 1 === o.nodeType && !Q.get(o, "hasDataAttrs"))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = V(r.slice(5)), ee(o, r, i[r])); Q.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof n ? this.each(function () { J.set(this, n) }) : _(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = J.get(o, n)) ? t : void 0 !== (t = ee(o, n)) ? t : void 0; this.each(function () { J.set(this, n, e) }) }, null, e, 1 < arguments.length, null, !0) }, removeData: function (e) { return this.each(function () { J.remove(this, e) }) } }), k.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Q.get(e, t), n && (!r || Array.isArray(n) ? r = Q.access(e, t, k.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = k.queue(e, t), r = n.length, i = n.shift(), o = k._queueHooks(e, t); "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () { k.dequeue(e, t) }, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Q.get(e, n) || Q.access(e, n, { empty: k.Callbacks("once memory").add(function () { Q.remove(e, [t + "queue", n]) }) }) } }), k.fn.extend({ queue: function (t, n) { var e = 2; return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? k.queue(this[0], t) : void 0 === n ? this : this.each(function () { var e = k.queue(this, t, n); k._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && k.dequeue(this, t) }) }, dequeue: function (e) { return this.each(function () { k.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = k.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = Q.get(o[a], e + "queueHooks")) && n.empty && (r++ , n.empty.add(s)); return s(), i.promise(t) } }); var te = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ne = new RegExp("^(?:([+-])=|)(" + te + ")([a-z%]*)$", "i"), re = ["Top", "Right", "Bottom", "Left"], ie = E.documentElement, oe = function (e) { return k.contains(e.ownerDocument, e) }, ae = { composed: !0 }; ie.getRootNode && (oe = function (e) { return k.contains(e.ownerDocument, e) || e.getRootNode(ae) === e.ownerDocument }); var se = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && oe(e) && "none" === k.css(e, "display") }, ue = function (e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o]; for (o in i = n.apply(e, r || []), t) e.style[o] = a[o]; return i }; function le(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return k.css(e, t, "") }, u = s(), l = n && n[3] || (k.cssNumber[t] ? "" : "px"), c = e.nodeType && (k.cssNumber[t] || "px" !== l && +u) && ne.exec(k.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) k.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, k.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var ce = {}; function fe(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Q.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && se(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ce[s]) || (o = a.body.appendChild(a.createElement(s)), u = k.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ce[s] = u)))) : "none" !== n && (l[c] = "none", Q.set(r, "display", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e } k.fn.extend({ show: function () { return fe(this, !0) }, hide: function () { return fe(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { se(this) ? k(this).show() : k(this).hide() }) } }); var pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i, ge = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? k.merge([e], n) : n } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval")) } ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; var me, xe, be = /<|&#?\w+;/; function we(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === w(o)) k.merge(p, o.nodeType ? [o] : o); else if (be.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + k.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; k.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && -1 < k.inArray(o, r)) i && i.push(o); else if (l = oe(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } me = E.createDocumentFragment().appendChild(E.createElement("div")), (xe = E.createElement("input")).setAttribute("type", "radio"), xe.setAttribute("checked", "checked"), xe.setAttribute("name", "t"), me.appendChild(xe), y.checkClone = me.cloneNode(!0).cloneNode(!0).lastChild.checked, me.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!me.cloneNode(!0).lastChild.defaultValue; var Te = /^key/, Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Ee = /^([^.]*)(?:\.(.+)|)/; function ke() { return !0 } function Se() { return !1 } function Ne(e, t) { return e === function () { try { return E.activeElement } catch (e) { } }() == ("focus" === t) } function Ae(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ae(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Se; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return k().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = k.guid++)), e.each(function () { k.event.add(this, t, i, r, n) }) } function De(e, i, o) { o ? (Q.set(e, i, !1), k.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Q.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (k.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Q.set(this, i, r), t = o(this, i), this[i](), r !== (n = Q.get(this, i)) || t ? Q.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n.value } else r.length && (Q.set(this, i, { value: k.event.trigger(k.extend(r[0], k.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Q.get(e, i) && k.event.add(e, i, ke) } k.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Q.get(t); if (v) { n.handler && (n = (o = n).handler, i = o.selector), i && k.find.matchesSelector(ie, i), n.guid || (n.guid = k.guid++), (u = v.events) || (u = v.events = {}), (a = v.handle) || (a = v.handle = function (e) { return "undefined" != typeof k && k.event.triggered !== e.type ? k.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || "").match(R) || [""]).length; while (l--) d = g = (s = Ee.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = k.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = k.event.special[d] || {}, c = k.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && k.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), k.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Q.hasData(e) && Q.get(e); if (v && (u = v.events)) { l = (t = (t || "").match(R) || [""]).length; while (l--) if (d = g = (s = Ee.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) { f = k.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount-- , f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || k.removeEvent(e, d, v.handle), delete u[d]) } else for (d in u) k.event.remove(e, d + t[l], n, r, !0); k.isEmptyObject(u) && Q.remove(e, "handle events") } }, dispatch: function (e) { var t, n, r, i, o, a, s = k.event.fix(e), u = new Array(arguments.length), l = (Q.get(this, "events") || {})[s.type] || [], c = k.event.special[s.type] || {}; for (u[0] = s, t = 1; t < arguments.length; t++)u[t] = arguments[t]; if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) { a = k.event.handlers.call(this, s, l), t = 0; while ((i = a[t++]) && !s.isPropagationStopped()) { s.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !s.isImmediatePropagationStopped()) s.rnamespace && !1 !== o.namespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((k.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, u)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, s), s.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < k(i, this).index(l) : k.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (t, e) { Object.defineProperty(k.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (e) { return e[k.expando] ? e : new k.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && De(t, "click", ke), !1 }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && De(t, "click"), !0 }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Q.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, k.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, k.Event = function (e, t) { if (!(this instanceof k.Event)) return new k.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? ke : Se, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && k.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[k.expando] = !0 }, k.Event.prototype = { constructor: k.Event, isDefaultPrevented: Se, isPropagationStopped: Se, isImmediatePropagationStopped: Se, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = ke, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = ke, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = ke, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, k.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && Te.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Ce.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, k.event.addProp), k.each({ focus: "focusin", blur: "focusout" }, function (e, t) { k.event.special[e] = { setup: function () { return De(this, e, Ne), !1 }, trigger: function () { return De(this, e), !0 }, delegateType: t } }), k.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, i) { k.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || k.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t } } }), k.fn.extend({ on: function (e, t, n, r) { return Ae(this, e, t, n, r) }, one: function (e, t, n, r) { return Ae(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, k(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Se), this.each(function () { k.event.remove(this, e, n, t) }) } }); var je = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, qe = /<script|<style|<link/i, Le = /checked\s*(?:[^=]|=\s*.checked.)/i, He = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function Oe(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && k(e).children("tbody")[0] || e } function Pe(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function Re(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Me(e, t) { var n, r, i, o, a, s, u, l; if (1 === t.nodeType) { if (Q.hasData(e) && (o = Q.access(e), a = Q.set(t, o), l = o.events)) for (i in delete a.handle, a.events = {}, l) for (n = 0, r = l[i].length; n < r; n++)k.event.add(t, i, l[i][n]); J.hasData(e) && (s = J.access(e), u = k.extend({}, s), J.set(t, u)) } } function Ie(n, r, i, o) { r = g.apply([], r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && "string" == typeof d && !y.checkClone && Le.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), Ie(t, r, i, o) }); if (f && (t = (e = we(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = k.map(ve(e, "script"), Pe)).length; c < f; c++)u = e, c !== p && (u = k.clone(u, !0, !0), s && k.merge(a, ve(u, "script"))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, k.map(a, Re), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Q.access(u, "globalEval") && k.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? k._evalUrl && !u.noModule && k._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }) : b(u.textContent.replace(He, ""), u, l)) } return n } function We(e, t, n) { for (var r, i = t ? k.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || k.cleanData(ve(r)), r.parentNode && (n && oe(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e } k.extend({ htmlPrefilter: function (e) { return e.replace(je, "<$1></$2>") }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = oe(e); if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || k.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Me(o[r], a[r]); else Me(e, c); return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c }, cleanData: function (e) { for (var t, n, r, i = k.event.special, o = 0; void 0 !== (n = e[o]); o++)if (G(n)) { if (t = n[Q.expando]) { if (t.events) for (r in t.events) i[r] ? k.event.remove(n, r) : k.removeEvent(n, r, t.handle); n[Q.expando] = void 0 } n[J.expando] && (n[J.expando] = void 0) } } }), k.fn.extend({ detach: function (e) { return We(this, e, !0) }, remove: function (e) { return We(this, e) }, text: function (e) { return _(this, function (e) { return void 0 === e ? k.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return Ie(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e) }) }, prepend: function () { return Ie(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Oe(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return Ie(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return Ie(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (k.cleanData(ve(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return k.clone(this, e, t) }) }, html: function (e) { return _(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !qe.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = k.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (k.cleanData(ve(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var n = []; return Ie(this, arguments, function (e) { var t = this.parentNode; k.inArray(this, n) < 0 && (k.cleanData(ve(this)), t && t.replaceChild(e, this)) }, n) } }), k.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, a) { k.fn[e] = function (e) { for (var t, n = [], r = k(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), k(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } }); var $e = new RegExp("^(" + te + ")(?!px)[a-z%]+$", "i"), Fe = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) }, Be = new RegExp(re.join("|"), "i"); function _e(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Fe(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || oe(e) || (a = k.style(e, t)), !y.pixelBoxStyles() && $e.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function ze(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (u) { s.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ie.appendChild(s).appendChild(u); var e = C.getComputedStyle(u); n = "1%" !== e.top, a = 12 === t(e.marginLeft), u.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", i = 12 === t(u.offsetWidth / 3), ie.removeChild(s), u = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, i, o, a, s = E.createElement("div"), u = E.createElement("div"); u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === u.style.backgroundClip, k.extend(y, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), a }, scrollboxSize: function () { return e(), i } })) }(); var Ue = ["Webkit", "Moz", "ms"], Xe = E.createElement("div").style, Ve = {}; function Ge(e) { var t = k.cssProps[e] || Ve[e]; return t || (e in Xe ? e : Ve[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = Ue.length; while (n--) if ((e = Ue[n] + t) in Xe) return e }(e) || e) } var Ye = /^(none|table(?!-c[ea]).+)/, Qe = /^--/, Je = { position: "absolute", visibility: "hidden", display: "block" }, Ke = { letterSpacing: "0", fontWeight: "400" }; function Ze(e, t, n) { var r = ne.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function et(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += k.css(e, n + re[a], !0, i)), r ? ("content" === n && (u -= k.css(e, "padding" + re[a], !0, i)), "margin" !== n && (u -= k.css(e, "border" + re[a] + "Width", !0, i))) : (u += k.css(e, "padding" + re[a], !0, i), "padding" !== n ? u += k.css(e, "border" + re[a] + "Width", !0, i) : s += k.css(e, "border" + re[a] + "Width", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u } function tt(e, t, n) { var r = Fe(e), i = (!y.boxSizingReliable() || n) && "border-box" === k.css(e, "boxSizing", !1, r), o = i, a = _e(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1); if ($e.test(a)) { if (!n) return a; a = "auto" } return (!y.boxSizingReliable() && i || "auto" === a || !parseFloat(a) && "inline" === k.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === k.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + et(e, t, n || (i ? "border" : "content"), o, r, a) + "px" } function nt(e, t, n, r, i) { return new nt.prototype.init(e, t, n, r, i) } k.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = _e(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = V(t), u = Qe.test(t), l = e.style; if (u || (t = Ge(s)), a = k.cssHooks[t] || k.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" === (o = typeof n) && (i = ne.exec(n)) && i[1] && (n = le(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (k.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = V(t); return Qe.test(t) || (t = Ge(s)), (a = k.cssHooks[t] || k.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = _e(e, t, r)), "normal" === i && t in Ke && (i = Ke[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), k.each(["height", "width"], function (e, u) { k.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ye.test(k.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? tt(e, u, n) : ue(e, Je, function () { return tt(e, u, n) }) }, set: function (e, t, n) { var r, i = Fe(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === k.css(e, "boxSizing", !1, i), s = n ? et(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - et(e, u, "border", !1, i) - .5)), s && (r = ne.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = k.css(e, u)), Ze(0, t, s) } } }), k.cssHooks.marginLeft = ze(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(_e(e, "marginLeft")) || e.getBoundingClientRect().left - ue(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), k.each({ margin: "", padding: "", border: "Width" }, function (i, o) { k.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)n[i + re[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, "margin" !== i && (k.cssHooks[i + o].set = Ze) }), k.fn.extend({ css: function (e, t) { return _(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Fe(e), i = t.length; a < i; a++)o[t[a]] = k.css(e, t[a], !1, r); return o } return void 0 !== n ? k.style(e, t, n) : k.css(e, t) }, e, t, 1 < arguments.length) } }), ((k.Tween = nt).prototype = { constructor: nt, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || k.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (k.cssNumber[n] ? "" : "px") }, cur: function () { var e = nt.propHooks[this.prop]; return e && e.get ? e.get(this) : nt.propHooks._default.get(this) }, run: function (e) { var t, n = nt.propHooks[this.prop]; return this.options.duration ? this.pos = t = k.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : nt.propHooks._default.set(this), this } }).init.prototype = nt.prototype, (nt.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = k.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { k.fx.step[e.prop] ? k.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !k.cssHooks[e.prop] && null == e.elem.style[Ge(e.prop)] ? e.elem[e.prop] = e.now : k.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = nt.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, k.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, k.fx = nt.prototype.init, k.fx.step = {}; var rt, it, ot, at, st = /^(?:toggle|show|hide)$/, ut = /queueHooks$/; function lt() { it && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(lt) : C.setTimeout(lt, k.fx.interval), k.fx.tick()) } function ct() { return C.setTimeout(function () { rt = void 0 }), rt = Date.now() } function ft(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = re[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function pt(e, t, n) { for (var r, i = (dt.tweeners[t] || []).concat(dt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function dt(o, e, t) { var n, a, r = 0, i = dt.prefilters.length, s = k.Deferred().always(function () { delete u.elem }), u = function () { if (a) return !1; for (var e = rt || ct(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) }, l = s.promise({ elem: o, props: k.extend({}, e), opts: k.extend(!0, { specialEasing: {}, easing: k.easing._default }, t), originalProperties: e, originalOptions: t, startTime: rt || ct(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = k.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = V(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = k.cssHooks[r]) && "expand" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i }(c, l.opts.specialEasing); r < i; r++)if (n = dt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (k._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return k.map(c, pt, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), k.fx.timer(k.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l } k.Animation = k.extend(dt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return le(n.elem, e, ne.exec(t), n), n }] }, tweener: function (e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(R); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], dt.tweeners[n] = dt.tweeners[n] || [], dt.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && se(e), v = Q.get(e, "fxshow"); for (r in n.queue || (null == (a = k._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++ , p.always(function () { p.always(function () { a.unqueued-- , k.queue(e, "fx").length || a.empty.fire() }) })), t) if (i = t[r], st.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !v || void 0 === v[r]) continue; g = !0 } d[r] = v && v[r] || k.style(e, r) } if ((u = !k.isEmptyObject(t)) || !k.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Q.get(e, "display")), "none" === (c = k.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = k.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === k.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Q.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && fe([e], !0), p.done(function () { for (r in g || fe([e]), Q.remove(e, "fxshow"), d) k.style(e, r, d[r]) })), u = pt(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) { t ? dt.prefilters.unshift(e) : dt.prefilters.push(e) } }), k.speed = function (e, t, n) { var r = e && "object" == typeof e ? k.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return k.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in k.fx.speeds ? r.duration = k.fx.speeds[r.duration] : r.duration = k.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && k.dequeue(this, r.queue) }, r }, k.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(se).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (t, e, n, r) { var i = k.isEmptyObject(t), o = k.speed(e, n, r), a = function () { var e = dt(this, k.extend({}, t), o); (i || Q.get(this, "finish")) && e.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o) }; return "string" != typeof i && (o = e, e = i, i = void 0), e && !1 !== i && this.queue(i || "fx", []), this.each(function () { var e = !0, t = null != i && i + "queueHooks", n = k.timers, r = Q.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && ut.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || k.dequeue(this, i) }) }, finish: function (a) { return !1 !== a && (a = a || "fx"), this.each(function () { var e, t = Q.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = k.timers, o = n ? n.length : 0; for (t.finish = !0, k.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish }) } }), k.each(["toggle", "show", "hide"], function (e, r) { var i = k.fn[r]; k.fn[r] = function (e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(ft(r, !0), e, t, n) } }), k.each({ slideDown: ft("show"), slideUp: ft("hide"), slideToggle: ft("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, r) { k.fn[e] = function (e, t, n) { return this.animate(r, e, t, n) } }), k.timers = [], k.fx.tick = function () { var e, t = 0, n = k.timers; for (rt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || k.fx.stop(), rt = void 0 }, k.fx.timer = function (e) { k.timers.push(e), k.fx.start() }, k.fx.interval = 13, k.fx.start = function () { it || (it = !0, lt()) }, k.fx.stop = function () { it = null }, k.fx.speeds = { slow: 600, fast: 200, _default: 400 }, k.fn.delay = function (r, e) { return r = k.fx && k.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n) } }) }, ot = E.createElement("input"), at = E.createElement("select").appendChild(E.createElement("option")), ot.type = "checkbox", y.checkOn = "" !== ot.value, y.optSelected = at.selected, (ot = E.createElement("input")).value = "t", ot.type = "radio", y.radioValue = "t" === ot.value; var ht, gt = k.expr.attrHandle; k.fn.extend({ attr: function (e, t) { return _(this, k.attr, e, t, 1 < arguments.length) }, removeAttr: function (e) { return this.each(function () { k.removeAttr(this, e) }) } }), k.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? k.prop(e, t, n) : (1 === o && k.isXMLDoc(e) || (i = k.attrHooks[t.toLowerCase()] || (k.expr.match.bool.test(t) ? ht : void 0)), void 0 !== n ? null === n ? void k.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = k.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(R); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), ht = { set: function (e, t, n) { return !1 === t ? k.removeAttr(e, n) : e.setAttribute(n, n), n } }, k.each(k.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = gt[t] || k.find.attr; gt[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = gt[o], gt[o] = r, r = null != a(e, t, n) ? o : null, gt[o] = i), r } }); var vt = /^(?:input|select|textarea|button)$/i, yt = /^(?:a|area)$/i; function mt(e) { return (e.match(R) || []).join(" ") } function xt(e) { return e.getAttribute && e.getAttribute("class") || "" } function bt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(R) || [] } k.fn.extend({ prop: function (e, t) { return _(this, k.prop, e, t, 1 < arguments.length) }, removeProp: function (e) { return this.each(function () { delete this[k.propFix[e] || e] }) } }), k.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && k.isXMLDoc(e) || (t = k.propFix[t] || t, i = k.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = k.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : vt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (k.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), k.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { k.propFix[this.toLowerCase()] = this }), k.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { k(this).addClass(t.call(this, e, xt(this))) }); if ((e = bt(t)).length) while (n = this[u++]) if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") { a = 0; while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = mt(r)) && n.setAttribute("class", s) } return this }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { k(this).removeClass(t.call(this, e, xt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((e = bt(t)).length) while (n = this[u++]) if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") { a = 0; while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " "); i !== (s = mt(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (i, t) { var o = typeof i, a = "string" === o || Array.isArray(i); return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { k(this).toggleClass(i.call(this, e, xt(this), t), t) }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = k(this), r = bt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && "boolean" !== o || ((e = xt(this)) && Q.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Q.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + mt(xt(n)) + " ").indexOf(t)) return !0; return !1 } }); var wt = /\r/g; k.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, k(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = k.map(t, function (e) { return null == e ? "" : e + "" })), (r = k.valHooks[this.type] || k.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t)) })) : t ? (r = k.valHooks[t.type] || k.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(wt, "") : null == e ? "" : e : void 0 } }), k.extend({ valHooks: { option: { get: function (e) { var t = k.find.attr(e, "value"); return null != t ? t : mt(k.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = k(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = k.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < k.inArray(k.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), k.each(["radio", "checkbox"], function () { k.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < k.inArray(k(e).val(), t) } }, y.checkOn || (k.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), y.focusin = "onfocusin" in C; var Tt = /^(?:focusinfocus|focusoutblur)$/, Ct = function (e) { e.stopPropagation() }; k.extend(k.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !Tt.test(d + k.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[k.expando] ? e : new k.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : k.makeArray(t, [e]), c = k.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, Tt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C) } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Q.get(o, "events") || {})[e.type] && Q.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && G(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !G(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), k.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Ct), n[d](), e.isPropagationStopped() && f.removeEventListener(d, Ct), k.event.triggered = void 0, a && (n[u] = a)), e.result } }, simulate: function (e, t, n) { var r = k.extend(new k.Event, n, { type: e, isSimulated: !0 }); k.event.trigger(r, null, t) } }), k.fn.extend({ trigger: function (e, t) { return this.each(function () { k.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return k.event.trigger(e, t, n, !0) } }), y.focusin || k.each({ focus: "focusin", blur: "focusout" }, function (n, r) { var i = function (e) { k.event.simulate(r, e.target, k.event.fix(e)) }; k.event.special[r] = { setup: function () { var e = this.ownerDocument || this, t = Q.access(e, r); t || e.addEventListener(n, i, !0), Q.access(e, r, (t || 0) + 1) }, teardown: function () { var e = this.ownerDocument || this, t = Q.access(e, r) - 1; t ? Q.access(e, r, t) : (e.removeEventListener(n, i, !0), Q.remove(e, r)) } } }); var Et = C.location, kt = Date.now(), St = /\?/; k.parseXML = function (e) { var t; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml") } catch (e) { t = void 0 } return t && !t.getElementsByTagName("parsererror").length || k.error("Invalid XML: " + e), t }; var Nt = /\[\]$/, At = /\r?\n/g, Dt = /^(?:submit|button|image|reset|file)$/i, jt = /^(?:input|select|textarea|keygen)/i; function qt(n, e, r, i) { var t; if (Array.isArray(e)) k.each(e, function (e, t) { r || Nt.test(n) ? i(n, t) : qt(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i) }); else if (r || "object" !== w(e)) i(n, e); else for (t in e) qt(n + "[" + t + "]", e[t], r, i) } k.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !k.isPlainObject(e)) k.each(e, function () { i(this.name, this.value) }); else for (n in e) qt(n, e[n], t, i); return r.join("&") }, k.fn.extend({ serialize: function () { return k.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = k.prop(this, "elements"); return e ? k.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !k(this).is(":disabled") && jt.test(this.nodeName) && !Dt.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = k(this).val(); return null == n ? null : Array.isArray(n) ? k.map(n, function (e) { return { name: t.name, value: e.replace(At, "\r\n") } }) : { name: t.name, value: n.replace(At, "\r\n") } }).get() } }); var Lt = /%20/g, Ht = /#.*$/, Ot = /([?&])_=[^&]*/, Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Rt = /^(?:GET|HEAD)$/, Mt = /^\/\//, It = {}, Wt = {}, $t = "*/".concat("*"), Ft = E.createElement("a"); function Bt(o) { return function (e, t) { "string" != typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase().match(R) || []; if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function _t(t, i, o, a) { var s = {}, u = t === Wt; function l(e) { var r; return s[e] = !0, k.each(t[e] || [], function (e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s["*"] && l("*") } function zt(e, t) { var n, r, i = k.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && k.extend(!0, e, r), e } Ft.href = Et.href, k.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Et.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": $t, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": k.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? zt(zt(e, k.ajaxSettings), t) : zt(k.ajaxSettings, e) }, ajaxPrefilter: Bt(It), ajaxTransport: Bt(Wt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = k.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? k(y) : k.event, x = k.Deferred(), b = k.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = Pt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) } t = n[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return h ? p : null }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || Et.href) + "").replace(Mt, Et.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(R) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Ft.protocol + "//" + Ft.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && "string" != typeof v.data && (v.data = k.param(v.data, v.traditional)), _t(It, v, t, T), h) return T; for (i in (g = k.event && v.global) && 0 == k.active++ && k.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Rt.test(v.type), f = v.url.replace(Ht, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Lt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (St.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Ot, "$1"), o = (St.test(f) ? "&" : "?") + "_=" + kt++ + o), v.url = f + o), v.ifModified && (k.lastModified[f] && T.setRequestHeader("If-Modified-Since", k.lastModified[f]), k.etag[f] && T.setRequestHeader("If-None-Match", k.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = _t(Wt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort("timeout") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (k.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (k.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --k.active || k.event.trigger("ajaxStop"))) } return T }, getJSON: function (e, t, n) { return k.get(e, t, n, "json") }, getScript: function (e, t) { return k.get(e, void 0, t, "script") } }), k.each(["get", "post"], function (e, i) { k[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), k.ajax(k.extend({ url: e, type: i, dataType: r, data: t, success: n }, k.isPlainObject(e) && e)) } }), k._evalUrl = function (e, t) { return k.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { k.globalEval(e, t) } }) }, k.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = k(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (n) { return m(n) ? this.each(function (e) { k(this).wrapInner(n.call(this, e)) }) : this.each(function () { var e = k(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function (t) { var n = m(t); return this.each(function (e) { k(this).wrapAll(n ? t.call(this, e) : t) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { k(this).replaceWith(this.childNodes) }), this } }), k.expr.pseudos.hidden = function (e) { return !k.expr.pseudos.visible(e) }, k.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, k.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest } catch (e) { } }; var Ut = { 0: 200, 1223: 204 }, Xt = k.ajaxSettings.xhr(); y.cors = !!Xt && "withCredentials" in Xt, y.ajax = Xt = !!Xt, k.ajaxTransport(function (i) { var o, a; if (y.cors || Xt && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Ut[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a() }) }, o = o("abort"); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function () { o && o() } } }), k.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), k.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return k.globalEval(e), e } } }), k.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), k.ajaxTransport("script", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = k("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function (e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function () { i && i() } } }); var Vt, Gt = [], Yt = /(=)\?(?=&|$)|\?\?/; k.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Gt.pop() || k.expando + "_" + kt++; return this[e] = !0, e } }), k.ajaxPrefilter("json jsonp", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Yt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Yt.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Yt, "$1" + r) : !1 !== e.jsonp && (e.url += (St.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return o || k.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function () { o = arguments }, n.always(function () { void 0 === i ? k(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((Vt = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Vt.childNodes.length), k.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = D.exec(e)) ? [t.createElement(i[1])] : (i = we([e], t, o), o && o.length && k(o).remove(), k.merge([], i.childNodes))); var r, i, o }, k.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = mt(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && k.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? k("<div>").append(k.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, k.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { k.fn[t] = function (e) { return this.on(t, e) } }), k.expr.pseudos.animated = function (t) { return k.grep(k.timers, function (e) { return t === e.elem }).length }, k.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = k.css(e, "position"), c = k(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = k.css(e, "top"), u = k.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, k.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f) } }, k.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { k.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === k.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === k.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = k(e).offset()).top += k.css(e, "borderTopWidth", !0), i.left += k.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - k.css(r, "marginTop", !0), left: t.left - i.left - k.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === k.css(e, "position")) e = e.offsetParent; return e || ie }) } }), k.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (t, i) { var o = "pageYOffset" === i; k.fn[t] = function (e) { return _(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), k.each(["top", "left"], function (e, n) { k.cssHooks[n] = ze(y.pixelPosition, function (e, t) { if (t) return t = _e(e, n), $e.test(t) ? k(e).position()[n] + "px" : t }) }), k.each({ Height: "height", Width: "width" }, function (a, s) { k.each({ padding: "inner" + a, content: s, "": "outer" + a }, function (r, o) { k.fn[o] = function (e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return _(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? k.css(e, t, i) : k.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) { k.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }), k.fn.extend({ hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), k.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) } }), k.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || k.guid++ , i }, k.holdReady = function (e) { e ? k.readyWait++ : k.ready(!0) }, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = function (e) { var t = k.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, "function" == typeof define && define.amd && define("jquery", [], function () { return k }); var Qt = C.jQuery, Jt = C.$; return k.noConflict = function (e) { return C.$ === k && (C.$ = Jt), e && C.jQuery === k && (C.jQuery = Qt), k }, e || (C.jQuery = C.$ = k), k });
/*! jQuery Validation Plugin - v1.17.0 - 7/29/2017
 * https://jqueryvalidation.org/
 * Copyright (c) 2017 Jörn Zaefferer; Licensed MIT */
!function (a) { "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof module && module.exports ? module.exports = a(require("jquery")) : a(jQuery) }(function (a) { a.extend(a.fn, { validate: function (b) { if (!this.length) return void (b && b.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")); var c = a.data(this[0], "validator"); return c ? c : (this.attr("novalidate", "novalidate"), c = new a.validator(b, this[0]), a.data(this[0], "validator", c), c.settings.onsubmit && (this.on("click.validate", ":submit", function (b) { c.submitButton = b.currentTarget, a(this).hasClass("cancel") && (c.cancelSubmit = !0), void 0 !== a(this).attr("formnovalidate") && (c.cancelSubmit = !0) }), this.on("submit.validate", function (b) { function d() { var d, e; return c.submitButton && (c.settings.submitHandler || c.formSubmitted) && (d = a("<input type='hidden'/>").attr("name", c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)), !c.settings.submitHandler || (e = c.settings.submitHandler.call(c, c.currentForm, b), d && d.remove(), void 0 !== e && e) } return c.settings.debug && b.preventDefault(), c.cancelSubmit ? (c.cancelSubmit = !1, d()) : c.form() ? c.pendingRequest ? (c.formSubmitted = !0, !1) : d() : (c.focusInvalid(), !1) })), c) }, valid: function () { var b, c, d; return a(this[0]).is("form") ? b = this.validate().form() : (d = [], b = !0, c = a(this[0].form).validate(), this.each(function () { b = c.element(this) && b, b || (d = d.concat(c.errorList)) }), c.errorList = d), b }, rules: function (b, c) { var d, e, f, g, h, i, j = this[0]; if (null != j && (!j.form && j.hasAttribute("contenteditable") && (j.form = this.closest("form")[0], j.name = this.attr("name")), null != j.form)) { if (b) switch (d = a.data(j.form, "validator").settings, e = d.rules, f = a.validator.staticRules(j), b) { case "add": a.extend(f, a.validator.normalizeRule(c)), delete f.messages, e[j.name] = f, c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages)); break; case "remove": return c ? (i = {}, a.each(c.split(/\s/), function (a, b) { i[b] = f[b], delete f[b] }), i) : (delete e[j.name], f) }return g = a.validator.normalizeRules(a.extend({}, a.validator.classRules(j), a.validator.attributeRules(j), a.validator.dataRules(j), a.validator.staticRules(j)), j), g.required && (h = g.required, delete g.required, g = a.extend({ required: h }, g)), g.remote && (h = g.remote, delete g.remote, g = a.extend(g, { remote: h })), g } } }), a.extend(a.expr.pseudos || a.expr[":"], { blank: function (b) { return !a.trim("" + a(b).val()) }, filled: function (b) { var c = a(b).val(); return null !== c && !!a.trim("" + c) }, unchecked: function (b) { return !a(b).prop("checked") } }), a.validator = function (b, c) { this.settings = a.extend(!0, {}, a.validator.defaults, b), this.currentForm = c, this.init() }, a.validator.format = function (b, c) { return 1 === arguments.length ? function () { var c = a.makeArray(arguments); return c.unshift(b), a.validator.format.apply(this, c) } : void 0 === c ? b : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)), c.constructor !== Array && (c = [c]), a.each(c, function (a, c) { b = b.replace(new RegExp("\\{" + a + "\\}", "g"), function () { return c }) }), b) }, a.extend(a.validator, { defaults: { messages: {}, groups: {}, rules: {}, errorClass: "error", pendingClass: "pending", validClass: "valid", errorElement: "label", focusCleanup: !1, focusInvalid: !0, errorContainer: a([]), errorLabelContainer: a([]), onsubmit: !0, ignore: ":hidden", ignoreTitle: !1, onfocusin: function (a) { this.lastActive = a, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(a))) }, onfocusout: function (a) { this.checkable(a) || !(a.name in this.submitted) && this.optional(a) || this.element(a) }, onkeyup: function (b, c) { var d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225]; 9 === c.which && "" === this.elementValue(b) || a.inArray(c.keyCode, d) !== -1 || (b.name in this.submitted || b.name in this.invalid) && this.element(b) }, onclick: function (a) { a.name in this.submitted ? this.element(a) : a.parentNode.name in this.submitted && this.element(a.parentNode) }, highlight: function (b, c, d) { "radio" === b.type ? this.findByName(b.name).addClass(c).removeClass(d) : a(b).addClass(c).removeClass(d) }, unhighlight: function (b, c, d) { "radio" === b.type ? this.findByName(b.name).removeClass(c).addClass(d) : a(b).removeClass(c).addClass(d) } }, setDefaults: function (b) { a.extend(a.validator.defaults, b) }, messages: { required: "This field is required.", remote: "Please fix this field.", email: "Please enter a valid email address.", url: "Please enter a valid URL.", date: "Please enter a valid date.", dateISO: "Please enter a valid date (ISO).", number: "Please enter a valid number.", digits: "Please enter only digits.", equalTo: "Please enter the same value again.", maxlength: a.validator.format("Please enter no more than {0} characters."), minlength: a.validator.format("Please enter at least {0} characters."), rangelength: a.validator.format("Please enter a value between {0} and {1} characters long."), range: a.validator.format("Please enter a value between {0} and {1}."), max: a.validator.format("Please enter a value less than or equal to {0}."), min: a.validator.format("Please enter a value greater than or equal to {0}."), step: a.validator.format("Please enter a multiple of {0}.") }, autoCreateRanges: !1, prototype: { init: function () { function b(b) { !this.form && this.hasAttribute("contenteditable") && (this.form = a(this).closest("form")[0], this.name = a(this).attr("name")); var c = a.data(this.form, "validator"), d = "on" + b.type.replace(/^validate/, ""), e = c.settings; e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b) } this.labelContainer = a(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || a(this.currentForm), this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset(); var c, d = this.groups = {}; a.each(this.settings.groups, function (b, c) { "string" == typeof c && (c = c.split(/\s/)), a.each(c, function (a, c) { d[c] = b }) }), c = this.settings.rules, a.each(c, function (b, d) { c[b] = a.validator.normalizeRule(d) }), a(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", b).on("click.validate", "select, option, [type='radio'], [type='checkbox']", b), this.settings.invalidHandler && a(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler) }, form: function () { return this.checkForm(), a.extend(this.submitted, this.errorMap), this.invalid = a.extend({}, this.errorMap), this.valid() || a(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid() }, checkForm: function () { this.prepareForm(); for (var a = 0, b = this.currentElements = this.elements(); b[a]; a++)this.check(b[a]); return this.valid() }, element: function (b) { var c, d, e = this.clean(b), f = this.validationTargetFor(e), g = this, h = !0; return void 0 === f ? delete this.invalid[e.name] : (this.prepareElement(f), this.currentElements = a(f), d = this.groups[f.name], d && a.each(this.groups, function (a, b) { b === d && a !== f.name && (e = g.validationTargetFor(g.clean(g.findByName(a))), e && e.name in g.invalid && (g.currentElements.push(e), h = g.check(e) && h)) }), c = this.check(f) !== !1, h = h && c, c ? this.invalid[f.name] = !1 : this.invalid[f.name] = !0, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), a(b).attr("aria-invalid", !c)), h }, showErrors: function (b) { if (b) { var c = this; a.extend(this.errorMap, b), this.errorList = a.map(this.errorMap, function (a, b) { return { message: a, element: c.findByName(b)[0] } }), this.successList = a.grep(this.successList, function (a) { return !(a.name in b) }) } this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors() }, resetForm: function () { a.fn.resetForm && a(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors(); var b = this.elements().removeData("previousValue").removeAttr("aria-invalid"); this.resetElements(b) }, resetElements: function (a) { var b; if (this.settings.unhighlight) for (b = 0; a[b]; b++)this.settings.unhighlight.call(this, a[b], this.settings.errorClass, ""), this.findByName(a[b].name).removeClass(this.settings.validClass); else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass) }, numberOfInvalids: function () { return this.objectLength(this.invalid) }, objectLength: function (a) { var b, c = 0; for (b in a) void 0 !== a[b] && null !== a[b] && a[b] !== !1 && c++; return c }, hideErrors: function () { this.hideThese(this.toHide) }, hideThese: function (a) { a.not(this.containers).text(""), this.addWrapper(a).hide() }, valid: function () { return 0 === this.size() }, size: function () { return this.errorList.length }, focusInvalid: function () { if (this.settings.focusInvalid) try { a(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin") } catch (b) { } }, findLastActive: function () { var b = this.lastActive; return b && 1 === a.grep(this.errorList, function (a) { return a.element.name === b.name }).length && b }, elements: function () { var b = this, c = {}; return a(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter(function () { var d = this.name || a(this).attr("name"); return !d && b.settings.debug && window.console && console.error("%o has no name assigned", this), this.hasAttribute("contenteditable") && (this.form = a(this).closest("form")[0], this.name = d), !(d in c || !b.objectLength(a(this).rules())) && (c[d] = !0, !0) }) }, clean: function (b) { return a(b)[0] }, errors: function () { var b = this.settings.errorClass.split(" ").join("."); return a(this.settings.errorElement + "." + b, this.errorContext) }, resetInternals: function () { this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = a([]), this.toHide = a([]) }, reset: function () { this.resetInternals(), this.currentElements = a([]) }, prepareForm: function () { this.reset(), this.toHide = this.errors().add(this.containers) }, prepareElement: function (a) { this.reset(), this.toHide = this.errorsFor(a) }, elementValue: function (b) { var c, d, e = a(b), f = b.type; return "radio" === f || "checkbox" === f ? this.findByName(b.name).filter(":checked").val() : "number" === f && "undefined" != typeof b.validity ? b.validity.badInput ? "NaN" : e.val() : (c = b.hasAttribute("contenteditable") ? e.text() : e.val(), "file" === f ? "C:\\fakepath\\" === c.substr(0, 12) ? c.substr(12) : (d = c.lastIndexOf("/"), d >= 0 ? c.substr(d + 1) : (d = c.lastIndexOf("\\"), d >= 0 ? c.substr(d + 1) : c)) : "string" == typeof c ? c.replace(/\r/g, "") : c) }, check: function (b) { b = this.validationTargetFor(this.clean(b)); var c, d, e, f, g = a(b).rules(), h = a.map(g, function (a, b) { return b }).length, i = !1, j = this.elementValue(b); if ("function" == typeof g.normalizer ? f = g.normalizer : "function" == typeof this.settings.normalizer && (f = this.settings.normalizer), f) { if (j = f.call(b, j), "string" != typeof j) throw new TypeError("The normalizer should return a string value."); delete g.normalizer } for (d in g) { e = { method: d, parameters: g[d] }; try { if (c = a.validator.methods[d].call(this, j, b, e.parameters), "dependency-mismatch" === c && 1 === h) { i = !0; continue } if (i = !1, "pending" === c) return void (this.toHide = this.toHide.not(this.errorsFor(b))); if (!c) return this.formatAndAdd(b, e), !1 } catch (k) { throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + b.id + ", check the '" + e.method + "' method.", k), k instanceof TypeError && (k.message += ".  Exception occurred when checking element " + b.id + ", check the '" + e.method + "' method."), k } } if (!i) return this.objectLength(g) && this.successList.push(b), !0 }, customDataMessage: function (b, c) { return a(b).data("msg" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()) || a(b).data("msg") }, customMessage: function (a, b) { var c = this.settings.messages[a]; return c && (c.constructor === String ? c : c[b]) }, findDefined: function () { for (var a = 0; a < arguments.length; a++)if (void 0 !== arguments[a]) return arguments[a] }, defaultMessage: function (b, c) { "string" == typeof c && (c = { method: c }); var d = this.findDefined(this.customMessage(b.name, c.method), this.customDataMessage(b, c.method), !this.settings.ignoreTitle && b.title || void 0, a.validator.messages[c.method], "<strong>Warning: No message defined for " + b.name + "</strong>"), e = /\$?\{(\d+)\}/g; return "function" == typeof d ? d = d.call(this, c.parameters, b) : e.test(d) && (d = a.validator.format(d.replace(e, "{$1}"), c.parameters)), d }, formatAndAdd: function (a, b) { var c = this.defaultMessage(a, b); this.errorList.push({ message: c, element: a, method: b.method }), this.errorMap[a.name] = c, this.submitted[a.name] = c }, addWrapper: function (a) { return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a }, defaultShowErrors: function () { var a, b, c; for (a = 0; this.errorList[a]; a++)c = this.errorList[a], this.settings.highlight && this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass), this.showLabel(c.element, c.message); if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (a = 0; this.successList[a]; a++)this.showLabel(this.successList[a]); if (this.settings.unhighlight) for (a = 0, b = this.validElements(); b[a]; a++)this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass); this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show() }, validElements: function () { return this.currentElements.not(this.invalidElements()) }, invalidElements: function () { return a(this.errorList).map(function () { return this.element }) }, showLabel: function (b, c) { var d, e, f, g, h = this.errorsFor(b), i = this.idOrName(b), j = a(b).attr("aria-describedby"); h.length ? (h.removeClass(this.settings.validClass).addClass(this.settings.errorClass), h.html(c)) : (h = a("<" + this.settings.errorElement + ">").attr("id", i + "-error").addClass(this.settings.errorClass).html(c || ""), d = h, this.settings.wrapper && (d = h.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(d) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, d, a(b)) : d.insertAfter(b), h.is("label") ? h.attr("for", i) : 0 === h.parents("label[for='" + this.escapeCssMeta(i) + "']").length && (f = h.attr("id"), j ? j.match(new RegExp("\\b" + this.escapeCssMeta(f) + "\\b")) || (j += " " + f) : j = f, a(b).attr("aria-describedby", j), e = this.groups[b.name], e && (g = this, a.each(g.groups, function (b, c) { c === e && a("[name='" + g.escapeCssMeta(b) + "']", g.currentForm).attr("aria-describedby", h.attr("id")) })))), !c && this.settings.success && (h.text(""), "string" == typeof this.settings.success ? h.addClass(this.settings.success) : this.settings.success(h, b)), this.toShow = this.toShow.add(h) }, errorsFor: function (b) { var c = this.escapeCssMeta(this.idOrName(b)), d = a(b).attr("aria-describedby"), e = "label[for='" + c + "'], label[for='" + c + "'] *"; return d && (e = e + ", #" + this.escapeCssMeta(d).replace(/\s+/g, ", #")), this.errors().filter(e) }, escapeCssMeta: function (a) { return a.replace(/([\\!"#$%&'()*+,.\/:;<=>?@\[\]^`{|}~])/g, "\\$1") }, idOrName: function (a) { return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name) }, validationTargetFor: function (b) { return this.checkable(b) && (b = this.findByName(b.name)), a(b).not(this.settings.ignore)[0] }, checkable: function (a) { return /radio|checkbox/i.test(a.type) }, findByName: function (b) { return a(this.currentForm).find("[name='" + this.escapeCssMeta(b) + "']") }, getLength: function (b, c) { switch (c.nodeName.toLowerCase()) { case "select": return a("option:selected", c).length; case "input": if (this.checkable(c)) return this.findByName(c.name).filter(":checked").length }return b.length }, depend: function (a, b) { return !this.dependTypes[typeof a] || this.dependTypes[typeof a](a, b) }, dependTypes: { "boolean": function (a) { return a }, string: function (b, c) { return !!a(b, c.form).length }, "function": function (a, b) { return a(b) } }, optional: function (b) { var c = this.elementValue(b); return !a.validator.methods.required.call(this, c, b) && "dependency-mismatch" }, startRequest: function (b) { this.pending[b.name] || (this.pendingRequest++ , a(b).addClass(this.settings.pendingClass), this.pending[b.name] = !0) }, stopRequest: function (b, c) { this.pendingRequest-- , this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[b.name], a(b).removeClass(this.settings.pendingClass), c && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (a(this.currentForm).submit(), this.submitButton && a("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove(), this.formSubmitted = !1) : !c && 0 === this.pendingRequest && this.formSubmitted && (a(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1) }, previousValue: function (b, c) { return c = "string" == typeof c && c || "remote", a.data(b, "previousValue") || a.data(b, "previousValue", { old: null, valid: !0, message: this.defaultMessage(b, { method: c }) }) }, destroy: function () { this.resetForm(), a(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur") } }, classRuleSettings: { required: { required: !0 }, email: { email: !0 }, url: { url: !0 }, date: { date: !0 }, dateISO: { dateISO: !0 }, number: { number: !0 }, digits: { digits: !0 }, creditcard: { creditcard: !0 } }, addClassRules: function (b, c) { b.constructor === String ? this.classRuleSettings[b] = c : a.extend(this.classRuleSettings, b) }, classRules: function (b) { var c = {}, d = a(b).attr("class"); return d && a.each(d.split(" "), function () { this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this]) }), c }, normalizeAttributeRule: function (a, b, c, d) { /min|max|step/.test(c) && (null === b || /number|range|text/.test(b)) && (d = Number(d), isNaN(d) && (d = void 0)), d || 0 === d ? a[c] = d : b === c && "range" !== b && (a[c] = !0) }, attributeRules: function (b) { var c, d, e = {}, f = a(b), g = b.getAttribute("type"); for (c in a.validator.methods) "required" === c ? (d = b.getAttribute(c), "" === d && (d = !0), d = !!d) : d = f.attr(c), this.normalizeAttributeRule(e, g, c, d); return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e }, dataRules: function (b) { var c, d, e = {}, f = a(b), g = b.getAttribute("type"); for (c in a.validator.methods) d = f.data("rule" + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()), this.normalizeAttributeRule(e, g, c, d); return e }, staticRules: function (b) { var c = {}, d = a.data(b.form, "validator"); return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c }, normalizeRules: function (b, c) { return a.each(b, function (d, e) { if (e === !1) return void delete b[d]; if (e.param || e.depends) { var f = !0; switch (typeof e.depends) { case "string": f = !!a(e.depends, c.form).length; break; case "function": f = e.depends.call(c, c) }f ? b[d] = void 0 === e.param || e.param : (a.data(c.form, "validator").resetElements(a(c)), delete b[d]) } }), a.each(b, function (d, e) { b[d] = a.isFunction(e) && "normalizer" !== d ? e(c) : e }), a.each(["minlength", "maxlength"], function () { b[this] && (b[this] = Number(b[this])) }), a.each(["rangelength", "range"], function () { var c; b[this] && (a.isArray(b[this]) ? b[this] = [Number(b[this][0]), Number(b[this][1])] : "string" == typeof b[this] && (c = b[this].replace(/[\[\]]/g, "").split(/[\s,]+/), b[this] = [Number(c[0]), Number(c[1])])) }), a.validator.autoCreateRanges && (null != b.min && null != b.max && (b.range = [b.min, b.max], delete b.min, delete b.max), null != b.minlength && null != b.maxlength && (b.rangelength = [b.minlength, b.maxlength], delete b.minlength, delete b.maxlength)), b }, normalizeRule: function (b) { if ("string" == typeof b) { var c = {}; a.each(b.split(/\s/), function () { c[this] = !0 }), b = c } return b }, addMethod: function (b, c, d) { a.validator.methods[b] = c, a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b], c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b)) }, methods: { required: function (b, c, d) { if (!this.depend(d, c)) return "dependency-mismatch"; if ("select" === c.nodeName.toLowerCase()) { var e = a(c).val(); return e && e.length > 0 } return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0 }, email: function (a, b) { return this.optional(b) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a) }, url: function (a, b) { return this.optional(b) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i.test(a) }, date: function (a, b) { return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString()) }, dateISO: function (a, b) { return this.optional(b) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a) }, number: function (a, b) { return this.optional(b) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a) }, digits: function (a, b) { return this.optional(b) || /^\d+$/.test(a) }, minlength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e >= d }, maxlength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e <= d }, rangelength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e >= d[0] && e <= d[1] }, min: function (a, b, c) { return this.optional(b) || a >= c }, max: function (a, b, c) { return this.optional(b) || a <= c }, range: function (a, b, c) { return this.optional(b) || a >= c[0] && a <= c[1] }, step: function (b, c, d) { var e, f = a(c).attr("type"), g = "Step attribute on input type " + f + " is not supported.", h = ["text", "number", "range"], i = new RegExp("\\b" + f + "\\b"), j = f && !i.test(h.join()), k = function (a) { var b = ("" + a).match(/(?:\.(\d+))?$/); return b && b[1] ? b[1].length : 0 }, l = function (a) { return Math.round(a * Math.pow(10, e)) }, m = !0; if (j) throw new Error(g); return e = k(d), (k(b) > e || l(b) % l(d) !== 0) && (m = !1), this.optional(c) || m }, equalTo: function (b, c, d) { var e = a(d); return this.settings.onfocusout && e.not(".validate-equalTo-blur").length && e.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function () { a(c).valid() }), b === e.val() }, remote: function (b, c, d, e) { if (this.optional(c)) return "dependency-mismatch"; e = "string" == typeof e && e || "remote"; var f, g, h, i = this.previousValue(c, e); return this.settings.messages[c.name] || (this.settings.messages[c.name] = {}), i.originalMessage = i.originalMessage || this.settings.messages[c.name][e], this.settings.messages[c.name][e] = i.message, d = "string" == typeof d && { url: d } || d, h = a.param(a.extend({ data: b }, d.data)), i.old === h ? i.valid : (i.old = h, f = this, this.startRequest(c), g = {}, g[c.name] = b, a.ajax(a.extend(!0, { mode: "abort", port: "validate" + c.name, dataType: "json", data: g, context: f.currentForm, success: function (a) { var d, g, h, j = a === !0 || "true" === a; f.settings.messages[c.name][e] = i.originalMessage, j ? (h = f.formSubmitted, f.resetInternals(), f.toHide = f.errorsFor(c), f.formSubmitted = h, f.successList.push(c), f.invalid[c.name] = !1, f.showErrors()) : (d = {}, g = a || f.defaultMessage(c, { method: e, parameters: b }), d[c.name] = i.message = g, f.invalid[c.name] = !0, f.showErrors(d)), i.valid = j, f.stopRequest(c, j) } }, d)), "pending") } } }); var b, c = {}; return a.ajaxPrefilter ? a.ajaxPrefilter(function (a, b, d) { var e = a.port; "abort" === a.mode && (c[e] && c[e].abort(), c[e] = d) }) : (b = a.ajax, a.ajax = function (d) { var e = ("mode" in d ? d : a.ajaxSettings).mode, f = ("port" in d ? d : a.ajaxSettings).port; return "abort" === e ? (c[f] && c[f].abort(), c[f] = b.apply(this, arguments), c[f]) : b.apply(this, arguments) }), a });
/*! jQuery & Zepto Lazy v1.7.6 - http://jquery.eisbehr.de/lazy - MIT&GPL-2.0 license - Copyright 2012-2017 Daniel 'Eisbehr' Kern */
!function (t, e) { "use strict"; function r(r, a, i, u, l) { function f() { L = t.devicePixelRatio > 1, i = c(i), a.delay >= 0 && setTimeout(function () { s(!0) }, a.delay), (a.delay < 0 || a.combined) && (u.e = v(a.throttle, function (t) { "resize" === t.type && (w = B = -1), s(t.all) }), u.a = function (t) { t = c(t), i.push.apply(i, t) }, u.g = function () { return i = n(i).filter(function () { return !n(this).data(a.loadedName) }) }, u.f = function (t) { for (var e = 0; e < t.length; e++) { var r = i.filter(function () { return this === t[e] }); r.length && s(!1, r) } }, s(), n(a.appendScroll).on("scroll." + l + " resize." + l, u.e)) } function c(t) { var i = a.defaultImage, o = a.placeholder, u = a.imageBase, l = a.srcsetAttribute, f = a.loaderAttribute, c = a._f || {}; t = n(t).filter(function () { var t = n(this), r = m(this); return !t.data(a.handledName) && (t.attr(a.attribute) || t.attr(l) || t.attr(f) || c[r] !== e) }).data("plugin_" + a.name, r); for (var s = 0, d = t.length; s < d; s++) { var A = n(t[s]), g = m(t[s]), h = A.attr(a.imageBaseAttribute) || u; g === N && h && A.attr(l) && A.attr(l, b(A.attr(l), h)), c[g] === e || A.attr(f) || A.attr(f, c[g]), g === N && i && !A.attr(E) ? A.attr(E, i) : g === N || !o || A.css(O) && "none" !== A.css(O) || A.css(O, "url('" + o + "')") } return t } function s(t, e) { if (!i.length) return void (a.autoDestroy && r.destroy()); for (var o = e || i, u = !1, l = a.imageBase || "", f = a.srcsetAttribute, c = a.handledName, s = 0; s < o.length; s++)if (t || e || A(o[s])) { var g = n(o[s]), h = m(o[s]), b = g.attr(a.attribute), v = g.attr(a.imageBaseAttribute) || l, p = g.attr(a.loaderAttribute); g.data(c) || a.visibleOnly && !g.is(":visible") || !((b || g.attr(f)) && (h === N && (v + b !== g.attr(E) || g.attr(f) !== g.attr(F)) || h !== N && v + b !== g.css(O)) || p) || (u = !0, g.data(c, !0), d(g, h, v, p)) } u && (i = n(i).filter(function () { return !n(this).data(c) })) } function d(t, e, r, i) { ++z; var o = function () { y("onError", t), p(), o = n.noop }; y("beforeLoad", t); var u = a.attribute, l = a.srcsetAttribute, f = a.sizesAttribute, c = a.retinaAttribute, s = a.removeAttribute, d = a.loadedName, A = t.attr(c); if (i) { var g = function () { s && t.removeAttr(a.loaderAttribute), t.data(d, !0), y(T, t), setTimeout(p, 1), g = n.noop }; t.off(I).one(I, o).one(D, g), y(i, t, function (e) { e ? (t.off(D), g()) : (t.off(I), o()) }) || t.trigger(I) } else { var h = n(new Image); h.one(I, o).one(D, function () { t.hide(), e === N ? t.attr(C, h.attr(C)).attr(F, h.attr(F)).attr(E, h.attr(E)) : t.css(O, "url('" + h.attr(E) + "')"), t[a.effect](a.effectTime), s && (t.removeAttr(u + " " + l + " " + c + " " + a.imageBaseAttribute), f !== C && t.removeAttr(f)), t.data(d, !0), y(T, t), h.remove(), p() }); var m = (L && A ? A : t.attr(u)) || ""; h.attr(C, t.attr(f)).attr(F, t.attr(l)).attr(E, m ? r + m : null), h.complete && h.trigger(D) } } function A(t) { var e = t.getBoundingClientRect(), r = a.scrollDirection, n = a.threshold, i = h() + n > e.top && -n < e.bottom, o = g() + n > e.left && -n < e.right; return "vertical" === r ? i : "horizontal" === r ? o : i && o } function g() { return w >= 0 ? w : w = n(t).width() } function h() { return B >= 0 ? B : B = n(t).height() } function m(t) { return t.tagName.toLowerCase() } function b(t, e) { if (e) { var r = t.split(","); t = ""; for (var a = 0, n = r.length; a < n; a++)t += e + r[a].trim() + (a !== n - 1 ? "," : "") } return t } function v(t, e) { var n, i = 0; return function (o, u) { function l() { i = +new Date, e.call(r, o) } var f = +new Date - i; n && clearTimeout(n), f > t || !a.enableThrottle || u ? l() : n = setTimeout(l, t - f) } } function p() { --z, i.length || z || y("onFinishedAll") } function y(t, e, n) { return !!(t = a[t]) && (t.apply(r, [].slice.call(arguments, 1)), !0) } var z = 0, w = -1, B = -1, L = !1, T = "afterLoad", D = "load", I = "error", N = "img", E = "src", F = "srcset", C = "sizes", O = "background-image"; "event" === a.bind || o ? f() : n(t).on(D + "." + l, f) } function a(a, o) { var u = this, l = n.extend({}, u.config, o), f = {}, c = l.name + "-" + ++i; return u.config = function (t, r) { return r === e ? l[t] : (l[t] = r, u) }, u.addItems = function (t) { return f.a && f.a("string" === n.type(t) ? n(t) : t), u }, u.getItems = function () { return f.g ? f.g() : {} }, u.update = function (t) { return f.e && f.e({}, !t), u }, u.force = function (t) { return f.f && f.f("string" === n.type(t) ? n(t) : t), u }, u.loadAll = function () { return f.e && f.e({ all: !0 }, !0), u }, u.destroy = function () { return n(l.appendScroll).off("." + c, f.e), n(t).off("." + c), f = {}, e }, r(u, l, a, f, c), l.chainable ? a : u } var n = t.jQuery || t.Zepto, i = 0, o = !1; n.fn.Lazy = n.fn.lazy = function (t) { return new a(this, t) }, n.Lazy = n.lazy = function (t, r, i) { if (n.isFunction(r) && (i = r, r = []), n.isFunction(i)) { t = n.isArray(t) ? t : [t], r = n.isArray(r) ? r : [r]; for (var o = a.prototype.config, u = o._f || (o._f = {}), l = 0, f = t.length; l < f; l++)(o[t[l]] === e || n.isFunction(o[t[l]])) && (o[t[l]] = i); for (var c = 0, s = r.length; c < s; c++)u[r[c]] = t[0] } }, a.prototype.config = { name: "lazy", chainable: !0, autoDestroy: !0, bind: "load", threshold: 500, visibleOnly: !1, appendScroll: t, scrollDirection: "both", imageBase: null, defaultImage: "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", placeholder: null, delay: -1, combined: !1, attribute: "data-src", srcsetAttribute: "data-srcset", sizesAttribute: "data-sizes", retinaAttribute: "data-retina", loaderAttribute: "data-loader", imageBaseAttribute: "data-imagebase", removeAttribute: !0, handledName: "handled", loadedName: "loaded", effect: "show", effectTime: 0, enableThrottle: !0, throttle: 250, beforeLoad: e, afterLoad: e, onError: e, onFinishedAll: e }, n(t).on("load", function () { o = !0 }) }(window);
/*! tooltipster v4.2.5 */!function (a, b) { "function" == typeof define && define.amd ? define(["jquery"], function (a) { return b(a) }) : "object" == typeof exports ? module.exports = b(require("jquery")) : b(jQuery) }(this, function (a) {
    function b(a) { this.$container, this.constraints = null, this.__$tooltip, this.__init(a) } function c(b, c) { var d = !0; return a.each(b, function (a, e) { return void 0 === c[a] || b[a] !== c[a] ? (d = !1, !1) : void 0 }), d } function d(b) { var c = b.attr("id"), d = c ? h.window.document.getElementById(c) : null; return d ? d === b[0] : a.contains(h.window.document.body, b[0]) } function e() { if (!g) return !1; var a = g.document.body || g.document.documentElement, b = a.style, c = "transition", d = ["Moz", "Webkit", "Khtml", "O", "ms"]; if ("string" == typeof b[c]) return !0; c = c.charAt(0).toUpperCase() + c.substr(1); for (var e = 0; e < d.length; e++)if ("string" == typeof b[d[e] + c]) return !0; return !1 } var f = { animation: "fade", animationDuration: 350, content: null, contentAsHTML: !1, contentCloning: !1, debug: !0, delay: 300, delayTouch: [300, 500], functionInit: null, functionBefore: null, functionReady: null, functionAfter: null, functionFormat: null, IEmin: 6, interactive: !1, multiple: !1, parent: null, plugins: ["sideTip"], repositionOnScroll: !1, restoration: "none", selfDestruction: !0, theme: [], timer: 0, trackerInterval: 500, trackOrigin: !1, trackTooltip: !1, trigger: "hover", triggerClose: { click: !1, mouseleave: !1, originClick: !1, scroll: !1, tap: !1, touchleave: !1 }, triggerOpen: { click: !1, mouseenter: !1, tap: !1, touchstart: !1 }, updateAnimation: "rotate", zIndex: 9999999 }, g = "undefined" != typeof window ? window : null, h = { hasTouchCapability: !(!g || !("ontouchstart" in g || g.DocumentTouch && g.document instanceof g.DocumentTouch || g.navigator.maxTouchPoints)), hasTransitions: e(), IE: !1, semVer: "4.2.5", window: g }, i = function () { this.__$emitterPrivate = a({}), this.__$emitterPublic = a({}), this.__instancesLatestArr = [], this.__plugins = {}, this._env = h }; i.prototype = { __bridge: function (b, c, d) { if (!c[d]) { var e = function () { }; e.prototype = b; var g = new e; g.__init && g.__init(c), a.each(b, function (a, b) { 0 != a.indexOf("__") && (c[a] ? f.debug && console.log("The " + a + " method of the " + d + " plugin conflicts with another plugin or native methods") : (c[a] = function () { return g[a].apply(g, Array.prototype.slice.apply(arguments)) }, c[a].bridged = g)) }), c[d] = g } return this }, __setWindow: function (a) { return h.window = a, this }, _getRuler: function (a) { return new b(a) }, _off: function () { return this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _on: function () { return this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _one: function () { return this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _plugin: function (b) { var c = this; if ("string" == typeof b) { var d = b, e = null; return d.indexOf(".") > 0 ? e = c.__plugins[d] : a.each(c.__plugins, function (a, b) { return b.name.substring(b.name.length - d.length - 1) == "." + d ? (e = b, !1) : void 0 }), e } if (b.name.indexOf(".") < 0) throw new Error("Plugins must be namespaced"); return c.__plugins[b.name] = b, b.core && c.__bridge(b.core, c, b.name), this }, _trigger: function () { var a = Array.prototype.slice.apply(arguments); return "string" == typeof a[0] && (a[0] = { type: a[0] }), this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, a), this.__$emitterPublic.trigger.apply(this.__$emitterPublic, a), this }, instances: function (b) { var c = [], d = b || ".tooltipstered"; return a(d).each(function () { var b = a(this), d = b.data("tooltipster-ns"); d && a.each(d, function (a, d) { c.push(b.data(d)) }) }), c }, instancesLatest: function () { return this.__instancesLatestArr }, off: function () { return this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, on: function () { return this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, one: function () { return this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, origins: function (b) { var c = b ? b + " " : ""; return a(c + ".tooltipstered").toArray() }, setDefaults: function (b) { return a.extend(f, b), this }, triggerHandler: function () { return this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this } }, a.tooltipster = new i, a.Tooltipster = function (b, c) { this.__callbacks = { close: [], open: [] }, this.__closingTime, this.__Content, this.__contentBcr, this.__destroyed = !1, this.__$emitterPrivate = a({}), this.__$emitterPublic = a({}), this.__enabled = !0, this.__garbageCollector, this.__Geometry, this.__lastPosition, this.__namespace = "tooltipster-" + Math.round(1e6 * Math.random()), this.__options, this.__$originParents, this.__pointerIsOverOrigin = !1, this.__previousThemes = [], this.__state = "closed", this.__timeouts = { close: [], open: null }, this.__touchEvents = [], this.__tracker = null, this._$origin, this._$tooltip, this.__init(b, c) }, a.Tooltipster.prototype = { __init: function (b, c) { var d = this; if (d._$origin = a(b), d.__options = a.extend(!0, {}, f, c), d.__optionsFormat(), !h.IE || h.IE >= d.__options.IEmin) { var e = null; if (void 0 === d._$origin.data("tooltipster-initialTitle") && (e = d._$origin.attr("title"), void 0 === e && (e = null), d._$origin.data("tooltipster-initialTitle", e)), null !== d.__options.content) d.__contentSet(d.__options.content); else { var g, i = d._$origin.attr("data-tooltip-content"); i && (g = a(i)), g && g[0] ? d.__contentSet(g.first()) : d.__contentSet(e) } d._$origin.removeAttr("title").addClass("tooltipstered"), d.__prepareOrigin(), d.__prepareGC(), a.each(d.__options.plugins, function (a, b) { d._plug(b) }), h.hasTouchCapability && a(h.window.document.body).on("touchmove." + d.__namespace + "-triggerOpen", function (a) { d._touchRecordEvent(a) }), d._on("created", function () { d.__prepareTooltip() })._on("repositioned", function (a) { d.__lastPosition = a.position }) } else d.__options.disabled = !0 }, __contentInsert: function () { var a = this, b = a._$tooltip.find(".tooltipster-content"), c = a.__Content, d = function (a) { c = a }; return a._trigger({ type: "format", content: a.__Content, format: d }), a.__options.functionFormat && (c = a.__options.functionFormat.call(a, a, { origin: a._$origin[0] }, a.__Content)), "string" != typeof c || a.__options.contentAsHTML ? b.empty().append(c) : b.text(c), a }, __contentSet: function (b) { return b instanceof a && this.__options.contentCloning && (b = b.clone(!0)), this.__Content = b, this._trigger({ type: "updated", content: b }), this }, __destroyError: function () { throw new Error("This tooltip has been destroyed and cannot execute your method call.") }, __geometry: function () { var b = this, c = b._$origin, d = b._$origin.is("area"); if (d) { var e = b._$origin.parent().attr("name"); c = a('img[usemap="#' + e + '"]') } var f = c[0].getBoundingClientRect(), g = a(h.window.document), i = a(h.window), j = c, k = { available: { document: null, window: null }, document: { size: { height: g.height(), width: g.width() } }, window: { scroll: { left: h.window.scrollX || h.window.document.documentElement.scrollLeft, top: h.window.scrollY || h.window.document.documentElement.scrollTop }, size: { height: i.height(), width: i.width() } }, origin: { fixedLineage: !1, offset: {}, size: { height: f.bottom - f.top, width: f.right - f.left }, usemapImage: d ? c[0] : null, windowOffset: { bottom: f.bottom, left: f.left, right: f.right, top: f.top } } }; if (d) { var l = b._$origin.attr("shape"), m = b._$origin.attr("coords"); if (m && (m = m.split(","), a.map(m, function (a, b) { m[b] = parseInt(a) })), "default" != l) switch (l) { case "circle": var n = m[0], o = m[1], p = m[2], q = o - p, r = n - p; k.origin.size.height = 2 * p, k.origin.size.width = k.origin.size.height, k.origin.windowOffset.left += r, k.origin.windowOffset.top += q; break; case "rect": var s = m[0], t = m[1], u = m[2], v = m[3]; k.origin.size.height = v - t, k.origin.size.width = u - s, k.origin.windowOffset.left += s, k.origin.windowOffset.top += t; break; case "poly": for (var w = 0, x = 0, y = 0, z = 0, A = "even", B = 0; B < m.length; B++) { var C = m[B]; "even" == A ? (C > y && (y = C, 0 === B && (w = y)), w > C && (w = C), A = "odd") : (C > z && (z = C, 1 == B && (x = z)), x > C && (x = C), A = "even") } k.origin.size.height = z - x, k.origin.size.width = y - w, k.origin.windowOffset.left += w, k.origin.windowOffset.top += x } } var D = function (a) { k.origin.size.height = a.height, k.origin.windowOffset.left = a.left, k.origin.windowOffset.top = a.top, k.origin.size.width = a.width }; for (b._trigger({ type: "geometry", edit: D, geometry: { height: k.origin.size.height, left: k.origin.windowOffset.left, top: k.origin.windowOffset.top, width: k.origin.size.width } }), k.origin.windowOffset.right = k.origin.windowOffset.left + k.origin.size.width, k.origin.windowOffset.bottom = k.origin.windowOffset.top + k.origin.size.height, k.origin.offset.left = k.origin.windowOffset.left + k.window.scroll.left, k.origin.offset.top = k.origin.windowOffset.top + k.window.scroll.top, k.origin.offset.bottom = k.origin.offset.top + k.origin.size.height, k.origin.offset.right = k.origin.offset.left + k.origin.size.width, k.available.document = { bottom: { height: k.document.size.height - k.origin.offset.bottom, width: k.document.size.width }, left: { height: k.document.size.height, width: k.origin.offset.left }, right: { height: k.document.size.height, width: k.document.size.width - k.origin.offset.right }, top: { height: k.origin.offset.top, width: k.document.size.width } }, k.available.window = { bottom: { height: Math.max(k.window.size.height - Math.max(k.origin.windowOffset.bottom, 0), 0), width: k.window.size.width }, left: { height: k.window.size.height, width: Math.max(k.origin.windowOffset.left, 0) }, right: { height: k.window.size.height, width: Math.max(k.window.size.width - Math.max(k.origin.windowOffset.right, 0), 0) }, top: { height: Math.max(k.origin.windowOffset.top, 0), width: k.window.size.width } }; "html" != j[0].tagName.toLowerCase();) { if ("fixed" == j.css("position")) { k.origin.fixedLineage = !0; break } j = j.parent() } return k }, __optionsFormat: function () { return "number" == typeof this.__options.animationDuration && (this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration]), "number" == typeof this.__options.delay && (this.__options.delay = [this.__options.delay, this.__options.delay]), "number" == typeof this.__options.delayTouch && (this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch]), "string" == typeof this.__options.theme && (this.__options.theme = [this.__options.theme]), null === this.__options.parent ? this.__options.parent = a(h.window.document.body) : "string" == typeof this.__options.parent && (this.__options.parent = a(this.__options.parent)), "hover" == this.__options.trigger ? (this.__options.triggerOpen = { mouseenter: !0, touchstart: !0 }, this.__options.triggerClose = { mouseleave: !0, originClick: !0, touchleave: !0 }) : "click" == this.__options.trigger && (this.__options.triggerOpen = { click: !0, tap: !0 }, this.__options.triggerClose = { click: !0, tap: !0 }), this._trigger("options"), this }, __prepareGC: function () { var b = this; return b.__options.selfDestruction ? b.__garbageCollector = setInterval(function () { var c = (new Date).getTime(); b.__touchEvents = a.grep(b.__touchEvents, function (a, b) { return c - a.time > 6e4 }), d(b._$origin) || b.close(function () { b.destroy() }) }, 2e4) : clearInterval(b.__garbageCollector), b }, __prepareOrigin: function () { var a = this; if (a._$origin.off("." + a.__namespace + "-triggerOpen"), h.hasTouchCapability && a._$origin.on("touchstart." + a.__namespace + "-triggerOpen touchend." + a.__namespace + "-triggerOpen touchcancel." + a.__namespace + "-triggerOpen", function (b) { a._touchRecordEvent(b) }), a.__options.triggerOpen.click || a.__options.triggerOpen.tap && h.hasTouchCapability) { var b = ""; a.__options.triggerOpen.click && (b += "click." + a.__namespace + "-triggerOpen "), a.__options.triggerOpen.tap && h.hasTouchCapability && (b += "touchend." + a.__namespace + "-triggerOpen"), a._$origin.on(b, function (b) { a._touchIsMeaningfulEvent(b) && a._open(b) }) } if (a.__options.triggerOpen.mouseenter || a.__options.triggerOpen.touchstart && h.hasTouchCapability) { var b = ""; a.__options.triggerOpen.mouseenter && (b += "mouseenter." + a.__namespace + "-triggerOpen "), a.__options.triggerOpen.touchstart && h.hasTouchCapability && (b += "touchstart." + a.__namespace + "-triggerOpen"), a._$origin.on(b, function (b) { !a._touchIsTouchEvent(b) && a._touchIsEmulatedEvent(b) || (a.__pointerIsOverOrigin = !0, a._openShortly(b)) }) } if (a.__options.triggerClose.mouseleave || a.__options.triggerClose.touchleave && h.hasTouchCapability) { var b = ""; a.__options.triggerClose.mouseleave && (b += "mouseleave." + a.__namespace + "-triggerOpen "), a.__options.triggerClose.touchleave && h.hasTouchCapability && (b += "touchend." + a.__namespace + "-triggerOpen touchcancel." + a.__namespace + "-triggerOpen"), a._$origin.on(b, function (b) { a._touchIsMeaningfulEvent(b) && (a.__pointerIsOverOrigin = !1) }) } return a }, __prepareTooltip: function () { var b = this, c = b.__options.interactive ? "auto" : ""; return b._$tooltip.attr("id", b.__namespace).css({ "pointer-events": c, zIndex: b.__options.zIndex }), a.each(b.__previousThemes, function (a, c) { b._$tooltip.removeClass(c) }), a.each(b.__options.theme, function (a, c) { b._$tooltip.addClass(c) }), b.__previousThemes = a.merge([], b.__options.theme), b }, __scrollHandler: function (b) { var c = this; if (c.__options.triggerClose.scroll) c._close(b); else if (d(c._$origin) && d(c._$tooltip)) { var e = null; if (b.target === h.window.document) c.__Geometry.origin.fixedLineage || c.__options.repositionOnScroll && c.reposition(b); else { e = c.__geometry(); var f = !1; if ("fixed" != c._$origin.css("position") && c.__$originParents.each(function (b, c) { var d = a(c), g = d.css("overflow-x"), h = d.css("overflow-y"); if ("visible" != g || "visible" != h) { var i = c.getBoundingClientRect(); if ("visible" != g && (e.origin.windowOffset.left < i.left || e.origin.windowOffset.right > i.right)) return f = !0, !1; if ("visible" != h && (e.origin.windowOffset.top < i.top || e.origin.windowOffset.bottom > i.bottom)) return f = !0, !1 } return "fixed" == d.css("position") ? !1 : void 0 }), f) c._$tooltip.css("visibility", "hidden"); else if (c._$tooltip.css("visibility", "visible"), c.__options.repositionOnScroll) c.reposition(b); else { var g = e.origin.offset.left - c.__Geometry.origin.offset.left, i = e.origin.offset.top - c.__Geometry.origin.offset.top; c._$tooltip.css({ left: c.__lastPosition.coord.left + g, top: c.__lastPosition.coord.top + i }) } } c._trigger({ type: "scroll", event: b, geo: e }) } return c }, __stateSet: function (a) { return this.__state = a, this._trigger({ type: "state", state: a }), this }, __timeoutsClear: function () { return clearTimeout(this.__timeouts.open), this.__timeouts.open = null, a.each(this.__timeouts.close, function (a, b) { clearTimeout(b) }), this.__timeouts.close = [], this }, __trackerStart: function () { var a = this, b = a._$tooltip.find(".tooltipster-content"); return a.__options.trackTooltip && (a.__contentBcr = b[0].getBoundingClientRect()), a.__tracker = setInterval(function () { if (d(a._$origin) && d(a._$tooltip)) { if (a.__options.trackOrigin) { var e = a.__geometry(), f = !1; c(e.origin.size, a.__Geometry.origin.size) && (a.__Geometry.origin.fixedLineage ? c(e.origin.windowOffset, a.__Geometry.origin.windowOffset) && (f = !0) : c(e.origin.offset, a.__Geometry.origin.offset) && (f = !0)), f || (a.__options.triggerClose.mouseleave ? a._close() : a.reposition()) } if (a.__options.trackTooltip) { var g = b[0].getBoundingClientRect(); g.height === a.__contentBcr.height && g.width === a.__contentBcr.width || (a.reposition(), a.__contentBcr = g) } } else a._close() }, a.__options.trackerInterval), a }, _close: function (b, c, d) { var e = this, f = !0; if (e._trigger({ type: "close", event: b, stop: function () { f = !1 } }), f || d) { c && e.__callbacks.close.push(c), e.__callbacks.open = [], e.__timeoutsClear(); var g = function () { a.each(e.__callbacks.close, function (a, c) { c.call(e, e, { event: b, origin: e._$origin[0] }) }), e.__callbacks.close = [] }; if ("closed" != e.__state) { var i = !0, j = new Date, k = j.getTime(), l = k + e.__options.animationDuration[1]; if ("disappearing" == e.__state && l > e.__closingTime && e.__options.animationDuration[1] > 0 && (i = !1), i) { e.__closingTime = l, "disappearing" != e.__state && e.__stateSet("disappearing"); var m = function () { clearInterval(e.__tracker), e._trigger({ type: "closing", event: b }), e._$tooltip.off("." + e.__namespace + "-triggerClose").removeClass("tooltipster-dying"), a(h.window).off("." + e.__namespace + "-triggerClose"), e.__$originParents.each(function (b, c) { a(c).off("scroll." + e.__namespace + "-triggerClose") }), e.__$originParents = null, a(h.window.document.body).off("." + e.__namespace + "-triggerClose"), e._$origin.off("." + e.__namespace + "-triggerClose"), e._off("dismissable"), e.__stateSet("closed"), e._trigger({ type: "after", event: b }), e.__options.functionAfter && e.__options.functionAfter.call(e, e, { event: b, origin: e._$origin[0] }), g() }; h.hasTransitions ? (e._$tooltip.css({ "-moz-animation-duration": e.__options.animationDuration[1] + "ms", "-ms-animation-duration": e.__options.animationDuration[1] + "ms", "-o-animation-duration": e.__options.animationDuration[1] + "ms", "-webkit-animation-duration": e.__options.animationDuration[1] + "ms", "animation-duration": e.__options.animationDuration[1] + "ms", "transition-duration": e.__options.animationDuration[1] + "ms" }), e._$tooltip.clearQueue().removeClass("tooltipster-show").addClass("tooltipster-dying"), e.__options.animationDuration[1] > 0 && e._$tooltip.delay(e.__options.animationDuration[1]), e._$tooltip.queue(m)) : e._$tooltip.stop().fadeOut(e.__options.animationDuration[1], m) } } else g() } return e }, _off: function () { return this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _on: function () { return this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _one: function () { return this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this }, _open: function (b, c) { var e = this; if (!e.__destroying && d(e._$origin) && e.__enabled) { var f = !0; if ("closed" == e.__state && (e._trigger({ type: "before", event: b, stop: function () { f = !1 } }), f && e.__options.functionBefore && (f = e.__options.functionBefore.call(e, e, { event: b, origin: e._$origin[0] }))), f !== !1 && null !== e.__Content) { c && e.__callbacks.open.push(c), e.__callbacks.close = [], e.__timeoutsClear(); var g, i = function () { "stable" != e.__state && e.__stateSet("stable"), a.each(e.__callbacks.open, function (a, b) { b.call(e, e, { origin: e._$origin[0], tooltip: e._$tooltip[0] }) }), e.__callbacks.open = [] }; if ("closed" !== e.__state) g = 0, "disappearing" === e.__state ? (e.__stateSet("appearing"), h.hasTransitions ? (e._$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-show"), e.__options.animationDuration[0] > 0 && e._$tooltip.delay(e.__options.animationDuration[0]), e._$tooltip.queue(i)) : e._$tooltip.stop().fadeIn(i)) : "stable" == e.__state && i(); else { if (e.__stateSet("appearing"), g = e.__options.animationDuration[0], e.__contentInsert(), e.reposition(b, !0), h.hasTransitions ? (e._$tooltip.addClass("tooltipster-" + e.__options.animation).addClass("tooltipster-initial").css({ "-moz-animation-duration": e.__options.animationDuration[0] + "ms", "-ms-animation-duration": e.__options.animationDuration[0] + "ms", "-o-animation-duration": e.__options.animationDuration[0] + "ms", "-webkit-animation-duration": e.__options.animationDuration[0] + "ms", "animation-duration": e.__options.animationDuration[0] + "ms", "transition-duration": e.__options.animationDuration[0] + "ms" }), setTimeout(function () { "closed" != e.__state && (e._$tooltip.addClass("tooltipster-show").removeClass("tooltipster-initial"), e.__options.animationDuration[0] > 0 && e._$tooltip.delay(e.__options.animationDuration[0]), e._$tooltip.queue(i)) }, 0)) : e._$tooltip.css("display", "none").fadeIn(e.__options.animationDuration[0], i), e.__trackerStart(), a(h.window).on("resize." + e.__namespace + "-triggerClose", function (b) { var c = a(document.activeElement); (c.is("input") || c.is("textarea")) && a.contains(e._$tooltip[0], c[0]) || e.reposition(b) }).on("scroll." + e.__namespace + "-triggerClose", function (a) { e.__scrollHandler(a) }), e.__$originParents = e._$origin.parents(), e.__$originParents.each(function (b, c) { a(c).on("scroll." + e.__namespace + "-triggerClose", function (a) { e.__scrollHandler(a) }) }), e.__options.triggerClose.mouseleave || e.__options.triggerClose.touchleave && h.hasTouchCapability) { e._on("dismissable", function (a) { a.dismissable ? a.delay ? (m = setTimeout(function () { e._close(a.event) }, a.delay), e.__timeouts.close.push(m)) : e._close(a) : clearTimeout(m) }); var j = e._$origin, k = "", l = "", m = null; e.__options.interactive && (j = j.add(e._$tooltip)), e.__options.triggerClose.mouseleave && (k += "mouseenter." + e.__namespace + "-triggerClose ", l += "mouseleave." + e.__namespace + "-triggerClose "), e.__options.triggerClose.touchleave && h.hasTouchCapability && (k += "touchstart." + e.__namespace + "-triggerClose", l += "touchend." + e.__namespace + "-triggerClose touchcancel." + e.__namespace + "-triggerClose"), j.on(l, function (a) { if (e._touchIsTouchEvent(a) || !e._touchIsEmulatedEvent(a)) { var b = "mouseleave" == a.type ? e.__options.delay : e.__options.delayTouch; e._trigger({ delay: b[1], dismissable: !0, event: a, type: "dismissable" }) } }).on(k, function (a) { !e._touchIsTouchEvent(a) && e._touchIsEmulatedEvent(a) || e._trigger({ dismissable: !1, event: a, type: "dismissable" }) }) } e.__options.triggerClose.originClick && e._$origin.on("click." + e.__namespace + "-triggerClose", function (a) { e._touchIsTouchEvent(a) || e._touchIsEmulatedEvent(a) || e._close(a) }), (e.__options.triggerClose.click || e.__options.triggerClose.tap && h.hasTouchCapability) && setTimeout(function () { if ("closed" != e.__state) { var b = "", c = a(h.window.document.body); e.__options.triggerClose.click && (b += "click." + e.__namespace + "-triggerClose "), e.__options.triggerClose.tap && h.hasTouchCapability && (b += "touchend." + e.__namespace + "-triggerClose"), c.on(b, function (b) { e._touchIsMeaningfulEvent(b) && (e._touchRecordEvent(b), e.__options.interactive && a.contains(e._$tooltip[0], b.target) || e._close(b)) }), e.__options.triggerClose.tap && h.hasTouchCapability && c.on("touchstart." + e.__namespace + "-triggerClose", function (a) { e._touchRecordEvent(a) }) } }, 0), e._trigger("ready"), e.__options.functionReady && e.__options.functionReady.call(e, e, { origin: e._$origin[0], tooltip: e._$tooltip[0] }) } if (e.__options.timer > 0) { var m = setTimeout(function () { e._close() }, e.__options.timer + g); e.__timeouts.close.push(m) } } } return e }, _openShortly: function (a) { var b = this, c = !0; if ("stable" != b.__state && "appearing" != b.__state && !b.__timeouts.open && (b._trigger({ type: "start", event: a, stop: function () { c = !1 } }), c)) { var d = 0 == a.type.indexOf("touch") ? b.__options.delayTouch : b.__options.delay; d[0] ? b.__timeouts.open = setTimeout(function () { b.__timeouts.open = null, b.__pointerIsOverOrigin && b._touchIsMeaningfulEvent(a) ? (b._trigger("startend"), b._open(a)) : b._trigger("startcancel") }, d[0]) : (b._trigger("startend"), b._open(a)) } return b }, _optionsExtract: function (b, c) { var d = this, e = a.extend(!0, {}, c), f = d.__options[b]; return f || (f = {}, a.each(c, function (a, b) { var c = d.__options[a]; void 0 !== c && (f[a] = c) })), a.each(e, function (b, c) { void 0 !== f[b] && ("object" != typeof c || c instanceof Array || null == c || "object" != typeof f[b] || f[b] instanceof Array || null == f[b] ? e[b] = f[b] : a.extend(e[b], f[b])) }), e }, _plug: function (b) { var c = a.tooltipster._plugin(b); if (!c) throw new Error('The "' + b + '" plugin is not defined'); return c.instance && a.tooltipster.__bridge(c.instance, this, c.name), this }, _touchIsEmulatedEvent: function (a) { for (var b = !1, c = (new Date).getTime(), d = this.__touchEvents.length - 1; d >= 0; d--) { var e = this.__touchEvents[d]; if (!(c - e.time < 500)) break; e.target === a.target && (b = !0) } return b }, _touchIsMeaningfulEvent: function (a) { return this._touchIsTouchEvent(a) && !this._touchSwiped(a.target) || !this._touchIsTouchEvent(a) && !this._touchIsEmulatedEvent(a) }, _touchIsTouchEvent: function (a) { return 0 == a.type.indexOf("touch") }, _touchRecordEvent: function (a) { return this._touchIsTouchEvent(a) && (a.time = (new Date).getTime(), this.__touchEvents.push(a)), this }, _touchSwiped: function (a) { for (var b = !1, c = this.__touchEvents.length - 1; c >= 0; c--) { var d = this.__touchEvents[c]; if ("touchmove" == d.type) { b = !0; break } if ("touchstart" == d.type && a === d.target) break } return b }, _trigger: function () { var b = Array.prototype.slice.apply(arguments); return "string" == typeof b[0] && (b[0] = { type: b[0] }), b[0].instance = this, b[0].origin = this._$origin ? this._$origin[0] : null, b[0].tooltip = this._$tooltip ? this._$tooltip[0] : null, this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, b), a.tooltipster._trigger.apply(a.tooltipster, b), this.__$emitterPublic.trigger.apply(this.__$emitterPublic, b), this }, _unplug: function (b) { var c = this; if (c[b]) { var d = a.tooltipster._plugin(b); d.instance && a.each(d.instance, function (a, d) { c[a] && c[a].bridged === c[b] && delete c[a] }), c[b].__destroy && c[b].__destroy(), delete c[b] } return c }, close: function (a) { return this.__destroyed ? this.__destroyError() : this._close(null, a), this }, content: function (a) { var b = this; if (void 0 === a) return b.__Content; if (b.__destroyed) b.__destroyError(); else if (b.__contentSet(a), null !== b.__Content) { if ("closed" !== b.__state && (b.__contentInsert(), b.reposition(), b.__options.updateAnimation)) if (h.hasTransitions) { var c = b.__options.updateAnimation; b._$tooltip.addClass("tooltipster-update-" + c), setTimeout(function () { "closed" != b.__state && b._$tooltip.removeClass("tooltipster-update-" + c) }, 1e3) } else b._$tooltip.fadeTo(200, .5, function () { "closed" != b.__state && b._$tooltip.fadeTo(200, 1) }) } else b._close(); return b }, destroy: function () { var b = this; if (b.__destroyed) b.__destroyError(); else { "closed" != b.__state ? b.option("animationDuration", 0)._close(null, null, !0) : b.__timeoutsClear(), b._trigger("destroy"), b.__destroyed = !0, b._$origin.removeData(b.__namespace).off("." + b.__namespace + "-triggerOpen"), a(h.window.document.body).off("." + b.__namespace + "-triggerOpen"); var c = b._$origin.data("tooltipster-ns"); if (c) if (1 === c.length) { var d = null; "previous" == b.__options.restoration ? d = b._$origin.data("tooltipster-initialTitle") : "current" == b.__options.restoration && (d = "string" == typeof b.__Content ? b.__Content : a("<div></div>").append(b.__Content).html()), d && b._$origin.attr("title", d), b._$origin.removeClass("tooltipstered"), b._$origin.removeData("tooltipster-ns").removeData("tooltipster-initialTitle") } else c = a.grep(c, function (a, c) { return a !== b.__namespace }), b._$origin.data("tooltipster-ns", c); b._trigger("destroyed"), b._off(), b.off(), b.__Content = null, b.__$emitterPrivate = null, b.__$emitterPublic = null, b.__options.parent = null, b._$origin = null, b._$tooltip = null, a.tooltipster.__instancesLatestArr = a.grep(a.tooltipster.__instancesLatestArr, function (a, c) { return b !== a }), clearInterval(b.__garbageCollector) } return b }, disable: function () { return this.__destroyed ? (this.__destroyError(), this) : (this._close(), this.__enabled = !1, this) }, elementOrigin: function () { return this.__destroyed ? void this.__destroyError() : this._$origin[0] }, elementTooltip: function () { return this._$tooltip ? this._$tooltip[0] : null }, enable: function () { return this.__enabled = !0, this }, hide: function (a) { return this.close(a) }, instance: function () { return this }, off: function () { return this.__destroyed || this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, on: function () { return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, one: function () { return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this }, open: function (a) { return this.__destroyed ? this.__destroyError() : this._open(null, a), this }, option: function (b, c) { return void 0 === c ? this.__options[b] : (this.__destroyed ? this.__destroyError() : (this.__options[b] = c, this.__optionsFormat(), a.inArray(b, ["trigger", "triggerClose", "triggerOpen"]) >= 0 && this.__prepareOrigin(), "selfDestruction" === b && this.__prepareGC()), this) }, reposition: function (a, b) { var c = this; return c.__destroyed ? c.__destroyError() : "closed" != c.__state && d(c._$origin) && (b || d(c._$tooltip)) && (b || c._$tooltip.detach(), c.__Geometry = c.__geometry(), c._trigger({ type: "reposition", event: a, helper: { geo: c.__Geometry } })), c }, show: function (a) { return this.open(a) }, status: function () { return { destroyed: this.__destroyed, enabled: this.__enabled, open: "closed" !== this.__state, state: this.__state } }, triggerHandler: function () { return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this } }, a.fn.tooltipster = function () { var b = Array.prototype.slice.apply(arguments), c = "You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE."; if (0 === this.length) return this; if ("string" == typeof b[0]) { var d = "#*$~&"; return this.each(function () { var e = a(this).data("tooltipster-ns"), f = e ? a(this).data(e[0]) : null; if (!f) throw new Error("You called Tooltipster's \"" + b[0] + '" method on an uninitialized element'); if ("function" != typeof f[b[0]]) throw new Error('Unknown method "' + b[0] + '"'); this.length > 1 && "content" == b[0] && (b[1] instanceof a || "object" == typeof b[1] && null != b[1] && b[1].tagName) && !f.__options.contentCloning && f.__options.debug && console.log(c); var g = f[b[0]](b[1], b[2]); return g !== f || "instance" === b[0] ? (d = g, !1) : void 0 }), "#*$~&" !== d ? d : this } a.tooltipster.__instancesLatestArr = []; var e = b[0] && void 0 !== b[0].multiple, g = e && b[0].multiple || !e && f.multiple, h = b[0] && void 0 !== b[0].content, i = h && b[0].content || !h && f.content, j = b[0] && void 0 !== b[0].contentCloning, k = j && b[0].contentCloning || !j && f.contentCloning, l = b[0] && void 0 !== b[0].debug, m = l && b[0].debug || !l && f.debug; return this.length > 1 && (i instanceof a || "object" == typeof i && null != i && i.tagName) && !k && m && console.log(c), this.each(function () { var c = !1, d = a(this), e = d.data("tooltipster-ns"), f = null; e ? g ? c = !0 : m && (console.log("Tooltipster: one or more tooltips are already attached to the element below. Ignoring."), console.log(this)) : c = !0, c && (f = new a.Tooltipster(this, b[0]), e || (e = []), e.push(f.__namespace), d.data("tooltipster-ns", e), d.data(f.__namespace, f), f.__options.functionInit && f.__options.functionInit.call(f, f, { origin: this }), f._trigger("init")), a.tooltipster.__instancesLatestArr.push(f) }), this }, b.prototype = { __init: function (b) { this.__$tooltip = b, this.__$tooltip.css({ left: 0, overflow: "hidden", position: "absolute", top: 0 }).find(".tooltipster-content").css("overflow", "auto"), this.$container = a('<div class="tooltipster-ruler"></div>').append(this.__$tooltip).appendTo(h.window.document.body) }, __forceRedraw: function () { var a = this.__$tooltip.parent(); this.__$tooltip.detach(), this.__$tooltip.appendTo(a) }, constrain: function (a, b) { return this.constraints = { width: a, height: b }, this.__$tooltip.css({ display: "block", height: "", overflow: "auto", width: a }), this }, destroy: function () { this.__$tooltip.detach().find(".tooltipster-content").css({ display: "", overflow: "" }), this.$container.remove() }, free: function () { return this.constraints = null, this.__$tooltip.css({ display: "", height: "", overflow: "visible", width: "" }), this }, measure: function () { this.__forceRedraw(); var a = this.__$tooltip[0].getBoundingClientRect(), b = { size: { height: a.height || a.bottom - a.top, width: a.width || a.right - a.left } }; if (this.constraints) { var c = this.__$tooltip.find(".tooltipster-content"), d = this.__$tooltip.outerHeight(), e = c[0].getBoundingClientRect(), f = { height: d <= this.constraints.height, width: a.width <= this.constraints.width && e.width >= c[0].scrollWidth - 1 }; b.fits = f.height && f.width } return h.IE && h.IE <= 11 && b.size.width !== h.window.document.documentElement.clientWidth && (b.size.width = Math.ceil(b.size.width) + 1), b } }; var j = navigator.userAgent.toLowerCase(); -1 != j.indexOf("msie") ? h.IE = parseInt(j.split("msie")[1]) : -1 !== j.toLowerCase().indexOf("trident") && -1 !== j.indexOf(" rv:11") ? h.IE = 11 : -1 != j.toLowerCase().indexOf("edge/") && (h.IE = parseInt(j.toLowerCase().split("edge/")[1])); var k = "tooltipster.sideTip"; return a.tooltipster._plugin({
        name: k, instance: {
            __defaults: function () { return { arrow: !0, distance: 6, functionPosition: null, maxWidth: null, minIntersection: 16, minWidth: 0, position: null, side: "top", viewportAware: !0 } }, __init: function (a) { var b = this; b.__instance = a, b.__namespace = "tooltipster-sideTip-" + Math.round(1e6 * Math.random()), b.__previousState = "closed", b.__options, b.__optionsFormat(), b.__instance._on("state." + b.__namespace, function (a) { "closed" == a.state ? b.__close() : "appearing" == a.state && "closed" == b.__previousState && b.__create(), b.__previousState = a.state }), b.__instance._on("options." + b.__namespace, function () { b.__optionsFormat() }), b.__instance._on("reposition." + b.__namespace, function (a) { b.__reposition(a.event, a.helper) }) }, __close: function () { this.__instance.content() instanceof a && this.__instance.content().detach(), this.__instance._$tooltip.remove(), this.__instance._$tooltip = null }, __create: function () {
                var b = a('<div class="tooltipster-base tooltipster-sidetip"><div class="tooltipster-box"><div class="tooltipster-content"></div></div><div class="tooltipster-arrow"><div class="tooltipster-arrow-uncropped"><div class="tooltipster-arrow-border"></div><div class="tooltipster-arrow-background"></div></div></div></div>'); this.__options.arrow || b.find(".tooltipster-box").css("margin", 0).end().find(".tooltipster-arrow").hide(), this.__options.minWidth && b.css("min-width", this.__options.minWidth + "px"), this.__options.maxWidth && b.css("max-width", this.__options.maxWidth + "px"),
                    this.__instance._$tooltip = b, this.__instance._trigger("created")
            }, __destroy: function () { this.__instance._off("." + self.__namespace) }, __optionsFormat: function () { var b = this; if (b.__options = b.__instance._optionsExtract(k, b.__defaults()), b.__options.position && (b.__options.side = b.__options.position), "object" != typeof b.__options.distance && (b.__options.distance = [b.__options.distance]), b.__options.distance.length < 4 && (void 0 === b.__options.distance[1] && (b.__options.distance[1] = b.__options.distance[0]), void 0 === b.__options.distance[2] && (b.__options.distance[2] = b.__options.distance[0]), void 0 === b.__options.distance[3] && (b.__options.distance[3] = b.__options.distance[1]), b.__options.distance = { top: b.__options.distance[0], right: b.__options.distance[1], bottom: b.__options.distance[2], left: b.__options.distance[3] }), "string" == typeof b.__options.side) { var c = { top: "bottom", right: "left", bottom: "top", left: "right" }; b.__options.side = [b.__options.side, c[b.__options.side]], "left" == b.__options.side[0] || "right" == b.__options.side[0] ? b.__options.side.push("top", "bottom") : b.__options.side.push("right", "left") } 6 === a.tooltipster._env.IE && b.__options.arrow !== !0 && (b.__options.arrow = !1) }, __reposition: function (b, c) { var d, e = this, f = e.__targetFind(c), g = []; e.__instance._$tooltip.detach(); var h = e.__instance._$tooltip.clone(), i = a.tooltipster._getRuler(h), j = !1, k = e.__instance.option("animation"); switch (k && h.removeClass("tooltipster-" + k), a.each(["window", "document"], function (d, k) { var l = null; if (e.__instance._trigger({ container: k, helper: c, satisfied: j, takeTest: function (a) { l = a }, results: g, type: "positionTest" }), 1 == l || 0 != l && 0 == j && ("window" != k || e.__options.viewportAware)) for (var d = 0; d < e.__options.side.length; d++) { var m = { horizontal: 0, vertical: 0 }, n = e.__options.side[d]; "top" == n || "bottom" == n ? m.vertical = e.__options.distance[n] : m.horizontal = e.__options.distance[n], e.__sideChange(h, n), a.each(["natural", "constrained"], function (a, d) { if (l = null, e.__instance._trigger({ container: k, event: b, helper: c, mode: d, results: g, satisfied: j, side: n, takeTest: function (a) { l = a }, type: "positionTest" }), 1 == l || 0 != l && 0 == j) { var h = { container: k, distance: m, fits: null, mode: d, outerSize: null, side: n, size: null, target: f[n], whole: null }, o = "natural" == d ? i.free() : i.constrain(c.geo.available[k][n].width - m.horizontal, c.geo.available[k][n].height - m.vertical), p = o.measure(); if (h.size = p.size, h.outerSize = { height: p.size.height + m.vertical, width: p.size.width + m.horizontal }, "natural" == d ? c.geo.available[k][n].width >= h.outerSize.width && c.geo.available[k][n].height >= h.outerSize.height ? h.fits = !0 : h.fits = !1 : h.fits = p.fits, "window" == k && (h.fits ? "top" == n || "bottom" == n ? h.whole = c.geo.origin.windowOffset.right >= e.__options.minIntersection && c.geo.window.size.width - c.geo.origin.windowOffset.left >= e.__options.minIntersection : h.whole = c.geo.origin.windowOffset.bottom >= e.__options.minIntersection && c.geo.window.size.height - c.geo.origin.windowOffset.top >= e.__options.minIntersection : h.whole = !1), g.push(h), h.whole) j = !0; else if ("natural" == h.mode && (h.fits || h.size.width <= c.geo.available[k][n].width)) return !1 } }) } }), e.__instance._trigger({ edit: function (a) { g = a }, event: b, helper: c, results: g, type: "positionTested" }), g.sort(function (a, b) { if (a.whole && !b.whole) return -1; if (!a.whole && b.whole) return 1; if (a.whole && b.whole) { var c = e.__options.side.indexOf(a.side), d = e.__options.side.indexOf(b.side); return d > c ? -1 : c > d ? 1 : "natural" == a.mode ? -1 : 1 } if (a.fits && !b.fits) return -1; if (!a.fits && b.fits) return 1; if (a.fits && b.fits) { var c = e.__options.side.indexOf(a.side), d = e.__options.side.indexOf(b.side); return d > c ? -1 : c > d ? 1 : "natural" == a.mode ? -1 : 1 } return "document" == a.container && "bottom" == a.side && "natural" == a.mode ? -1 : 1 }), d = g[0], d.coord = {}, d.side) { case "left": case "right": d.coord.top = Math.floor(d.target - d.size.height / 2); break; case "bottom": case "top": d.coord.left = Math.floor(d.target - d.size.width / 2) }switch (d.side) { case "left": d.coord.left = c.geo.origin.windowOffset.left - d.outerSize.width; break; case "right": d.coord.left = c.geo.origin.windowOffset.right + d.distance.horizontal; break; case "top": d.coord.top = c.geo.origin.windowOffset.top - d.outerSize.height; break; case "bottom": d.coord.top = c.geo.origin.windowOffset.bottom + d.distance.vertical }"window" == d.container ? "top" == d.side || "bottom" == d.side ? d.coord.left < 0 ? c.geo.origin.windowOffset.right - this.__options.minIntersection >= 0 ? d.coord.left = 0 : d.coord.left = c.geo.origin.windowOffset.right - this.__options.minIntersection - 1 : d.coord.left > c.geo.window.size.width - d.size.width && (c.geo.origin.windowOffset.left + this.__options.minIntersection <= c.geo.window.size.width ? d.coord.left = c.geo.window.size.width - d.size.width : d.coord.left = c.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - d.size.width) : d.coord.top < 0 ? c.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0 ? d.coord.top = 0 : d.coord.top = c.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1 : d.coord.top > c.geo.window.size.height - d.size.height && (c.geo.origin.windowOffset.top + this.__options.minIntersection <= c.geo.window.size.height ? d.coord.top = c.geo.window.size.height - d.size.height : d.coord.top = c.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - d.size.height) : (d.coord.left > c.geo.window.size.width - d.size.width && (d.coord.left = c.geo.window.size.width - d.size.width), d.coord.left < 0 && (d.coord.left = 0)), e.__sideChange(h, d.side), c.tooltipClone = h[0], c.tooltipParent = e.__instance.option("parent").parent[0], c.mode = d.mode, c.whole = d.whole, c.origin = e.__instance._$origin[0], c.tooltip = e.__instance._$tooltip[0], delete d.container, delete d.fits, delete d.mode, delete d.outerSize, delete d.whole, d.distance = d.distance.horizontal || d.distance.vertical; var l = a.extend(!0, {}, d); if (e.__instance._trigger({ edit: function (a) { d = a }, event: b, helper: c, position: l, type: "position" }), e.__options.functionPosition) { var m = e.__options.functionPosition.call(e, e.__instance, c, l); m && (d = m) } i.destroy(); var n, o; "top" == d.side || "bottom" == d.side ? (n = { prop: "left", val: d.target - d.coord.left }, o = d.size.width - this.__options.minIntersection) : (n = { prop: "top", val: d.target - d.coord.top }, o = d.size.height - this.__options.minIntersection), n.val < this.__options.minIntersection ? n.val = this.__options.minIntersection : n.val > o && (n.val = o); var p; p = c.geo.origin.fixedLineage ? c.geo.origin.windowOffset : { left: c.geo.origin.windowOffset.left + c.geo.window.scroll.left, top: c.geo.origin.windowOffset.top + c.geo.window.scroll.top }, d.coord = { left: p.left + (d.coord.left - c.geo.origin.windowOffset.left), top: p.top + (d.coord.top - c.geo.origin.windowOffset.top) }, e.__sideChange(e.__instance._$tooltip, d.side), c.geo.origin.fixedLineage ? e.__instance._$tooltip.css("position", "fixed") : e.__instance._$tooltip.css("position", ""), e.__instance._$tooltip.css({ left: d.coord.left, top: d.coord.top, height: d.size.height, width: d.size.width }).find(".tooltipster-arrow").css({ left: "", top: "" }).css(n.prop, n.val), e.__instance._$tooltip.appendTo(e.__instance.option("parent")), e.__instance._trigger({ type: "repositioned", event: b, position: d }) }, __sideChange: function (a, b) { a.removeClass("tooltipster-bottom").removeClass("tooltipster-left").removeClass("tooltipster-right").removeClass("tooltipster-top").addClass("tooltipster-" + b) }, __targetFind: function (a) { var b = {}, c = this.__instance._$origin[0].getClientRects(); if (c.length > 1) { var d = this.__instance._$origin.css("opacity"); 1 == d && (this.__instance._$origin.css("opacity", .99), c = this.__instance._$origin[0].getClientRects(), this.__instance._$origin.css("opacity", 1)) } if (c.length < 2) b.top = Math.floor(a.geo.origin.windowOffset.left + a.geo.origin.size.width / 2), b.bottom = b.top, b.left = Math.floor(a.geo.origin.windowOffset.top + a.geo.origin.size.height / 2), b.right = b.left; else { var e = c[0]; b.top = Math.floor(e.left + (e.right - e.left) / 2), e = c.length > 2 ? c[Math.ceil(c.length / 2) - 1] : c[0], b.right = Math.floor(e.top + (e.bottom - e.top) / 2), e = c[c.length - 1], b.bottom = Math.floor(e.left + (e.right - e.left) / 2), e = c.length > 2 ? c[Math.ceil((c.length + 1) / 2) - 1] : c[c.length - 1], b.left = Math.floor(e.top + (e.bottom - e.top) / 2) } return b }
        }
    }), a
});
/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function (window, undefined) {
    '$:nomunge'; // Used by YUI compressor.

    // Since jQuery really isn't required for this plugin, use `jQuery` as the
    // namespace only if it already exists, otherwise use the `Cowboy` namespace,
    // creating it if necessary.
    var $ = window.jQuery || window.Cowboy || (window.Cowboy = {}),

        // Internal method reference.
        jq_throttle;

    // Method: jQuery.throttle
    // 
    // Throttle execution of a function. Especially useful for rate limiting
    // execution of handlers on events like resize and scroll. If you want to
    // rate-limit execution of a function to a single time, see the
    // <jQuery.debounce> method.
    // 
    // In this visualization, | is a throttled-function call and X is the actual
    // callback execution:
    // 
    // > Throttled with `no_trailing` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X    X        X    X    X    X    X    X
    // > 
    // > Throttled with `no_trailing` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X             X    X    X    X    X
    // 
    // Usage:
    // 
    // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', throttled );
    // > jQuery('selector').unbind( 'someevent', throttled );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
    //    true, callback will only execute every `delay` milliseconds while the
    //    throttled-function is being called. If no_trailing is false or
    //    unspecified, callback will be executed one final time after the last
    //    throttled-function call. (After the throttled-function has not been
    //    called for `delay` milliseconds, the internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the throttled-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, throttled, function.

    $.throttle = jq_throttle = function (delay, no_trailing, callback, debounce_mode) {
        // After wrapper has stopped being called, this timeout ensures that
        // `callback` is executed at the proper times in `throttle` and `end`
        // debounce modes.
        var timeout_id,

            // Keep track of the last time `callback` was executed.
            last_exec = 0;

        // `no_trailing` defaults to falsy.
        if (typeof no_trailing !== 'boolean') {
            debounce_mode = callback;
            callback = no_trailing;
            no_trailing = undefined;
        }

        // The `wrapper` function encapsulates all of the throttling / debouncing
        // functionality and when executed will limit the rate at which `callback`
        // is executed.
        function wrapper() {
            var that = this,
                elapsed = +new Date() - last_exec,
                args = arguments;

            // Execute `callback` and update the `last_exec` timestamp.
            function exec() {
                last_exec = +new Date();
                callback.apply(that, args);
            };

            // If `debounce_mode` is true (at_begin) this is used to clear the flag
            // to allow future `callback` executions.
            function clear() {
                timeout_id = undefined;
            };

            if (debounce_mode && !timeout_id) {
                // Since `wrapper` is being called for the first time and
                // `debounce_mode` is true (at_begin), execute `callback`.
                exec();
            }

            // Clear any existing timeout.
            timeout_id && clearTimeout(timeout_id);

            if (debounce_mode === undefined && elapsed > delay) {
                // In throttle mode, if `delay` time has been exceeded, execute
                // `callback`.
                exec();

            } else if (no_trailing !== true) {
                // In trailing throttle mode, since `delay` time has not been
                // exceeded, schedule `callback` to execute `delay` ms after most
                // recent execution.
                // 
                // If `debounce_mode` is true (at_begin), schedule `clear` to execute
                // after `delay` ms.
                // 
                // If `debounce_mode` is false (at end), schedule `callback` to
                // execute after `delay` ms.
                timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
            }
        };

        // Set the guid of `wrapper` function to the same of original callback, so
        // it can be removed in jQuery 1.4+ .unbind or .die by using the original
        // callback as a reference.
        if ($.guid) {
            wrapper.guid = callback.guid = callback.guid || $.guid++;
        }

        // Return the wrapper function.
        return wrapper;
    };

    // Method: jQuery.debounce
    // 
    // Debounce execution of a function. Debouncing, unlike throttling,
    // guarantees that a function is only executed a single time, either at the
    // very beginning of a series of calls, or at the very end. If you want to
    // simply rate-limit execution of a function, see the <jQuery.throttle>
    // method.
    // 
    // In this visualization, | is a debounced-function call and X is the actual
    // callback execution:
    // 
    // > Debounced with `at_begin` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // >                          X                                 X
    // > 
    // > Debounced with `at_begin` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X                                 X
    // 
    // Usage:
    // 
    // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', debounced );
    // > jQuery('selector').unbind( 'someevent', debounced );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
    //    unspecified, callback will only be executed `delay` milliseconds after
    //    the last debounced-function call. If at_begin is true, callback will be
    //    executed only at the first debounced-function call. (After the
    //    throttled-function has not been called for `delay` milliseconds, the
    //    internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the debounced-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, debounced, function.

    $.debounce = function (delay, at_begin, callback) {
        return callback === undefined
            ? jq_throttle(delay, at_begin, false)
            : jq_throttle(delay, callback, at_begin !== false);
    };

})(window);
(function ($) {

    $.fn.shuffle = function () {

        var allElems = this.get(),
            getRandom = function (max) {
                return Math.floor(Math.random() * max);
            },
            shuffled = $.map(allElems, function () {
                var random = getRandom(allElems.length),
                    randEl = $(allElems[random]).clone(true)[0];
                allElems.splice(random, 1);
                return randEl;
            });

        this.each(function (i) {
            $(this).replaceWith($(shuffled[i]));
        });

        return $(shuffled);

    };

})(jQuery);
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
  
!function (root, name, definition) {
    if (typeof module != 'undefined' && module.exports) module.exports = definition()
    else if (typeof define == 'function' && define.amd) define(name, definition)
    else {
        window[name] = definition()
    }
}(this, 'bowser', function () {
    /**
      * See useragents.js for examples of navigator.userAgent
      */

    var t = true

    function detect(ua) {

        function getFirstMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[1]) || '';
        }

        function getSecondMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[2]) || '';
        }

        var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
            , likeAndroid = /like android/i.test(ua)
            , android = !likeAndroid && /android/i.test(ua)
            , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
            , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
            , chromeos = /CrOS/.test(ua)
            , silk = /silk/i.test(ua)
            , sailfish = /sailfish/i.test(ua)
            , tizen = /tizen/i.test(ua)
            , webos = /(web|hpw)(o|0)s/i.test(ua)
            , windowsphone = /windows phone/i.test(ua)
            , samsungBrowser = /SamsungBrowser/i.test(ua)
            , windows = !windowsphone && /windows/i.test(ua)
            , mac = !iosdevice && !silk && /macintosh/i.test(ua)
            , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
            , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
            , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
            , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
            , mobile = !tablet && /[^-]mobi/i.test(ua)
            , xbox = /xbox/i.test(ua)
            , result

        if (/opera/i.test(ua)) {
            //  an old Opera
            result = {
                name: 'Opera'
                , opera: t
                , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            }
        } else if (/opr\/|opios/i.test(ua)) {
            // a new Opera
            result = {
                name: 'Opera'
                , opera: t
                , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (/SamsungBrowser/i.test(ua)) {
            result = {
                name: 'Samsung Internet for Android'
                , samsungBrowser: t
                , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/Whale/i.test(ua)) {
            result = {
                name: 'NAVER Whale browser'
                , whale: t
                , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/MZBrowser/i.test(ua)) {
            result = {
                name: 'MZ Browser'
                , mzbrowser: t
                , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/coast/i.test(ua)) {
            result = {
                name: 'Opera Coast'
                , coast: t
                , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/focus/i.test(ua)) {
            result = {
                name: 'Focus'
                , focus: t
                , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/yabrowser/i.test(ua)) {
            result = {
                name: 'Yandex Browser'
                , yandexbrowser: t
                , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/ucbrowser/i.test(ua)) {
            result = {
                name: 'UC Browser'
                , ucbrowser: t
                , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/mxios/i.test(ua)) {
            result = {
                name: 'Maxthon'
                , maxthon: t
                , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/epiphany/i.test(ua)) {
            result = {
                name: 'Epiphany'
                , epiphany: t
                , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/puffin/i.test(ua)) {
            result = {
                name: 'Puffin'
                , puffin: t
                , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
            }
        }
        else if (/sleipnir/i.test(ua)) {
            result = {
                name: 'Sleipnir'
                , sleipnir: t
                , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/k-meleon/i.test(ua)) {
            result = {
                name: 'K-Meleon'
                , kMeleon: t
                , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (windowsphone) {
            result = {
                name: 'Windows Phone'
                , osname: 'Windows Phone'
                , windowsphone: t
            }
            if (edgeVersion) {
                result.msedge = t
                result.version = edgeVersion
            }
            else {
                result.msie = t
                result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/msie|trident/i.test(ua)) {
            result = {
                name: 'Internet Explorer'
                , msie: t
                , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
            }
        } else if (chromeos) {
            result = {
                name: 'Chrome'
                , osname: 'Chrome OS'
                , chromeos: t
                , chromeBook: t
                , chrome: t
                , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            }
        } else if (/edg([ea]|ios)/i.test(ua)) {
            result = {
                name: 'Microsoft Edge'
                , msedge: t
                , version: edgeVersion
            }
        }
        else if (/vivaldi/i.test(ua)) {
            result = {
                name: 'Vivaldi'
                , vivaldi: t
                , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (sailfish) {
            result = {
                name: 'Sailfish'
                , osname: 'Sailfish OS'
                , sailfish: t
                , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/seamonkey\//i.test(ua)) {
            result = {
                name: 'SeaMonkey'
                , seamonkey: t
                , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/firefox|iceweasel|fxios/i.test(ua)) {
            result = {
                name: 'Firefox'
                , firefox: t
                , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            }
            if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
                result.firefoxos = t
                result.osname = 'Firefox OS'
            }
        }
        else if (silk) {
            result = {
                name: 'Amazon Silk'
                , silk: t
                , version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/phantom/i.test(ua)) {
            result = {
                name: 'PhantomJS'
                , phantom: t
                , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/slimerjs/i.test(ua)) {
            result = {
                name: 'SlimerJS'
                , slimer: t
                , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
            result = {
                name: 'BlackBerry'
                , osname: 'BlackBerry OS'
                , blackberry: t
                , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
            }
        }
        else if (webos) {
            result = {
                name: 'WebOS'
                , osname: 'WebOS'
                , webos: t
                , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
            };
            /touchpad\//i.test(ua) && (result.touchpad = t)
        }
        else if (/bada/i.test(ua)) {
            result = {
                name: 'Bada'
                , osname: 'Bada'
                , bada: t
                , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
            };
        }
        else if (tizen) {
            result = {
                name: 'Tizen'
                , osname: 'Tizen'
                , tizen: t
                , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
            };
        }
        else if (/qupzilla/i.test(ua)) {
            result = {
                name: 'QupZilla'
                , qupzilla: t
                , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
            }
        }
        else if (/chromium/i.test(ua)) {
            result = {
                name: 'Chromium'
                , chromium: t
                , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (/chrome|crios|crmo/i.test(ua)) {
            result = {
                name: 'Chrome'
                , chrome: t
                , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            }
        }
        else if (android) {
            result = {
                name: 'Android'
                , version: versionIdentifier
            }
        }
        else if (/safari|applewebkit/i.test(ua)) {
            result = {
                name: 'Safari'
                , safari: t
            }
            if (versionIdentifier) {
                result.version = versionIdentifier
            }
        }
        else if (iosdevice) {
            result = {
                name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
            }
            // WTF: version is not part of user agent in web apps
            if (versionIdentifier) {
                result.version = versionIdentifier
            }
        }
        else if (/googlebot/i.test(ua)) {
            result = {
                name: 'Googlebot'
                , googlebot: t
                , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
            }
        }
        else {
            result = {
                name: getFirstMatch(/^(.*)\/(.*) /),
                version: getSecondMatch(/^(.*)\/(.*) /)
            };
        }

        // set webkit or gecko flag for browsers based on these engines
        if (!result.msedge && /(apple)?webkit/i.test(ua)) {
            if (/(apple)?webkit\/537\.36/i.test(ua)) {
                result.name = result.name || "Blink"
                result.blink = t
            } else {
                result.name = result.name || "Webkit"
                result.webkit = t
            }
            if (!result.version && versionIdentifier) {
                result.version = versionIdentifier
            }
        } else if (!result.opera && /gecko\//i.test(ua)) {
            result.name = result.name || "Gecko"
            result.gecko = t
            result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
        }

        // set OS flags for platforms that have multiple browsers
        if (!result.windowsphone && (android || result.silk)) {
            result.android = t
            result.osname = 'Android'
        } else if (!result.windowsphone && iosdevice) {
            result[iosdevice] = t
            result.ios = t
            result.osname = 'iOS'
        } else if (mac) {
            result.mac = t
            result.osname = 'macOS'
        } else if (xbox) {
            result.xbox = t
            result.osname = 'Xbox'
        } else if (windows) {
            result.windows = t
            result.osname = 'Windows'
        } else if (linux) {
            result.linux = t
            result.osname = 'Linux'
        }

        function getWindowsVersion(s) {
            switch (s) {
                case 'NT': return 'NT'
                case 'XP': return 'XP'
                case 'NT 5.0': return '2000'
                case 'NT 5.1': return 'XP'
                case 'NT 5.2': return '2003'
                case 'NT 6.0': return 'Vista'
                case 'NT 6.1': return '7'
                case 'NT 6.2': return '8'
                case 'NT 6.3': return '8.1'
                case 'NT 10.0': return '10'
                default: return undefined
            }
        }

        // OS version extraction
        var osVersion = '';
        if (result.windows) {
            osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
        } else if (result.windowsphone) {
            osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
        } else if (result.mac) {
            osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
            osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (iosdevice) {
            osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
            osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (android) {
            osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
        } else if (result.webos) {
            osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
        } else if (result.blackberry) {
            osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
        } else if (result.bada) {
            osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
        } else if (result.tizen) {
            osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
        }
        if (osVersion) {
            result.osversion = osVersion;
        }

        // device type extraction
        var osMajorVersion = !result.windows && osVersion.split('.')[0];
        if (
            tablet
            || nexusTablet
            || iosdevice == 'ipad'
            || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
            || result.silk
        ) {
            result.tablet = t
        } else if (
            mobile
            || iosdevice == 'iphone'
            || iosdevice == 'ipod'
            || android
            || nexusMobile
            || result.blackberry
            || result.webos
            || result.bada
        ) {
            result.mobile = t
        }

        // Graded Browser Support
        // http://developer.yahoo.com/yui/articles/gbs
        if (result.msedge ||
            (result.msie && result.version >= 10) ||
            (result.yandexbrowser && result.version >= 15) ||
            (result.vivaldi && result.version >= 1.0) ||
            (result.chrome && result.version >= 20) ||
            (result.samsungBrowser && result.version >= 4) ||
            (result.whale && compareVersions([result.version, '1.0']) === 1) ||
            (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
            (result.focus && compareVersions([result.version, '1.0']) === 1) ||
            (result.firefox && result.version >= 20.0) ||
            (result.safari && result.version >= 6) ||
            (result.opera && result.version >= 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
            (result.blackberry && result.version >= 10.1)
            || (result.chromium && result.version >= 20)
        ) {
            result.a = t;
        }
        else if ((result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20.0) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
            || (result.chromium && result.version < 20)
        ) {
            result.c = t
        } else result.x = t

        return result
    }

    var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

    bowser.test = function (browserList) {
        for (var i = 0; i < browserList.length; ++i) {
            var browserItem = browserList[i];
            if (typeof browserItem === 'string') {
                if (browserItem in bowser) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Get version precisions count
     *
     * @example
     *   getVersionPrecision("1.10.3") // 3
     *
     * @param  {string} version
     * @return {number}
     */
    function getVersionPrecision(version) {
        return version.split(".").length;
    }

    /**
     * Array::map polyfill
     *
     * @param  {Array} arr
     * @param  {Function} iterator
     * @return {Array}
     */
    function map(arr, iterator) {
        var result = [], i;
        if (Array.prototype.map) {
            return Array.prototype.map.call(arr, iterator);
        }
        for (i = 0; i < arr.length; i++) {
            result.push(iterator(arr[i]));
        }
        return result;
    }

    /**
     * Calculate browser version weight
     *
     * @example
     *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
     *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
     *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
     *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
     *
     * @param  {Array<String>} versions versions to compare
     * @return {Number} comparison result
     */
    function compareVersions(versions) {
        // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
        var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
        var chunks = map(versions, function (version) {
            var delta = precision - getVersionPrecision(version);

            // 2) "9" -> "9.0" (for precision = 2)
            version = version + new Array(delta + 1).join(".0");

            // 3) "9.0" -> ["000000000"", "000000009"]
            return map(version.split("."), function (chunk) {
                return new Array(20 - chunk.length).join("0") + chunk;
            }).reverse();
        });

        // iterate in reverse order by reversed chunks array
        while (--precision >= 0) {
            // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
            if (chunks[0][precision] > chunks[1][precision]) {
                return 1;
            }
            else if (chunks[0][precision] === chunks[1][precision]) {
                if (precision === 0) {
                    // all version chunks are same
                    return 0;
                }
            }
            else {
                return -1;
            }
        }
    }

    /**
     * Check if browser is unsupported
     *
     * @example
     *   bowser.isUnsupportedBrowser({
     *     msie: "10",
     *     firefox: "23",
     *     chrome: "29",
     *     safari: "5.1",
     *     opera: "16",
     *     phantom: "534"
     *   });
     *
     * @param  {Object}  minVersions map of minimal version to browser
     * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
     * @param  {String}  [ua] user agent string
     * @return {Boolean}
     */
    function isUnsupportedBrowser(minVersions, strictMode, ua) {
        var _bowser = bowser;

        // make strictMode param optional with ua param usage
        if (typeof strictMode === 'string') {
            ua = strictMode;
            strictMode = void (0);
        }

        if (strictMode === void (0)) {
            strictMode = false;
        }
        if (ua) {
            _bowser = detect(ua);
        }

        var version = "" + _bowser.version;
        for (var browser in minVersions) {
            if (minVersions.hasOwnProperty(browser)) {
                if (_bowser[browser]) {
                    if (typeof minVersions[browser] !== 'string') {
                        throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
                    }

                    // browser version and min supported version.
                    return compareVersions([version, minVersions[browser]]) < 0;
                }
            }
        }

        return strictMode; // not found
    }

    /**
     * Check if browser is supported
     *
     * @param  {Object} minVersions map of minimal version to browser
     * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
     * @param  {String}  [ua] user agent string
     * @return {Boolean}
     */
    function check(minVersions, strictMode, ua) {
        return !isUnsupportedBrowser(minVersions, strictMode, ua);
    }

    bowser.isUnsupportedBrowser = isUnsupportedBrowser;
    bowser.compareVersions = compareVersions;
    bowser.check = check;

    /*
     * Set our detect method to the main bowser object so we can
     * reuse it to test other user agents.
     * This is needed to implement future tests.
     */
    bowser._detect = detect;

    /*
     * Set our detect public method to the main bowser object
     * This is needed to implement bowser in server side
     */
    bowser.detect = detect;
    return bowser
});
// Promise.finally has not been implemented in Microsoft Edge
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
if (Promise.prototype.finally === undefined) {
    // It's replaced unconditionally to preserve the expected behavior
    // in programs even if there's ever a native finally.
    window.Promise.prototype['finally'] = function finallyPolyfill(callback) {
        let constructor = this.constructor;

        return this.then((value) => {
            return constructor.resolve(callback()).then(() => {
                return value;
            });
        }, (reason) => {
            return constructor.resolve(callback()).then(() => {
                throw reason;
            });
        });
    };
}
var layoutr = window.layoutr || {};
{
    layoutr.siteName = 'layoutr';

    layoutr.throttleInterval = 50;
    layoutr.debounceInterval = 50;

    layoutr.transitionTime = 400;
    layoutr.fadeOutTime = 500;
    layoutr.htmlOverflowEnabled = true;
    layoutr.smallBreakpoint = 732;
    layoutr.scrollbarWidth = 0;
    layoutr.loadingCount = 0;
    layoutr.document = document.documentElement;
    layoutr.fullscreen = false;
    layoutr.ajax = 'dist/ajax/';
    layoutr.arrowKeyLocked = false;
    layoutr.sort = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;

    layoutr.navigation = [];
    bowser.desktop = !bowser.mobile && !bowser.tablet;

    let l = window.location,
        segmentCount = l.origin.endsWith('github.io') ? 1 : 0;
    layoutr.host = `${l.protocol}//${l.hostname}${l.port ? `:${l.port}` : ''}${l.pathname.split('/').slice(0, 1 + segmentCount).join('/')}/`;

    layoutr.awaitInterval = 50;
    // window.Areion = Ghostlab
    layoutr.isLocalhost = window.Areion || l.hostname === 'localhost' || l.hostname === '127.0.0.1' || l.hostname === '192.168.40.100';

    layoutr.settings = JSON.parse(localStorage.getItem("settings"));
    if (layoutr.settings === null) layoutr.settings = [];
    layoutr.theme = 'light';
    layoutr.settings.forEach((entry) => {
        if (entry.name === 'theme') {
            layoutr.theme = entry.id.substring(entry.id.indexOf("-") + 1);
        }
    });

    $(() => {
        layoutr.html = $('html');
        layoutr.head = $('head');
        layoutr.body = $('body');
        layoutr.main = $('main');
        layoutr.content = $('#content > div');
        layoutr.header = $('header');
        layoutr.footer = $('footer');
        layoutr.left = $('#left');
        layoutr.right = $('#right');
        layoutr.loading = $('#loading');
        layoutr.overflow = $('#overflow');
        layoutr.modal = $('#modal');
        layoutr.title = $('#title');
        layoutr.authentication = $('#authentication');
        layoutr.unauthenticated = layoutr.authentication.children('.unauthenticated');
        layoutr.authenticated = layoutr.authentication.children('.authenticated');
        layoutr.authenticatedLinks = layoutr.authentication.find('.links');
        layoutr.cookie = $('#cookie');
        layoutr.focus = $('#focus');
    });
}
{
    String.prototype.replaceAll = function (search, replacement) {
        let target = this;
        return target.replace(new RegExp(search, 'g'), replacement);
    };

    layoutr.guid = () => {
        let s4 = () => {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        };
        return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4() + s4()}`;
    };

    layoutr.isSmallBreakpoint = () => {
        return $(window).outerWidth() < 732 || layoutr.isAsideLeft() && !layoutr.isAsideLeftShrink() || layoutr.isAsideRight() && !layoutr.isAsideRightShrink();
    };

    layoutr.isAside = () => {
        return layoutr.html.attr('data-aside').length;
    };

    layoutr.isAsideLeft = () => {
        return layoutr.html.attr('data-aside') === 'left';
    };

    layoutr.isAsideRight = () => {
        return layoutr.html.attr('data-aside') === 'right';
    };

    layoutr.isAsideLeftShrink = () => {
        return layoutr.html.hasClass('left-shrink') && layoutr.isAsideLeft();
    };

    layoutr.isAsideRightShrink = () => {
        return layoutr.html.hasClass('right-shrink') && layoutr.isAsideRight();
    };

    layoutr.isAsideLeftCloseOnClickOutside = () => {
        return layoutr.html.hasClass('close-left-click-outside');
    };
    layoutr.isAsideRightCloseOnClickOutside = () => {
        return layoutr.html.hasClass('close-right-click-outside');
    };

    layoutr.isModal = () => {
        return layoutr.html.hasClass('modal');
    };

    layoutr.isModalForm = () => {
        return layoutr.html.attr('data-modal') === 'form';
    };

    layoutr.isModalImage = () => {
        return layoutr.html.attr('data-modal') === 'image';
    };

    layoutr.isFocus = () => {
        return layoutr.html.hasClass('focus') && layoutr.html.attr('data-focus') === 'true';
    };

    layoutr.isTTS = () => {
        return layoutr.html.hasClass('tts');
    };

    layoutr.isTTSEnabled = () => {
        return layoutr.html.hasClass('tts') && layoutr.html.attr('data-tts') === 'true';
    };

    layoutr.isAuthentication = () => {
        return layoutr.html.attr('data-authentication') !== '';
    };

    layoutr.isLoading = () => {
        return layoutr.html.hasClass('loading');
    };

    layoutr.isScrollDisabled = () => {
        return layoutr.html.hasClass('scroll-disabled');
    };

    layoutr.isCloseLeftPageChange = () => {
        return layoutr.html.hasClass('close-left-page-change');
    };

    layoutr.isTransitions = () => {
        return layoutr.html.hasClass('transitions');
    };

    layoutr.isSwipe = () => {
        return layoutr.html.hasClass('swipe');
    };

    layoutr.isSiteLoaded = () => {
        return layoutr.html.hasClass('site-loaded');
    };

    layoutr.capitalize = (string) => {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };

    layoutr.scrollTop = () => {
        return Math.max(layoutr.body.scrollTop(), layoutr.main.scrollTop(), layoutr.html.scrollTop());
    };

    layoutr.tryParseInt = (str, defaultValue) => {
        let retValue = defaultValue;
        if (str !== undefined && str !== null && str.length > 0 && !isNaN(str)) {
            retValue = parseInt(str);
        }
        return retValue;
    };

    layoutr.tryParseFloat = (str, defaultValue) => {
        let retValue = defaultValue;
        if (str !== undefined && str !== null && str.length > 0 && !isNaN(str)) {
            retValue = parseFloat(str);
        }
        return retValue;
    };

    layoutr.tryParseJSON = (str, defaultValue) => {
        let retValue = defaultValue;
        try {
            retValue = JSON.parse(str);
        } catch (e) {
        }
        return retValue;
    };

    layoutr.isTrue = (str) => {
        return str === 'true';
    };
}
{
    $(() => {
        if (bowser.msedge) {
            layoutr.html.addClass('msedge'); // used by layoutr.enableScroll()
        }
        if (bowser.mobile) {
            layoutr.html.addClass('mobile'); // disables fixed footer
        } else if (bowser.tablet) {
            layoutr.html.addClass('tablet'); // does nothing currently
        } else {
            layoutr.html.addClass('desktop'); // enables hover effects
        }

        if (bowser.android) {
            layoutr.html.addClass('android'); // used by modal
        } else if (bowser.ios) {
            layoutr.html.addClass('ios'); // used to apply focus
        }

        if (bowser.msedge) {
            // disable smooth scrolling, since it causes element jumping/lagging on scroll
            // https://stackoverflow.com/questions/29416448/how-to-disable-smooth-scrolling-in-ie11
            layoutr.body.on("mousewheel", (e) => {
                let target = $(e.target);
                if (!layoutr.isModal() && event.ctrlKey !== true) {
                    e.preventDefault();
                    let aside = target.closest('aside > .content') || target.parents('aside .content'),
                        wheelDelta = e.originalEvent.wheelDelta,
                        currentScrollPosition;
                    if (aside.length) {
                        currentScrollPosition = aside.scrollTop();
                        aside.scrollTop(currentScrollPosition - wheelDelta);
                    } else {
                        currentScrollPosition = window.pageYOffset;
                        window.scrollTo(0, currentScrollPosition - wheelDelta);
                    }
                }
            });

            // at some zoom levels edge/ie makes $(window) heigher than $(document)
            // it causes a gap between footer and the bottom of $(window).
            $(window).scroll(() => {
                let scrollTop = self.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
                if (scrollTop + $(window).height() >= $(document).height()) {
                    layoutr.html.addClass('subpixel');
                } else {
                    layoutr.html.removeClass('subpixel');
                }
            });
        }
    });
}
{
    layoutr.load = (() => {
        let _load = (tag) => {
            return (url) => {
                return new Promise((resolve, reject) => {
                    if (tag === 'link' || tag === 'script' || tag === 'img') {
                        let element = document.createElement(tag);

                        element.onload = () => {
                            if (tag === 'img') {
                                document.body.removeChild(element);
                            }
                            resolve();
                        };
                        element.onerror = () => {
                            reject();
                        };
                        if (tag === 'link') {
                            element.type = 'text/css';
                            element.rel = 'stylesheet';
                            element.href = url;
                        } else if (tag === 'script' || tag === 'img') {
                            element.async = true;
                            element.src = url;
                            if (tag === 'img') {
                                element.className = 'hidden';
                            }
                        }
                        document.body.appendChild(element);
                    } else if (tag === 'html') {
                        fetch(url).then((response) => {
                            if (response.status === 200) {
                                return response.text();
                            } else {
                                reject(response.status);
                            }
                        }).then((response) => {
                            resolve(response);
                        });
                    }
                });
            };
        };

        return {
            css: _load('link'),
            js: _load('script'),
            img: _load('img'),
            html: _load('html')
        };
    })();
}
{
    layoutr.promiseCSS = layoutr.load.css(`${layoutr.host}dist/css/theme/${layoutr.theme}.css`).catch((e) => {
        console.error('Failed to load css:', e);
    });
    
    $(() => {
        layoutr.footer.html(`<p>\u00A9 ${new Date().getFullYear()} Frederik Nielsen</p>`);

        //layoutr.setHtmlScroll(); // outcomment if it can be disabled at first page load

        layoutr.load.html(`${layoutr.host}${layoutr.ajax}svg/base.html`).then((response) => {
            $(response).prependTo(layoutr.body);
        }).catch((e) => {
            layoutr.showPopupAlert('Failed to load base svg html', 'danger');
            console.error(e);
        });

        if (bowser.android) {
            // android doesn't handle vh correctly, so it gets converted to px
            $(window).resize(() => {
                if (layoutr.isModal() && layoutr.isModalImage()) {
                    layoutr.modal.find('#modal-img').css('max-height', window.innerHeight);
                }
            });
        }
    });

    $(window).click((e) => {
        let target = $(e.target),
            modal = target.closest(layoutr.modal[0]);

        if (!layoutr.isLoading() && !layoutr.isFocus()) {
            if (bowser.ios) {
                // ios browsers doesn't apply :focus to buttons in many cases,
                // this forces :focus to be applied correctly.
                if (target.parents('button').length) {
                    target.parents('button').focus();
                } else if (target.closest('button').length) {
                    target.focus();
                }
            }

            if (layoutr.isAuthentication() && !target.closest('#authentication').length && !target.closest('#modal').length) {
                layoutr.html.attr('data-authentication', '');
            } else if (modal.length) {
                let image = layoutr.isModalImage() && !target.closest('#modal-toggle').length && !target.closest('#modal-title').length && !target.closest('#modal-description').length,
                    form = layoutr.isModalForm() && !target.closest('#modal > div > div > div').length;
                if (image || form || target.closest('#modal-close').length) {
                    layoutr.closeModal();
                }
            } else {
                let isSmallBreakpoint = layoutr.isSmallBreakpoint(),
                    left = layoutr.isAsideLeft() && (layoutr.isAsideLeftCloseOnClickOutside() || isSmallBreakpoint) && !target.closest("#left").length,
                    right = layoutr.isAsideRight() && (layoutr.isAsideRightCloseOnClickOutside() || isSmallBreakpoint) && !target.closest("#right").length,
                    notTarget = !target.closest(".aside").length && !target.closest('.popup').length && !target.closest('#cookie').length;
                if ((left || right) && notTarget && !layoutr.isLoading()) {
                    layoutr.enableScroll();
                    layoutr.toggleAside(undefined, false);
                }
            }
        }
    });
}
{
    layoutr.promiseFont = new Promise((resolve, reject) => {
        WebFont.load({
            typekit: {
                id: ['bhz3dxx']
            },
            active: () => {
                resolve();
            },
            inactive: () => {
                reject();
            }
        });
    }).catch((e) => {
        //layoutr.showPopupAlert('Failed to load fonts', 'danger');
        console.error(e);
    });
}
{
    layoutr.contentLoaded = (element) => {
        layoutr.checkResponsiveBackground(element.find('.rb'));
        layoutr.checkLazy(element.find('.lazy'));
        layoutr.checkAccordion(element.find('.accordion'));
        layoutr.checkDropdown(element.find('select.dropdown'));
        layoutr.checkTooltip(element.find('.tooltip'));
        layoutr.checkAssignment(element.find('.assignment'));
        layoutr.checkMath(element.find('.math'));
        layoutr.checkMedia(element.find('audio, video'));
        layoutr.checkMap(element.find('.map'));
        layoutr.checkDatatable(element.find('.dataTable'));
        layoutr.checkSwiper(element.find('.swiper'));
    };

    layoutr.pageLoaded = (initial) => {
        let promiseScrollTop = new Promise((resolve, reject) => {
            layoutr.main.css('overflow', 'auto');
            layoutr.main.scrollTop(0);
            layoutr.main.css('overflow', '');
            setTimeout(() => {
                layoutr.html.scrollTop(0);
                resolve();
            });
        }).then(() => {
            setTimeout(() => {
                if (!initial && layoutr.isCloseLeftPageChange()) {
                    layoutr.toggleAside(undefined, true);
                }
            }, 200);

            if (initial) {
                layoutr.promiseFont.then(() => {
                    $('#site').css('display', 'block');
                    layoutr.responsiveHeader();
                    layoutr.contentLoaded(layoutr.content);
                    let scroll = JSON.parse(localStorage.getItem("scroll"));
                    layoutr.enableScroll();
                    // promise version doesn't always scroll to correct position
                    $.Deferred((defer) => {
                        if (scroll !== null && window.location.href === scroll.href) {
                            let scrollTop = layoutr.body[0].scrollHeight >= scroll.scrollTop ? scroll.scrollTop : layoutr.body[0].scrollHeight;
                            $("html, body").animate({
                                scrollTop: scrollTop
                            }, 0, defer.resolve);
                        } else {
                            defer.resolve();
                        }
                    }).done(() => {
                        layoutr.hideLoading();
                        layoutr.html.addClass('site-loaded');
                        $(window).scroll($.throttle(layoutr.throttleInterval, false, () => {
                            layoutr.setScrollTop();
                        }));

                        $(window).resize($.throttle(layoutr.throttleInterval, false, () => {
                            layoutr.checkModal();
                            layoutr.setHtmlScroll();
                            layoutr.setScrollTop();
                        }));
                    });
                });
            } else {
                layoutr.hideLoading();
                layoutr.contentLoaded(layoutr.content);
            }
        });
    };
}
{
    $(() => {
        $.validator.setDefaults({
            submitHandler: () => {
                alert("Fake submitted!");
            }
        });

        $.validator.addMethod('password_regex', (value) => {
            return /^(?=.*[a-zæøå])(?=.*[A-ZÆØÅ])(?=.*\d).{8,}$/.test(value);
        }, 'Password must contain at least eight characters, one uppercase letter, one lowercase letter and one number');
    });

    layoutr.addValidation = (form, rules, messages) => {
        form.validate({
            rules: rules,
            messages: messages,
            errorElement: "em",
            errorPlacement: (error, element) => {
                element = element.parent();
                if (element.hasClass('checkbox') || element.hasClass('radio') || element.hasClass('input-group')) {
                    element = element.parent();
                }
                element.append(error);
            },
            highlight: (element, errorClass, validClass) => {
                $(element).parents(".form-group").addClass("theme-danger");
            },
            unhighlight: (element, errorClass, validClass) => {
                $(element).parents(".form-group").removeClass("theme-danger");
            }
        });
        form.on('change', 'input, textarea, select', (e) => {
            $(e.currentTarget).valid();
        });
    };
}
{
    let fullscreenScrollTop;

    layoutr.requestFullScreen = () => {
        if (!layoutr.fullscreen && bowser.desktop) {
            fullscreenScrollTop = layoutr.scrollTop();
            if (layoutr.document.requestFullscreen) {
                layoutr.document.requestFullscreen();
            }
            else if (layoutr.document.msRequestFullscreen) {
                layoutr.document.msRequestFullscreen();
            }
            else if (layoutr.document.mozRequestFullScreen) {
                layoutr.document.mozRequestFullScreen();
            }
            else if (layoutr.document.webkitRequestFullscreen) {
                layoutr.document.webkitRequestFullscreen();
            }
        }
    };

    let fullscreenChange = () => {
        layoutr.fullscreen = !layoutr.fullscreen;
        if (!layoutr.fullscreen && bowser.desktop) {
            if (layoutr.isModal()) {
                layoutr.closeModal();
            }
            layoutr.body.scrollTop(fullscreenScrollTop);
            layoutr.html.scrollTop(fullscreenScrollTop);
        }
    };

    document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
    document.addEventListener('mozfullscreenchange', fullscreenChange, false);
    document.addEventListener('fullscreenchange', fullscreenChange, false);
    document.addEventListener('MSFullscreenChange', fullscreenChange, false);

    layoutr.exitFullScreen = () => {
        if (layoutr.fullscreen && bowser.desktop) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        }
    };

    layoutr.toggleFullScreen = (element) => {
        if (layoutr.fullscreen)
            exitFullScreen();
        else
            requestFullScreen(element);
    };
}
{
    let scrollbarWidth = () => {
        layoutr.body.append('<div id="scrollbar-width"></div>');
        let element = layoutr.body.children('#scrollbar-width');
        element.css({
            'overflow': "scroll",
            'visibility': "hidden",
            'position': 'absolute',
            'width': '100px',
            'height': '100px'
        });
        layoutr.scrollbarWidth = element[0].offsetWidth - element[0].clientWidth;
        element.remove();
    };

    layoutr.disableScroll = () => {
        if (layoutr.htmlOverflowEnabled) {
            layoutr.htmlOverflowEnabled = false;
            if (layoutr.isModal()) {
                layoutr.checkModal();
                layoutr.modal.focus();
            }
            let scrollTop = layoutr.scrollTop();
            layoutr.html.addClass('scroll-disabled');
            layoutr.body.scrollTop(scrollTop);
            layoutr.main.scrollTop(scrollTop);
        }
    };

    layoutr.enableScroll = () => {
        if (!layoutr.htmlOverflowEnabled) {
            layoutr.htmlOverflowEnabled = true;
            if (layoutr.isSiteLoaded()) {
                let scrollTop = layoutr.scrollTop();
                layoutr.html.removeClass('scroll-disabled modal');
                layoutr.main.focus();
                layoutr.body.scrollTop(scrollTop); // edge, safari
                layoutr.html.scrollTop(scrollTop); // chrome, firefox, ie
            } else {
                layoutr.html.removeClass('scroll-disabled modal');
            }
        }
    };

    layoutr.setHtmlScroll = () => {
        if (!layoutr.isModal() && !layoutr.isLoading() && !layoutr.htmlOverflowEnabled && (!layoutr.isSmallBreakpoint() || layoutr.isSmallBreakpoint() && !layoutr.isAsideLeft() && !layoutr.isAsideRight())) {
            layoutr.enableScroll();
        } else if (layoutr.isModal() || layoutr.isSmallBreakpoint() && layoutr.htmlOverflowEnabled && (layoutr.isAsideLeft() || layoutr.isAsideRight())) {
            layoutr.disableScroll();
        }
    };

    $(() => {
        scrollbarWidth();
    });

    layoutr.setScrollTop = () => {
        let entry = {
            href: window.location.href,
            scrollTop: layoutr.scrollTop()
        };
        localStorage.setItem('scroll', JSON.stringify(entry));
    };

}
{
    layoutr.showLoading = () => {
        layoutr.loadingCount++;
        layoutr.disableScroll();
        layoutr.html.addClass('loading');
    };

    layoutr.hideLoading = () => {
        layoutr.loadingCount--;
        if (layoutr.loadingCount <= 0) {
            layoutr.loadingCount = 0;
            layoutr.html.removeClass('loading');
            layoutr.setHtmlScroll();
        }
    };
}
{
    let transitionLock = false;

    layoutr.asideChanged = () => {
        let trigger = () => {
            layoutr.html.trigger('aside-changed.datatables');
            layoutr.html.trigger('aside-changed.rb');
            layoutr.html.trigger('aside-changed.map');
        };

        if (layoutr.isTransitions()) {
            let awaitInterval = setInterval(() => {
                if (!transitionLock) {
                    clearInterval(awaitInterval);
                } else {
                    trigger();
                }
            }, layoutr.awaitInterval);
            setTimeout(() => {
                transitionLock = false;
            }, layoutr.transitionTime);
        } else {
            transitionLock = false;
            trigger();
        }
    };

    layoutr.toggleAside = (aside, pageChanged) => {
        if (!transitionLock) {
            transitionLock = true;
            layoutr.html.attr('data-authentication', '');
            let currentAside = layoutr.html.attr('data-aside');
            if (currentAside.length) {
                if (aside === undefined || currentAside === aside) {
                    let scrollTop = layoutr.scrollTop();
                    layoutr.html.attr('data-aside', '');
                    layoutr.main.focus();
                    layoutr.body.scrollTop(scrollTop); // edge, safari
                    layoutr.html.scrollTop(scrollTop); // chrome, firefox, ie
                } else {
                    layoutr.html.attr('data-aside', aside);
                }
            } else {
                layoutr.html.attr('data-aside', aside);
            }
            if (aside === 'left') {
                layoutr.left.focus();
            } else if (aside === 'right') {
                layoutr.right.focus();
            }

            layoutr.asideChanged();
            layoutr.setHtmlScroll();
        }
    };

    $(() => {
        layoutr.main.find('.aside.left').click(() => {
            layoutr.toggleAside('left');
        });

        layoutr.main.find('.aside.right').click(() => {
            layoutr.toggleAside('right');
        });
    });
}
{
    $(() => {
        layoutr.authentication.on('click', '> div > button', (e) => {
            let $this = $(e.currentTarget),
                type = $this.attr('data-type');
            if (layoutr.html.attr('data-authentication') === type) {
                layoutr.html.attr('data-authentication', '');
            } else {
                layoutr.html.attr('data-authentication', type);
                layoutr.authentication.children(':last-child').focus();
            }
        });

        layoutr.authenticatedLinks.on('click', '> a', (e) => {
            e.preventDefault();
        });

        layoutr.addValidation(
            layoutr.authentication.find('.register > form'),
            {
                register_username: {
                    required: true,
                    minlength: 2
                },
                register_password: {
                    required: true,
                    password_regex: true
                },
                register_confirm_password: {
                    required: true,
                    equalTo: "#register_password"
                },
                register_email: {
                    required: true,
                    email: true
                }
            },
            {
                register_username: {
                    required: "Please enter your username"
                },
                register_password: {
                    required: "Please enter your password"
                },
                register_confirm_password: {
                    required: "Please provide a password",
                    equalTo: "Please enter the same password as above"
                },
                register_email: "Please enter a valid email address"
            }
        );

        layoutr.addValidation(
            layoutr.authentication.find('.login > form'),
            {
                username: {
                    required: true
                },
                password: {
                    required: true
                }
            },
            {
                username: {
                    required: "Please enter your username"
                },
                password: {
                    required: "Please enter your password"
                }
            }
        );
    });
}
{
    $(() => {
        layoutr.cookie.on('click', '#cookie-accept', () => {
            localStorage.setItem('cookie', 'cookie');
            layoutr.html.removeClass('cookie');
        });

        let cookie = localStorage.getItem("cookie");
        if (cookie === null) {
            layoutr.html.addClass('cookie');
        }
    });
}
{
    layoutr.loadPage = (url, pushState, initial) => {
        layoutr.showLoading();
        layoutr.load.html(`${layoutr.host}${layoutr.ajax}pages${url === '/' ? '/home' : url}.html`).then((response) => {
            layoutr.content.html(response);
            let q = url.indexOf('?');
            url = url.substring(0, q !== -1 ? q : url.length);
            layoutr.left.find('.tree a.label.active').removeClass('active');
            layoutr.left.find(`a.label[href="${url}"]`).addClass('active');
            layoutr.html.attr('data-status', '');
            layoutr.title.html('');
            document.title = layoutr.siteName;
            if (url === '/') {
                if (layoutr.body.children('#svg-browser').length === 0) {
                    layoutr.load.html(layoutr.host + layoutr.ajax + 'svg/browser.html').then((response) => {
                        $(response).prependTo(layoutr.body);
                    }).catch((e) => {
                        layoutr.showPopupAlert('Failed to load browser svg html', 'danger');
                        console.error(e);
                    });
                }
                if (layoutr.body.children('#svg-os').length === 0) {
                    layoutr.load.html(layoutr.host + layoutr.ajax + 'svg/os.html').then((response) => {
                        $(response).prependTo(layoutr.body);
                    }).catch((e) => {
                        layoutr.showPopupAlert('Failed to load os svg html', 'danger');
                        console.error(e);
                    });
                }
            } else {
                let title = layoutr.capitalize(url.replace('/', '').replaceAll('-', ' '));
                layoutr.title.html(title);
                document.title = `${title} - ${layoutr.siteName}`;
                if (url === '/form') {
                    layoutr.pageForm();
                }
            }
            layoutr.html.trigger('header-changed.responsiveHeader');
            layoutr.promiseCSS.then(() => {
                layoutr.pageLoaded(initial);
            });
        }).catch((response) => {
            layoutr.load.html(layoutr.host + layoutr.ajax + 'pages/error.html').then((response2) => {
                layoutr.content.html(response2);
                layoutr.html.attr('data-status', 'error');
                document.title = `${response}-${layoutr.siteName}`;
                let title = `${response} - `;
                if (response === 404) {
                    title += 'Page not found';
                } else {
                    title += 'Server error';
                }
                layoutr.content.find('#error-title').html(title);
                layoutr.html.trigger('header-changed.responsiveHeader');
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load content html', 'danger');
                console.error(e);
            }).finally(() => {
                layoutr.promiseCSS.then(() => {
                    layoutr.pageLoaded(initial);
                });
            });
        });

        let historyUrl = (layoutr.isLocalhost ? '' : `/${window.location.pathname.split('/')[1]}`) + url;
        if (pushState) {
            window.history.pushState(null, null, historyUrl);
            loadPage = true;
        }
    };

    layoutr.internalLinkClick = (href, e) => {
        if (!e.ctrlKey) {
            e.preventDefault();
            layoutr.loadPage(href, true, false);
        }
    };

    if (window.location.search) {
        layoutr.url = {};
        window.location.search.slice(1).split('&').forEach((v) => {
            let a = v.split('=');
            layoutr.url[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&');
        });
        if (layoutr.url.p !== undefined) {
            window.history.replaceState(null, null,
                window.location.pathname.slice(0, -1) + layoutr.url.p +
                (layoutr.url.q ? `?${layoutr.url.q}` : '') +
                window.location.hash
            );
        }
    }

    let loadPage = window.history.state;
    window.onpopstate = (e) => {
        if (loadPage) {
            let url = location.pathname;
            if (!layoutr.isLocalhost) {
                url = url.substring(url.indexOf("/", url.indexOf("/") + 1));
            }
            layoutr.loadPage(url, false, true);
        }
    };

    layoutr.applyNavigation = (id, value, set) => {
        if (set) {
            let entry = {
                "id": id,
                "value": value
            },
                exists = $.grep(layoutr.navigation, (e) => { return e.name === name; });
            if (exists.length === 0) {
                // not found
                layoutr.navigation.push(entry);
            } else if (exists.length === 1) {
                // found
                exists[0].value = value;
            }
            localStorage.setItem('navigation', JSON.stringify(layoutr.navigation));
        } else {
            layoutr.left.find(`#${id}`).prop('checked', value);
        }
    };

    $(() => {
        layoutr.load.html(layoutr.host + layoutr.ajax + 'layout/navigation.html').then((response) => {
            layoutr.left.find('> .content > div').html(response);
            layoutr.navigationTree = layoutr.left.find('.tree');
            layoutr.navigation = JSON.parse(localStorage.getItem("navigation"));
            if (layoutr.navigation === null) layoutr.navigation = [];
            $.each(layoutr.navigation, (i, entry) => {
                layoutr.applyNavigation(entry.id, entry.value, false);
            });
            layoutr.navigationTree.on('change', 'input[type=checkbox]', (e) => {
                let checkbox = $(e.currentTarget),
                    id = checkbox.attr('id'),
                    value = checkbox.is(':checked');
                layoutr.applyNavigation(id, value, true);
            });
            layoutr.header.find('.aside.left').addClass('loaded');
            if (layoutr.url && layoutr.url.p) {
                layoutr.navigationTree.find(`a.label[href="${layoutr.url.p}"]`).addClass('active');
            } else {
                layoutr.navigationTree.find('a.label[href=""]').addClass('active');
            }
        }).catch((e) => {
            layoutr.showPopupAlert('Failed to load navigation html', 'danger');
            console.error(e);
        });

        if (layoutr.url && layoutr.url.p) {
            layoutr.loadPage(layoutr.url.p, true, true);
        } else {
            let l = window.location,
                segmentCount = l.origin.endsWith('github.io') ? 1 : 0,
                url = `/${l.pathname.slice(1).split('/').slice(segmentCount)}`;
            layoutr.loadPage(url, true, true);
        }
        layoutr.left.on('click', '.tree a.label:not(.active)', (e) => {
            layoutr.internalLinkClick($(e.currentTarget).attr('href'), e);
        });

        layoutr.body.on('click', '.internal-link', (e) => {
            layoutr.internalLinkClick($(e.currentTarget).attr('href'), e);
        });

        layoutr.left.on('click', '#navigation-expand', () => {
            layoutr.navigationTree.find('input[type=checkbox]:not(:checked)').click();
        });

        layoutr.left.on('click', '#navigation-collapse', () => {
            layoutr.navigationTree.find('input[type=checkbox]:checked').click();
        });
    });
}
{
    layoutr.applySettings = (id, name, type, value, set) => {
        if (set) {
            let entry = {
                "id": id,
                "name": name,
                "type": type,
                "value": value
            },
                exists = $.grep(layoutr.settings, (e) => { return e.name === name; });
            if (exists.length === 0) {
                // not found
                layoutr.settings.push(entry);
            } else if (exists.length === 1) {
                // found
                exists[0].id = id;
                exists[0].value = value;
            }
            localStorage.setItem('settings', JSON.stringify(layoutr.settings));
        } else {
            if (type === "checkbox" || type === "radio") {
                layoutr.right.find(`#settings-${id}`).prop('checked', value);
            } else if (type === "slider") {
                layoutr.right.find(`#settings-${id}`).slider('setValue', value);
            }
        }
        if (type === 'checkbox' || type === "radio") {
            if (type === 'radio') {
                $.each(layoutr.right.find(`input[type=radio][name="settings-${name}"]:not(#settings-${id})`), (i, radio) => {
                    layoutr.html.removeClass($(radio).attr('id').replace('settings-', ''));
                });
            }
            if (name === 'theme') {
                layoutr.loadTheme(id);
            }
            if (name === 'focus' && value) {
                layoutr.enableFocus();
            } else if (name === 'tts' && value) {
                //layoutr.enableTTS();
            } else if (name === 'swipe' && value) {
                layoutr.enableSwipe();
            }
            if (value) {
                layoutr.html.addClass(id);
            } else {
                layoutr.html.removeClass(id);
            }
            if (id === 'two-columns') {
                layoutr.html.trigger('columns-changed.rb');
            }
            if (id === 'signed-in' || id === 'focus' || id === 'tts') {
                layoutr.html.trigger('header-changed.responsiveHeader');
            }
            if (name === 'aside-left' || 'aside-right') {
                layoutr.asideChanged();
            }
        }
    };

    $(() => {
        layoutr.load.html(layoutr.host + layoutr.ajax + 'layout/settings.html').then((response) => {
            let $this = layoutr.right.find('> .content > div');
            $this.html(response);
            layoutr.promiseCSS.then(() => {
                $.each(layoutr.settings, (i, entry) => {
                    layoutr.applySettings(entry.id, entry.name, entry.type, entry.value, false);
                });
                layoutr.header.find('.aside.right').addClass('loaded');
                $this.on('change', 'input[type=checkbox], input[type=radio]', (e) => {
                    let input = $(e.currentTarget),
                        id = input.attr('id').replace('settings-', ''),
                        name = input.attr('name').replace('settings-', ''),
                        type = input.attr('type'),
                        value = input.is(':checked');
                    layoutr.applySettings(id, name, type, value, true);
                    if (id === 'left-shrink' || id === 'right-shrink' ||
                        id === 'left-push' || id === 'right-push' ||
                        id === 'left-overlay' || id === 'right-overlay') {
                        layoutr.setHtmlScroll();
                    }
                });
            });
        }).catch((e) => {
            layoutr.showPopupAlert('Failed to load settings html', 'danger');
            console.error(e);
        });

        layoutr.right.on('click', '#settings-clear-localstorage', () => {
            localStorage.clear();
            location.reload();
        });
    });
}
{
    $(() => {
        layoutr.body.on("keydown", (e) => {
            let target = $(e.target),
                parent = target.parent();
            if (layoutr.isLoading()) {
                if (e.which === 9 || e.ctrlKey && e.keyCode === 65) { // tab ||  ctrl + a
                    e.preventDefault();
                }
            } else {
                if (e.which === 37 && !layoutr.isFocus() && !layoutr.isModal()) { // left
                    if (!layoutr.arrowKeyLocked) {
                        if (layoutr.isAsideLeft()) {
                            layoutr.toggleAside(); // closes right
                        } else if (!layoutr.isAsideRight()) {
                            layoutr.toggleAside('right'); // opens right
                        }
                    }
                } else if (e.which === 39 && !layoutr.isFocus() && !layoutr.isModal()) { // right
                    if (!layoutr.arrowKeyLocked) {
                        if (layoutr.isAsideRight()) {
                            layoutr.toggleAside(); // closes left
                        } else if (!layoutr.isAsideLeft()) {
                            layoutr.toggleAside('left'); // opens left
                        }
                    }
                } else if (e.which === 27) { // esc
                    e.stopPropagation();
                    if (layoutr.tts !== undefined && layoutr.tts.IsSpeaking()) {
                        layoutr.stopTTS();
                    } else if (layoutr.isFocus()) {
                        layoutr.hideFocus();
                    } else if (layoutr.isModal()) {
                        layoutr.closeModal();
                    } else {
                        if (layoutr.isAside()) {
                            layoutr.toggleAside(); // closes aside
                        }
                        let popups = layoutr.body.children('.popup');
                        if (popups.length) {
                            popups.fadeOut(layoutr.fadeOutTime, () => {
                                popups.remove();
                            });
                        }
                        let dropdowns = layoutr.content.find('div.dropdown.open');
                        if (dropdowns.length) {
                            dropdowns.removeClass('open');
                        }
                        layoutr.html.attr('data-authentication', '');
                    }
                }
                if (e.which === 13) { // enter
                    let dropdown = target.parents('div.dropdown');
                    if (dropdown.length || parent.parent().hasClass('accordion')) {
                        target.click();
                        e.preventDefault();
                        if (dropdown.length) {
                            dropdown.children('div').focus();
                        }
                    } else if (parent.hasClass('checkbox') || parent.hasClass('radio') || parent.hasClass('switch') || target.hasClass('toggle')) {
                        target.siblings('input').click();
                        e.preventDefault();
                    }
                }
            }
        });

        layoutr.body.on('keyup', (e) => {
            if (!layoutr.isLoading() && !layoutr.isFocus()) {
                if (e.which === 9) { // tab
                    let target = $(e.target);
                    if (!target.parents('div.dropdown.open').length) {
                        $('div.dropdown.open').removeClass('open');
                    }
                    if (!target.parents('#authenticated.open').length || target.closest('#authenticated > button').length) {
                        $('#authenticated.open').removeClass('open');
                    }
                    if (layoutr.isModal()) {
                        if (!target.parents('#modal').length) {
                            layoutr.closeModal();
                        }
                    } else {
                        let aside = target.parents('aside');
                        if (aside.length === 0 && target.is('aside')) {
                            aside = target;
                        }
                        if (aside.length && aside.attr('id') !== layoutr.html.attr('data-aside')) {
                            layoutr.toggleAside(aside.attr('id'));
                        } else if (!aside.length && layoutr.isAside()) {
                            layoutr.toggleAside();
                        }
                    }
                }
            }
        });
    });
}
{
    layoutr.showModal = (type) => {
        layoutr.html.attr('data-modal', type);
        layoutr.html.addClass('modal');
        layoutr.hideLoading();
        layoutr.checkModal();
        layoutr.modal.focus();
    };

    layoutr.closeModal = () => {
        if (layoutr.fullscreen) {
            layoutr.exitFullScreen();
        } else {
            layoutr.html.removeClass('modal').attr('data-modal', '');
            layoutr.modal.removeClass('info-shown').empty();
            layoutr.checkModal();
            layoutr.setHtmlScroll();
        }
    };

    layoutr.checkModal = () => {
        if (layoutr.isModal()) {
            layoutr.body.css('padding-right', layoutr.scrollbarWidth);
            if (layoutr.html.attr('data-aside') === 'right') {
                layoutr.right.css('margin-right', layoutr.scrollbarWidth);
            }
            layoutr.body.children('.popup').css('margin-right', layoutr.scrollbarWidth);
        } else {
            layoutr.body.css('padding-right', 0);
            layoutr.right.css('margin-right', 0);
            layoutr.body.children('.popup').css('margin-right', 0);
        }
        layoutr.html.trigger('model-check');
    };

    $(() => {
        layoutr.body.on('click', '.modal', (e) => {
            let $this = $(e.currentTarget),
                type = $this.attr('data-modal');
            if (type !== undefined && type.length && (type === 'image' || type === 'form')) {
                layoutr.showLoading();
                let id = $this.attr('data-modal-id'),
                    dataTitle = $this.attr('data-modal-title'),
                    dataContent = $this.attr('data-modal-content'),
                    dataFullscreen = $this.attr('data-modal-fullscreen') === 'true';

                let template = () => {
                    let result;

                    if (type === 'image' && $this.attr('data-modal-img').length) {
                        if (dataTitle !== undefined || dataContent !== undefined) {
                            layoutr.modal.addClass('has-info');
                        }
                        result = 
`${dataTitle !== undefined || dataContent !== undefined ? `
<button id="modal-toggle" class="btn" aria-label="Toggle info">
    <svg focusable="false"><use xlink:href="#svg-info"></use></svg>
</button>
${dataTitle !== undefined ? `<div id="modal-title">${dataTitle}</div>` : ''}
${dataContent !== undefined ? `<div id="modal-content">${dataContent}</div>` : ''}
` : ''}
<img id="modal-img" />`;
                    } else if (type === 'form') {
                        result = 
`<div class="header">
    ${dataTitle !== undefined ? `<span class="title">${dataTitle}</span>` : ''}
    <button id="modal-close" class="close expand" aria-label="Close ${dataTitle !== undefined ? dataTitle : ''}">
        <svg focusable="false"><use xlink:href="#svg-close"></use></svg>
    </button>
</div>
<div class="content">
</div>`;
                    }
                    return result;
                };

                let html = 
`<div>
    <div>
        <div id="modal-container">
            ${template()}
        </div>
    </div>
</div>`;
                layoutr.modal.html(html);
                if (type === 'image') {
                    let image = layoutr.modal.find('#modal-img');
                    image.on('load', () => {
                        if (bowser.android) {
                            image.css('max-height', window.innerHeight);
                        }
                        layoutr.showModal(type);
                    });
                    image.attr('src', $this.attr('data-modal-img'));
                } else {
                    let dataSize = $this.attr('data-modal-size');
                    if (dataSize !== undefined) {
                        layoutr.modal.children('div').attr('data-modal-size', dataSize);
                    }
                    let content = layoutr.modal.find('#modal-container > .content');
                    content.append(dataContent);
                    layoutr.contentLoaded(content);
                    layoutr.showModal(type);
                }
                if (dataFullscreen) {
                    layoutr.requestFullScreen();
                }
            }
        });

        layoutr.body.on('click', '#modal-toggle', () => {
            layoutr.modal.toggleClass('info-shown');
        });
    });
}
{
    layoutr.responsiveHeader = () => {
        let h1 = layoutr.header.find('h1'),
            link = h1.children('a');

        let check = () => {
            h1.addClass('show-title');
            layoutr.unauthenticated.addClass('show-text');
            if (h1.outerWidth() < link.outerWidth()) {
                layoutr.unauthenticated.removeClass('show-text');
                if (h1.outerWidth() < link.outerWidth()) {
                    h1.removeClass('show-title');
                }
            }
        };

        $(window).on('resize', () => {
            check();
        });

        check();

        layoutr.html.on('header-changed.responsiveHeader', () => {
            check();
        });
    };
}
{
    layoutr.enableFocus = () => {
        let component = layoutr.focus.find('> .component > div');

        if (!layoutr.html.hasClass('focus-loaded')) {
            layoutr.showLoading();
            layoutr.promiseFocus = layoutr.load.js('dist/js/focus.js').finally(() => {
                layoutr.hideLoading();
            });
            layoutr.html.addClass('focus-loaded');
        }

        layoutr.promiseFocus.then(() => {
            component
                .draggable({
                    axis: "y",
                    containment: "parent",
                    handle: ".move"
                })
                .resizable({
                    handles: {
                        n: '.ui-resizable-n',
                        s: '.ui-resizable-s'
                    },
                    minHeight: 50,
                    containment: "parent"
                }).on('resize', (e) => {
                    e.stopPropagation();
                });

            layoutr.focus.on('click', '.close', () => {
                layoutr.hideFocus();
            });

            layoutr.main.find('.focus').click(() => {
                layoutr.showFocus();
            });

            let height = $(window).height();
            $(window).resize(() => {
                // do nothing if the height is the same
                if ($(window).height() === height) return;
                height = $(window).height();
                component.removeAttr('style');
            });
        }).catch((e) => {
            layoutr.showPopupAlert('Failed to load focus', 'danger');
            console.error(e);
        });
    };

    layoutr.showFocus = () => {
        layoutr.html.attr('data-authentication', '');
        layoutr.html.attr('data-focus', true);
        layoutr.focus.focus();
    };
    layoutr.hideFocus = () => {
        let scrollTop = layoutr.scrollTop();
        layoutr.html.attr('data-focus', false);
        layoutr.main.focus();
        layoutr.body.scrollTop(scrollTop); // edge, safari
        layoutr.html.scrollTop(scrollTop); // chrome, firefox, ie
    };
}
{
    layoutr.enableSwipe = () => {
        if (bowser.android) {
            let xDown = null,
                yDown = null,
                offsetBefore;

            let handleTouchStart = (e) => {
                if (layoutr.isSwipe()) {
                    xDown = e.touches[0].clientX;
                    yDown = e.touches[0].clientY;

                    offsetBefore = $(e.target).offset().left;
                }
            };

            let handleTouchMove = (e) => {
                if (layoutr.isSwipe()) {
                    let offsetAfter = $(e.target).offset().left;
                    if (!xDown || !yDown || offsetBefore !== offsetAfter) {
                        return;
                    }
                    let xUp = e.changedTouches[0].clientX,
                        yUp = e.changedTouches[0].clientY,
                        xDiff = xDown - xUp,
                        yDiff = yDown - yUp;
                    if (Math.abs(xDiff) > Math.abs(yDiff)) {
                        let distance = parseInt($(window).width() / 2);
                        if (yDiff > -100 || yDiff < 100) {
                            let currentAside;
                            if (xDiff > distance) {
                                /* left swipe */
                                if (!layoutr.isModal() && !layoutr.isLoading()) {
                                    currentAside = layoutr.html.attr('data-aside');
                                    if (currentAside === 'left' && currentAside !== 'right') {
                                        layoutr.toggleAside();
                                    } else if (currentAside !== 'right') {
                                        layoutr.toggleAside('right');
                                    }
                                }
                            } else if (xDiff < -distance) {
                                /* right swipe */
                                if (!layoutr.isModal() && !layoutr.isLoading()) {
                                    currentAside = layoutr.html.attr('data-aside');
                                    if (currentAside === 'right' && currentAside !== 'left') {
                                        layoutr.toggleAside();
                                    } else if (currentAside !== 'left') {
                                        layoutr.toggleAside('left');
                                    }
                                }
                            }
                        }

                    }
                    /* reset values */
                    xDown = null;
                    yDown = null;
                }
            };
            document.addEventListener('touchstart', handleTouchStart, false);
            document.addEventListener('touchend', handleTouchMove, false);
        }
    };
}
{
    layoutr.clearSelection = () => {
        let selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(document.createRange());
    };

    layoutr.stopTTS = () => {
        layoutr.clearSelection();
        if (layoutr.tts && layoutr.tts.IsSpeaking()) {
            layoutr.tts.ShutUp();
        }
    };

    layoutr.enableTTS = () => {
        if (bowser.desktop) {
            let snapSelectionToWord = () => {
                let selection = window.getSelection();
                if (!selection.isCollapsed) {
                    let range = selection.getRangeAt(0);
                    if (range.collapsed || range.toString().length === 0) {
                        return;
                    }

                    try {
                        // select full start word
                        while (range.startOffset > 0 && range.toString()[0].match(/[^\s]/)) {
                            range.setStart(range.startContainer, range.startOffset - 1);
                        }
                        // remove space as first selected
                        let start = range.startContainer.data.substring(range.startOffset).charAt(0);
                        if (start === ' ') {
                            range.setStart(range.startContainer, range.startOffset + 1);
                        }
                    } catch (e) {
                        console.error(e);
                    }

                    try {
                        // select full end word
                        while (range.endOffset < range.endContainer.length && range.toString()[range.toString().length - 1].match(/[^\s]/)) {
                            range.setEnd(range.endContainer, range.endOffset + 1);
                        }
                        // remove space as last selected
                        let end = range.endContainer.data.substring(0, range.endOffset).slice(-1);
                        if (end === ' ') {
                            range.setEnd(range.endContainer, range.endOffset - 1);
                        }
                    } catch (e) {
                        console.error(e);
                    }

                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                return selection;
            };

            let getText = (node, selection) => {
                let text = [],
                    nonWhitespaceMatcher = /\S/,
                    getTextNodes = (node) => {
                        let parent = $(node.parentNode),
                            special = false;

                        if (selection.containsNode(node, false) && (node.nodeName.toLowerCase() === 'input' ||
                            node.nodeName.toLowerCase() === 'textarea') && nonWhitespaceMatcher.test(node.value)) {
                            special = true;
                        }

                        if (!special &&
                            selection.containsNode(node, true) &&
                            node.nodeType === 3 &&
                            nonWhitespaceMatcher.test(node.nodeValue) &&
                            parent.is(':visible') &&
                            parent.css('user-select') !== 'none' &&
                            parent.parents().css('user-select') !== 'none' &&
                            node.parentNode.tagName !== 'SCRIPT'
                        ) {
                            if (!(selection.extentNode.nodeType !== 3 && $(selection.extentNode).is(parent))) {
                                if (!node.nodeValue.match(/\.\s*$/) && node.nextElementSibling === null && parent.is('h1 span, h1, h2, h3, h4, h5, h6, p, th, td, .dataTable th span')) {
                                    text.push(node.nodeValue + '. ');
                                } else {
                                    text.push(node.nodeValue);
                                }
                            }
                            if (text.length === 1) {
                                if ($(selection.anchorNode).is(selection.focusNode)) {
                                    text[0] = text[0].substring(0, selection.focusOffset).substring(selection.baseOffset);
                                } else {
                                    text[0] = text[0].substring(selection.baseOffset);
                                }
                                if (text[0] === '. ' || text[0] === ' ') {
                                    text[0] = '';
                                }
                            }
                        } else {
                            for (let i = 0; i < node.childNodes.length; i++) {
                                getTextNodes(node.childNodes[i]);
                            }
                        }
                    };

                getTextNodes(node);
                if (text.length && text.length > 1) {
                    text[text.length - 1] = text[text.length - 1].substring(0, selection.focusOffset);
                }
                text = text.join(' ').replace(/(?:\r\n|\r|\n)/g, ' ').replace(/ +\./g, '. ').replace(/\s\s+/g, ' ').replace(',.', '.').trim();
                return text;
            };

            if (!layoutr.html.hasClass('tts-loaded')) {
                layoutr.showLoading();
                layoutr.PromiseTTS = layoutr.load.js('dist/js/tts.js').finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('tts-loaded');
            }
            layoutr.PromiseTTS.then(() => {
                let awsCredentials = new AWS.Credentials('AKIAI5JMCVBZ4CWSSOOQ', 'FM7j9FbQLkUU8u3tHScv0IOG4IoayUkp/RNNNNni'),
                    settings = {
                        awsCredentials: awsCredentials,
                        awsRegion: 'eu-central-1',
                        pollyVoiceId: 'Russell'
                    };

                layoutr.tts = ChattyKathy(settings);

                layoutr.html.attr('data-tts', true);

                $(window).on('mousedown touchstart', (e) => {
                    if (!layoutr.isLoading() && !layoutr.isFocus() && layoutr.isTTS() && layoutr.isTTSEnabled()) {
                        layoutr.clearSelection();
                    }
                });

                $(window).on('mouseup touchend', (e) => {
                    if (!$(document.activeElement).is('input, textarea, button, select, .dropdown')) {
                        if (!layoutr.isLoading() && !layoutr.isFocus() && layoutr.isTTS() && layoutr.isTTSEnabled() && e.originalEvent.detail < 3) {
                            setTimeout(() => {
                                let selection = snapSelectionToWord(),
                                    text = getText(selection.getRangeAt(0).commonAncestorContainer, selection);

                                if (text.length) {
                                    layoutr.tts.SpeakWithPromise(text).then(() => {
                                        layoutr.clearSelection();
                                    });
                                } else {
                                    layoutr.stopTTS();
                                }
                            });
                        }
                    }
                });

                layoutr.header.find('.tts').click(() => {
                    if (layoutr.html.attr('data-tts') === 'true') {
                        layoutr.html.attr('data-tts', false);
                        layoutr.stopTTS();
                    } else {
                        layoutr.html.attr('data-tts', true);
                    }
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load tts', 'danger');
                console.error(e);
            });
        }
    };
}
{
    $(() => {
        layoutr.html.on('model-check', () => {
            let contentHeader = layoutr.content.children('.content-header:not(.full)');
            if (contentHeader.length) {
                if (layoutr.isModal() && contentHeader.css('position') === 'fixed') {
                    let halfOverflowY = layoutr.scrollbarWidth / 2;
                    contentHeader.children().css('width', `calc(100% - ${halfOverflowY}px)`);
                } else {
                    contentHeader.children().css('width', '');
                }
            }
        });
    });
}
{
    //layoutr.loadTheme = (id) => {
    //    let stylesheet = layoutr.body.children(`link[rel="stylesheet"][href^="${layoutr.host}dist/css/theme/"]`),
    //        href1 = stylesheet.attr('href'),
    //        split1 = href1.split('/'),
    //        split2 = split1[split1.length - 1].split('.');
    //    let href2 = [];
    //    for (let i = 0; i < split1.length - 1; i++) {
    //        href2.push(split1[i] + '/');
    //    }
    //    let theme = id.substring(id.indexOf("-") + 1);
    //    href2.push(theme);

    //    for (let i = 1; i < split2.length; i++) {
    //        href2.push(`.${split2[i]}`);
    //    }
    //    href2 = href2.join("");
    //    if (href1 !== href2) {
    //        layoutr.showLoading();
    //        layoutr.load.css(href2).then(() => {
    //            stylesheet.remove();
    //        }).catch((e) => {
    //            layoutr.showPopupAlert('Failed to load theme', 'danger');
    //            console.error(e);
    //        }).finally(() => {
    //            layoutr.hideLoading();
    //        });
    //    }
    //};

    $(() => {
        let body = $("body"),
            colors = [
                {
                    name: 'blue',
                    value: '#0072ED'
                },
                {
                    name: 'indigo',
                    value: '#6610f2'
                },
                {
                    name: 'purple',
                    value: '´#6f42c1'
                },
                {
                    name: 'pink',
                    value: '#e83e8c'
                },
                {
                    name: 'red',
                    value: '#dc3545'
                },
                {
                    name: 'orange',
                    value: '#BE5A06'
                },
                {
                    name: 'yellow',
                    value: '#ffc107'
                },
                {
                    name: 'green',
                    value: '#218838'
                },
                {
                    name: 'teal',
                    value: '#20c997'
                },
                {
                    name: 'cyan',
                    value: '#138294'
                }
            ];
        let themeLight = {
            name: 'light',
            hover: 7.5,
            body: '#f1f1f1',
            grays: [
                "#ffffff",
                "#f8f9fa",
                "#e9ecef",
                "#dee2e6",
                "#ced4da",
                "#adb5bd",
                "#6F7780",
                "#495057",
                "#343a40",
                "#212529",
                "#000000"
            ],
            colors: [
                {
                    name: "primary",
                    hex: () => { return colors.find(x => x.name === 'blue').value }
                },
                {
                    name: "secondary",
                    hex: () => { return themeLight.grays[6] }
                },
                {
                    name: "success",
                    hex: () => { return colors.find(x => x.name === 'green').value }
                },
                {
                    name: "info",
                    hex: () => { return colors.find(x => x.name === 'cyan').value }
                },
                {
                    name: "warning",
                    hex: () => { return colors.find(x => x.name === 'orange').value }
                },
                {
                    name: "danger",
                    hex: () => { return colors.find(x => x.name === 'red').value }
                },
                {
                    name: "light",
                    hex: () => { return themeLight.grays[1] }
                },
                {
                    name: "dark",
                    hex: () => { return themeLight.grays[8] }
                }
            ]
        };
        let themes = [
            themeLight
        ];

        function arraysEqual(a, b) {
            if (a === b) return true;
            if (a == null || b == null) return false;
            if (a.length != b.length) return false;

            // If you don't care about the order of the elements inside
            // the array, you should sort both arrays here.
            // Please note that calling sort on an array will modify that array.
            // you might want to clone your array first.

            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        let rgbAlpha = (rgb, percentage) => {
            return rgb.map(d => (d += percentage) < 0 ? 0 : d > 255 ? 255 : d | 0);
        };


        let yiq = rgb => {
            return rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114 > 145 ? [ 0, 0, 0 ] : [ 255, 255, 255 ];
        };

        let lighten = (rgb, percent) => {
            return rgbAlpha(rgb, percent);
        };

        let darken = (rgb, percent) => {
            return rgbAlpha(rgb, -percent);
        };

        let border = (color, yiq, percent) => {
            if (arraysEqual(yiq, [0, 0, 0])) {
                return darken(color, percent);
            } else {
                return lighten(color, percent);
            }
        };

        let hexToRgb = (hex) => {
            hex = hex.replace('#', '');
            return [
                parseInt(hex.substring(0, 2), 16),
                parseInt(hex.substring(2, 4), 16),
                parseInt(hex.substring(4, 6), 16)
            ];
        }



        let loadTheme = (name) => {
            let theme = themes.find(x => x.name === name);

            $.each(theme.grays, (i, gray) => {
                body.css(`--gray-${i * 10}`, hexToRgb(gray));
            });
            $.each(theme.colors, (i, color) => {
                let rgb = hexToRgb(color.hex());

                let variants = [
                    {
                        name: 'default',
                        value: rgb
                    },
                    {
                        name: 'default-hover',
                        value: rgbAlpha(rgb, theme.hover)
                    }
                ];

                $.each(variants, (j, variant) => {
                    let textColor = yiq(variant.value);
                    body.css(`--${color.name}-${variant.name}-background`, variant.value);
                    body.css(`--${color.name}-${variant.name}-text`, textColor);
                    body.css(`--${color.name}-${variant.name}-border`, border(variant.value, textColor, 20));
                });
            });
        };

        loadTheme('light');
    });
}
{
    layoutr.setOnline = () => {
        let online = navigator.onLine;

        layoutr.body.find('.alert[data-type="connected"]').remove();
        if (online) {
            layoutr.showPopupAlert('You are online', 'success', 'bottom right', 'connected');
        } else {
            layoutr.showPopupAlert('You are offline', 'danger', 'bottom right', 'connected');
        }
    };

    $(() => {
        window.addEventListener('online', layoutr.setOnline);
        window.addEventListener('offline', layoutr.setOnline);

        if (!navigator.onLine) {
            layoutr.setOnline();
        }
    });
}
{
    layoutr.checkDropdown = (dropdowns) => {
        dropdowns.each((i, e) => {
            let $this = $(e),
                selected = $this.children('option:selected'),
                attr = $this.attr('class'),
                theme = '',
                width = $this.attr('data-width');
            if (selected.length !== 1) {
                selected = $this.children().first();
            }
            if (typeof attr !== typeof undefined && attr !== false) {
                let temp = attr.split(' ');
                temp = $.grep(temp, (item, index) => {
                    return item.trim().match(/^theme-/);
                });
                if (temp.length === 1) {
                    theme = temp[0];
                }
            }

            let liTemplate = (e) => {
                let li = $(e),
                    text = li.text();
                if (!text.length) {
                    text = '&nbsp;';
                }
                if (text.indexOf('$$') === 0) {
                    li.attr('data-math', text);
                }
                return `<li data-id="${li.val()}"${li.is(':selected') ? ' class="selected"' : ''}>
    <div tabindex="0" class="theme-light">
        <label>${text}</label>
        <svg focusable="false"><use xlink:href="#svg-checkmark"></use></svg>
    </div>
</li>`;
            };
            let html = 
`<div class="dropdown
    ${$this.hasClass('not-first') ? ' not-first' : ''}
    ${$this.hasClass('nowrap') ? ' nowrap' : ''}
    ${$this.hasClass('check') ? ' check' : ''}
    ${$this.hasClass('ellipsis') ? ' ellipsis' : ''}
    ${$this.hasClass('align-left') ? ' align-left' : ''}
    ${$this.hasClass('align-right') ? ' align-right' : ''}
    ${$this.hasClass('direction-up') ? ' direction-up' : ''}
    "
    ${width !== undefined ? ` style="width: ${width}px"` : ''}
>
    <div tabindex="0" class="${theme}">
        <label>${selected.text()}</label>
        <svg focusable="false"><use xlink:href="#svg-arrow"></use></svg>
    </div>
    <ul class="${theme}">
        ${$.makeArray($this.children()).map(liTemplate).join('')}
    </ul>
</div>`;
            $this.after(html);
            html = $this.next();

            if ($this.hasClass('nowrap')) {
                let top = html.children().eq(0),
                    bottom = html.children().eq(1),
                    topWidth = top.width(),
                    bottomWidth = bottom.width();
                if (bottomWidth > topWidth) {
                    top.css('min-width', bottomWidth);
                }
            }

            html.on('click', '> div', (e) => {
                let $that = $(e.currentTarget);
                $that.parent().toggleClass('open');
            });
            html.on('click', 'li', (e) => {
                let $that = $(e.currentTarget);
                if (!$that.hasClass('selected')) {
                    console.log('test a');
                    $that.siblings('.selected').removeClass('selected');
                    $that.addClass('selected');
                    let option = $this.children(`[value="${$that.attr('data-id')}"]`),
                        text = $that.text(),
                        math = option.attr('data-math');
                    if (math !== undefined) {
                        text = math;
                    }
                    let label = html.children('div').children('label');
                    label.text(text);
                    if (math !== undefined) {
                        renderMathInElement(label[0]);
                    }
                    $this.children(':selected').removeAttr('selected');
                    option.prop('selected', true);
                    $this.change();
                }
                html.removeClass('open');
            });
        });
    };

    $(window).click((e) => {
        let target = $(e.target);
        if (target.closest("div.dropdown").length) {
            $('div.dropdown').not(target.closest("div.dropdown")).removeClass('open');
        }

        if (!target.closest(".dropdown").length) {
            $('div.dropdown').removeClass('open');
        }
    });
}
{
    layoutr.checkAccordion = (elements) => {
        elements.on("click", ".headline", (e) => {
            let content = $(e.currentTarget).next();
            if (content.hasClass('open')) {
                content
                    .removeClass('open')
                    .slideUp("800");
            } else {
                content
                    .addClass("open")
                    .slideToggle("800")
                    .parents('.accordion').find(".content.open").not(content).removeClass('open').slideUp("800");
            }
        });
    };
}
{
    let closeAlert = (target) => {
        target.fadeOut(layoutr.fadeOutTime, () => {
            let parent = target.parent();
            if (parent.hasClass('popup') && parent.children().length === 1) {
                parent.remove();
            } else {
                target.remove();
            }
        });
    };

    $(() => {
        layoutr.body.on('click', '.alert .close', (e) => {
            let target = $(e.currentTarget).parent();
            closeAlert(target);
        });
    });
}
{
    layoutr.checkMap = (maps) => {
        layoutr.head.find('script[src^="https://maps.googleapis.com/maps-api-"]').remove();
        if (maps.length) {
            if (!layoutr.html.hasClass('map-loaded')) {
                layoutr.showLoading();
                layoutr.promiseMap = layoutr.load.js('https://maps.googleapis.com/maps/api/js?key=AIzaSyBEcomDjRS4Nu3RQCkkSIQ0nrBhuQM0gng').finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('map-loaded');
            }

            layoutr.promiseMap.then(() => {
                maps.each((i, e) => {
                    let $this = $(e),
                        lat = layoutr.tryParseFloat($this.attr('data-lat'), 37.4029937),
                        lng = layoutr.tryParseFloat($this.attr('data-lng'), -122.1811793),
                        zoom = layoutr.tryParseInt($this.attr('data-zoom'), 4),
                        cords = { lat: lat, lng: lng };

                    let map = new google.maps.Map($this[0], {
                        zoom: zoom,
                        center: cords
                    });

                    let marker = new google.maps.Marker({
                        position: cords,
                        map: map
                    });

                    $(window).bind('resize.map', $.throttle(layoutr.throttleInterval, false, () => {
                        google.maps.event.trigger($this[0], 'resize');
                    }));

                    layoutr.html.on('aside-changed.map', () => {
                        google.maps.event.trigger($this[0], 'resize');
                    });
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load maps', 'danger');
                console.error(e);
            });
        } else {
            $(window).unbind('resize.map');
            layoutr.html.off('aside-changed.map');
        }
    };
}
{
    layoutr.checkMath = (math) => {
        if (math.length) {
            if (!layoutr.html.hasClass('math-loaded')) {
                layoutr.showLoading();
                layoutr.promiseMath = Promise.all([
                    layoutr.load.css('dist/css/katex.css'),
                    layoutr.load.js('dist/js/katex.js')
                ]).finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('math-loaded');
            }

            layoutr.promiseMath.then(() => {
                math.each((i, e) => {
                    let $this = $(e);
                    renderMathInElement($this[0]);
                    setTimeout(() => {
                        $this.removeClass('math');
                    });
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load math', 'danger');
                console.error(e);
            });
        }
    };
}
{
    layoutr.checkMedia = (media) => {
        if (media.length) {
            if (!layoutr.html.hasClass('media-loaded')) {
                layoutr.showLoading();
                layoutr.promiseMedia = Promise.all([
                    layoutr.load.css('dist/css/plyr.css'),
                    layoutr.load.js('dist/js/plyr.js')
                ]).finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('media-loaded');
            }

            layoutr.promiseMedia.then(() => {
                media.each((i, item) => {
                    new Plyr(item);
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load media', 'danger');
                console.error(e);
            });
        }
    };
}
{
    layoutr.checkLazy = (elements) => {
        elements.lazy({
            afterLoad: (element) => {
                element.removeClass('lazy');
            }
        });
    };
};
{
    $(() => {
        layoutr.body.on('click', '.show-popup-alert', (e) => {
            let $this = $(e.currentTarget),
                title = $this.attr('data-popup-title'),
                theme = $this.attr('data-popup-theme'),
                position = $this.attr('data-popup-position');
            layoutr.showPopupAlert(title, theme, position);
        });
    });

    layoutr.showPopupAlert = (title, theme = 'light', position = 'top left', type = 'default') => {
        if (title !== undefined) {
            let popup = layoutr.body.children(`.popup[data-position="${position}"]`),
                html =
                    `<div class="alert theme-${theme}" data-type="${type}">
<div><p>${title}</p></div>
<button class="close" aria-label="Close popup"><svg focusable="false"><use xlink:href="#svg-close"></use></svg></button>
</div>`;
            if (popup.length) {
                popup.append(html);
            } else {
                html = `<div class="popup position ${position}" data-position="${position}">${html}`;
                html = `${html}</div>`;
                layoutr.body.prepend(html);
            }
        }
    };
}
{
    layoutr.checkResponsiveBackground = (elements) => {
        let setRb = (element) => {
            let clone = element.children('.clone'),
                image = element.attr('data-rb-image'),
                filetype = element.attr('data-rb-image-filetype'),
                sizesWidth = element.attr('data-rb-sizes'),
                current = element.attr('data-rb-current'),
                aspectRatio = element.attr('data-rb-aspect-ratio');
            if (image !== undefined && image.length &&
                filetype !== undefined && filetype.length &&
                sizesWidth !== undefined && sizesWidth.length &&
                aspectRatio !== undefined && aspectRatio.length) {
                if ((filetype === 'jpg' || filetype === 'jpeg' || filetype === 'png') &&
                    (aspectRatio === '21by9' || aspectRatio === '16by9' || aspectRatio === '4by3' || aspectRatio === '1by1')) {
                    sizesWidth = sizesWidth.replace(/\s/g, '').split(',').sort((a, b) => { return a - b; });
                    clone.attr('style', element.attr('style'));

                    let goalWidth = element.width(),
                        goalHeight = element.height(),
                        closestWidth,
                        closestHeight,
                        heightPercentage;

                    let getHeightInPercentage = (num, amount) => {
                        return num * 100 / amount;
                    };

                    if (aspectRatio === '21by9') {
                        heightPercentage = getHeightInPercentage(9, 21);
                    } else if (aspectRatio === '16by9') {
                        heightPercentage = getHeightInPercentage(9, 16);

                    } else if (aspectRatio === '4by3') {
                        heightPercentage = getHeightInPercentage(3, 4);

                    } else if (aspectRatio === '1by1') {
                        heightPercentage = 100;
                    }

                    let getHeightInPixels = (num, amount) => {
                        return num * amount / 100;
                    };

                    $.each(sizesWidth, (i, e) => {
                        let width = parseInt(e),
                            height = getHeightInPixels(heightPercentage, width);
                        if (closestWidth === undefined || width < goalWidth || closestWidth < goalWidth ||
                            closestHeight === undefined || height < goalHeight || closestHeight < goalHeight) {
                            closestWidth = width;
                            closestHeight = height;
                        }
                    });

                    if (current !== undefined && current.length && parseInt(current) < closestWidth || current === undefined || current.length === 0) {
                        let src = `${image}-${closestWidth}.${filetype}`;
                        layoutr.load.img(src).then(() => {
                            clone.css('background-image', `url(${src})`);
                            setTimeout(function () {
                                element.css('background-image', `url(${src})`);
                            }, 500);
                            // todo: find replacement for 500 ms timeout
                            element.attr('data-rb-current', closestWidth);
                        }).catch((e) => {
                            layoutr.showPopupAlert('Failed to load responsive background image', 'danger');
                            console.error(e);
                        });
                    }
                }
            }
        };

        if (elements.length) {
            elements.each((i, e) => {
                let element = $(e);

                setRb(element);

                $(window).on('resize.rb', () => {
                    setRb(element);
                });

                layoutr.html.on('columns-changed.rb', () => {
                    setRb(element);
                });

                layoutr.html.on('aside-changed.rb', () => {
                    setRb(element);
                });
            });

        } else {
            $(window).off('resize.rb');
            layoutr.html.off('columns-changed.rb');
            layoutr.html.off('aside-changed.rb');
        }

    };
}
{
    layoutr.checkTooltip = (tooltips) => {
        tooltips.each((i, e) => {
            let $this = $(e),
                interactive = $this.hasClass('interactive');
            $this.tooltipster({
                animationDuration: 0,
                interactive: interactive,
                trigger: 'custom',
                triggerOpen: {
                    mouseenter: true,
                    touchstart: true
                },
                triggerClose: {
                    mouseleave: true,
                    tap: true,
                    scroll: true
                }
            });
        });
    };
}
{
    layoutr.checkDatatable = (tables) => {
        if (tables.length) {
            if (!layoutr.html.hasClass('datatables-loaded')) {
                layoutr.showLoading();
                layoutr.promiseDatatables = layoutr.load.js('dist/js/datatables.js').finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('datatables-loaded');
            }
            layoutr.promiseDatatables.then(() => {
                let count = 0,
                    gap = 'gap-3';
                let table_header_input = (instance, wrapper) => {
                    let ths = wrapper.find('thead th'),
                        elements = jQuery.grep(ths, (e) => {
                            let column = $(e);
                            return column.hasClass('dropdown') || column.hasClass('text');
                        });
                    for (let i = 0; i < ths.length; i++) {
                        let column = $(ths[i]),
                            text = column.html(),
                            minWidth = column.attr('data-min-width'),
                            style = minWidth ? `min-width: ${minWidth}px;` : '',
                            html =
                                `<div style="${style}">
    <div>
        <span>${text}</span>
    </div>
    ${elements.length ? '<div></div>' : ''}
</div>`;
                        column.empty().append(html);
                        let index = column.index();

                        if (column.hasClass('dropdown')) {
                            let select = $('<select class="dropdown align-left nowrap"><option value=""></option></select>')
                                .appendTo(column.find('> div > div:last-child'))
                                .on('change', (e) => {
                                    instance.column(index).search(e.currentTarget.value).draw();
                                });

                            instance.column(i).data().unique().sort(layoutr.sort).each((d, j) => {
                                select.append(`<option value="${d}">${d}</option>`);
                            });
                        } else if (column.hasClass('text')) {
                            let input = $('<input type="text" />')
                                .appendTo(column.find('> div > div:last-child'))
                                .on('keyup', (e) => {
                                    let $this = $(e.currentTarget),
                                        val = $this.val();

                                    if ($this.attr('data-last') !== val) {
                                        instance.column(index).search(val).draw();
                                    }
                                    $this.attr('data-last', val);
                                });
                            input.parent().addClass('form-group');
                        }
                        //debugger;
                    }
                };
                let table_header_sort = (instance, wrapper) => {
                    wrapper.find('thead th').unbind('click');

                    let enabled = wrapper.find('thead th:not(.sorting-disabled)'),
                        disabled = wrapper.find('thead th.sorting-disabled');

                    disabled.removeAttr('tabindex');

                    enabled.find('> div > div:first-child').append('<span class="sort-btn"></span>');
                    enabled.click((e) => {
                        let $this = $(e.target);
                        if (!$this.closest('div.dropdown').length && !$this.closest('input').length) {
                            let parent = $this.parents('th'),
                                index = parent.index();
                            if (parent.hasClass('sorting_asc')) {
                                instance.column(index).order('desc').draw();

                            } else {
                                instance.column(index).order('asc').draw();
                            }
                        }
                    });
                };
                let table_header_length = (wrapper, header) => {
                    let length = wrapper.find('.dataTables_length'),
                        dropdown = length.find('select');

                    length.append(dropdown);
                    length.children('label').remove();
                    dropdown.addClass('dropdown').attr('data-width', 100);
                    header.append(length);
                };
                let table_header_buttons = (wrapper, header) => {
                    let container = wrapper.find('.dt-buttons');

                    container.append(`<div class="flex wrap ${gap}"></div>`);

                    let div = container.children('div'),
                        buttons = container.children('button');

                    container.append(div);
                    buttons.addClass('btn');
                    div.append(buttons);
                    header.append(container);
                };
                let table_header_filter = (wrapper, header) => {
                    let filter = wrapper.find('.dataTables_filter');

                    filter.addClass('input-group');
                    filter.find('input').appendTo(filter);
                    filter.append('<div class="input-group-addon"><svg focusable="false"><use xlink:href="#svg-search"></use></svg></div>');
                    filter.find('label').remove();
                    header.append(filter);
                };
                let table_content = (wrapper, content) => {
                    let table = wrapper.find('table');
                    content.append(table);
                    return table;
                };
                let table_footer_info = (wrapper, footer) => {
                    let info = wrapper.find('.dataTables_info');
                    footer.append(info);
                };
                let paginateFix = (paginate) => {
                    let span = paginate.children('span'),
                        prev = paginate.find('.paginate_button.previous'),
                        next = paginate.find('.paginate_button.next');

                    prev.html('<svg focusable="false"><use xlink:href="#svg-arrow"></use></svg>');
                    next.html('<svg focusable="false"><use xlink:href="#svg-arrow"></use></svg>');

                    prev.prependTo(span);
                    next.appendTo(span);
                };
                let table_footer_paginate = (wrapper, footer, paginate) => {
                    paginate.addClass('flex wrap');
                    footer.append('<div class="dataTables_paginate_container"></div>');
                    let container = footer.find('.dataTables_paginate_container');
                    paginateFix(paginate);
                    container.append(paginate);
                };
                let table_dropdowns = (wrapper) => {
                    let dropdowns = wrapper.find('select.dropdown');
                    layoutr.checkDropdown(dropdowns);
                };

                tables.each((i, e) => {
                    let $this = $(e),
                        exportOptions = {
                            "format": {
                                header: (text, index, th) => {
                                    return $(th).find('span:first').html();
                                }
                            }
                        };
                    $this.addClass('nowrap');
                    $this.DataTable({
                        "dom": 'lBfrtip',
                        "bSortCellsTop": true,
                        buttons: [
                            {
                                extend: 'copyHtml5',
                                footer: false,
                                exportOptions: exportOptions
                            },
                            {
                                extend: 'excelHtml5',
                                footer: false,
                                exportOptions: exportOptions
                            },
                            {
                                extend: 'csvHtml5',
                                footer: false,
                                exportOptions: exportOptions
                            }
                        ],
                        responsive: true,
                        initComplete: (settings) => {
                            let instance = settings.oInstance.api(true),
                                wrapper = $(settings.nTableWrapper);

                            wrapper.append(`<div class="dataTables_header flex column grow"><div class="flex wrap ${gap}"></div></div>`);
                            let header = wrapper.find('> .dataTables_header > div');

                            wrapper.append('<div class="dataTables_content table"></div>');
                            let content = wrapper.find('> .dataTables_content');

                            wrapper.append(`<div class="dataTables_footer"><div class="flex wrap vertical-center ${gap}"></div></div>`);
                            let footer = wrapper.find('> .dataTables_footer > div');

                            table_header_input(instance, wrapper);
                            table_header_sort(instance, wrapper);
                            table_header_length(wrapper, header);
                            table_header_buttons(wrapper, header);
                            table_header_filter(wrapper, header);

                            let table = table_content(wrapper, content);

                            table_footer_info(wrapper, footer);

                            let paginate = wrapper.find('.dataTables_paginate');
                            table_footer_paginate(wrapper, footer, paginate);

                            table_dropdowns(wrapper);

                            count++;
                            if (count === tables.length) {
                                layoutr.hideLoading();
                            }

                            $this.on('draw.dt', () => {
                                let columns = instance.columns().responsiveHidden();
                                $this.trigger('responsive-resize.dt', [table[0], columns]);
                            });

                            layoutr.html.on('aside-changed.datatables', () => {
                                instance.responsive.recalc();
                            });

                            $this.on('responsive-resize.dt', (e, datatable, columns) => {
                                let count = columns.reduce((a, b) => {
                                    return b === false ? a + 1 : a;
                                }, 0);

                                let elements = table.find('tbody tr:not(.child) > *:first-child:not(.dataTables_empty)');
                                elements.removeAttr('tabindex');

                                elements.children('i').remove();
                                if (count) {
                                    elements.prepend('<i tabindex="0"><svg focusable="false"><use xlink:href="#svg-plus"></use></svg><svg focusable="false"><use xlink:href="#svg-minus"></use></svg></i>');
                                }
                            });

                        }
                    });
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load datatables', 'danger');
                console.error(e);
            });
        } else {
            layoutr.html.off('aside-changed.datatables');
        }
    };
}
{
    layoutr.checkSwiper = (swiper) => {
        if (swiper.length) {
            if (!layoutr.html.hasClass('swiper-loaded')) {
                layoutr.showLoading();
                layoutr.promiseSwiper = Promise.all([
                    layoutr.load.css('dist/css/swiper.css'),
                    layoutr.load.js('dist/js/swiper.js')
                ]).finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('swiper-loaded');
            }

            layoutr.promiseSwiper.then(() => {
                swiper.each((i, e) => {
                    let $this = $(e);
                    if (!$this.hasClass('loaded')) {
                        $this.append('<div class="swiper-footer"></div>');
                        $this.children('.swiper-footer').append('<div></div>');

                        let footer = $this.find('> .swiper-footer > div'),
                            pagination = $this.hasClass('pagination'),
                            dynamicBullets = $this.hasClass('dynamic-bullets'),
                            navigation = $this.hasClass('navigation'),
                            loop = layoutr.isTrue($this.attr('data-loop')),
                            spaceBetween = $this.hasClass('space-between'),
                            slidesPerView = layoutr.tryParseInt($this.attr('data-slides-per-view'), 1),
                            breakpoints = layoutr.tryParseJSON($this.attr('data-breakpoints'), {});

                        footer.addClass('flex wrap gap-3 center');

                        if (pagination || dynamicBullets) {
                            footer.append('<div class="swiper-pagination flex wrap gap-1 center vertical-center"></div>');
                        }

                        if (navigation) {
                            footer.append('<button class="btn square circle prev theme-dark"><svg focusable="false"><use xlink:href="#svg-arrow"></use></svg></button>');
                            footer.append('<button class="btn square circle next theme-dark"><svg focusable="false"><use xlink:href="#svg-arrow"></use></svg></button>');
                        }

                        if (spaceBetween) {
                            spaceBetween = 16;
                        }

                        let swiper = new Swiper($this[0], {
                            loop: loop,
                            slidesPerView: slidesPerView,
                            spaceBetween: spaceBetween,

                            // If we need pagination
                            pagination: {
                                el: '.swiper-pagination',
                                dynamicBullets: dynamicBullets
                            },

                            // Navigation arrows
                            navigation: {
                                nextEl: '.swiper-footer .next',
                                prevEl: '.swiper-footer .prev'
                            },

                            // And if we need scrollbar
                            scrollbar: {
                                el: '.swiper-scrollbar'
                            },
                            breakpoints: breakpoints,
                            on: {
                                init: () => {
                                    $this.addClass('loaded');
                                },
                                slideChange: () => {
                                    layoutr.checkLazy($this.find('.lazy'));
                                }
                            }
                        });
                    }
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load swiper', 'danger');
                console.error(e);
            });
        }
    };
}
{
    layoutr.getAssignmentItem = (items, id) => {
        return $($.map(items, (item) => {
            if (item.getAttribute("data-id") === id) {
                return item;
            }
        }));
    };

    layoutr.checkAssignment = (assignments) => {
        if (assignments.length) {
            if (!layoutr.html.hasClass('assignment-loaded')) {
                layoutr.showLoading();
                layoutr.promiseAssignment = layoutr.load.js('dist/js/assignment.js').finally(() => {
                    layoutr.hideLoading();
                });
                layoutr.html.addClass('assignment-loaded');
            }

            layoutr.promiseAssignment.then(() => {
                $(assignments).each((i, assignment) => {
                    assignment = $(assignment);
                    layoutr.checkAssignmentSort(assignment);
                    layoutr.checkAssignmentDragAndDrop(assignment);
                    layoutr.checkAssignmentColor(assignment);
                    layoutr.checkAssignmentPuzzle(assignment);
                });
            }).catch((e) => {
                layoutr.showPopupAlert('Failed to load assignment', 'danger');
                console.error(e);
            });
        } else {
            layoutr.arrowKeyLocked = false;
            $(window).unbind('resize.assignmentSort');
            layoutr.body.on('keydown.assignmentPuzzle');
        }
    };
}
{
    layoutr.pageForm = () => {
        layoutr.addValidation(
            layoutr.content.find('#form'),
            {
                firstName: {
                    required: true,
                    minlength: 2
                },
                lastName: {
                    required: true,
                    minlength: 2
                },
                username: {
                    required: true,
                    minlength: 2
                },
                password: {
                    required: true,
                    password_regex: true
                },
                confirm_password: {
                    required: true,
                    equalTo: "#password"
                },
                email: {
                    required: true,
                    email: true
                },
                dropdown_1: "required",
                dropdown_2: "required",
                dropdown_3: "required",
                dropdown_4: "required",
                dropdown_5: "required",
                dropdown_6: "required",
                gender: "required",
                interests: "required",
                agree: "required",
                font_size: "required"
            },
            {
                firstName: {
                    required: "Please enter your first name",
                    minlength: "Your first name must consist of at least 2 characters"
                },
                lastName: {
                    required: "Please enter your last name",
                    minlength: "Your last name must consist of at least 2 characters"
                },
                username: {
                    required: "Please enter a username",
                    minlength: "Your username must consist of at least 2 characters"
                },
                password: {
                    required: "Please provide a password"
                },
                confirm_password: {
                    required: "Please provide a password",
                    equalTo: "Please enter the same password as above"
                },
                email: "Please enter a valid email address",
                dropdown_1: "Please select an option",
                dropdown_2: "Please select an option",
                dropdown_3: "Please select an option",
                dropdown_4: "Please select an option",
                dropdown_5: "Please select an option",
                dropdown_6: "Please select an option",
                gender: "Please select your gender",
                interests: "Please select at least one interest",
                agree: "Please accept our policy"
            }
        );
    };
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIl9icm93c2VyLmpzIiwid2ViZm9udGxvYWRlci5taW4uanMiLCJqcXVlcnktMy40LjEubWluLmpzIiwianF1ZXJ5LnZhbGlkYXRlLm1pbi5qcyIsImpxdWVyeS5sYXp5Lm1pbi5qcyIsInRvb2x0aXBzdGVyLm1pbi5qcyIsImpxdWVyeS5iYS10aHJvdHRsZS1kZWJvdW5jZS5qcyIsImpxdWVyeS5zaHVmZmxlLmpzIiwiYm93c2VyLmpzIiwiX3BvbHlmaWxsLmpzIiwiX3ZhcmlhYmxlLmpzIiwiX2Z1bmN0aW9uLmpzIiwiX2Jvd3Nlci5qcyIsIl9sb2FkLmpzIiwiX2FwcC5qcyIsImZvbnQuanMiLCJsb2FkZWQuanMiLCJmb3JtLmpzIiwiZnVsbHNjcmVlbi5qcyIsInNjcm9sbC5qcyIsImxvYWRpbmcuanMiLCJhc2lkZS5qcyIsImF1dGhlbnRpY2F0aW9uLmpzIiwiY29va2llLmpzIiwibmF2aWdhdGlvbi5qcyIsInNldHRpbmdzLmpzIiwia2V5Ym9hcmQuanMiLCJtb2RhbC5qcyIsInJlc3BvbnNpdmVIZWFkZXIuanMiLCJmb2N1cy5qcyIsInN3aXBlLmpzIiwidHRzLmpzIiwiY29udGVudEhlYWRlci5qcyIsInRoZW1lLmpzIiwiY29ubmVjdGVkLmpzIiwiZHJvcGRvd24uanMiLCJhY2NvcmRpb24uanMiLCJhbGVydC5qcyIsIm1hcC5qcyIsIm1hdGguanMiLCJtZWRpYS5qcyIsImxhenkuanMiLCJwb3B1cC5qcyIsInJlc3BvbnNpdmVCYWNrZ3JvdW5kLmpzIiwidG9vbHRpcC5qcyIsImRhdGF0YWJsZXMuanMiLCJzd2lwZXIuanMiLCJfYXNzaWdubWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0E5QnJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAhPT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudFxcLzdcXC4vKSkge1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Jyb3dzZXItbm90LXN1cHBvcnRlZCcpO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLmlubmVySFRNTCA9XHJcbmA8bWFpbj5cclxuPGgxPkludGVybmV0IEV4cGxvcmVyIGlzIG5vdCBzdXBwb3J0ZWQ8L2gxPlxyXG48cD5Zb3UncmUgdXNpbmcgYSB3ZWIgYnJvd3NlciB3ZSBkb24ndCBzdXBwb3J0LjxiciAvPlxyXG5Ucnkgb25lIG9mIHRoZXNlIG9wdGlvbnMgdG8gaGF2ZSBhIGJldHRlciBleHBlcmllbmNlIG9uIGxheW91dHIuPC9wPlxyXG48dWw+XHJcbjxsaT5PcGVuIE1pY3Jvc29mdCBFZGdlPC9saT5cclxuPGxpPjxhIGhyZWY9XCJodHRwczovL3d3dy5nb29nbGUuY29tL2Nocm9tZS9cIj5Eb3dubG9hZCBHb29nbGUgQ2hyb21lPC9hPjwvbGk+XHJcbjxsaT48YSBocmVmPVwiaHR0cHM6Ly93d3cubW96aWxsYS5vcmcvZmlyZWZveFwiPkRvd25sb2FkIE1vemlsbGEgRmlyZWZveDwvYT48L2xpPlxyXG48L3VsPlxyXG48L21haW4+YDtcclxuICAgIHRocm93ICdicm93c2VyLW5vdC1zdXBwb3J0ZWQnO1xyXG59IiwiLyogV2ViIEZvbnQgTG9hZGVyIHYxLjYuMjggLSAoYykgQWRvYmUgU3lzdGVtcywgR29vZ2xlLiBMaWNlbnNlOiBBcGFjaGUgMi4wICovKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYWEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYmEoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcChhLGIsYyl7cD1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2FhOmJhO3JldHVybiBwLmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgcT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O2Z1bmN0aW9uIGNhKGEsYil7dGhpcy5hPWE7dGhpcy5vPWJ8fGE7dGhpcy5jPXRoaXMuby5kb2N1bWVudH12YXIgZGE9ISF3aW5kb3cuRm9udEZhY2U7ZnVuY3Rpb24gdChhLGIsYyxkKXtiPWEuYy5jcmVhdGVFbGVtZW50KGIpO2lmKGMpZm9yKHZhciBlIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShlKSYmKFwic3R5bGVcIj09ZT9iLnN0eWxlLmNzc1RleHQ9Y1tlXTpiLnNldEF0dHJpYnV0ZShlLGNbZV0pKTtkJiZiLmFwcGVuZENoaWxkKGEuYy5jcmVhdGVUZXh0Tm9kZShkKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyl7YT1hLmMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYilbMF07YXx8KGE9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTthLmluc2VydEJlZm9yZShjLGEubGFzdENoaWxkKX1mdW5jdGlvbiB2KGEpe2EucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfVxyXG5mdW5jdGlvbiB3KGEsYixjKXtiPWJ8fFtdO2M9Y3x8W107Zm9yKHZhciBkPWEuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyksZT0wO2U8Yi5sZW5ndGg7ZSs9MSl7Zm9yKHZhciBmPSExLGc9MDtnPGQubGVuZ3RoO2crPTEpaWYoYltlXT09PWRbZ10pe2Y9ITA7YnJlYWt9Znx8ZC5wdXNoKGJbZV0pfWI9W107Zm9yKGU9MDtlPGQubGVuZ3RoO2UrPTEpe2Y9ITE7Zm9yKGc9MDtnPGMubGVuZ3RoO2crPTEpaWYoZFtlXT09PWNbZ10pe2Y9ITA7YnJlYWt9Znx8Yi5wdXNoKGRbZV0pfWEuY2xhc3NOYW1lPWIuam9pbihcIiBcIikucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC8sXCJcIil9ZnVuY3Rpb24geShhLGIpe2Zvcih2YXIgYz1hLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspaWYoY1tkXT09YilyZXR1cm4hMDtyZXR1cm4hMX1cclxuZnVuY3Rpb24gZWEoYSl7cmV0dXJuIGEuby5sb2NhdGlvbi5ob3N0bmFtZXx8YS5hLmxvY2F0aW9uLmhvc3RuYW1lfWZ1bmN0aW9uIHooYSxiLGMpe2Z1bmN0aW9uIGQoKXttJiZlJiZmJiYobShnKSxtPW51bGwpfWI9dChhLFwibGlua1wiLHtyZWw6XCJzdHlsZXNoZWV0XCIsaHJlZjpiLG1lZGlhOlwiYWxsXCJ9KTt2YXIgZT0hMSxmPSEwLGc9bnVsbCxtPWN8fG51bGw7ZGE/KGIub25sb2FkPWZ1bmN0aW9uKCl7ZT0hMDtkKCl9LGIub25lcnJvcj1mdW5jdGlvbigpe2U9ITA7Zz1FcnJvcihcIlN0eWxlc2hlZXQgZmFpbGVkIHRvIGxvYWRcIik7ZCgpfSk6c2V0VGltZW91dChmdW5jdGlvbigpe2U9ITA7ZCgpfSwwKTt1KGEsXCJoZWFkXCIsYil9XHJcbmZ1bmN0aW9uIEEoYSxiLGMsZCl7dmFyIGU9YS5jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtpZihlKXt2YXIgZj10KGEsXCJzY3JpcHRcIix7c3JjOmJ9KSxnPSExO2Yub25sb2FkPWYub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7Z3x8dGhpcy5yZWFkeVN0YXRlJiZcImxvYWRlZFwiIT10aGlzLnJlYWR5U3RhdGUmJlwiY29tcGxldGVcIiE9dGhpcy5yZWFkeVN0YXRlfHwoZz0hMCxjJiZjKG51bGwpLGYub25sb2FkPWYub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsXCJIRUFEXCI9PWYucGFyZW50Tm9kZS50YWdOYW1lJiZlLnJlbW92ZUNoaWxkKGYpKX07ZS5hcHBlbmRDaGlsZChmKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Z3x8KGc9ITAsYyYmYyhFcnJvcihcIlNjcmlwdCBsb2FkIHRpbWVvdXRcIikpKX0sZHx8NUUzKTtyZXR1cm4gZn1yZXR1cm4gbnVsbH07ZnVuY3Rpb24gQigpe3RoaXMuYT0wO3RoaXMuYz1udWxsfWZ1bmN0aW9uIEMoYSl7YS5hKys7cmV0dXJuIGZ1bmN0aW9uKCl7YS5hLS07RChhKX19ZnVuY3Rpb24gRShhLGIpe2EuYz1iO0QoYSl9ZnVuY3Rpb24gRChhKXswPT1hLmEmJmEuYyYmKGEuYygpLGEuYz1udWxsKX07ZnVuY3Rpb24gRihhKXt0aGlzLmE9YXx8XCItXCJ9Ri5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz0wO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYi5wdXNoKGFyZ3VtZW50c1tjXS5yZXBsYWNlKC9bXFxXX10rL2csXCJcIikudG9Mb3dlckNhc2UoKSk7cmV0dXJuIGIuam9pbih0aGlzLmEpfTtmdW5jdGlvbiBHKGEsYil7dGhpcy5jPWE7dGhpcy5mPTQ7dGhpcy5hPVwiblwiO3ZhciBjPShifHxcIm40XCIpLm1hdGNoKC9eKFtuaW9dKShbMS05XSkkL2kpO2MmJih0aGlzLmE9Y1sxXSx0aGlzLmY9cGFyc2VJbnQoY1syXSwxMCkpfWZ1bmN0aW9uIGZhKGEpe3JldHVybiBIKGEpK1wiIFwiKyhhLmYrXCIwMFwiKStcIiAzMDBweCBcIitJKGEuYyl9ZnVuY3Rpb24gSShhKXt2YXIgYj1bXTthPWEuc3BsaXQoLyxcXHMqLyk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY10ucmVwbGFjZSgvWydcIl0vZyxcIlwiKTstMSE9ZC5pbmRleE9mKFwiIFwiKXx8L15cXGQvLnRlc3QoZCk/Yi5wdXNoKFwiJ1wiK2QrXCInXCIpOmIucHVzaChkKX1yZXR1cm4gYi5qb2luKFwiLFwiKX1mdW5jdGlvbiBKKGEpe3JldHVybiBhLmErYS5mfWZ1bmN0aW9uIEgoYSl7dmFyIGI9XCJub3JtYWxcIjtcIm9cIj09PWEuYT9iPVwib2JsaXF1ZVwiOlwiaVwiPT09YS5hJiYoYj1cIml0YWxpY1wiKTtyZXR1cm4gYn1cclxuZnVuY3Rpb24gZ2EoYSl7dmFyIGI9NCxjPVwiblwiLGQ9bnVsbDthJiYoKGQ9YS5tYXRjaCgvKG5vcm1hbHxvYmxpcXVlfGl0YWxpYykvaSkpJiZkWzFdJiYoYz1kWzFdLnN1YnN0cigwLDEpLnRvTG93ZXJDYXNlKCkpLChkPWEubWF0Y2goLyhbMS05XTAwfG5vcm1hbHxib2xkKS9pKSkmJmRbMV0mJigvYm9sZC9pLnRlc3QoZFsxXSk/Yj03Oi9bMS05XTAwLy50ZXN0KGRbMV0pJiYoYj1wYXJzZUludChkWzFdLnN1YnN0cigwLDEpLDEwKSkpKTtyZXR1cm4gYytifTtmdW5jdGlvbiBoYShhLGIpe3RoaXMuYz1hO3RoaXMuZj1hLm8uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3RoaXMuaD1iO3RoaXMuYT1uZXcgRihcIi1cIik7dGhpcy5qPSExIT09Yi5ldmVudHM7dGhpcy5nPSExIT09Yi5jbGFzc2VzfWZ1bmN0aW9uIGlhKGEpe2EuZyYmdyhhLmYsW2EuYS5jKFwid2ZcIixcImxvYWRpbmdcIildKTtLKGEsXCJsb2FkaW5nXCIpfWZ1bmN0aW9uIEwoYSl7aWYoYS5nKXt2YXIgYj15KGEuZixhLmEuYyhcIndmXCIsXCJhY3RpdmVcIikpLGM9W10sZD1bYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKV07Ynx8Yy5wdXNoKGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpKTt3KGEuZixjLGQpfUsoYSxcImluYWN0aXZlXCIpfWZ1bmN0aW9uIEsoYSxiLGMpe2lmKGEuaiYmYS5oW2JdKWlmKGMpYS5oW2JdKGMuYyxKKGMpKTtlbHNlIGEuaFtiXSgpfTtmdW5jdGlvbiBqYSgpe3RoaXMuYz17fX1mdW5jdGlvbiBrYShhLGIsYyl7dmFyIGQ9W10sZTtmb3IoZSBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBmPWEuY1tlXTtmJiZkLnB1c2goZihiW2VdLGMpKX1yZXR1cm4gZH07ZnVuY3Rpb24gTShhLGIpe3RoaXMuYz1hO3RoaXMuZj1iO3RoaXMuYT10KHRoaXMuYyxcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSx0aGlzLmYpfWZ1bmN0aW9uIE4oYSl7dShhLmMsXCJib2R5XCIsYS5hKX1mdW5jdGlvbiBPKGEpe3JldHVyblwiZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTk5OTlweDtsZWZ0Oi05OTk5cHg7Zm9udC1zaXplOjMwMHB4O3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bGluZS1oZWlnaHQ6bm9ybWFsO21hcmdpbjowO3BhZGRpbmc6MDtmb250LXZhcmlhbnQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpcIitJKGEuYykrXCI7XCIrKFwiZm9udC1zdHlsZTpcIitIKGEpK1wiO2ZvbnQtd2VpZ2h0OlwiKyhhLmYrXCIwMFwiKStcIjtcIil9O2Z1bmN0aW9uIFAoYSxiLGMsZCxlLGYpe3RoaXMuZz1hO3RoaXMuaj1iO3RoaXMuYT1kO3RoaXMuYz1jO3RoaXMuZj1lfHwzRTM7dGhpcy5oPWZ8fHZvaWQgMH1QLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYy5vLmRvY3VtZW50LGI9dGhpcyxjPXEoKSxkPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gZigpe3EoKS1jPj1iLmY/ZSgpOmEuZm9udHMubG9hZChmYShiLmEpLGIuaCkudGhlbihmdW5jdGlvbihhKXsxPD1hLmxlbmd0aD9kKCk6c2V0VGltZW91dChmLDI1KX0sZnVuY3Rpb24oKXtlKCl9KX1mKCl9KSxlPW51bGwsZj1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGQpe2U9c2V0VGltZW91dChkLGIuZil9KTtQcm9taXNlLnJhY2UoW2YsZF0pLnRoZW4oZnVuY3Rpb24oKXtlJiYoY2xlYXJUaW1lb3V0KGUpLGU9bnVsbCk7Yi5nKGIuYSl9LGZ1bmN0aW9uKCl7Yi5qKGIuYSl9KX07ZnVuY3Rpb24gUShhLGIsYyxkLGUsZixnKXt0aGlzLnY9YTt0aGlzLkI9Yjt0aGlzLmM9Yzt0aGlzLmE9ZDt0aGlzLnM9Z3x8XCJCRVNic3d5XCI7dGhpcy5mPXt9O3RoaXMudz1lfHwzRTM7dGhpcy51PWZ8fG51bGw7dGhpcy5tPXRoaXMuaj10aGlzLmg9dGhpcy5nPW51bGw7dGhpcy5nPW5ldyBNKHRoaXMuYyx0aGlzLnMpO3RoaXMuaD1uZXcgTSh0aGlzLmMsdGhpcy5zKTt0aGlzLmo9bmV3IE0odGhpcy5jLHRoaXMucyk7dGhpcy5tPW5ldyBNKHRoaXMuYyx0aGlzLnMpO2E9bmV3IEcodGhpcy5hLmMrXCIsc2VyaWZcIixKKHRoaXMuYSkpO2E9TyhhKTt0aGlzLmcuYS5zdHlsZS5jc3NUZXh0PWE7YT1uZXcgRyh0aGlzLmEuYytcIixzYW5zLXNlcmlmXCIsSih0aGlzLmEpKTthPU8oYSk7dGhpcy5oLmEuc3R5bGUuY3NzVGV4dD1hO2E9bmV3IEcoXCJzZXJpZlwiLEoodGhpcy5hKSk7YT1PKGEpO3RoaXMuai5hLnN0eWxlLmNzc1RleHQ9YTthPW5ldyBHKFwic2Fucy1zZXJpZlwiLEoodGhpcy5hKSk7YT1cclxuTyhhKTt0aGlzLm0uYS5zdHlsZS5jc3NUZXh0PWE7Tih0aGlzLmcpO04odGhpcy5oKTtOKHRoaXMuaik7Tih0aGlzLm0pfXZhciBSPXtEOlwic2VyaWZcIixDOlwic2Fucy1zZXJpZlwifSxTPW51bGw7ZnVuY3Rpb24gVCgpe2lmKG51bGw9PT1TKXt2YXIgYT0vQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7Uz0hIWEmJig1MzY+cGFyc2VJbnQoYVsxXSwxMCl8fDUzNj09PXBhcnNlSW50KGFbMV0sMTApJiYxMT49cGFyc2VJbnQoYVsyXSwxMCkpfXJldHVybiBTfVEucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5mLnNlcmlmPXRoaXMuai5hLm9mZnNldFdpZHRoO3RoaXMuZltcInNhbnMtc2VyaWZcIl09dGhpcy5tLmEub2Zmc2V0V2lkdGg7dGhpcy5BPXEoKTtVKHRoaXMpfTtcclxuZnVuY3Rpb24gbGEoYSxiLGMpe2Zvcih2YXIgZCBpbiBSKWlmKFIuaGFzT3duUHJvcGVydHkoZCkmJmI9PT1hLmZbUltkXV0mJmM9PT1hLmZbUltkXV0pcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gVShhKXt2YXIgYj1hLmcuYS5vZmZzZXRXaWR0aCxjPWEuaC5hLm9mZnNldFdpZHRoLGQ7KGQ9Yj09PWEuZi5zZXJpZiYmYz09PWEuZltcInNhbnMtc2VyaWZcIl0pfHwoZD1UKCkmJmxhKGEsYixjKSk7ZD9xKCktYS5BPj1hLnc/VCgpJiZsYShhLGIsYykmJihudWxsPT09YS51fHxhLnUuaGFzT3duUHJvcGVydHkoYS5hLmMpKT9WKGEsYS52KTpWKGEsYS5CKTptYShhKTpWKGEsYS52KX1mdW5jdGlvbiBtYShhKXtzZXRUaW1lb3V0KHAoZnVuY3Rpb24oKXtVKHRoaXMpfSxhKSw1MCl9ZnVuY3Rpb24gVihhLGIpe3NldFRpbWVvdXQocChmdW5jdGlvbigpe3YodGhpcy5nLmEpO3YodGhpcy5oLmEpO3YodGhpcy5qLmEpO3YodGhpcy5tLmEpO2IodGhpcy5hKX0sYSksMCl9O2Z1bmN0aW9uIFcoYSxiLGMpe3RoaXMuYz1hO3RoaXMuYT1iO3RoaXMuZj0wO3RoaXMubT10aGlzLmo9ITE7dGhpcy5zPWN9dmFyIFg9bnVsbDtXLnByb3RvdHlwZS5nPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYTtiLmcmJncoYi5mLFtiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImFjdGl2ZVwiKV0sW2IuYS5jKFwid2ZcIixhLmMsSihhKS50b1N0cmluZygpLFwibG9hZGluZ1wiKSxiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImluYWN0aXZlXCIpXSk7SyhiLFwiZm9udGFjdGl2ZVwiLGEpO3RoaXMubT0hMDtuYSh0aGlzKX07XHJcblcucHJvdG90eXBlLmg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO2lmKGIuZyl7dmFyIGM9eShiLmYsYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJhY3RpdmVcIikpLGQ9W10sZT1bYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpXTtjfHxkLnB1c2goYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJpbmFjdGl2ZVwiKSk7dyhiLmYsZCxlKX1LKGIsXCJmb250aW5hY3RpdmVcIixhKTtuYSh0aGlzKX07ZnVuY3Rpb24gbmEoYSl7MD09LS1hLmYmJmEuaiYmKGEubT8oYT1hLmEsYS5nJiZ3KGEuZixbYS5hLmMoXCJ3ZlwiLFwiYWN0aXZlXCIpXSxbYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKSxhLmEuYyhcIndmXCIsXCJpbmFjdGl2ZVwiKV0pLEsoYSxcImFjdGl2ZVwiKSk6TChhLmEpKX07ZnVuY3Rpb24gb2EoYSl7dGhpcy5qPWE7dGhpcy5hPW5ldyBqYTt0aGlzLmg9MDt0aGlzLmY9dGhpcy5nPSEwfW9hLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3RoaXMuYz1uZXcgY2EodGhpcy5qLGEuY29udGV4dHx8dGhpcy5qKTt0aGlzLmc9ITEhPT1hLmV2ZW50czt0aGlzLmY9ITEhPT1hLmNsYXNzZXM7cGEodGhpcyxuZXcgaGEodGhpcy5jLGEpLGEpfTtcclxuZnVuY3Rpb24gcWEoYSxiLGMsZCxlKXt2YXIgZj0wPT0tLWEuaDsoYS5mfHxhLmcpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGE9ZXx8bnVsbCxtPWR8fG51bGx8fHt9O2lmKDA9PT1jLmxlbmd0aCYmZilMKGIuYSk7ZWxzZXtiLmYrPWMubGVuZ3RoO2YmJihiLmo9Zik7dmFyIGgsbD1bXTtmb3IoaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgaz1jW2hdLG49bVtrLmNdLHI9Yi5hLHg9aztyLmcmJncoci5mLFtyLmEuYyhcIndmXCIseC5jLEooeCkudG9TdHJpbmcoKSxcImxvYWRpbmdcIildKTtLKHIsXCJmb250bG9hZGluZ1wiLHgpO3I9bnVsbDtpZihudWxsPT09WClpZih3aW5kb3cuRm9udEZhY2Upe3ZhciB4PS9HZWNrby4qRmlyZWZveFxcLyhcXGQrKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkseGE9L09TIFguKlZlcnNpb25cXC8xMFxcLi4qU2FmYXJpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSYmL0FwcGxlLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudmVuZG9yKTtcclxuWD14PzQyPHBhcnNlSW50KHhbMV0sMTApOnhhPyExOiEwfWVsc2UgWD0hMTtYP3I9bmV3IFAocChiLmcsYikscChiLmgsYiksYi5jLGssYi5zLG4pOnI9bmV3IFEocChiLmcsYikscChiLmgsYiksYi5jLGssYi5zLGEsbik7bC5wdXNoKHIpfWZvcihoPTA7aDxsLmxlbmd0aDtoKyspbFtoXS5zdGFydCgpfX0sMCl9ZnVuY3Rpb24gcGEoYSxiLGMpe3ZhciBkPVtdLGU9Yy50aW1lb3V0O2lhKGIpO3ZhciBkPWthKGEuYSxjLGEuYyksZj1uZXcgVyhhLmMsYixlKTthLmg9ZC5sZW5ndGg7Yj0wO2ZvcihjPWQubGVuZ3RoO2I8YztiKyspZFtiXS5sb2FkKGZ1bmN0aW9uKGIsZCxjKXtxYShhLGYsYixkLGMpfSl9O2Z1bmN0aW9uIHJhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9XHJcbnJhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtpZihmW1wiX19tdGlfZm50THN0XCIrZF0pe3ZhciBjPWZbXCJfX210aV9mbnRMc3RcIitkXSgpLGU9W10saDtpZihjKWZvcih2YXIgbD0wO2w8Yy5sZW5ndGg7bCsrKXt2YXIgaz1jW2xdLmZvbnRmYW1pbHk7dm9pZCAwIT1jW2xdLmZvbnRTdHlsZSYmdm9pZCAwIT1jW2xdLmZvbnRXZWlnaHQ/KGg9Y1tsXS5mb250U3R5bGUrY1tsXS5mb250V2VpZ2h0LGUucHVzaChuZXcgRyhrLGgpKSk6ZS5wdXNoKG5ldyBHKGspKX1hKGUpfWVsc2Ugc2V0VGltZW91dChmdW5jdGlvbigpe2IoKX0sNTApfXZhciBjPXRoaXMsZD1jLmEucHJvamVjdElkLGU9Yy5hLnZlcnNpb247aWYoZCl7dmFyIGY9Yy5jLm87QSh0aGlzLmMsKGMuYS5hcGl8fFwiaHR0cHM6Ly9mYXN0LmZvbnRzLm5ldC9qc2FwaVwiKStcIi9cIitkK1wiLmpzXCIrKGU/XCI/dj1cIitlOlwiXCIpLGZ1bmN0aW9uKGUpe2U/YShbXSk6KGZbXCJfX01vbm90eXBlQ29uZmlndXJhdGlvbl9fXCIrXHJcbmRdPWZ1bmN0aW9uKCl7cmV0dXJuIGMuYX0sYigpKX0pLmlkPVwiX19Nb25vdHlwZUFQSVNjcmlwdF9fXCIrZH1lbHNlIGEoW10pfTtmdW5jdGlvbiBzYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifXNhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD10aGlzLmEudXJsc3x8W10sZT10aGlzLmEuZmFtaWxpZXN8fFtdLGY9dGhpcy5hLnRlc3RTdHJpbmdzfHx7fSxnPW5ldyBCO2I9MDtmb3IoYz1kLmxlbmd0aDtiPGM7YisrKXoodGhpcy5jLGRbYl0sQyhnKSk7dmFyIG09W107Yj0wO2ZvcihjPWUubGVuZ3RoO2I8YztiKyspaWYoZD1lW2JdLnNwbGl0KFwiOlwiKSxkWzFdKWZvcih2YXIgaD1kWzFdLnNwbGl0KFwiLFwiKSxsPTA7bDxoLmxlbmd0aDtsKz0xKW0ucHVzaChuZXcgRyhkWzBdLGhbbF0pKTtlbHNlIG0ucHVzaChuZXcgRyhkWzBdKSk7RShnLGZ1bmN0aW9uKCl7YShtLGYpfSl9O2Z1bmN0aW9uIHRhKGEsYil7YT90aGlzLmM9YTp0aGlzLmM9dWE7dGhpcy5hPVtdO3RoaXMuZj1bXTt0aGlzLmc9Ynx8XCJcIn12YXIgdWE9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzc1wiO2Z1bmN0aW9uIHZhKGEsYil7Zm9yKHZhciBjPWIubGVuZ3RoLGQ9MDtkPGM7ZCsrKXt2YXIgZT1iW2RdLnNwbGl0KFwiOlwiKTszPT1lLmxlbmd0aCYmYS5mLnB1c2goZS5wb3AoKSk7dmFyIGY9XCJcIjsyPT1lLmxlbmd0aCYmXCJcIiE9ZVsxXSYmKGY9XCI6XCIpO2EuYS5wdXNoKGUuam9pbihmKSl9fVxyXG5mdW5jdGlvbiB3YShhKXtpZigwPT1hLmEubGVuZ3RoKXRocm93IEVycm9yKFwiTm8gZm9udHMgdG8gbG9hZCFcIik7aWYoLTEhPWEuYy5pbmRleE9mKFwia2l0PVwiKSlyZXR1cm4gYS5jO2Zvcih2YXIgYj1hLmEubGVuZ3RoLGM9W10sZD0wO2Q8YjtkKyspYy5wdXNoKGEuYVtkXS5yZXBsYWNlKC8gL2csXCIrXCIpKTtiPWEuYytcIj9mYW1pbHk9XCIrYy5qb2luKFwiJTdDXCIpOzA8YS5mLmxlbmd0aCYmKGIrPVwiJnN1YnNldD1cIithLmYuam9pbihcIixcIikpOzA8YS5nLmxlbmd0aCYmKGIrPVwiJnRleHQ9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZykpO3JldHVybiBifTtmdW5jdGlvbiB5YShhKXt0aGlzLmY9YTt0aGlzLmE9W107dGhpcy5jPXt9fVxyXG52YXIgemE9e2xhdGluOlwiQkVTYnN3eVwiLFwibGF0aW4tZXh0XCI6XCJcXHUwMGU3XFx1MDBmNlxcdTAwZmNcXHUwMTFmXFx1MDE1ZlwiLGN5cmlsbGljOlwiXFx1MDQzOVxcdTA0NGZcXHUwNDE2XCIsZ3JlZWs6XCJcXHUwM2IxXFx1MDNiMlxcdTAzYTNcIixraG1lcjpcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwiLEhhbnVtYW46XCJcXHUxNzgwXFx1MTc4MVxcdTE3ODJcIn0sQWE9e3RoaW46XCIxXCIsZXh0cmFsaWdodDpcIjJcIixcImV4dHJhLWxpZ2h0XCI6XCIyXCIsdWx0cmFsaWdodDpcIjJcIixcInVsdHJhLWxpZ2h0XCI6XCIyXCIsbGlnaHQ6XCIzXCIscmVndWxhcjpcIjRcIixib29rOlwiNFwiLG1lZGl1bTpcIjVcIixcInNlbWktYm9sZFwiOlwiNlwiLHNlbWlib2xkOlwiNlwiLFwiZGVtaS1ib2xkXCI6XCI2XCIsZGVtaWJvbGQ6XCI2XCIsYm9sZDpcIjdcIixcImV4dHJhLWJvbGRcIjpcIjhcIixleHRyYWJvbGQ6XCI4XCIsXCJ1bHRyYS1ib2xkXCI6XCI4XCIsdWx0cmFib2xkOlwiOFwiLGJsYWNrOlwiOVwiLGhlYXZ5OlwiOVwiLGw6XCIzXCIscjpcIjRcIixiOlwiN1wifSxCYT17aTpcImlcIixpdGFsaWM6XCJpXCIsbjpcIm5cIixub3JtYWw6XCJuXCJ9LFxyXG5DYT0vXih0aGlufCg/Oig/OmV4dHJhfHVsdHJhKS0/KT9saWdodHxyZWd1bGFyfGJvb2t8bWVkaXVtfCg/Oig/OnNlbWl8ZGVtaXxleHRyYXx1bHRyYSktPyk/Ym9sZHxibGFja3xoZWF2eXxsfHJ8YnxbMS05XTAwKT8obnxpfG5vcm1hbHxpdGFsaWMpPyQvO1xyXG5mdW5jdGlvbiBEYShhKXtmb3IodmFyIGI9YS5mLmxlbmd0aCxjPTA7YzxiO2MrKyl7dmFyIGQ9YS5mW2NdLnNwbGl0KFwiOlwiKSxlPWRbMF0ucmVwbGFjZSgvXFwrL2csXCIgXCIpLGY9W1wibjRcIl07aWYoMjw9ZC5sZW5ndGgpe3ZhciBnO3ZhciBtPWRbMV07Zz1bXTtpZihtKWZvcih2YXIgbT1tLnNwbGl0KFwiLFwiKSxoPW0ubGVuZ3RoLGw9MDtsPGg7bCsrKXt2YXIgaztrPW1bbF07aWYoay5tYXRjaCgvXltcXHctXSskLykpe3ZhciBuPUNhLmV4ZWMoay50b0xvd2VyQ2FzZSgpKTtpZihudWxsPT1uKWs9XCJcIjtlbHNle2s9blsyXTtrPW51bGw9PWt8fFwiXCI9PWs/XCJuXCI6QmFba107bj1uWzFdO2lmKG51bGw9PW58fFwiXCI9PW4pbj1cIjRcIjtlbHNlIHZhciByPUFhW25dLG49cj9yOmlzTmFOKG4pP1wiNFwiOm4uc3Vic3RyKDAsMSk7az1bayxuXS5qb2luKFwiXCIpfX1lbHNlIGs9XCJcIjtrJiZnLnB1c2goayl9MDxnLmxlbmd0aCYmKGY9Zyk7Mz09ZC5sZW5ndGgmJihkPWRbMl0sZz1bXSxkPWQ/ZC5zcGxpdChcIixcIik6XHJcbmcsMDxkLmxlbmd0aCYmKGQ9emFbZFswXV0pJiYoYS5jW2VdPWQpKX1hLmNbZV18fChkPXphW2VdKSYmKGEuY1tlXT1kKTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCs9MSlhLmEucHVzaChuZXcgRyhlLGZbZF0pKX19O2Z1bmN0aW9uIEVhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9dmFyIEZhPXtBcmltbzohMCxDb3VzaW5lOiEwLFRpbm9zOiEwfTtFYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgQixjPXRoaXMuYyxkPW5ldyB0YSh0aGlzLmEuYXBpLHRoaXMuYS50ZXh0KSxlPXRoaXMuYS5mYW1pbGllczt2YShkLGUpO3ZhciBmPW5ldyB5YShlKTtEYShmKTt6KGMsd2EoZCksQyhiKSk7RShiLGZ1bmN0aW9uKCl7YShmLmEsZi5jLEZhKX0pfTtmdW5jdGlvbiBHYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifUdhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5pZCxjPXRoaXMuYy5vO2I/QSh0aGlzLmMsKHRoaXMuYS5hcGl8fFwiaHR0cHM6Ly91c2UudHlwZWtpdC5uZXRcIikrXCIvXCIrYitcIi5qc1wiLGZ1bmN0aW9uKGIpe2lmKGIpYShbXSk7ZWxzZSBpZihjLlR5cGVraXQmJmMuVHlwZWtpdC5jb25maWcmJmMuVHlwZWtpdC5jb25maWcuZm4pe2I9Yy5UeXBla2l0LmNvbmZpZy5mbjtmb3IodmFyIGU9W10sZj0wO2Y8Yi5sZW5ndGg7Zis9Milmb3IodmFyIGc9YltmXSxtPWJbZisxXSxoPTA7aDxtLmxlbmd0aDtoKyspZS5wdXNoKG5ldyBHKGcsbVtoXSkpO3RyeXtjLlR5cGVraXQubG9hZCh7ZXZlbnRzOiExLGNsYXNzZXM6ITEsYXN5bmM6ITB9KX1jYXRjaChsKXt9YShlKX19LDJFMyk6YShbXSl9O2Z1bmN0aW9uIEhhKGEsYil7dGhpcy5jPWE7dGhpcy5mPWI7dGhpcy5hPVtdfUhhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZi5pZCxjPXRoaXMuYy5vLGQ9dGhpcztiPyhjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX198fChjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX189e30pLGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfX1tiXT1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZz0wLG09Yy5mb250cy5sZW5ndGg7ZzxtOysrZyl7dmFyIGg9Yy5mb250c1tnXTtkLmEucHVzaChuZXcgRyhoLm5hbWUsZ2EoXCJmb250LXdlaWdodDpcIitoLndlaWdodCtcIjtmb250LXN0eWxlOlwiK2guc3R5bGUpKSl9YShkLmEpfSxBKHRoaXMuYywodGhpcy5mLmFwaXx8XCJodHRwczovL2YuZm9udGRlY2suY29tL3MvY3NzL2pzL1wiKStlYSh0aGlzLmMpK1wiL1wiK2IrXCIuanNcIixmdW5jdGlvbihiKXtiJiZhKFtdKX0pKTphKFtdKX07dmFyIFk9bmV3IG9hKHdpbmRvdyk7WS5hLmMuY3VzdG9tPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBzYShiLGEpfTtZLmEuYy5mb250ZGVjaz1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSGEoYixhKX07WS5hLmMubW9ub3R5cGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHJhKGIsYSl9O1kuYS5jLnR5cGVraXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEdhKGIsYSl9O1kuYS5jLmdvb2dsZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgRWEoYixhKX07dmFyIFo9e2xvYWQ6cChZLmxvYWQsWSl9O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIFp9KTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9Wjood2luZG93LldlYkZvbnQ9Wix3aW5kb3cuV2ViRm9udENvbmZpZyYmWS5sb2FkKHdpbmRvdy5XZWJGb250Q29uZmlnKSk7fSgpKTtcclxuIiwiLyohIGpRdWVyeSB2My40LjEgfCAoYykgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXHJcbiFmdW5jdGlvbiAoZSwgdCkgeyBcInVzZSBzdHJpY3RcIjsgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBlLmRvY3VtZW50ID8gdChlLCAhMCkgOiBmdW5jdGlvbiAoZSkgeyBpZiAoIWUuZG9jdW1lbnQpIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7IHJldHVybiB0KGUpIH0gOiB0KGUpIH0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKEMsIGUpIHsgXCJ1c2Ugc3RyaWN0XCI7IHZhciB0ID0gW10sIEUgPSBDLmRvY3VtZW50LCByID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBzID0gdC5zbGljZSwgZyA9IHQuY29uY2F0LCB1ID0gdC5wdXNoLCBpID0gdC5pbmRleE9mLCBuID0ge30sIG8gPSBuLnRvU3RyaW5nLCB2ID0gbi5oYXNPd25Qcm9wZXJ0eSwgYSA9IHYudG9TdHJpbmcsIGwgPSBhLmNhbGwoT2JqZWN0KSwgeSA9IHt9LCBtID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBcIm51bWJlclwiICE9IHR5cGVvZiBlLm5vZGVUeXBlIH0sIHggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gbnVsbCAhPSBlICYmIGUgPT09IGUud2luZG93IH0sIGMgPSB7IHR5cGU6ICEwLCBzcmM6ICEwLCBub25jZTogITAsIG5vTW9kdWxlOiAhMCB9OyBmdW5jdGlvbiBiKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8gPSAobiA9IG4gfHwgRSkuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTsgaWYgKG8udGV4dCA9IGUsIHQpIGZvciAociBpbiBjKSAoaSA9IHRbcl0gfHwgdC5nZXRBdHRyaWJ1dGUgJiYgdC5nZXRBdHRyaWJ1dGUocikpICYmIG8uc2V0QXR0cmlidXRlKHIsIGkpOyBuLmhlYWQuYXBwZW5kQ2hpbGQobykucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvKSB9IGZ1bmN0aW9uIHcoZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gZSArIFwiXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IG5bby5jYWxsKGUpXSB8fCBcIm9iamVjdFwiIDogdHlwZW9mIGUgfSB2YXIgZiA9IFwiMy40LjFcIiwgayA9IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBuZXcgay5mbi5pbml0KGUsIHQpIH0sIHAgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7IGZ1bmN0aW9uIGQoZSkgeyB2YXIgdCA9ICEhZSAmJiBcImxlbmd0aFwiIGluIGUgJiYgZS5sZW5ndGgsIG4gPSB3KGUpOyByZXR1cm4gIW0oZSkgJiYgIXgoZSkgJiYgKFwiYXJyYXlcIiA9PT0gbiB8fCAwID09PSB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgMCA8IHQgJiYgdCAtIDEgaW4gZSkgfSBrLmZuID0gay5wcm90b3R5cGUgPSB7IGpxdWVyeTogZiwgY29uc3RydWN0b3I6IGssIGxlbmd0aDogMCwgdG9BcnJheTogZnVuY3Rpb24gKCkgeyByZXR1cm4gcy5jYWxsKHRoaXMpIH0sIGdldDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG51bGwgPT0gZSA/IHMuY2FsbCh0aGlzKSA6IGUgPCAwID8gdGhpc1tlICsgdGhpcy5sZW5ndGhdIDogdGhpc1tlXSB9LCBwdXNoU3RhY2s6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gay5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGUpOyByZXR1cm4gdC5wcmV2T2JqZWN0ID0gdGhpcywgdCB9LCBlYWNoOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gay5lYWNoKHRoaXMsIGUpIH0sIG1hcDogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGsubWFwKHRoaXMsIGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBuLmNhbGwoZSwgdCwgZSkgfSkpIH0sIHNsaWNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIH0sIGZpcnN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVxKDApIH0sIGxhc3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZXEoLTEpIH0sIGVxOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IHRoaXMubGVuZ3RoLCBuID0gK2UgKyAoZSA8IDAgPyB0IDogMCk7IHJldHVybiB0aGlzLnB1c2hTdGFjaygwIDw9IG4gJiYgbiA8IHQgPyBbdGhpc1tuXV0gOiBbXSkgfSwgZW5kOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpIH0sIHB1c2g6IHUsIHNvcnQ6IHQuc29ydCwgc3BsaWNlOiB0LnNwbGljZSB9LCBrLmV4dGVuZCA9IGsuZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkgeyB2YXIgZSwgdCwgbiwgciwgaSwgbywgYSA9IGFyZ3VtZW50c1swXSB8fCB7fSwgcyA9IDEsIHUgPSBhcmd1bWVudHMubGVuZ3RoLCBsID0gITE7IGZvciAoXCJib29sZWFuXCIgPT0gdHlwZW9mIGEgJiYgKGwgPSBhLCBhID0gYXJndW1lbnRzW3NdIHx8IHt9LCBzKyspLCBcIm9iamVjdFwiID09IHR5cGVvZiBhIHx8IG0oYSkgfHwgKGEgPSB7fSksIHMgPT09IHUgJiYgKGEgPSB0aGlzLCBzLS0pOyBzIDwgdTsgcysrKWlmIChudWxsICE9IChlID0gYXJndW1lbnRzW3NdKSkgZm9yICh0IGluIGUpIHIgPSBlW3RdLCBcIl9fcHJvdG9fX1wiICE9PSB0ICYmIGEgIT09IHIgJiYgKGwgJiYgciAmJiAoay5pc1BsYWluT2JqZWN0KHIpIHx8IChpID0gQXJyYXkuaXNBcnJheShyKSkpID8gKG4gPSBhW3RdLCBvID0gaSAmJiAhQXJyYXkuaXNBcnJheShuKSA/IFtdIDogaSB8fCBrLmlzUGxhaW5PYmplY3QobikgPyBuIDoge30sIGkgPSAhMSwgYVt0XSA9IGsuZXh0ZW5kKGwsIG8sIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAoYVt0XSA9IHIpKTsgcmV0dXJuIGEgfSwgay5leHRlbmQoeyBleHBhbmRvOiBcImpRdWVyeVwiICsgKGYgKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywgXCJcIiksIGlzUmVhZHk6ICEwLCBlcnJvcjogZnVuY3Rpb24gKGUpIHsgdGhyb3cgbmV3IEVycm9yKGUpIH0sIG5vb3A6IGZ1bmN0aW9uICgpIHsgfSwgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKGUpIHsgdmFyIHQsIG47IHJldHVybiAhKCFlIHx8IFwiW29iamVjdCBPYmplY3RdXCIgIT09IG8uY2FsbChlKSkgJiYgKCEodCA9IHIoZSkpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG4gPSB2LmNhbGwodCwgXCJjb25zdHJ1Y3RvclwiKSAmJiB0LmNvbnN0cnVjdG9yKSAmJiBhLmNhbGwobikgPT09IGwpIH0sIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uIChlKSB7IHZhciB0OyBmb3IgKHQgaW4gZSkgcmV0dXJuICExOyByZXR1cm4gITAgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24gKGUsIHQpIHsgYihlLCB7IG5vbmNlOiB0ICYmIHQubm9uY2UgfSkgfSwgZWFjaDogZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4sIHIgPSAwOyBpZiAoZChlKSkgeyBmb3IgKG4gPSBlLmxlbmd0aDsgciA8IG47IHIrKylpZiAoITEgPT09IHQuY2FsbChlW3JdLCByLCBlW3JdKSkgYnJlYWsgfSBlbHNlIGZvciAociBpbiBlKSBpZiAoITEgPT09IHQuY2FsbChlW3JdLCByLCBlW3JdKSkgYnJlYWs7IHJldHVybiBlIH0sIHRyaW06IGZ1bmN0aW9uIChlKSB7IHJldHVybiBudWxsID09IGUgPyBcIlwiIDogKGUgKyBcIlwiKS5yZXBsYWNlKHAsIFwiXCIpIH0sIG1ha2VBcnJheTogZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSB0IHx8IFtdOyByZXR1cm4gbnVsbCAhPSBlICYmIChkKE9iamVjdChlKSkgPyBrLm1lcmdlKG4sIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBbZV0gOiBlKSA6IHUuY2FsbChuLCBlKSksIG4gfSwgaW5BcnJheTogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIG51bGwgPT0gdCA/IC0xIDogaS5jYWxsKHQsIGUsIG4pIH0sIG1lcmdlOiBmdW5jdGlvbiAoZSwgdCkgeyBmb3IgKHZhciBuID0gK3QubGVuZ3RoLCByID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgbjsgcisrKWVbaSsrXSA9IHRbcl07IHJldHVybiBlLmxlbmd0aCA9IGksIGUgfSwgZ3JlcDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IFtdLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBhID0gIW47IGkgPCBvOyBpKyspIXQoZVtpXSwgaSkgIT09IGEgJiYgci5wdXNoKGVbaV0pOyByZXR1cm4gciB9LCBtYXA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gMCwgYSA9IFtdOyBpZiAoZChlKSkgZm9yIChyID0gZS5sZW5ndGg7IG8gPCByOyBvKyspbnVsbCAhPSAoaSA9IHQoZVtvXSwgbywgbikpICYmIGEucHVzaChpKTsgZWxzZSBmb3IgKG8gaW4gZSkgbnVsbCAhPSAoaSA9IHQoZVtvXSwgbywgbikpICYmIGEucHVzaChpKTsgcmV0dXJuIGcuYXBwbHkoW10sIGEpIH0sIGd1aWQ6IDEsIHN1cHBvcnQ6IHkgfSksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIChrLmZuW1N5bWJvbC5pdGVyYXRvcl0gPSB0W1N5bWJvbC5pdGVyYXRvcl0pLCBrLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGUsIHQpIHsgbltcIltvYmplY3QgXCIgKyB0ICsgXCJdXCJdID0gdC50b0xvd2VyQ2FzZSgpIH0pOyB2YXIgaCA9IGZ1bmN0aW9uIChuKSB7IHZhciBlLCBkLCBiLCBvLCBpLCBoLCBmLCBnLCB3LCB1LCBsLCBULCBDLCBhLCBFLCB2LCBzLCBjLCB5LCBrID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSwgbSA9IG4uZG9jdW1lbnQsIFMgPSAwLCByID0gMCwgcCA9IHVlKCksIHggPSB1ZSgpLCBOID0gdWUoKSwgQSA9IHVlKCksIEQgPSBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gZSA9PT0gdCAmJiAobCA9ICEwKSwgMCB9LCBqID0ge30uaGFzT3duUHJvcGVydHksIHQgPSBbXSwgcSA9IHQucG9wLCBMID0gdC5wdXNoLCBIID0gdC5wdXNoLCBPID0gdC5zbGljZSwgUCA9IGZ1bmN0aW9uIChlLCB0KSB7IGZvciAodmFyIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspaWYgKGVbbl0gPT09IHQpIHJldHVybiBuOyByZXR1cm4gLTEgfSwgUiA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIiwgTSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIiwgSSA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIiwgVyA9IFwiXFxcXFtcIiArIE0gKyBcIiooXCIgKyBJICsgXCIpKD86XCIgKyBNICsgXCIqKFsqXiR8IX5dPz0pXCIgKyBNICsgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIEkgKyBcIikpfClcIiArIE0gKyBcIipcXFxcXVwiLCAkID0gXCI6KFwiICsgSSArIFwiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIFcgKyBcIikqKXwuKilcXFxcKXwpXCIsIEYgPSBuZXcgUmVnRXhwKE0gKyBcIitcIiwgXCJnXCIpLCBCID0gbmV3IFJlZ0V4cChcIl5cIiArIE0gKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyBNICsgXCIrJFwiLCBcImdcIiksIF8gPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKixcIiArIE0gKyBcIipcIiksIHogPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKihbPit+XXxcIiArIE0gKyBcIilcIiArIE0gKyBcIipcIiksIFUgPSBuZXcgUmVnRXhwKE0gKyBcInw+XCIpLCBYID0gbmV3IFJlZ0V4cCgkKSwgViA9IG5ldyBSZWdFeHAoXCJeXCIgKyBJICsgXCIkXCIpLCBHID0geyBJRDogbmV3IFJlZ0V4cChcIl4jKFwiICsgSSArIFwiKVwiKSwgQ0xBU1M6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBJICsgXCIpXCIpLCBUQUc6IG5ldyBSZWdFeHAoXCJeKFwiICsgSSArIFwifFsqXSlcIiksIEFUVFI6IG5ldyBSZWdFeHAoXCJeXCIgKyBXKSwgUFNFVURPOiBuZXcgUmVnRXhwKFwiXlwiICsgJCksIENISUxEOiBuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIE0gKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgTSArIFwiKig/OihbKy1dfClcIiArIE0gKyBcIiooXFxcXGQrKXwpKVwiICsgTSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLCBib29sOiBuZXcgUmVnRXhwKFwiXig/OlwiICsgUiArIFwiKSRcIiwgXCJpXCIpLCBuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgTSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIE0gKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIikgfSwgWSA9IC9IVE1MJC9pLCBRID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSwgSiA9IC9eaFxcZCQvaSwgSyA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLywgZWUgPSAvWyt+XS8sIHRlID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgTSArIFwiP3woXCIgKyBNICsgXCIpfC4pXCIsIFwiaWdcIiksIG5lID0gZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIgPSBcIjB4XCIgKyB0IC0gNjU1MzY7IHJldHVybiByICE9IHIgfHwgbiA/IHQgOiByIDwgMCA/IFN0cmluZy5mcm9tQ2hhckNvZGUociArIDY1NTM2KSA6IFN0cmluZy5mcm9tQ2hhckNvZGUociA+PiAxMCB8IDU1Mjk2LCAxMDIzICYgciB8IDU2MzIwKSB9LCByZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLCBpZSA9IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiB0ID8gXCJcXDBcIiA9PT0gZSA/IFwiXFx1ZmZmZFwiIDogZS5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGUuY2hhckNvZGVBdChlLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiIDogXCJcXFxcXCIgKyBlIH0sIG9lID0gZnVuY3Rpb24gKCkgeyBUKCkgfSwgYWUgPSBiZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gITAgPT09IGUuZGlzYWJsZWQgJiYgXCJmaWVsZHNldFwiID09PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgfSwgeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH0pOyB0cnkgeyBILmFwcGx5KHQgPSBPLmNhbGwobS5jaGlsZE5vZGVzKSwgbS5jaGlsZE5vZGVzKSwgdFttLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZSB9IGNhdGNoIChlKSB7IEggPSB7IGFwcGx5OiB0Lmxlbmd0aCA/IGZ1bmN0aW9uIChlLCB0KSB7IEwuYXBwbHkoZSwgTy5jYWxsKHQpKSB9IDogZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBlLmxlbmd0aCwgciA9IDA7IHdoaWxlIChlW24rK10gPSB0W3IrK10pOyBlLmxlbmd0aCA9IG4gLSAxIH0gfSB9IGZ1bmN0aW9uIHNlKHQsIGUsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMsIHUsIGwsIGMsIGYgPSBlICYmIGUub3duZXJEb2N1bWVudCwgcCA9IGUgPyBlLm5vZGVUeXBlIDogOTsgaWYgKG4gPSBuIHx8IFtdLCBcInN0cmluZ1wiICE9IHR5cGVvZiB0IHx8ICF0IHx8IDEgIT09IHAgJiYgOSAhPT0gcCAmJiAxMSAhPT0gcCkgcmV0dXJuIG47IGlmICghciAmJiAoKGUgPyBlLm93bmVyRG9jdW1lbnQgfHwgZSA6IG0pICE9PSBDICYmIFQoZSksIGUgPSBlIHx8IEMsIEUpKSB7IGlmICgxMSAhPT0gcCAmJiAodSA9IFouZXhlYyh0KSkpIGlmIChpID0gdVsxXSkgeyBpZiAoOSA9PT0gcCkgeyBpZiAoIShhID0gZS5nZXRFbGVtZW50QnlJZChpKSkpIHJldHVybiBuOyBpZiAoYS5pZCA9PT0gaSkgcmV0dXJuIG4ucHVzaChhKSwgbiB9IGVsc2UgaWYgKGYgJiYgKGEgPSBmLmdldEVsZW1lbnRCeUlkKGkpKSAmJiB5KGUsIGEpICYmIGEuaWQgPT09IGkpIHJldHVybiBuLnB1c2goYSksIG4gfSBlbHNlIHsgaWYgKHVbMl0pIHJldHVybiBILmFwcGx5KG4sIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCkpLCBuOyBpZiAoKGkgPSB1WzNdKSAmJiBkLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSByZXR1cm4gSC5hcHBseShuLCBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSkpLCBuIH0gaWYgKGQucXNhICYmICFBW3QgKyBcIiBcIl0gJiYgKCF2IHx8ICF2LnRlc3QodCkpICYmICgxICE9PSBwIHx8IFwib2JqZWN0XCIgIT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHsgaWYgKGMgPSB0LCBmID0gZSwgMSA9PT0gcCAmJiBVLnRlc3QodCkpIHsgKHMgPSBlLmdldEF0dHJpYnV0ZShcImlkXCIpKSA/IHMgPSBzLnJlcGxhY2UocmUsIGllKSA6IGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgcyA9IGspLCBvID0gKGwgPSBoKHQpKS5sZW5ndGg7IHdoaWxlIChvLS0pIGxbb10gPSBcIiNcIiArIHMgKyBcIiBcIiArIHhlKGxbb10pOyBjID0gbC5qb2luKFwiLFwiKSwgZiA9IGVlLnRlc3QodCkgJiYgeWUoZS5wYXJlbnROb2RlKSB8fCBlIH0gdHJ5IHsgcmV0dXJuIEguYXBwbHkobiwgZi5xdWVyeVNlbGVjdG9yQWxsKGMpKSwgbiB9IGNhdGNoIChlKSB7IEEodCwgITApIH0gZmluYWxseSB7IHMgPT09IGsgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKSB9IH0gfSByZXR1cm4gZyh0LnJlcGxhY2UoQiwgXCIkMVwiKSwgZSwgbiwgcikgfSBmdW5jdGlvbiB1ZSgpIHsgdmFyIHIgPSBbXTsgcmV0dXJuIGZ1bmN0aW9uIGUodCwgbikgeyByZXR1cm4gci5wdXNoKHQgKyBcIiBcIikgPiBiLmNhY2hlTGVuZ3RoICYmIGRlbGV0ZSBlW3Iuc2hpZnQoKV0sIGVbdCArIFwiIFwiXSA9IG4gfSB9IGZ1bmN0aW9uIGxlKGUpIHsgcmV0dXJuIGVba10gPSAhMCwgZSB9IGZ1bmN0aW9uIGNlKGUpIHsgdmFyIHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTsgdHJ5IHsgcmV0dXJuICEhZSh0KSB9IGNhdGNoIChlKSB7IHJldHVybiAhMSB9IGZpbmFsbHkgeyB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLCB0ID0gbnVsbCB9IH0gZnVuY3Rpb24gZmUoZSwgdCkgeyB2YXIgbiA9IGUuc3BsaXQoXCJ8XCIpLCByID0gbi5sZW5ndGg7IHdoaWxlIChyLS0pIGIuYXR0ckhhbmRsZVtuW3JdXSA9IHQgfSBmdW5jdGlvbiBwZShlLCB0KSB7IHZhciBuID0gdCAmJiBlLCByID0gbiAmJiAxID09PSBlLm5vZGVUeXBlICYmIDEgPT09IHQubm9kZVR5cGUgJiYgZS5zb3VyY2VJbmRleCAtIHQuc291cmNlSW5kZXg7IGlmIChyKSByZXR1cm4gcjsgaWYgKG4pIHdoaWxlIChuID0gbi5uZXh0U2libGluZykgaWYgKG4gPT09IHQpIHJldHVybiAtMTsgcmV0dXJuIGUgPyAxIDogLTEgfSBmdW5jdGlvbiBkZSh0KSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gXCJpbnB1dFwiID09PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgZS50eXBlID09PSB0IH0gfSBmdW5jdGlvbiBoZShuKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsgcmV0dXJuIChcImlucHV0XCIgPT09IHQgfHwgXCJidXR0b25cIiA9PT0gdCkgJiYgZS50eXBlID09PSBuIH0gfSBmdW5jdGlvbiBnZSh0KSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gXCJmb3JtXCIgaW4gZSA/IGUucGFyZW50Tm9kZSAmJiAhMSA9PT0gZS5kaXNhYmxlZCA/IFwibGFiZWxcIiBpbiBlID8gXCJsYWJlbFwiIGluIGUucGFyZW50Tm9kZSA/IGUucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gdCA6IGUuZGlzYWJsZWQgPT09IHQgOiBlLmlzRGlzYWJsZWQgPT09IHQgfHwgZS5pc0Rpc2FibGVkICE9PSAhdCAmJiBhZShlKSA9PT0gdCA6IGUuZGlzYWJsZWQgPT09IHQgOiBcImxhYmVsXCIgaW4gZSAmJiBlLmRpc2FibGVkID09PSB0IH0gfSBmdW5jdGlvbiB2ZShhKSB7IHJldHVybiBsZShmdW5jdGlvbiAobykgeyByZXR1cm4gbyA9ICtvLCBsZShmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiwgciA9IGEoW10sIGUubGVuZ3RoLCBvKSwgaSA9IHIubGVuZ3RoOyB3aGlsZSAoaS0tKSBlW24gPSByW2ldXSAmJiAoZVtuXSA9ICEodFtuXSA9IGVbbl0pKSB9KSB9KSB9IGZ1bmN0aW9uIHllKGUpIHsgcmV0dXJuIGUgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBlIH0gZm9yIChlIGluIGQgPSBzZS5zdXBwb3J0ID0ge30sIGkgPSBzZS5pc1hNTCA9IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gZS5uYW1lc3BhY2VVUkksIG4gPSAoZS5vd25lckRvY3VtZW50IHx8IGUpLmRvY3VtZW50RWxlbWVudDsgcmV0dXJuICFZLnRlc3QodCB8fCBuICYmIG4ubm9kZU5hbWUgfHwgXCJIVE1MXCIpIH0sIFQgPSBzZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuLCByID0gZSA/IGUub3duZXJEb2N1bWVudCB8fCBlIDogbTsgcmV0dXJuIHIgIT09IEMgJiYgOSA9PT0gci5ub2RlVHlwZSAmJiByLmRvY3VtZW50RWxlbWVudCAmJiAoYSA9IChDID0gcikuZG9jdW1lbnRFbGVtZW50LCBFID0gIWkoQyksIG0gIT09IEMgJiYgKG4gPSBDLmRlZmF1bHRWaWV3KSAmJiBuLnRvcCAhPT0gbiAmJiAobi5hZGRFdmVudExpc3RlbmVyID8gbi5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIG9lLCAhMSkgOiBuLmF0dGFjaEV2ZW50ICYmIG4uYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCBvZSkpLCBkLmF0dHJpYnV0ZXMgPSBjZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5jbGFzc05hbWUgPSBcImlcIiwgIWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpIH0pLCBkLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gY2UoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoQy5jcmVhdGVDb21tZW50KFwiXCIpKSwgIWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aCB9KSwgZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gSy50ZXN0KEMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksIGQuZ2V0QnlJZCA9IGNlKGZ1bmN0aW9uIChlKSB7IHJldHVybiBhLmFwcGVuZENoaWxkKGUpLmlkID0gaywgIUMuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIUMuZ2V0RWxlbWVudHNCeU5hbWUoaykubGVuZ3RoIH0pLCBkLmdldEJ5SWQgPyAoYi5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGUucmVwbGFjZSh0ZSwgbmUpOyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IHQgfSB9LCBiLmZpbmQuSUQgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCAmJiBFKSB7IHZhciBuID0gdC5nZXRFbGVtZW50QnlJZChlKTsgcmV0dXJuIG4gPyBbbl0gOiBbXSB9IH0pIDogKGIuZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHsgdmFyIG4gPSBlLnJlcGxhY2UodGUsIG5lKTsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlICYmIGUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpOyByZXR1cm4gdCAmJiB0LnZhbHVlID09PSBuIH0gfSwgYi5maW5kLklEID0gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQgJiYgRSkgeyB2YXIgbiwgciwgaSwgbyA9IHQuZ2V0RWxlbWVudEJ5SWQoZSk7IGlmIChvKSB7IGlmICgobiA9IG8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSAmJiBuLnZhbHVlID09PSBlKSByZXR1cm4gW29dOyBpID0gdC5nZXRFbGVtZW50c0J5TmFtZShlKSwgciA9IDA7IHdoaWxlIChvID0gaVtyKytdKSBpZiAoKG4gPSBvLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkgJiYgbi52YWx1ZSA9PT0gZSkgcmV0dXJuIFtvXSB9IHJldHVybiBbXSB9IH0pLCBiLmZpbmQuVEFHID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gdC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKSA6IGQucXNhID8gdC5xdWVyeVNlbGVjdG9yQWxsKGUpIDogdm9pZCAwIH0gOiBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiwgciA9IFtdLCBpID0gMCwgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7IGlmIChcIipcIiA9PT0gZSkgeyB3aGlsZSAobiA9IG9baSsrXSkgMSA9PT0gbi5ub2RlVHlwZSAmJiByLnB1c2gobik7IHJldHVybiByIH0gcmV0dXJuIG8gfSwgYi5maW5kLkNMQVNTID0gZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChlLCB0KSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgRSkgcmV0dXJuIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlKSB9LCBzID0gW10sIHYgPSBbXSwgKGQucXNhID0gSy50ZXN0KEMucXVlcnlTZWxlY3RvckFsbCkpICYmIChjZShmdW5jdGlvbiAoZSkgeyBhLmFwcGVuZENoaWxkKGUpLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgayArIFwiJz48L2E+PHNlbGVjdCBpZD0nXCIgKyBrICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIiwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICYmIHYucHVzaChcIlsqXiRdPVwiICsgTSArIFwiKig/OicnfFxcXCJcXFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggfHwgdi5wdXNoKFwiXFxcXFtcIiArIE0gKyBcIiooPzp2YWx1ZXxcIiArIFIgKyBcIilcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIgKyBrICsgXCItXVwiKS5sZW5ndGggfHwgdi5wdXNoKFwifj1cIiksIGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCB8fCB2LnB1c2goXCI6Y2hlY2tlZFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIiArIGsgKyBcIisqXCIpLmxlbmd0aCB8fCB2LnB1c2goXCIuIy4rWyt+XVwiKSB9KSwgY2UoZnVuY3Rpb24gKGUpIHsgZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+PHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiOyB2YXIgdCA9IEMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpOyB0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIiksIGUuYXBwZW5kQ2hpbGQodCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCAmJiB2LnB1c2goXCJuYW1lXCIgKyBNICsgXCIqWypeJHwhfl0/PVwiKSwgMiAhPT0gZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICYmIHYucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpLCBhLmFwcGVuZENoaWxkKGUpLmRpc2FibGVkID0gITAsIDIgIT09IGUucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggJiYgdi5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIiksIHYucHVzaChcIiwuKjpcIikgfSkpLCAoZC5tYXRjaGVzU2VsZWN0b3IgPSBLLnRlc3QoYyA9IGEubWF0Y2hlcyB8fCBhLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBhLm1vek1hdGNoZXNTZWxlY3RvciB8fCBhLm9NYXRjaGVzU2VsZWN0b3IgfHwgYS5tc01hdGNoZXNTZWxlY3RvcikpICYmIGNlKGZ1bmN0aW9uIChlKSB7IGQuZGlzY29ubmVjdGVkTWF0Y2ggPSBjLmNhbGwoZSwgXCIqXCIpLCBjLmNhbGwoZSwgXCJbcyE9JyddOnhcIiksIHMucHVzaChcIiE9XCIsICQpIH0pLCB2ID0gdi5sZW5ndGggJiYgbmV3IFJlZ0V4cCh2LmpvaW4oXCJ8XCIpKSwgcyA9IHMubGVuZ3RoICYmIG5ldyBSZWdFeHAocy5qb2luKFwifFwiKSksIHQgPSBLLnRlc3QoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiksIHkgPSB0IHx8IEsudGVzdChhLmNvbnRhaW5zKSA/IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuID0gOSA9PT0gZS5ub2RlVHlwZSA/IGUuZG9jdW1lbnRFbGVtZW50IDogZSwgciA9IHQgJiYgdC5wYXJlbnROb2RlOyByZXR1cm4gZSA9PT0gciB8fCAhKCFyIHx8IDEgIT09IHIubm9kZVR5cGUgfHwgIShuLmNvbnRhaW5zID8gbi5jb250YWlucyhyKSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSkgfSA6IGZ1bmN0aW9uIChlLCB0KSB7IGlmICh0KSB3aGlsZSAodCA9IHQucGFyZW50Tm9kZSkgaWYgKHQgPT09IGUpIHJldHVybiAhMDsgcmV0dXJuICExIH0sIEQgPSB0ID8gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKGUgPT09IHQpIHJldHVybiBsID0gITAsIDA7IHZhciBuID0gIWUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjsgcmV0dXJuIG4gfHwgKDEgJiAobiA9IChlLm93bmVyRG9jdW1lbnQgfHwgZSkgPT09ICh0Lm93bmVyRG9jdW1lbnQgfHwgdCkgPyBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpIDogMSkgfHwgIWQuc29ydERldGFjaGVkICYmIHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSkgPT09IG4gPyBlID09PSBDIHx8IGUub3duZXJEb2N1bWVudCA9PT0gbSAmJiB5KG0sIGUpID8gLTEgOiB0ID09PSBDIHx8IHQub3duZXJEb2N1bWVudCA9PT0gbSAmJiB5KG0sIHQpID8gMSA6IHUgPyBQKHUsIGUpIC0gUCh1LCB0KSA6IDAgOiA0ICYgbiA/IC0xIDogMSkgfSA6IGZ1bmN0aW9uIChlLCB0KSB7IGlmIChlID09PSB0KSByZXR1cm4gbCA9ICEwLCAwOyB2YXIgbiwgciA9IDAsIGkgPSBlLnBhcmVudE5vZGUsIG8gPSB0LnBhcmVudE5vZGUsIGEgPSBbZV0sIHMgPSBbdF07IGlmICghaSB8fCAhbykgcmV0dXJuIGUgPT09IEMgPyAtMSA6IHQgPT09IEMgPyAxIDogaSA/IC0xIDogbyA/IDEgOiB1ID8gUCh1LCBlKSAtIFAodSwgdCkgOiAwOyBpZiAoaSA9PT0gbykgcmV0dXJuIHBlKGUsIHQpOyBuID0gZTsgd2hpbGUgKG4gPSBuLnBhcmVudE5vZGUpIGEudW5zaGlmdChuKTsgbiA9IHQ7IHdoaWxlIChuID0gbi5wYXJlbnROb2RlKSBzLnVuc2hpZnQobik7IHdoaWxlIChhW3JdID09PSBzW3JdKSByKys7IHJldHVybiByID8gcGUoYVtyXSwgc1tyXSkgOiBhW3JdID09PSBtID8gLTEgOiBzW3JdID09PSBtID8gMSA6IDAgfSksIEMgfSwgc2UubWF0Y2hlcyA9IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBzZShlLCBudWxsLCBudWxsLCB0KSB9LCBzZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoKGUub3duZXJEb2N1bWVudCB8fCBlKSAhPT0gQyAmJiBUKGUpLCBkLm1hdGNoZXNTZWxlY3RvciAmJiBFICYmICFBW3QgKyBcIiBcIl0gJiYgKCFzIHx8ICFzLnRlc3QodCkpICYmICghdiB8fCAhdi50ZXN0KHQpKSkgdHJ5IHsgdmFyIG4gPSBjLmNhbGwoZSwgdCk7IGlmIChuIHx8IGQuZGlzY29ubmVjdGVkTWF0Y2ggfHwgZS5kb2N1bWVudCAmJiAxMSAhPT0gZS5kb2N1bWVudC5ub2RlVHlwZSkgcmV0dXJuIG4gfSBjYXRjaCAoZSkgeyBBKHQsICEwKSB9IHJldHVybiAwIDwgc2UodCwgQywgbnVsbCwgW2VdKS5sZW5ndGggfSwgc2UuY29udGFpbnMgPSBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gKGUub3duZXJEb2N1bWVudCB8fCBlKSAhPT0gQyAmJiBUKGUpLCB5KGUsIHQpIH0sIHNlLmF0dHIgPSBmdW5jdGlvbiAoZSwgdCkgeyAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBDICYmIFQoZSk7IHZhciBuID0gYi5hdHRySGFuZGxlW3QudG9Mb3dlckNhc2UoKV0sIHIgPSBuICYmIGouY2FsbChiLmF0dHJIYW5kbGUsIHQudG9Mb3dlckNhc2UoKSkgPyBuKGUsIHQsICFFKSA6IHZvaWQgMDsgcmV0dXJuIHZvaWQgMCAhPT0gciA/IHIgOiBkLmF0dHJpYnV0ZXMgfHwgIUUgPyBlLmdldEF0dHJpYnV0ZSh0KSA6IChyID0gZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSAmJiByLnNwZWNpZmllZCA/IHIudmFsdWUgOiBudWxsIH0sIHNlLmVzY2FwZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiAoZSArIFwiXCIpLnJlcGxhY2UocmUsIGllKSB9LCBzZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSkgfSwgc2UudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuID0gW10sIHIgPSAwLCBpID0gMDsgaWYgKGwgPSAhZC5kZXRlY3REdXBsaWNhdGVzLCB1ID0gIWQuc29ydFN0YWJsZSAmJiBlLnNsaWNlKDApLCBlLnNvcnQoRCksIGwpIHsgd2hpbGUgKHQgPSBlW2krK10pIHQgPT09IGVbaV0gJiYgKHIgPSBuLnB1c2goaSkpOyB3aGlsZSAoci0tKSBlLnNwbGljZShuW3JdLCAxKSB9IHJldHVybiB1ID0gbnVsbCwgZSB9LCBvID0gc2UuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuID0gXCJcIiwgciA9IDAsIGkgPSBlLm5vZGVUeXBlOyBpZiAoaSkgeyBpZiAoMSA9PT0gaSB8fCA5ID09PSBpIHx8IDExID09PSBpKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlLnRleHRDb250ZW50KSByZXR1cm4gZS50ZXh0Q29udGVudDsgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZyluICs9IG8oZSkgfSBlbHNlIGlmICgzID09PSBpIHx8IDQgPT09IGkpIHJldHVybiBlLm5vZGVWYWx1ZSB9IGVsc2Ugd2hpbGUgKHQgPSBlW3IrK10pIG4gKz0gbyh0KTsgcmV0dXJuIG4gfSwgKGIgPSBzZS5zZWxlY3RvcnMgPSB7IGNhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBsZSwgbWF0Y2g6IEcsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHsgXCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6ICEwIH0sIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSwgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogITAgfSwgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlWzFdID0gZVsxXS5yZXBsYWNlKHRlLCBuZSksIGVbM10gPSAoZVszXSB8fCBlWzRdIHx8IGVbNV0gfHwgXCJcIikucmVwbGFjZSh0ZSwgbmUpLCBcIn49XCIgPT09IGVbMl0gJiYgKGVbM10gPSBcIiBcIiArIGVbM10gKyBcIiBcIiksIGUuc2xpY2UoMCwgNCkgfSwgQ0hJTEQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlWzFdID0gZVsxXS50b0xvd2VyQ2FzZSgpLCBcIm50aFwiID09PSBlWzFdLnNsaWNlKDAsIDMpID8gKGVbM10gfHwgc2UuZXJyb3IoZVswXSksIGVbNF0gPSArKGVbNF0gPyBlWzVdICsgKGVbNl0gfHwgMSkgOiAyICogKFwiZXZlblwiID09PSBlWzNdIHx8IFwib2RkXCIgPT09IGVbM10pKSwgZVs1XSA9ICsoZVs3XSArIGVbOF0gfHwgXCJvZGRcIiA9PT0gZVszXSkpIDogZVszXSAmJiBzZS5lcnJvcihlWzBdKSwgZSB9LCBQU0VVRE86IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuID0gIWVbNl0gJiYgZVsyXTsgcmV0dXJuIEcuQ0hJTEQudGVzdChlWzBdKSA/IG51bGwgOiAoZVszXSA/IGVbMl0gPSBlWzRdIHx8IGVbNV0gfHwgXCJcIiA6IG4gJiYgWC50ZXN0KG4pICYmICh0ID0gaChuLCAhMCkpICYmICh0ID0gbi5pbmRleE9mKFwiKVwiLCBuLmxlbmd0aCAtIHQpIC0gbi5sZW5ndGgpICYmIChlWzBdID0gZVswXS5zbGljZSgwLCB0KSwgZVsyXSA9IG4uc2xpY2UoMCwgdCkpLCBlLnNsaWNlKDAsIDMpKSB9IH0sIGZpbHRlcjogeyBUQUc6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gZS5yZXBsYWNlKHRlLCBuZSkudG9Mb3dlckNhc2UoKTsgcmV0dXJuIFwiKlwiID09PSBlID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gITAgfSA6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdCB9IH0sIENMQVNTOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IHBbZSArIFwiIFwiXTsgcmV0dXJuIHQgfHwgKHQgPSBuZXcgUmVnRXhwKFwiKF58XCIgKyBNICsgXCIpXCIgKyBlICsgXCIoXCIgKyBNICsgXCJ8JClcIikpICYmIHAoZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQudGVzdChcInN0cmluZ1wiID09IHR5cGVvZiBlLmNsYXNzTmFtZSAmJiBlLmNsYXNzTmFtZSB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLmdldEF0dHJpYnV0ZSAmJiBlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpIH0pIH0sIEFUVFI6IGZ1bmN0aW9uIChuLCByLCBpKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IHNlLmF0dHIoZSwgbik7IHJldHVybiBudWxsID09IHQgPyBcIiE9XCIgPT09IHIgOiAhciB8fCAodCArPSBcIlwiLCBcIj1cIiA9PT0gciA/IHQgPT09IGkgOiBcIiE9XCIgPT09IHIgPyB0ICE9PSBpIDogXCJePVwiID09PSByID8gaSAmJiAwID09PSB0LmluZGV4T2YoaSkgOiBcIio9XCIgPT09IHIgPyBpICYmIC0xIDwgdC5pbmRleE9mKGkpIDogXCIkPVwiID09PSByID8gaSAmJiB0LnNsaWNlKC1pLmxlbmd0aCkgPT09IGkgOiBcIn49XCIgPT09IHIgPyAtMSA8IChcIiBcIiArIHQucmVwbGFjZShGLCBcIiBcIikgKyBcIiBcIikuaW5kZXhPZihpKSA6IFwifD1cIiA9PT0gciAmJiAodCA9PT0gaSB8fCB0LnNsaWNlKDAsIGkubGVuZ3RoICsgMSkgPT09IGkgKyBcIi1cIikpIH0gfSwgQ0hJTEQ6IGZ1bmN0aW9uIChoLCBlLCB0LCBnLCB2KSB7IHZhciB5ID0gXCJudGhcIiAhPT0gaC5zbGljZSgwLCAzKSwgbSA9IFwibGFzdFwiICE9PSBoLnNsaWNlKC00KSwgeCA9IFwib2YtdHlwZVwiID09PSBlOyByZXR1cm4gMSA9PT0gZyAmJiAwID09PSB2ID8gZnVuY3Rpb24gKGUpIHsgcmV0dXJuICEhZS5wYXJlbnROb2RlIH0gOiBmdW5jdGlvbiAoZSwgdCwgbikgeyB2YXIgciwgaSwgbywgYSwgcywgdSwgbCA9IHkgIT09IG0gPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLCBjID0gZS5wYXJlbnROb2RlLCBmID0geCAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHAgPSAhbiAmJiAheCwgZCA9ICExOyBpZiAoYykgeyBpZiAoeSkgeyB3aGlsZSAobCkgeyBhID0gZTsgd2hpbGUgKGEgPSBhW2xdKSBpZiAoeCA/IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZiA6IDEgPT09IGEubm9kZVR5cGUpIHJldHVybiAhMTsgdSA9IGwgPSBcIm9ubHlcIiA9PT0gaCAmJiAhdSAmJiBcIm5leHRTaWJsaW5nXCIgfSByZXR1cm4gITAgfSBpZiAodSA9IFttID8gYy5maXJzdENoaWxkIDogYy5sYXN0Q2hpbGRdLCBtICYmIHApIHsgZCA9IChzID0gKHIgPSAoaSA9IChvID0gKGEgPSBjKVtrXSB8fCAoYVtrXSA9IHt9KSlbYS51bmlxdWVJRF0gfHwgKG9bYS51bmlxdWVJRF0gPSB7fSkpW2hdIHx8IFtdKVswXSA9PT0gUyAmJiByWzFdKSAmJiByWzJdLCBhID0gcyAmJiBjLmNoaWxkTm9kZXNbc107IHdoaWxlIChhID0gKytzICYmIGEgJiYgYVtsXSB8fCAoZCA9IHMgPSAwKSB8fCB1LnBvcCgpKSBpZiAoMSA9PT0gYS5ub2RlVHlwZSAmJiArK2QgJiYgYSA9PT0gZSkgeyBpW2hdID0gW1MsIHMsIGRdOyBicmVhayB9IH0gZWxzZSBpZiAocCAmJiAoZCA9IHMgPSAociA9IChpID0gKG8gPSAoYSA9IGUpW2tdIHx8IChhW2tdID0ge30pKVthLnVuaXF1ZUlEXSB8fCAob1thLnVuaXF1ZUlEXSA9IHt9KSlbaF0gfHwgW10pWzBdID09PSBTICYmIHJbMV0pLCAhMSA9PT0gZCkgd2hpbGUgKGEgPSArK3MgJiYgYSAmJiBhW2xdIHx8IChkID0gcyA9IDApIHx8IHUucG9wKCkpIGlmICgoeCA/IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZiA6IDEgPT09IGEubm9kZVR5cGUpICYmICsrZCAmJiAocCAmJiAoKGkgPSAobyA9IGFba10gfHwgKGFba10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSA9IFtTLCBkXSksIGEgPT09IGUpKSBicmVhazsgcmV0dXJuIChkIC09IHYpID09PSBnIHx8IGQgJSBnID09IDAgJiYgMCA8PSBkIC8gZyB9IH0gfSwgUFNFVURPOiBmdW5jdGlvbiAoZSwgbykgeyB2YXIgdCwgYSA9IGIucHNldWRvc1tlXSB8fCBiLnNldEZpbHRlcnNbZS50b0xvd2VyQ2FzZSgpXSB8fCBzZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBlKTsgcmV0dXJuIGFba10gPyBhKG8pIDogMSA8IGEubGVuZ3RoID8gKHQgPSBbZSwgZSwgXCJcIiwgb10sIGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpID8gbGUoZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4sIHIgPSBhKGUsIG8pLCBpID0gci5sZW5ndGg7IHdoaWxlIChpLS0pIGVbbiA9IFAoZSwgcltpXSldID0gISh0W25dID0gcltpXSkgfSkgOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYShlLCAwLCB0KSB9KSA6IGEgfSB9LCBwc2V1ZG9zOiB7IG5vdDogbGUoZnVuY3Rpb24gKGUpIHsgdmFyIHIgPSBbXSwgaSA9IFtdLCBzID0gZihlLnJlcGxhY2UoQiwgXCIkMVwiKSk7IHJldHVybiBzW2tdID8gbGUoZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHsgdmFyIGksIG8gPSBzKGUsIG51bGwsIHIsIFtdKSwgYSA9IGUubGVuZ3RoOyB3aGlsZSAoYS0tKSAoaSA9IG9bYV0pICYmIChlW2FdID0gISh0W2FdID0gaSkpIH0pIDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIHJbMF0gPSBlLCBzKHIsIG51bGwsIG4sIGkpLCByWzBdID0gbnVsbCwgIWkucG9wKCkgfSB9KSwgaGFzOiBsZShmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDAgPCBzZSh0LCBlKS5sZW5ndGggfSB9KSwgY29udGFpbnM6IGxlKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ID0gdC5yZXBsYWNlKHRlLCBuZSksIGZ1bmN0aW9uIChlKSB7IHJldHVybiAtMSA8IChlLnRleHRDb250ZW50IHx8IG8oZSkpLmluZGV4T2YodCkgfSB9KSwgbGFuZzogbGUoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFYudGVzdChuIHx8IFwiXCIpIHx8IHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBuKSwgbiA9IG4ucmVwbGFjZSh0ZSwgbmUpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uIChlKSB7IHZhciB0OyBkbyB7IGlmICh0ID0gRSA/IGUubGFuZyA6IGUuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSByZXR1cm4gKHQgPSB0LnRvTG93ZXJDYXNlKCkpID09PSBuIHx8IDAgPT09IHQuaW5kZXhPZihuICsgXCItXCIpIH0gd2hpbGUgKChlID0gZS5wYXJlbnROb2RlKSAmJiAxID09PSBlLm5vZGVUeXBlKTsgcmV0dXJuICExIH0gfSksIHRhcmdldDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBuLmxvY2F0aW9uICYmIG4ubG9jYXRpb24uaGFzaDsgcmV0dXJuIHQgJiYgdC5zbGljZSgxKSA9PT0gZS5pZCB9LCByb290OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSA9PT0gYSB9LCBmb2N1czogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPT09IEMuYWN0aXZlRWxlbWVudCAmJiAoIUMuaGFzRm9jdXMgfHwgQy5oYXNGb2N1cygpKSAmJiAhIShlLnR5cGUgfHwgZS5ocmVmIHx8IH5lLnRhYkluZGV4KSB9LCBlbmFibGVkOiBnZSghMSksIGRpc2FibGVkOiBnZSghMCksIGNoZWNrZWQ6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gXCJpbnB1dFwiID09PSB0ICYmICEhZS5jaGVja2VkIHx8IFwib3B0aW9uXCIgPT09IHQgJiYgISFlLnNlbGVjdGVkIH0sIHNlbGVjdGVkOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5wYXJlbnROb2RlICYmIGUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCAhMCA9PT0gZS5zZWxlY3RlZCB9LCBlbXB0eTogZnVuY3Rpb24gKGUpIHsgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZylpZiAoZS5ub2RlVHlwZSA8IDYpIHJldHVybiAhMTsgcmV0dXJuICEwIH0sIHBhcmVudDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuICFiLnBzZXVkb3MuZW1wdHkoZSkgfSwgaGVhZGVyOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gSi50ZXN0KGUubm9kZU5hbWUpIH0sIGlucHV0OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gUS50ZXN0KGUubm9kZU5hbWUpIH0sIGJ1dHRvbjogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IHJldHVybiBcImlucHV0XCIgPT09IHQgJiYgXCJidXR0b25cIiA9PT0gZS50eXBlIHx8IFwiYnV0dG9uXCIgPT09IHQgfSwgdGV4dDogZnVuY3Rpb24gKGUpIHsgdmFyIHQ7IHJldHVybiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBcInRleHRcIiA9PT0gZS50eXBlICYmIChudWxsID09ICh0ID0gZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSB8fCBcInRleHRcIiA9PT0gdC50b0xvd2VyQ2FzZSgpKSB9LCBmaXJzdDogdmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gWzBdIH0pLCBsYXN0OiB2ZShmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gW3QgLSAxXSB9KSwgZXE6IHZlKGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiBbbiA8IDAgPyBuICsgdCA6IG5dIH0pLCBldmVuOiB2ZShmdW5jdGlvbiAoZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQ7IG4gKz0gMillLnB1c2gobik7IHJldHVybiBlIH0pLCBvZGQ6IHZlKGZ1bmN0aW9uIChlLCB0KSB7IGZvciAodmFyIG4gPSAxOyBuIDwgdDsgbiArPSAyKWUucHVzaChuKTsgcmV0dXJuIGUgfSksIGx0OiB2ZShmdW5jdGlvbiAoZSwgdCwgbikgeyBmb3IgKHZhciByID0gbiA8IDAgPyBuICsgdCA6IHQgPCBuID8gdCA6IG47IDAgPD0gLS1yOyllLnB1c2gocik7IHJldHVybiBlIH0pLCBndDogdmUoZnVuY3Rpb24gKGUsIHQsIG4pIHsgZm9yICh2YXIgciA9IG4gPCAwID8gbiArIHQgOiBuOyArK3IgPCB0OyllLnB1c2gocik7IHJldHVybiBlIH0pIH0gfSkucHNldWRvcy5udGggPSBiLnBzZXVkb3MuZXEsIHsgcmFkaW86ICEwLCBjaGVja2JveDogITAsIGZpbGU6ICEwLCBwYXNzd29yZDogITAsIGltYWdlOiAhMCB9KSBiLnBzZXVkb3NbZV0gPSBkZShlKTsgZm9yIChlIGluIHsgc3VibWl0OiAhMCwgcmVzZXQ6ICEwIH0pIGIucHNldWRvc1tlXSA9IGhlKGUpOyBmdW5jdGlvbiBtZSgpIHsgfSBmdW5jdGlvbiB4ZShlKSB7IGZvciAodmFyIHQgPSAwLCBuID0gZS5sZW5ndGgsIHIgPSBcIlwiOyB0IDwgbjsgdCsrKXIgKz0gZVt0XS52YWx1ZTsgcmV0dXJuIHIgfSBmdW5jdGlvbiBiZShzLCBlLCB0KSB7IHZhciB1ID0gZS5kaXIsIGwgPSBlLm5leHQsIGMgPSBsIHx8IHUsIGYgPSB0ICYmIFwicGFyZW50Tm9kZVwiID09PSBjLCBwID0gcisrOyByZXR1cm4gZS5maXJzdCA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHdoaWxlIChlID0gZVt1XSkgaWYgKDEgPT09IGUubm9kZVR5cGUgfHwgZikgcmV0dXJuIHMoZSwgdCwgbik7IHJldHVybiAhMSB9IDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8sIGEgPSBbUywgcF07IGlmIChuKSB7IHdoaWxlIChlID0gZVt1XSkgaWYgKCgxID09PSBlLm5vZGVUeXBlIHx8IGYpICYmIHMoZSwgdCwgbikpIHJldHVybiAhMCB9IGVsc2Ugd2hpbGUgKGUgPSBlW3VdKSBpZiAoMSA9PT0gZS5ub2RlVHlwZSB8fCBmKSBpZiAoaSA9IChvID0gZVtrXSB8fCAoZVtrXSA9IHt9KSlbZS51bmlxdWVJRF0gfHwgKG9bZS51bmlxdWVJRF0gPSB7fSksIGwgJiYgbCA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSBlID0gZVt1XSB8fCBlOyBlbHNlIHsgaWYgKChyID0gaVtjXSkgJiYgclswXSA9PT0gUyAmJiByWzFdID09PSBwKSByZXR1cm4gYVsyXSA9IHJbMl07IGlmICgoaVtjXSA9IGEpWzJdID0gcyhlLCB0LCBuKSkgcmV0dXJuICEwIH0gcmV0dXJuICExIH0gfSBmdW5jdGlvbiB3ZShpKSB7IHJldHVybiAxIDwgaS5sZW5ndGggPyBmdW5jdGlvbiAoZSwgdCwgbikgeyB2YXIgciA9IGkubGVuZ3RoOyB3aGlsZSAoci0tKSBpZiAoIWlbcl0oZSwgdCwgbikpIHJldHVybiAhMTsgcmV0dXJuICEwIH0gOiBpWzBdIH0gZnVuY3Rpb24gVGUoZSwgdCwgbiwgciwgaSkgeyBmb3IgKHZhciBvLCBhID0gW10sIHMgPSAwLCB1ID0gZS5sZW5ndGgsIGwgPSBudWxsICE9IHQ7IHMgPCB1OyBzKyspKG8gPSBlW3NdKSAmJiAobiAmJiAhbihvLCByLCBpKSB8fCAoYS5wdXNoKG8pLCBsICYmIHQucHVzaChzKSkpOyByZXR1cm4gYSB9IGZ1bmN0aW9uIENlKGQsIGgsIGcsIHYsIHksIGUpIHsgcmV0dXJuIHYgJiYgIXZba10gJiYgKHYgPSBDZSh2KSksIHkgJiYgIXlba10gJiYgKHkgPSBDZSh5LCBlKSksIGxlKGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhLCBzID0gW10sIHUgPSBbXSwgbCA9IHQubGVuZ3RoLCBjID0gZSB8fCBmdW5jdGlvbiAoZSwgdCwgbikgeyBmb3IgKHZhciByID0gMCwgaSA9IHQubGVuZ3RoOyByIDwgaTsgcisrKXNlKGUsIHRbcl0sIG4pOyByZXR1cm4gbiB9KGggfHwgXCIqXCIsIG4ubm9kZVR5cGUgPyBbbl0gOiBuLCBbXSksIGYgPSAhZCB8fCAhZSAmJiBoID8gYyA6IFRlKGMsIHMsIGQsIG4sIHIpLCBwID0gZyA/IHkgfHwgKGUgPyBkIDogbCB8fCB2KSA/IFtdIDogdCA6IGY7IGlmIChnICYmIGcoZiwgcCwgbiwgciksIHYpIHsgaSA9IFRlKHAsIHUpLCB2KGksIFtdLCBuLCByKSwgbyA9IGkubGVuZ3RoOyB3aGlsZSAoby0tKSAoYSA9IGlbb10pICYmIChwW3Vbb11dID0gIShmW3Vbb11dID0gYSkpIH0gaWYgKGUpIHsgaWYgKHkgfHwgZCkgeyBpZiAoeSkgeyBpID0gW10sIG8gPSBwLmxlbmd0aDsgd2hpbGUgKG8tLSkgKGEgPSBwW29dKSAmJiBpLnB1c2goZltvXSA9IGEpOyB5KG51bGwsIHAgPSBbXSwgaSwgcikgfSBvID0gcC5sZW5ndGg7IHdoaWxlIChvLS0pIChhID0gcFtvXSkgJiYgLTEgPCAoaSA9IHkgPyBQKGUsIGEpIDogc1tvXSkgJiYgKGVbaV0gPSAhKHRbaV0gPSBhKSkgfSB9IGVsc2UgcCA9IFRlKHAgPT09IHQgPyBwLnNwbGljZShsLCBwLmxlbmd0aCkgOiBwKSwgeSA/IHkobnVsbCwgdCwgcCwgcikgOiBILmFwcGx5KHQsIHApIH0pIH0gZnVuY3Rpb24gRWUoZSkgeyBmb3IgKHZhciBpLCB0LCBuLCByID0gZS5sZW5ndGgsIG8gPSBiLnJlbGF0aXZlW2VbMF0udHlwZV0sIGEgPSBvIHx8IGIucmVsYXRpdmVbXCIgXCJdLCBzID0gbyA/IDEgOiAwLCB1ID0gYmUoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPT09IGkgfSwgYSwgITApLCBsID0gYmUoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIC0xIDwgUChpLCBlKSB9LCBhLCAhMCksIGMgPSBbZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIgPSAhbyAmJiAobiB8fCB0ICE9PSB3KSB8fCAoKGkgPSB0KS5ub2RlVHlwZSA/IHUoZSwgdCwgbikgOiBsKGUsIHQsIG4pKTsgcmV0dXJuIGkgPSBudWxsLCByIH1dOyBzIDwgcjsgcysrKWlmICh0ID0gYi5yZWxhdGl2ZVtlW3NdLnR5cGVdKSBjID0gW2JlKHdlKGMpLCB0KV07IGVsc2UgeyBpZiAoKHQgPSBiLmZpbHRlcltlW3NdLnR5cGVdLmFwcGx5KG51bGwsIGVbc10ubWF0Y2hlcykpW2tdKSB7IGZvciAobiA9ICsrczsgbiA8IHI7IG4rKylpZiAoYi5yZWxhdGl2ZVtlW25dLnR5cGVdKSBicmVhazsgcmV0dXJuIENlKDEgPCBzICYmIHdlKGMpLCAxIDwgcyAmJiB4ZShlLnNsaWNlKDAsIHMgLSAxKS5jb25jYXQoeyB2YWx1ZTogXCIgXCIgPT09IGVbcyAtIDJdLnR5cGUgPyBcIipcIiA6IFwiXCIgfSkpLnJlcGxhY2UoQiwgXCIkMVwiKSwgdCwgcyA8IG4gJiYgRWUoZS5zbGljZShzLCBuKSksIG4gPCByICYmIEVlKGUgPSBlLnNsaWNlKG4pKSwgbiA8IHIgJiYgeGUoZSkpIH0gYy5wdXNoKHQpIH0gcmV0dXJuIHdlKGMpIH0gcmV0dXJuIG1lLnByb3RvdHlwZSA9IGIuZmlsdGVycyA9IGIucHNldWRvcywgYi5zZXRGaWx0ZXJzID0gbmV3IG1lLCBoID0gc2UudG9rZW5pemUgPSBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiwgciwgaSwgbywgYSwgcywgdSwgbCA9IHhbZSArIFwiIFwiXTsgaWYgKGwpIHJldHVybiB0ID8gMCA6IGwuc2xpY2UoMCk7IGEgPSBlLCBzID0gW10sIHUgPSBiLnByZUZpbHRlcjsgd2hpbGUgKGEpIHsgZm9yIChvIGluIG4gJiYgIShyID0gXy5leGVjKGEpKSB8fCAociAmJiAoYSA9IGEuc2xpY2UoclswXS5sZW5ndGgpIHx8IGEpLCBzLnB1c2goaSA9IFtdKSksIG4gPSAhMSwgKHIgPSB6LmV4ZWMoYSkpICYmIChuID0gci5zaGlmdCgpLCBpLnB1c2goeyB2YWx1ZTogbiwgdHlwZTogclswXS5yZXBsYWNlKEIsIFwiIFwiKSB9KSwgYSA9IGEuc2xpY2Uobi5sZW5ndGgpKSwgYi5maWx0ZXIpICEociA9IEdbb10uZXhlYyhhKSkgfHwgdVtvXSAmJiAhKHIgPSB1W29dKHIpKSB8fCAobiA9IHIuc2hpZnQoKSwgaS5wdXNoKHsgdmFsdWU6IG4sIHR5cGU6IG8sIG1hdGNoZXM6IHIgfSksIGEgPSBhLnNsaWNlKG4ubGVuZ3RoKSk7IGlmICghbikgYnJlYWsgfSByZXR1cm4gdCA/IGEubGVuZ3RoIDogYSA/IHNlLmVycm9yKGUpIDogeChlLCBzKS5zbGljZSgwKSB9LCBmID0gc2UuY29tcGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCB2LCB5LCBtLCB4LCByLCBpID0gW10sIG8gPSBbXSwgYSA9IE5bZSArIFwiIFwiXTsgaWYgKCFhKSB7IHQgfHwgKHQgPSBoKGUpKSwgbiA9IHQubGVuZ3RoOyB3aGlsZSAobi0tKSAoYSA9IEVlKHRbbl0pKVtrXSA/IGkucHVzaChhKSA6IG8ucHVzaChhKTsgKGEgPSBOKGUsICh2ID0gbywgbSA9IDAgPCAoeSA9IGkpLmxlbmd0aCwgeCA9IDAgPCB2Lmxlbmd0aCwgciA9IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpKSB7IHZhciBvLCBhLCBzLCB1ID0gMCwgbCA9IFwiMFwiLCBjID0gZSAmJiBbXSwgZiA9IFtdLCBwID0gdywgZCA9IGUgfHwgeCAmJiBiLmZpbmQuVEFHKFwiKlwiLCBpKSwgaCA9IFMgKz0gbnVsbCA9PSBwID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgLjEsIGcgPSBkLmxlbmd0aDsgZm9yIChpICYmICh3ID0gdCA9PT0gQyB8fCB0IHx8IGkpOyBsICE9PSBnICYmIG51bGwgIT0gKG8gPSBkW2xdKTsgbCsrKSB7IGlmICh4ICYmIG8pIHsgYSA9IDAsIHQgfHwgby5vd25lckRvY3VtZW50ID09PSBDIHx8IChUKG8pLCBuID0gIUUpOyB3aGlsZSAocyA9IHZbYSsrXSkgaWYgKHMobywgdCB8fCBDLCBuKSkgeyByLnB1c2gobyk7IGJyZWFrIH0gaSAmJiAoUyA9IGgpIH0gbSAmJiAoKG8gPSAhcyAmJiBvKSAmJiB1LS0gLCBlICYmIGMucHVzaChvKSkgfSBpZiAodSArPSBsLCBtICYmIGwgIT09IHUpIHsgYSA9IDA7IHdoaWxlIChzID0geVthKytdKSBzKGMsIGYsIHQsIG4pOyBpZiAoZSkgeyBpZiAoMCA8IHUpIHdoaWxlIChsLS0pIGNbbF0gfHwgZltsXSB8fCAoZltsXSA9IHEuY2FsbChyKSk7IGYgPSBUZShmKSB9IEguYXBwbHkociwgZiksIGkgJiYgIWUgJiYgMCA8IGYubGVuZ3RoICYmIDEgPCB1ICsgeS5sZW5ndGggJiYgc2UudW5pcXVlU29ydChyKSB9IHJldHVybiBpICYmIChTID0gaCwgdyA9IHApLCBjIH0sIG0gPyBsZShyKSA6IHIpKSkuc2VsZWN0b3IgPSBlIH0gcmV0dXJuIGEgfSwgZyA9IHNlLnNlbGVjdCA9IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhLCBzLCB1LCBsID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUsIGMgPSAhciAmJiBoKGUgPSBsLnNlbGVjdG9yIHx8IGUpOyBpZiAobiA9IG4gfHwgW10sIDEgPT09IGMubGVuZ3RoKSB7IGlmICgyIDwgKG8gPSBjWzBdID0gY1swXS5zbGljZSgwKSkubGVuZ3RoICYmIFwiSURcIiA9PT0gKGEgPSBvWzBdKS50eXBlICYmIDkgPT09IHQubm9kZVR5cGUgJiYgRSAmJiBiLnJlbGF0aXZlW29bMV0udHlwZV0pIHsgaWYgKCEodCA9IChiLmZpbmQuSUQoYS5tYXRjaGVzWzBdLnJlcGxhY2UodGUsIG5lKSwgdCkgfHwgW10pWzBdKSkgcmV0dXJuIG47IGwgJiYgKHQgPSB0LnBhcmVudE5vZGUpLCBlID0gZS5zbGljZShvLnNoaWZ0KCkudmFsdWUubGVuZ3RoKSB9IGkgPSBHLm5lZWRzQ29udGV4dC50ZXN0KGUpID8gMCA6IG8ubGVuZ3RoOyB3aGlsZSAoaS0tKSB7IGlmIChhID0gb1tpXSwgYi5yZWxhdGl2ZVtzID0gYS50eXBlXSkgYnJlYWs7IGlmICgodSA9IGIuZmluZFtzXSkgJiYgKHIgPSB1KGEubWF0Y2hlc1swXS5yZXBsYWNlKHRlLCBuZSksIGVlLnRlc3Qob1swXS50eXBlKSAmJiB5ZSh0LnBhcmVudE5vZGUpIHx8IHQpKSkgeyBpZiAoby5zcGxpY2UoaSwgMSksICEoZSA9IHIubGVuZ3RoICYmIHhlKG8pKSkgcmV0dXJuIEguYXBwbHkobiwgciksIG47IGJyZWFrIH0gfSB9IHJldHVybiAobCB8fCBmKGUsIGMpKShyLCB0LCAhRSwgbiwgIXQgfHwgZWUudGVzdChlKSAmJiB5ZSh0LnBhcmVudE5vZGUpIHx8IHQpLCBuIH0sIGQuc29ydFN0YWJsZSA9IGsuc3BsaXQoXCJcIikuc29ydChEKS5qb2luKFwiXCIpID09PSBrLCBkLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIFQoKSwgZC5zb3J0RGV0YWNoZWQgPSBjZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gMSAmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oQy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpIH0pLCBjZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIiwgXCIjXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIH0pIHx8IGZlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiAoZSwgdCwgbikgeyBpZiAoIW4pIHJldHVybiBlLmdldEF0dHJpYnV0ZSh0LCBcInR5cGVcIiA9PT0gdC50b0xvd2VyQ2FzZSgpID8gMSA6IDIpIH0pLCBkLmF0dHJpYnV0ZXMgJiYgY2UoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiLCBlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIiksIFwiXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB9KSB8fCBmZShcInZhbHVlXCIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IGlmICghbiAmJiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgcmV0dXJuIGUuZGVmYXVsdFZhbHVlIH0pLCBjZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gbnVsbCA9PSBlLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpIH0pIHx8IGZlKFIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByOyBpZiAoIW4pIHJldHVybiAhMCA9PT0gZVt0XSA/IHQudG9Mb3dlckNhc2UoKSA6IChyID0gZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSAmJiByLnNwZWNpZmllZCA/IHIudmFsdWUgOiBudWxsIH0pLCBzZSB9KEMpOyBrLmZpbmQgPSBoLCBrLmV4cHIgPSBoLnNlbGVjdG9ycywgay5leHByW1wiOlwiXSA9IGsuZXhwci5wc2V1ZG9zLCBrLnVuaXF1ZVNvcnQgPSBrLnVuaXF1ZSA9IGgudW5pcXVlU29ydCwgay50ZXh0ID0gaC5nZXRUZXh0LCBrLmlzWE1MRG9jID0gaC5pc1hNTCwgay5jb250YWlucyA9IGguY29udGFpbnMsIGsuZXNjYXBlU2VsZWN0b3IgPSBoLmVzY2FwZTsgdmFyIFQgPSBmdW5jdGlvbiAoZSwgdCwgbikgeyB2YXIgciA9IFtdLCBpID0gdm9pZCAwICE9PSBuOyB3aGlsZSAoKGUgPSBlW3RdKSAmJiA5ICE9PSBlLm5vZGVUeXBlKSBpZiAoMSA9PT0gZS5ub2RlVHlwZSkgeyBpZiAoaSAmJiBrKGUpLmlzKG4pKSBicmVhazsgci5wdXNoKGUpIH0gcmV0dXJuIHIgfSwgUyA9IGZ1bmN0aW9uIChlLCB0KSB7IGZvciAodmFyIG4gPSBbXTsgZTsgZSA9IGUubmV4dFNpYmxpbmcpMSA9PT0gZS5ub2RlVHlwZSAmJiBlICE9PSB0ICYmIG4ucHVzaChlKTsgcmV0dXJuIG4gfSwgTiA9IGsuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7IGZ1bmN0aW9uIEEoZSwgdCkgeyByZXR1cm4gZS5ub2RlTmFtZSAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHQudG9Mb3dlckNhc2UoKSB9IHZhciBEID0gL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2k7IGZ1bmN0aW9uIGooZSwgbiwgcikgeyByZXR1cm4gbShuKSA/IGsuZ3JlcChlLCBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gISFuLmNhbGwoZSwgdCwgZSkgIT09IHIgfSkgOiBuLm5vZGVUeXBlID8gay5ncmVwKGUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID09PSBuICE9PSByIH0pIDogXCJzdHJpbmdcIiAhPSB0eXBlb2YgbiA/IGsuZ3JlcChlLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gLTEgPCBpLmNhbGwobiwgZSkgIT09IHIgfSkgOiBrLmZpbHRlcihuLCBlLCByKSB9IGsuZmlsdGVyID0gZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIgPSB0WzBdOyByZXR1cm4gbiAmJiAoZSA9IFwiOm5vdChcIiArIGUgKyBcIilcIiksIDEgPT09IHQubGVuZ3RoICYmIDEgPT09IHIubm9kZVR5cGUgPyBrLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHIsIGUpID8gW3JdIDogW10gOiBrLmZpbmQubWF0Y2hlcyhlLCBrLmdyZXAodCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDEgPT09IGUubm9kZVR5cGUgfSkpIH0sIGsuZm4uZXh0ZW5kKHsgZmluZDogZnVuY3Rpb24gKGUpIHsgdmFyIHQsIG4sIHIgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXM7IGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gdGhpcy5wdXNoU3RhY2soayhlKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyBmb3IgKHQgPSAwOyB0IDwgcjsgdCsrKWlmIChrLmNvbnRhaW5zKGlbdF0sIHRoaXMpKSByZXR1cm4gITAgfSkpOyBmb3IgKG4gPSB0aGlzLnB1c2hTdGFjayhbXSksIHQgPSAwOyB0IDwgcjsgdCsrKWsuZmluZChlLCBpW3RdLCBuKTsgcmV0dXJuIDEgPCByID8gay51bmlxdWVTb3J0KG4pIDogbiB9LCBmaWx0ZXI6IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhqKHRoaXMsIGUgfHwgW10sICExKSkgfSwgbm90OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcy5wdXNoU3RhY2soaih0aGlzLCBlIHx8IFtdLCAhMCkpIH0sIGlzOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gISFqKHRoaXMsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgTi50ZXN0KGUpID8gayhlKSA6IGUgfHwgW10sICExKS5sZW5ndGggfSB9KTsgdmFyIHEsIEwgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLzsgKGsuZm4uaW5pdCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpOyBpZiAoIWUpIHJldHVybiB0aGlzOyBpZiAobiA9IG4gfHwgcSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgeyBpZiAoIShyID0gXCI8XCIgPT09IGVbMF0gJiYgXCI+XCIgPT09IGVbZS5sZW5ndGggLSAxXSAmJiAzIDw9IGUubGVuZ3RoID8gW251bGwsIGUsIG51bGxdIDogTC5leGVjKGUpKSB8fCAhclsxXSAmJiB0KSByZXR1cm4gIXQgfHwgdC5qcXVlcnkgPyAodCB8fCBuKS5maW5kKGUpIDogdGhpcy5jb25zdHJ1Y3Rvcih0KS5maW5kKGUpOyBpZiAoclsxXSkgeyBpZiAodCA9IHQgaW5zdGFuY2VvZiBrID8gdFswXSA6IHQsIGsubWVyZ2UodGhpcywgay5wYXJzZUhUTUwoclsxXSwgdCAmJiB0Lm5vZGVUeXBlID8gdC5vd25lckRvY3VtZW50IHx8IHQgOiBFLCAhMCkpLCBELnRlc3QoclsxXSkgJiYgay5pc1BsYWluT2JqZWN0KHQpKSBmb3IgKHIgaW4gdCkgbSh0aGlzW3JdKSA/IHRoaXNbcl0odFtyXSkgOiB0aGlzLmF0dHIociwgdFtyXSk7IHJldHVybiB0aGlzIH0gcmV0dXJuIChpID0gRS5nZXRFbGVtZW50QnlJZChyWzJdKSkgJiYgKHRoaXNbMF0gPSBpLCB0aGlzLmxlbmd0aCA9IDEpLCB0aGlzIH0gcmV0dXJuIGUubm9kZVR5cGUgPyAodGhpc1swXSA9IGUsIHRoaXMubGVuZ3RoID0gMSwgdGhpcykgOiBtKGUpID8gdm9pZCAwICE9PSBuLnJlYWR5ID8gbi5yZWFkeShlKSA6IGUoaykgOiBrLm1ha2VBcnJheShlLCB0aGlzKSB9KS5wcm90b3R5cGUgPSBrLmZuLCBxID0gayhFKTsgdmFyIEggPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLywgTyA9IHsgY2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMCB9OyBmdW5jdGlvbiBQKGUsIHQpIHsgd2hpbGUgKChlID0gZVt0XSkgJiYgMSAhPT0gZS5ub2RlVHlwZSk7IHJldHVybiBlIH0gay5mbi5leHRlbmQoeyBoYXM6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gayhlLCB0aGlzKSwgbiA9IHQubGVuZ3RoOyByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBlID0gMDsgZSA8IG47IGUrKylpZiAoay5jb250YWlucyh0aGlzLCB0W2VdKSkgcmV0dXJuICEwIH0pIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCByID0gMCwgaSA9IHRoaXMubGVuZ3RoLCBvID0gW10sIGEgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIGsoZSk7IGlmICghTi50ZXN0KGUpKSBmb3IgKDsgciA8IGk7IHIrKylmb3IgKG4gPSB0aGlzW3JdOyBuICYmIG4gIT09IHQ7IG4gPSBuLnBhcmVudE5vZGUpaWYgKG4ubm9kZVR5cGUgPCAxMSAmJiAoYSA/IC0xIDwgYS5pbmRleChuKSA6IDEgPT09IG4ubm9kZVR5cGUgJiYgay5maW5kLm1hdGNoZXNTZWxlY3RvcihuLCBlKSkpIHsgby5wdXNoKG4pOyBicmVhayB9IHJldHVybiB0aGlzLnB1c2hTdGFjaygxIDwgby5sZW5ndGggPyBrLnVuaXF1ZVNvcnQobykgOiBvKSB9LCBpbmRleDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gaS5jYWxsKGsoZSksIHRoaXNbMF0pIDogaS5jYWxsKHRoaXMsIGUuanF1ZXJ5ID8gZVswXSA6IGUpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xIH0sIGFkZDogZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGsudW5pcXVlU29ydChrLm1lcmdlKHRoaXMuZ2V0KCksIGsoZSwgdCkpKSkgfSwgYWRkQmFjazogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuYWRkKG51bGwgPT0gZSA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpIH0gfSksIGsuZWFjaCh7IHBhcmVudDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlLnBhcmVudE5vZGU7IHJldHVybiB0ICYmIDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IG51bGwgfSwgcGFyZW50czogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFQoZSwgXCJwYXJlbnROb2RlXCIpIH0sIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIFQoZSwgXCJwYXJlbnROb2RlXCIsIG4pIH0sIG5leHQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBQKGUsIFwibmV4dFNpYmxpbmdcIikgfSwgcHJldjogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFAoZSwgXCJwcmV2aW91c1NpYmxpbmdcIikgfSwgbmV4dEFsbDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFQoZSwgXCJuZXh0U2libGluZ1wiKSB9LCBwcmV2QWxsOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gVChlLCBcInByZXZpb3VzU2libGluZ1wiKSB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiBUKGUsIFwibmV4dFNpYmxpbmdcIiwgbikgfSwgcHJldlVudGlsOiBmdW5jdGlvbiAoZSwgdCwgbikgeyByZXR1cm4gVChlLCBcInByZXZpb3VzU2libGluZ1wiLCBuKSB9LCBzaWJsaW5nczogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFMoKGUucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgZSkgfSwgY2hpbGRyZW46IGZ1bmN0aW9uIChlKSB7IHJldHVybiBTKGUuZmlyc3RDaGlsZCkgfSwgY29udGVudHM6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLmNvbnRlbnREb2N1bWVudCA/IGUuY29udGVudERvY3VtZW50IDogKEEoZSwgXCJ0ZW1wbGF0ZVwiKSAmJiAoZSA9IGUuY29udGVudCB8fCBlKSwgay5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSkgfSB9LCBmdW5jdGlvbiAociwgaSkgeyBrLmZuW3JdID0gZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBrLm1hcCh0aGlzLCBpLCBlKTsgcmV0dXJuIFwiVW50aWxcIiAhPT0gci5zbGljZSgtNSkgJiYgKHQgPSBlKSwgdCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gay5maWx0ZXIodCwgbikpLCAxIDwgdGhpcy5sZW5ndGggJiYgKE9bcl0gfHwgay51bmlxdWVTb3J0KG4pLCBILnRlc3QocikgJiYgbi5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhuKSB9IH0pOyB2YXIgUiA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZzsgZnVuY3Rpb24gTShlKSB7IHJldHVybiBlIH0gZnVuY3Rpb24gSShlKSB7IHRocm93IGUgfSBmdW5jdGlvbiBXKGUsIHQsIG4sIHIpIHsgdmFyIGk7IHRyeSB7IGUgJiYgbShpID0gZS5wcm9taXNlKSA/IGkuY2FsbChlKS5kb25lKHQpLmZhaWwobikgOiBlICYmIG0oaSA9IGUudGhlbikgPyBpLmNhbGwoZSwgdCwgbikgOiB0LmFwcGx5KHZvaWQgMCwgW2VdLnNsaWNlKHIpKSB9IGNhdGNoIChlKSB7IG4uYXBwbHkodm9pZCAwLCBbZV0pIH0gfSBrLkNhbGxiYWNrcyA9IGZ1bmN0aW9uIChyKSB7IHZhciBlLCBuOyByID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgciA/IChlID0gciwgbiA9IHt9LCBrLmVhY2goZS5tYXRjaChSKSB8fCBbXSwgZnVuY3Rpb24gKGUsIHQpIHsgblt0XSA9ICEwIH0pLCBuKSA6IGsuZXh0ZW5kKHt9LCByKTsgdmFyIGksIHQsIG8sIGEsIHMgPSBbXSwgdSA9IFtdLCBsID0gLTEsIGMgPSBmdW5jdGlvbiAoKSB7IGZvciAoYSA9IGEgfHwgci5vbmNlLCBvID0gaSA9ICEwOyB1Lmxlbmd0aDsgbCA9IC0xKSB7IHQgPSB1LnNoaWZ0KCk7IHdoaWxlICgrK2wgPCBzLmxlbmd0aCkgITEgPT09IHNbbF0uYXBwbHkodFswXSwgdFsxXSkgJiYgci5zdG9wT25GYWxzZSAmJiAobCA9IHMubGVuZ3RoLCB0ID0gITEpIH0gci5tZW1vcnkgfHwgKHQgPSAhMSksIGkgPSAhMSwgYSAmJiAocyA9IHQgPyBbXSA6IFwiXCIpIH0sIGYgPSB7IGFkZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcyAmJiAodCAmJiAhaSAmJiAobCA9IHMubGVuZ3RoIC0gMSwgdS5wdXNoKHQpKSwgZnVuY3Rpb24gbihlKSB7IGsuZWFjaChlLCBmdW5jdGlvbiAoZSwgdCkgeyBtKHQpID8gci51bmlxdWUgJiYgZi5oYXModCkgfHwgcy5wdXNoKHQpIDogdCAmJiB0Lmxlbmd0aCAmJiBcInN0cmluZ1wiICE9PSB3KHQpICYmIG4odCkgfSkgfShhcmd1bWVudHMpLCB0ICYmICFpICYmIGMoKSksIHRoaXMgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBrLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbjsgd2hpbGUgKC0xIDwgKG4gPSBrLmluQXJyYXkodCwgcywgbikpKSBzLnNwbGljZShuLCAxKSwgbiA8PSBsICYmIGwtLSB9KSwgdGhpcyB9LCBoYXM6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID8gLTEgPCBrLmluQXJyYXkoZSwgcykgOiAwIDwgcy5sZW5ndGggfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHMgJiYgKHMgPSBbXSksIHRoaXMgfSwgZGlzYWJsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gYSA9IHUgPSBbXSwgcyA9IHQgPSBcIlwiLCB0aGlzIH0sIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAhcyB9LCBsb2NrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhID0gdSA9IFtdLCB0IHx8IGkgfHwgKHMgPSB0ID0gXCJcIiksIHRoaXMgfSwgbG9ja2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIWEgfSwgZmlyZVdpdGg6IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBhIHx8ICh0ID0gW2UsICh0ID0gdCB8fCBbXSkuc2xpY2UgPyB0LnNsaWNlKCkgOiB0XSwgdS5wdXNoKHQpLCBpIHx8IGMoKSksIHRoaXMgfSwgZmlyZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzIH0sIGZpcmVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIW8gfSB9OyByZXR1cm4gZiB9LCBrLmV4dGVuZCh7IERlZmVycmVkOiBmdW5jdGlvbiAoZSkgeyB2YXIgbyA9IFtbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBrLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgay5DYWxsYmFja3MoXCJtZW1vcnlcIiksIDJdLCBbXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBrLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBrLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAwLCBcInJlc29sdmVkXCJdLCBbXCJyZWplY3RcIiwgXCJmYWlsXCIsIGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDEsIFwicmVqZWN0ZWRcIl1dLCBpID0gXCJwZW5kaW5nXCIsIGEgPSB7IHN0YXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBpIH0sIGFsd2F5czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcy5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLCB0aGlzIH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGEudGhlbihudWxsLCBlKSB9LCBwaXBlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gYXJndW1lbnRzOyByZXR1cm4gay5EZWZlcnJlZChmdW5jdGlvbiAocikgeyBrLmVhY2gobywgZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBtKGlbdFs0XV0pICYmIGlbdFs0XV07IHNbdFsxXV0oZnVuY3Rpb24gKCkgeyB2YXIgZSA9IG4gJiYgbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyBlICYmIG0oZS5wcm9taXNlKSA/IGUucHJvbWlzZSgpLnByb2dyZXNzKHIubm90aWZ5KS5kb25lKHIucmVzb2x2ZSkuZmFpbChyLnJlamVjdCkgOiByW3RbMF0gKyBcIldpdGhcIl0odGhpcywgbiA/IFtlXSA6IGFyZ3VtZW50cykgfSkgfSksIGkgPSBudWxsIH0pLnByb21pc2UoKSB9LCB0aGVuOiBmdW5jdGlvbiAodCwgbiwgcikgeyB2YXIgdSA9IDA7IGZ1bmN0aW9uIGwoaSwgbywgYSwgcykgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgbiA9IHRoaXMsIHIgPSBhcmd1bWVudHMsIGUgPSBmdW5jdGlvbiAoKSB7IHZhciBlLCB0OyBpZiAoIShpIDwgdSkpIHsgaWYgKChlID0gYS5hcHBseShuLCByKSkgPT09IG8ucHJvbWlzZSgpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpOyB0ID0gZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpICYmIGUudGhlbiwgbSh0KSA/IHMgPyB0LmNhbGwoZSwgbCh1LCBvLCBNLCBzKSwgbCh1LCBvLCBJLCBzKSkgOiAodSsrICwgdC5jYWxsKGUsIGwodSwgbywgTSwgcyksIGwodSwgbywgSSwgcyksIGwodSwgbywgTSwgby5ub3RpZnlXaXRoKSkpIDogKGEgIT09IE0gJiYgKG4gPSB2b2lkIDAsIHIgPSBbZV0pLCAocyB8fCBvLnJlc29sdmVXaXRoKShuLCByKSkgfSB9LCB0ID0gcyA/IGUgOiBmdW5jdGlvbiAoKSB7IHRyeSB7IGUoKSB9IGNhdGNoIChlKSB7IGsuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayAmJiBrLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSwgdC5zdGFja1RyYWNlKSwgdSA8PSBpICsgMSAmJiAoYSAhPT0gSSAmJiAobiA9IHZvaWQgMCwgciA9IFtlXSksIG8ucmVqZWN0V2l0aChuLCByKSkgfSB9OyBpID8gdCgpIDogKGsuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICYmICh0LnN0YWNrVHJhY2UgPSBrLkRlZmVycmVkLmdldFN0YWNrSG9vaygpKSwgQy5zZXRUaW1lb3V0KHQpKSB9IH0gcmV0dXJuIGsuRGVmZXJyZWQoZnVuY3Rpb24gKGUpIHsgb1swXVszXS5hZGQobCgwLCBlLCBtKHIpID8gciA6IE0sIGUubm90aWZ5V2l0aCkpLCBvWzFdWzNdLmFkZChsKDAsIGUsIG0odCkgPyB0IDogTSkpLCBvWzJdWzNdLmFkZChsKDAsIGUsIG0obikgPyBuIDogSSkpIH0pLnByb21pc2UoKSB9LCBwcm9taXNlOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gbnVsbCAhPSBlID8gay5leHRlbmQoZSwgYSkgOiBhIH0gfSwgcyA9IHt9OyByZXR1cm4gay5lYWNoKG8sIGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuID0gdFsyXSwgciA9IHRbNV07IGFbdFsxXV0gPSBuLmFkZCwgciAmJiBuLmFkZChmdW5jdGlvbiAoKSB7IGkgPSByIH0sIG9bMyAtIGVdWzJdLmRpc2FibGUsIG9bMyAtIGVdWzNdLmRpc2FibGUsIG9bMF1bMl0ubG9jaywgb1swXVszXS5sb2NrKSwgbi5hZGQodFszXS5maXJlKSwgc1t0WzBdXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNbdFswXSArIFwiV2l0aFwiXSh0aGlzID09PSBzID8gdm9pZCAwIDogdGhpcywgYXJndW1lbnRzKSwgdGhpcyB9LCBzW3RbMF0gKyBcIldpdGhcIl0gPSBuLmZpcmVXaXRoIH0pLCBhLnByb21pc2UocyksIGUgJiYgZS5jYWxsKHMsIHMpLCBzIH0sIHdoZW46IGZ1bmN0aW9uIChlKSB7IHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG4sIHIgPSBBcnJheSh0KSwgaSA9IHMuY2FsbChhcmd1bWVudHMpLCBvID0gay5EZWZlcnJlZCgpLCBhID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHJbdF0gPSB0aGlzLCBpW3RdID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBzLmNhbGwoYXJndW1lbnRzKSA6IGUsIC0tbiB8fCBvLnJlc29sdmVXaXRoKHIsIGkpIH0gfTsgaWYgKG4gPD0gMSAmJiAoVyhlLCBvLmRvbmUoYSh0KSkucmVzb2x2ZSwgby5yZWplY3QsICFuKSwgXCJwZW5kaW5nXCIgPT09IG8uc3RhdGUoKSB8fCBtKGlbdF0gJiYgaVt0XS50aGVuKSkpIHJldHVybiBvLnRoZW4oKTsgd2hpbGUgKHQtLSkgVyhpW3RdLCBhKHQpLCBvLnJlamVjdCk7IHJldHVybiBvLnByb21pc2UoKSB9IH0pOyB2YXIgJCA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvOyBrLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiAoZSwgdCkgeyBDLmNvbnNvbGUgJiYgQy5jb25zb2xlLndhcm4gJiYgZSAmJiAkLnRlc3QoZS5uYW1lKSAmJiBDLmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZS5tZXNzYWdlLCBlLnN0YWNrLCB0KSB9LCBrLnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24gKGUpIHsgQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZSB9KSB9OyB2YXIgRiA9IGsuRGVmZXJyZWQoKTsgZnVuY3Rpb24gQigpIHsgRS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBCKSwgQy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBCKSwgay5yZWFkeSgpIH0gay5mbi5yZWFkeSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBGLnRoZW4oZSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkgeyBrLnJlYWR5RXhjZXB0aW9uKGUpIH0pLCB0aGlzIH0sIGsuZXh0ZW5kKHsgaXNSZWFkeTogITEsIHJlYWR5V2FpdDogMSwgcmVhZHk6IGZ1bmN0aW9uIChlKSB7ICghMCA9PT0gZSA/IC0tay5yZWFkeVdhaXQgOiBrLmlzUmVhZHkpIHx8IChrLmlzUmVhZHkgPSAhMCkgIT09IGUgJiYgMCA8IC0tay5yZWFkeVdhaXQgfHwgRi5yZXNvbHZlV2l0aChFLCBba10pIH0gfSksIGsucmVhZHkudGhlbiA9IEYudGhlbiwgXCJjb21wbGV0ZVwiID09PSBFLnJlYWR5U3RhdGUgfHwgXCJsb2FkaW5nXCIgIT09IEUucmVhZHlTdGF0ZSAmJiAhRS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBDLnNldFRpbWVvdXQoay5yZWFkeSkgOiAoRS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBCKSwgQy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBCKSk7IHZhciBfID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGksIG8sIGEpIHsgdmFyIHMgPSAwLCB1ID0gZS5sZW5ndGgsIGwgPSBudWxsID09IG47IGlmIChcIm9iamVjdFwiID09PSB3KG4pKSBmb3IgKHMgaW4gaSA9ICEwLCBuKSBfKGUsIHQsIHMsIG5bc10sICEwLCBvLCBhKTsgZWxzZSBpZiAodm9pZCAwICE9PSByICYmIChpID0gITAsIG0ocikgfHwgKGEgPSAhMCksIGwgJiYgKGEgPyAodC5jYWxsKGUsIHIpLCB0ID0gbnVsbCkgOiAobCA9IHQsIHQgPSBmdW5jdGlvbiAoZSwgdCwgbikgeyByZXR1cm4gbC5jYWxsKGsoZSksIG4pIH0pKSwgdCkpIGZvciAoOyBzIDwgdTsgcysrKXQoZVtzXSwgbiwgYSA/IHIgOiByLmNhbGwoZVtzXSwgcywgdChlW3NdLCBuKSkpOyByZXR1cm4gaSA/IGUgOiBsID8gdC5jYWxsKGUpIDogdSA/IHQoZVswXSwgbikgOiBvIH0sIHogPSAvXi1tcy0vLCBVID0gLy0oW2Etel0pL2c7IGZ1bmN0aW9uIFgoZSwgdCkgeyByZXR1cm4gdC50b1VwcGVyQ2FzZSgpIH0gZnVuY3Rpb24gVihlKSB7IHJldHVybiBlLnJlcGxhY2UoeiwgXCJtcy1cIikucmVwbGFjZShVLCBYKSB9IHZhciBHID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDEgPT09IGUubm9kZVR5cGUgfHwgOSA9PT0gZS5ub2RlVHlwZSB8fCAhK2Uubm9kZVR5cGUgfTsgZnVuY3Rpb24gWSgpIHsgdGhpcy5leHBhbmRvID0gay5leHBhbmRvICsgWS51aWQrKyB9IFkudWlkID0gMSwgWS5wcm90b3R5cGUgPSB7IGNhY2hlOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGVbdGhpcy5leHBhbmRvXTsgcmV0dXJuIHQgfHwgKHQgPSB7fSwgRyhlKSAmJiAoZS5ub2RlVHlwZSA/IGVbdGhpcy5leHBhbmRvXSA9IHQgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdGhpcy5leHBhbmRvLCB7IHZhbHVlOiB0LCBjb25maWd1cmFibGU6ICEwIH0pKSksIHQgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikgeyB2YXIgciwgaSA9IHRoaXMuY2FjaGUoZSk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSBpW1YodCldID0gbjsgZWxzZSBmb3IgKHIgaW4gdCkgaVtWKHIpXSA9IHRbcl07IHJldHVybiBpIH0sIGdldDogZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHZvaWQgMCA9PT0gdCA/IHRoaXMuY2FjaGUoZSkgOiBlW3RoaXMuZXhwYW5kb10gJiYgZVt0aGlzLmV4cGFuZG9dW1YodCldIH0sIGFjY2VzczogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIHZvaWQgMCA9PT0gdCB8fCB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdm9pZCAwID09PSBuID8gdGhpcy5nZXQoZSwgdCkgOiAodGhpcy5zZXQoZSwgdCwgbiksIHZvaWQgMCAhPT0gbiA/IG4gOiB0KSB9LCByZW1vdmU6IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCByID0gZVt0aGlzLmV4cGFuZG9dOyBpZiAodm9pZCAwICE9PSByKSB7IGlmICh2b2lkIDAgIT09IHQpIHsgbiA9ICh0ID0gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKFYpIDogKHQgPSBWKHQpKSBpbiByID8gW3RdIDogdC5tYXRjaChSKSB8fCBbXSkubGVuZ3RoOyB3aGlsZSAobi0tKSBkZWxldGUgclt0W25dXSB9ICh2b2lkIDAgPT09IHQgfHwgay5pc0VtcHR5T2JqZWN0KHIpKSAmJiAoZS5ub2RlVHlwZSA/IGVbdGhpcy5leHBhbmRvXSA9IHZvaWQgMCA6IGRlbGV0ZSBlW3RoaXMuZXhwYW5kb10pIH0gfSwgaGFzRGF0YTogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlW3RoaXMuZXhwYW5kb107IHJldHVybiB2b2lkIDAgIT09IHQgJiYgIWsuaXNFbXB0eU9iamVjdCh0KSB9IH07IHZhciBRID0gbmV3IFksIEogPSBuZXcgWSwgSyA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLywgWiA9IC9bQS1aXS9nOyBmdW5jdGlvbiBlZShlLCB0LCBuKSB7IHZhciByLCBpOyBpZiAodm9pZCAwID09PSBuICYmIDEgPT09IGUubm9kZVR5cGUpIGlmIChyID0gXCJkYXRhLVwiICsgdC5yZXBsYWNlKFosIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCksIFwic3RyaW5nXCIgPT0gdHlwZW9mIChuID0gZS5nZXRBdHRyaWJ1dGUocikpKSB7IHRyeSB7IG4gPSBcInRydWVcIiA9PT0gKGkgPSBuKSB8fCBcImZhbHNlXCIgIT09IGkgJiYgKFwibnVsbFwiID09PSBpID8gbnVsbCA6IGkgPT09ICtpICsgXCJcIiA/ICtpIDogSy50ZXN0KGkpID8gSlNPTi5wYXJzZShpKSA6IGkpIH0gY2F0Y2ggKGUpIHsgfSBKLnNldChlLCB0LCBuKSB9IGVsc2UgbiA9IHZvaWQgMDsgcmV0dXJuIG4gfSBrLmV4dGVuZCh7IGhhc0RhdGE6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBKLmhhc0RhdGEoZSkgfHwgUS5oYXNEYXRhKGUpIH0sIGRhdGE6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiBKLmFjY2VzcyhlLCB0LCBuKSB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSwgdCkgeyBKLnJlbW92ZShlLCB0KSB9LCBfZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIFEuYWNjZXNzKGUsIHQsIG4pIH0sIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSwgdCkgeyBRLnJlbW92ZShlLCB0KSB9IH0pLCBrLmZuLmV4dGVuZCh7IGRhdGE6IGZ1bmN0aW9uIChuLCBlKSB7IHZhciB0LCByLCBpLCBvID0gdGhpc1swXSwgYSA9IG8gJiYgby5hdHRyaWJ1dGVzOyBpZiAodm9pZCAwID09PSBuKSB7IGlmICh0aGlzLmxlbmd0aCAmJiAoaSA9IEouZ2V0KG8pLCAxID09PSBvLm5vZGVUeXBlICYmICFRLmdldChvLCBcImhhc0RhdGFBdHRyc1wiKSkpIHsgdCA9IGEubGVuZ3RoOyB3aGlsZSAodC0tKSBhW3RdICYmIDAgPT09IChyID0gYVt0XS5uYW1lKS5pbmRleE9mKFwiZGF0YS1cIikgJiYgKHIgPSBWKHIuc2xpY2UoNSkpLCBlZShvLCByLCBpW3JdKSk7IFEuc2V0KG8sIFwiaGFzRGF0YUF0dHJzXCIsICEwKSB9IHJldHVybiBpIH0gcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBKLnNldCh0aGlzLCBuKSB9KSA6IF8odGhpcywgZnVuY3Rpb24gKGUpIHsgdmFyIHQ7IGlmIChvICYmIHZvaWQgMCA9PT0gZSkgcmV0dXJuIHZvaWQgMCAhPT0gKHQgPSBKLmdldChvLCBuKSkgPyB0IDogdm9pZCAwICE9PSAodCA9IGVlKG8sIG4pKSA/IHQgOiB2b2lkIDA7IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IEouc2V0KHRoaXMsIG4sIGUpIH0pIH0sIG51bGwsIGUsIDEgPCBhcmd1bWVudHMubGVuZ3RoLCBudWxsLCAhMCkgfSwgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IEoucmVtb3ZlKHRoaXMsIGUpIH0pIH0gfSksIGsuZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByOyBpZiAoZSkgcmV0dXJuIHQgPSAodCB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiLCByID0gUS5nZXQoZSwgdCksIG4gJiYgKCFyIHx8IEFycmF5LmlzQXJyYXkobikgPyByID0gUS5hY2Nlc3MoZSwgdCwgay5tYWtlQXJyYXkobikpIDogci5wdXNoKG4pKSwgciB8fCBbXSB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSwgdCkgeyB0ID0gdCB8fCBcImZ4XCI7IHZhciBuID0gay5xdWV1ZShlLCB0KSwgciA9IG4ubGVuZ3RoLCBpID0gbi5zaGlmdCgpLCBvID0gay5fcXVldWVIb29rcyhlLCB0KTsgXCJpbnByb2dyZXNzXCIgPT09IGkgJiYgKGkgPSBuLnNoaWZ0KCksIHItLSksIGkgJiYgKFwiZnhcIiA9PT0gdCAmJiBuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLCBkZWxldGUgby5zdG9wLCBpLmNhbGwoZSwgZnVuY3Rpb24gKCkgeyBrLmRlcXVldWUoZSwgdCkgfSwgbykpLCAhciAmJiBvICYmIG8uZW1wdHkuZmlyZSgpIH0sIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiA9IHQgKyBcInF1ZXVlSG9va3NcIjsgcmV0dXJuIFEuZ2V0KGUsIG4pIHx8IFEuYWNjZXNzKGUsIG4sIHsgZW1wdHk6IGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uICgpIHsgUS5yZW1vdmUoZSwgW3QgKyBcInF1ZXVlXCIsIG5dKSB9KSB9KSB9IH0pLCBrLmZuLmV4dGVuZCh7IHF1ZXVlOiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IDI7IHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9IFwiZnhcIiwgZS0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGUgPyBrLnF1ZXVlKHRoaXNbMF0sIHQpIDogdm9pZCAwID09PSBuID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHZhciBlID0gay5xdWV1ZSh0aGlzLCB0LCBuKTsgay5fcXVldWVIb29rcyh0aGlzLCB0KSwgXCJmeFwiID09PSB0ICYmIFwiaW5wcm9ncmVzc1wiICE9PSBlWzBdICYmIGsuZGVxdWV1ZSh0aGlzLCB0KSB9KSB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgay5kZXF1ZXVlKHRoaXMsIGUpIH0pIH0sIGNsZWFyUXVldWU6IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLnF1ZXVlKGUgfHwgXCJmeFwiLCBbXSkgfSwgcHJvbWlzZTogZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4sIHIgPSAxLCBpID0gay5EZWZlcnJlZCgpLCBvID0gdGhpcywgYSA9IHRoaXMubGVuZ3RoLCBzID0gZnVuY3Rpb24gKCkgeyAtLXIgfHwgaS5yZXNvbHZlV2l0aChvLCBbb10pIH07IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgZSA9IGUgfHwgXCJmeFwiOyB3aGlsZSAoYS0tKSAobiA9IFEuZ2V0KG9bYV0sIGUgKyBcInF1ZXVlSG9va3NcIikpICYmIG4uZW1wdHkgJiYgKHIrKyAsIG4uZW1wdHkuYWRkKHMpKTsgcmV0dXJuIHMoKSwgaS5wcm9taXNlKHQpIH0gfSk7IHZhciB0ZSA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSwgbmUgPSBuZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIiArIHRlICsgXCIpKFthLXolXSopJFwiLCBcImlcIiksIHJlID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLCBpZSA9IEUuZG9jdW1lbnRFbGVtZW50LCBvZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBrLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSkgfSwgYWUgPSB7IGNvbXBvc2VkOiAhMCB9OyBpZS5nZXRSb290Tm9kZSAmJiAob2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gay5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpIHx8IGUuZ2V0Um9vdE5vZGUoYWUpID09PSBlLm93bmVyRG9jdW1lbnQgfSk7IHZhciBzZSA9IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBcIm5vbmVcIiA9PT0gKGUgPSB0IHx8IGUpLnN0eWxlLmRpc3BsYXkgfHwgXCJcIiA9PT0gZS5zdHlsZS5kaXNwbGF5ICYmIG9lKGUpICYmIFwibm9uZVwiID09PSBrLmNzcyhlLCBcImRpc3BsYXlcIikgfSwgdWUgPSBmdW5jdGlvbiAoZSwgdCwgbiwgcikgeyB2YXIgaSwgbywgYSA9IHt9OyBmb3IgKG8gaW4gdCkgYVtvXSA9IGUuc3R5bGVbb10sIGUuc3R5bGVbb10gPSB0W29dOyBmb3IgKG8gaW4gaSA9IG4uYXBwbHkoZSwgciB8fCBbXSksIHQpIGUuc3R5bGVbb10gPSBhW29dOyByZXR1cm4gaSB9OyBmdW5jdGlvbiBsZShlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhID0gMjAsIHMgPSByID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gci5jdXIoKSB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gay5jc3MoZSwgdCwgXCJcIikgfSwgdSA9IHMoKSwgbCA9IG4gJiYgblszXSB8fCAoay5jc3NOdW1iZXJbdF0gPyBcIlwiIDogXCJweFwiKSwgYyA9IGUubm9kZVR5cGUgJiYgKGsuY3NzTnVtYmVyW3RdIHx8IFwicHhcIiAhPT0gbCAmJiArdSkgJiYgbmUuZXhlYyhrLmNzcyhlLCB0KSk7IGlmIChjICYmIGNbM10gIT09IGwpIHsgdSAvPSAyLCBsID0gbCB8fCBjWzNdLCBjID0gK3UgfHwgMTsgd2hpbGUgKGEtLSkgay5zdHlsZShlLCB0LCBjICsgbCksICgxIC0gbykgKiAoMSAtIChvID0gcygpIC8gdSB8fCAuNSkpIDw9IDAgJiYgKGEgPSAwKSwgYyAvPSBvOyBjICo9IDIsIGsuc3R5bGUoZSwgdCwgYyArIGwpLCBuID0gbiB8fCBbXSB9IHJldHVybiBuICYmIChjID0gK2MgfHwgK3UgfHwgMCwgaSA9IG5bMV0gPyBjICsgKG5bMV0gKyAxKSAqIG5bMl0gOiArblsyXSwgciAmJiAoci51bml0ID0gbCwgci5zdGFydCA9IGMsIHIuZW5kID0gaSkpLCBpIH0gdmFyIGNlID0ge307IGZ1bmN0aW9uIGZlKGUsIHQpIHsgZm9yICh2YXIgbiwgciwgaSwgbywgYSwgcywgdSwgbCA9IFtdLCBjID0gMCwgZiA9IGUubGVuZ3RoOyBjIDwgZjsgYysrKShyID0gZVtjXSkuc3R5bGUgJiYgKG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAoXCJub25lXCIgPT09IG4gJiYgKGxbY10gPSBRLmdldChyLCBcImRpc3BsYXlcIikgfHwgbnVsbCwgbFtjXSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIikpLCBcIlwiID09PSByLnN0eWxlLmRpc3BsYXkgJiYgc2UocikgJiYgKGxbY10gPSAodSA9IGEgPSBvID0gdm9pZCAwLCBhID0gKGkgPSByKS5vd25lckRvY3VtZW50LCBzID0gaS5ub2RlTmFtZSwgKHUgPSBjZVtzXSkgfHwgKG8gPSBhLmJvZHkuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KHMpKSwgdSA9IGsuY3NzKG8sIFwiZGlzcGxheVwiKSwgby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLCBcIm5vbmVcIiA9PT0gdSAmJiAodSA9IFwiYmxvY2tcIiksIGNlW3NdID0gdSkpKSkgOiBcIm5vbmVcIiAhPT0gbiAmJiAobFtjXSA9IFwibm9uZVwiLCBRLnNldChyLCBcImRpc3BsYXlcIiwgbikpKTsgZm9yIChjID0gMDsgYyA8IGY7IGMrKyludWxsICE9IGxbY10gJiYgKGVbY10uc3R5bGUuZGlzcGxheSA9IGxbY10pOyByZXR1cm4gZSB9IGsuZm4uZXh0ZW5kKHsgc2hvdzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmUodGhpcywgITApIH0sIGhpZGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZlKHRoaXMpIH0sIHRvZ2dsZTogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiBlID8gZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBzZSh0aGlzKSA/IGsodGhpcykuc2hvdygpIDogayh0aGlzKS5oaWRlKCkgfSkgfSB9KTsgdmFyIHBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2ksIGRlID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pLCBoZSA9IC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksIGdlID0geyBvcHRpb246IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sIHRoZWFkOiBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sIGNvbDogWzIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLCB0cjogWzIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLCB0ZDogWzMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLCBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdIH07IGZ1bmN0aW9uIHZlKGUsIHQpIHsgdmFyIG47IHJldHVybiBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCB8fCBcIipcIikgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlLnF1ZXJ5U2VsZWN0b3JBbGwodCB8fCBcIipcIikgOiBbXSwgdm9pZCAwID09PSB0IHx8IHQgJiYgQShlLCB0KSA/IGsubWVyZ2UoW2VdLCBuKSA6IG4gfSBmdW5jdGlvbiB5ZShlLCB0KSB7IGZvciAodmFyIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspUS5zZXQoZVtuXSwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IFEuZ2V0KHRbbl0sIFwiZ2xvYmFsRXZhbFwiKSkgfSBnZS5vcHRncm91cCA9IGdlLm9wdGlvbiwgZ2UudGJvZHkgPSBnZS50Zm9vdCA9IGdlLmNvbGdyb3VwID0gZ2UuY2FwdGlvbiA9IGdlLnRoZWFkLCBnZS50aCA9IGdlLnRkOyB2YXIgbWUsIHhlLCBiZSA9IC88fCYjP1xcdys7LzsgZnVuY3Rpb24gd2UoZSwgdCwgbiwgciwgaSkgeyBmb3IgKHZhciBvLCBhLCBzLCB1LCBsLCBjLCBmID0gdC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHAgPSBbXSwgZCA9IDAsIGggPSBlLmxlbmd0aDsgZCA8IGg7IGQrKylpZiAoKG8gPSBlW2RdKSB8fCAwID09PSBvKSBpZiAoXCJvYmplY3RcIiA9PT0gdyhvKSkgay5tZXJnZShwLCBvLm5vZGVUeXBlID8gW29dIDogbyk7IGVsc2UgaWYgKGJlLnRlc3QobykpIHsgYSA9IGEgfHwgZi5hcHBlbmRDaGlsZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBzID0gKGRlLmV4ZWMobykgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCB1ID0gZ2Vbc10gfHwgZ2UuX2RlZmF1bHQsIGEuaW5uZXJIVE1MID0gdVsxXSArIGsuaHRtbFByZWZpbHRlcihvKSArIHVbMl0sIGMgPSB1WzBdOyB3aGlsZSAoYy0tKSBhID0gYS5sYXN0Q2hpbGQ7IGsubWVyZ2UocCwgYS5jaGlsZE5vZGVzKSwgKGEgPSBmLmZpcnN0Q2hpbGQpLnRleHRDb250ZW50ID0gXCJcIiB9IGVsc2UgcC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpOyBmLnRleHRDb250ZW50ID0gXCJcIiwgZCA9IDA7IHdoaWxlIChvID0gcFtkKytdKSBpZiAociAmJiAtMSA8IGsuaW5BcnJheShvLCByKSkgaSAmJiBpLnB1c2gobyk7IGVsc2UgaWYgKGwgPSBvZShvKSwgYSA9IHZlKGYuYXBwZW5kQ2hpbGQobyksIFwic2NyaXB0XCIpLCBsICYmIHllKGEpLCBuKSB7IGMgPSAwOyB3aGlsZSAobyA9IGFbYysrXSkgaGUudGVzdChvLnR5cGUgfHwgXCJcIikgJiYgbi5wdXNoKG8pIH0gcmV0dXJuIGYgfSBtZSA9IEUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSksICh4ZSA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIiksIHhlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpLCB4ZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKSwgbWUuYXBwZW5kQ2hpbGQoeGUpLCB5LmNoZWNrQ2xvbmUgPSBtZS5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIG1lLmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiLCB5Lm5vQ2xvbmVDaGVja2VkID0gISFtZS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7IHZhciBUZSA9IC9ea2V5LywgQ2UgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sIEVlID0gL14oW14uXSopKD86XFwuKC4rKXwpLzsgZnVuY3Rpb24ga2UoKSB7IHJldHVybiAhMCB9IGZ1bmN0aW9uIFNlKCkgeyByZXR1cm4gITEgfSBmdW5jdGlvbiBOZShlLCB0KSB7IHJldHVybiBlID09PSBmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiBFLmFjdGl2ZUVsZW1lbnQgfSBjYXRjaCAoZSkgeyB9IH0oKSA9PSAoXCJmb2N1c1wiID09PSB0KSB9IGZ1bmN0aW9uIEFlKGUsIHQsIG4sIHIsIGksIG8pIHsgdmFyIGEsIHM7IGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7IGZvciAocyBpbiBcInN0cmluZ1wiICE9IHR5cGVvZiBuICYmIChyID0gciB8fCBuLCBuID0gdm9pZCAwKSwgdCkgQWUoZSwgcywgbiwgciwgdFtzXSwgbyk7IHJldHVybiBlIH0gaWYgKG51bGwgPT0gciAmJiBudWxsID09IGkgPyAoaSA9IG4sIHIgPSBuID0gdm9pZCAwKSA6IG51bGwgPT0gaSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiA/IChpID0gciwgciA9IHZvaWQgMCkgOiAoaSA9IHIsIHIgPSBuLCBuID0gdm9pZCAwKSksICExID09PSBpKSBpID0gU2U7IGVsc2UgaWYgKCFpKSByZXR1cm4gZTsgcmV0dXJuIDEgPT09IG8gJiYgKGEgPSBpLCAoaSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBrKCkub2ZmKGUpLCBhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSkuZ3VpZCA9IGEuZ3VpZCB8fCAoYS5ndWlkID0gay5ndWlkKyspKSwgZS5lYWNoKGZ1bmN0aW9uICgpIHsgay5ldmVudC5hZGQodGhpcywgdCwgaSwgciwgbikgfSkgfSBmdW5jdGlvbiBEZShlLCBpLCBvKSB7IG8gPyAoUS5zZXQoZSwgaSwgITEpLCBrLmV2ZW50LmFkZChlLCBpLCB7IG5hbWVzcGFjZTogITEsIGhhbmRsZXI6IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuLCByID0gUS5nZXQodGhpcywgaSk7IGlmICgxICYgZS5pc1RyaWdnZXIgJiYgdGhpc1tpXSkgeyBpZiAoci5sZW5ndGgpIChrLmV2ZW50LnNwZWNpYWxbaV0gfHwge30pLmRlbGVnYXRlVHlwZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpOyBlbHNlIGlmIChyID0gcy5jYWxsKGFyZ3VtZW50cyksIFEuc2V0KHRoaXMsIGksIHIpLCB0ID0gbyh0aGlzLCBpKSwgdGhpc1tpXSgpLCByICE9PSAobiA9IFEuZ2V0KHRoaXMsIGkpKSB8fCB0ID8gUS5zZXQodGhpcywgaSwgITEpIDogbiA9IHt9LCByICE9PSBuKSByZXR1cm4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBuLnZhbHVlIH0gZWxzZSByLmxlbmd0aCAmJiAoUS5zZXQodGhpcywgaSwgeyB2YWx1ZTogay5ldmVudC50cmlnZ2VyKGsuZXh0ZW5kKHJbMF0sIGsuRXZlbnQucHJvdG90eXBlKSwgci5zbGljZSgxKSwgdGhpcykgfSksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpIH0gfSkpIDogdm9pZCAwID09PSBRLmdldChlLCBpKSAmJiBrLmV2ZW50LmFkZChlLCBpLCBrZSkgfSBrLmV2ZW50ID0geyBnbG9iYWw6IHt9LCBhZGQ6IGZ1bmN0aW9uICh0LCBlLCBuLCByLCBpKSB7IHZhciBvLCBhLCBzLCB1LCBsLCBjLCBmLCBwLCBkLCBoLCBnLCB2ID0gUS5nZXQodCk7IGlmICh2KSB7IG4uaGFuZGxlciAmJiAobiA9IChvID0gbikuaGFuZGxlciwgaSA9IG8uc2VsZWN0b3IpLCBpICYmIGsuZmluZC5tYXRjaGVzU2VsZWN0b3IoaWUsIGkpLCBuLmd1aWQgfHwgKG4uZ3VpZCA9IGsuZ3VpZCsrKSwgKHUgPSB2LmV2ZW50cykgfHwgKHUgPSB2LmV2ZW50cyA9IHt9KSwgKGEgPSB2LmhhbmRsZSkgfHwgKGEgPSB2LmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBrICYmIGsuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgPyBrLmV2ZW50LmRpc3BhdGNoLmFwcGx5KHQsIGFyZ3VtZW50cykgOiB2b2lkIDAgfSksIGwgPSAoZSA9IChlIHx8IFwiXCIpLm1hdGNoKFIpIHx8IFtcIlwiXSkubGVuZ3RoOyB3aGlsZSAobC0tKSBkID0gZyA9IChzID0gRWUuZXhlYyhlW2xdKSB8fCBbXSlbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkICYmIChmID0gay5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBkID0gKGkgPyBmLmRlbGVnYXRlVHlwZSA6IGYuYmluZFR5cGUpIHx8IGQsIGYgPSBrLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIGMgPSBrLmV4dGVuZCh7IHR5cGU6IGQsIG9yaWdUeXBlOiBnLCBkYXRhOiByLCBoYW5kbGVyOiBuLCBndWlkOiBuLmd1aWQsIHNlbGVjdG9yOiBpLCBuZWVkc0NvbnRleHQ6IGkgJiYgay5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGkpLCBuYW1lc3BhY2U6IGguam9pbihcIi5cIikgfSwgbyksIChwID0gdVtkXSkgfHwgKChwID0gdVtkXSA9IFtdKS5kZWxlZ2F0ZUNvdW50ID0gMCwgZi5zZXR1cCAmJiAhMSAhPT0gZi5zZXR1cC5jYWxsKHQsIHIsIGgsIGEpIHx8IHQuYWRkRXZlbnRMaXN0ZW5lciAmJiB0LmFkZEV2ZW50TGlzdGVuZXIoZCwgYSkpLCBmLmFkZCAmJiAoZi5hZGQuY2FsbCh0LCBjKSwgYy5oYW5kbGVyLmd1aWQgfHwgKGMuaGFuZGxlci5ndWlkID0gbi5ndWlkKSksIGkgPyBwLnNwbGljZShwLmRlbGVnYXRlQ291bnQrKywgMCwgYykgOiBwLnB1c2goYyksIGsuZXZlbnQuZ2xvYmFsW2RdID0gITApIH0gfSwgcmVtb3ZlOiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkgeyB2YXIgbywgYSwgcywgdSwgbCwgYywgZiwgcCwgZCwgaCwgZywgdiA9IFEuaGFzRGF0YShlKSAmJiBRLmdldChlKTsgaWYgKHYgJiYgKHUgPSB2LmV2ZW50cykpIHsgbCA9ICh0ID0gKHQgfHwgXCJcIikubWF0Y2goUikgfHwgW1wiXCJdKS5sZW5ndGg7IHdoaWxlIChsLS0pIGlmIChkID0gZyA9IChzID0gRWUuZXhlYyh0W2xdKSB8fCBbXSlbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkKSB7IGYgPSBrLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIHAgPSB1W2QgPSAociA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgZF0gfHwgW10sIHMgPSBzWzJdICYmIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGEgPSBvID0gcC5sZW5ndGg7IHdoaWxlIChvLS0pIGMgPSBwW29dLCAhaSAmJiBnICE9PSBjLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBjLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGMubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGMuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhYy5zZWxlY3RvcikgfHwgKHAuc3BsaWNlKG8sIDEpLCBjLnNlbGVjdG9yICYmIHAuZGVsZWdhdGVDb3VudC0tICwgZi5yZW1vdmUgJiYgZi5yZW1vdmUuY2FsbChlLCBjKSk7IGEgJiYgIXAubGVuZ3RoICYmIChmLnRlYXJkb3duICYmICExICE9PSBmLnRlYXJkb3duLmNhbGwoZSwgaCwgdi5oYW5kbGUpIHx8IGsucmVtb3ZlRXZlbnQoZSwgZCwgdi5oYW5kbGUpLCBkZWxldGUgdVtkXSkgfSBlbHNlIGZvciAoZCBpbiB1KSBrLmV2ZW50LnJlbW92ZShlLCBkICsgdFtsXSwgbiwgciwgITApOyBrLmlzRW1wdHlPYmplY3QodSkgJiYgUS5yZW1vdmUoZSwgXCJoYW5kbGUgZXZlbnRzXCIpIH0gfSwgZGlzcGF0Y2g6IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuLCByLCBpLCBvLCBhLCBzID0gay5ldmVudC5maXgoZSksIHUgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksIGwgPSAoUS5nZXQodGhpcywgXCJldmVudHNcIikgfHwge30pW3MudHlwZV0gfHwgW10sIGMgPSBrLmV2ZW50LnNwZWNpYWxbcy50eXBlXSB8fCB7fTsgZm9yICh1WzBdID0gcywgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspdVt0XSA9IGFyZ3VtZW50c1t0XTsgaWYgKHMuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhYy5wcmVEaXNwYXRjaCB8fCAhMSAhPT0gYy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIHMpKSB7IGEgPSBrLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgcywgbCksIHQgPSAwOyB3aGlsZSAoKGkgPSBhW3QrK10pICYmICFzLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHsgcy5jdXJyZW50VGFyZ2V0ID0gaS5lbGVtLCBuID0gMDsgd2hpbGUgKChvID0gaS5oYW5kbGVyc1tuKytdKSAmJiAhcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSBzLnJuYW1lc3BhY2UgJiYgITEgIT09IG8ubmFtZXNwYWNlICYmICFzLnJuYW1lc3BhY2UudGVzdChvLm5hbWVzcGFjZSkgfHwgKHMuaGFuZGxlT2JqID0gbywgcy5kYXRhID0gby5kYXRhLCB2b2lkIDAgIT09IChyID0gKChrLmV2ZW50LnNwZWNpYWxbby5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBvLmhhbmRsZXIpLmFwcGx5KGkuZWxlbSwgdSkpICYmICExID09PSAocy5yZXN1bHQgPSByKSAmJiAocy5wcmV2ZW50RGVmYXVsdCgpLCBzLnN0b3BQcm9wYWdhdGlvbigpKSkgfSByZXR1cm4gYy5wb3N0RGlzcGF0Y2ggJiYgYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBzKSwgcy5yZXN1bHQgfSB9LCBoYW5kbGVyczogZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4sIHIsIGksIG8sIGEsIHMgPSBbXSwgdSA9IHQuZGVsZWdhdGVDb3VudCwgbCA9IGUudGFyZ2V0OyBpZiAodSAmJiBsLm5vZGVUeXBlICYmICEoXCJjbGlja1wiID09PSBlLnR5cGUgJiYgMSA8PSBlLmJ1dHRvbikpIGZvciAoOyBsICE9PSB0aGlzOyBsID0gbC5wYXJlbnROb2RlIHx8IHRoaXMpaWYgKDEgPT09IGwubm9kZVR5cGUgJiYgKFwiY2xpY2tcIiAhPT0gZS50eXBlIHx8ICEwICE9PSBsLmRpc2FibGVkKSkgeyBmb3IgKG8gPSBbXSwgYSA9IHt9LCBuID0gMDsgbiA8IHU7IG4rKyl2b2lkIDAgPT09IGFbaSA9IChyID0gdFtuXSkuc2VsZWN0b3IgKyBcIiBcIl0gJiYgKGFbaV0gPSByLm5lZWRzQ29udGV4dCA/IC0xIDwgayhpLCB0aGlzKS5pbmRleChsKSA6IGsuZmluZChpLCB0aGlzLCBudWxsLCBbbF0pLmxlbmd0aCksIGFbaV0gJiYgby5wdXNoKHIpOyBvLmxlbmd0aCAmJiBzLnB1c2goeyBlbGVtOiBsLCBoYW5kbGVyczogbyB9KSB9IHJldHVybiBsID0gdGhpcywgdSA8IHQubGVuZ3RoICYmIHMucHVzaCh7IGVsZW06IGwsIGhhbmRsZXJzOiB0LnNsaWNlKHUpIH0pLCBzIH0sIGFkZFByb3A6IGZ1bmN0aW9uICh0LCBlKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrLkV2ZW50LnByb3RvdHlwZSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgZ2V0OiBtKGUpID8gZnVuY3Rpb24gKCkgeyBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSByZXR1cm4gZSh0aGlzLm9yaWdpbmFsRXZlbnQpIH0gOiBmdW5jdGlvbiAoKSB7IGlmICh0aGlzLm9yaWdpbmFsRXZlbnQpIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbdF0gfSwgc2V0OiBmdW5jdGlvbiAoZSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSB9IH0pIH0sIGZpeDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbay5leHBhbmRvXSA/IGUgOiBuZXcgay5FdmVudChlKSB9LCBzcGVjaWFsOiB7IGxvYWQ6IHsgbm9CdWJibGU6ICEwIH0sIGNsaWNrOiB7IHNldHVwOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IHRoaXMgfHwgZTsgcmV0dXJuIHBlLnRlc3QodC50eXBlKSAmJiB0LmNsaWNrICYmIEEodCwgXCJpbnB1dFwiKSAmJiBEZSh0LCBcImNsaWNrXCIsIGtlKSwgITEgfSwgdHJpZ2dlcjogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSB0aGlzIHx8IGU7IHJldHVybiBwZS50ZXN0KHQudHlwZSkgJiYgdC5jbGljayAmJiBBKHQsIFwiaW5wdXRcIikgJiYgRGUodCwgXCJjbGlja1wiKSwgITAgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gZS50YXJnZXQ7IHJldHVybiBwZS50ZXN0KHQudHlwZSkgJiYgdC5jbGljayAmJiBBKHQsIFwiaW5wdXRcIikgJiYgUS5nZXQodCwgXCJjbGlja1wiKSB8fCBBKHQsIFwiYVwiKSB9IH0sIGJlZm9yZXVubG9hZDogeyBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uIChlKSB7IHZvaWQgMCAhPT0gZS5yZXN1bHQgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIChlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBlLnJlc3VsdCkgfSB9IH0gfSwgay5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IGUucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbikgfSwgay5FdmVudCA9IGZ1bmN0aW9uIChlLCB0KSB7IGlmICghKHRoaXMgaW5zdGFuY2VvZiBrLkV2ZW50KSkgcmV0dXJuIG5ldyBrLkV2ZW50KGUsIHQpOyBlICYmIGUudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLCB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gZS5kZWZhdWx0UHJldmVudGVkICYmICExID09PSBlLnJldHVyblZhbHVlID8ga2UgOiBTZSwgdGhpcy50YXJnZXQgPSBlLnRhcmdldCAmJiAzID09PSBlLnRhcmdldC5ub2RlVHlwZSA/IGUudGFyZ2V0LnBhcmVudE5vZGUgOiBlLnRhcmdldCwgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LCB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQpIDogdGhpcy50eXBlID0gZSwgdCAmJiBrLmV4dGVuZCh0aGlzLCB0KSwgdGhpcy50aW1lU3RhbXAgPSBlICYmIGUudGltZVN0YW1wIHx8IERhdGUubm93KCksIHRoaXNbay5leHBhbmRvXSA9ICEwIH0sIGsuRXZlbnQucHJvdG90eXBlID0geyBjb25zdHJ1Y3Rvcjogay5FdmVudCwgaXNEZWZhdWx0UHJldmVudGVkOiBTZSwgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IFNlLCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogU2UsIGlzU2ltdWxhdGVkOiAhMSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0ga2UsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpIH0sIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkgeyB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDsgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGtlLCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGUuc3RvcFByb3BhZ2F0aW9uKCkgfSwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7IHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50OyB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0ga2UsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKSB9IH0sIGsuZWFjaCh7IGFsdEtleTogITAsIGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgY2hhbmdlZFRvdWNoZXM6ICEwLCBjdHJsS2V5OiAhMCwgZGV0YWlsOiAhMCwgZXZlbnRQaGFzZTogITAsIG1ldGFLZXk6ICEwLCBwYWdlWDogITAsIHBhZ2VZOiAhMCwgc2hpZnRLZXk6ICEwLCB2aWV3OiAhMCwgXCJjaGFyXCI6ICEwLCBjb2RlOiAhMCwgY2hhckNvZGU6ICEwLCBrZXk6ICEwLCBrZXlDb2RlOiAhMCwgYnV0dG9uOiAhMCwgYnV0dG9uczogITAsIGNsaWVudFg6ICEwLCBjbGllbnRZOiAhMCwgb2Zmc2V0WDogITAsIG9mZnNldFk6ICEwLCBwb2ludGVySWQ6ICEwLCBwb2ludGVyVHlwZTogITAsIHNjcmVlblg6ICEwLCBzY3JlZW5ZOiAhMCwgdGFyZ2V0VG91Y2hlczogITAsIHRvRWxlbWVudDogITAsIHRvdWNoZXM6ICEwLCB3aGljaDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlLmJ1dHRvbjsgcmV0dXJuIG51bGwgPT0gZS53aGljaCAmJiBUZS50ZXN0KGUudHlwZSkgPyBudWxsICE9IGUuY2hhckNvZGUgPyBlLmNoYXJDb2RlIDogZS5rZXlDb2RlIDogIWUud2hpY2ggJiYgdm9pZCAwICE9PSB0ICYmIENlLnRlc3QoZS50eXBlKSA/IDEgJiB0ID8gMSA6IDIgJiB0ID8gMyA6IDQgJiB0ID8gMiA6IDAgOiBlLndoaWNoIH0gfSwgay5ldmVudC5hZGRQcm9wKSwgay5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24gKGUsIHQpIHsgay5ldmVudC5zcGVjaWFsW2VdID0geyBzZXR1cDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGUodGhpcywgZSwgTmUpLCAhMSB9LCB0cmlnZ2VyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZSh0aGlzLCBlKSwgITAgfSwgZGVsZWdhdGVUeXBlOiB0IH0gfSksIGsuZWFjaCh7IG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIiwgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCIgfSwgZnVuY3Rpb24gKGUsIGkpIHsgay5ldmVudC5zcGVjaWFsW2VdID0geyBkZWxlZ2F0ZVR5cGU6IGksIGJpbmRUeXBlOiBpLCBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuID0gZS5yZWxhdGVkVGFyZ2V0LCByID0gZS5oYW5kbGVPYmo7IHJldHVybiBuICYmIChuID09PSB0aGlzIHx8IGsuY29udGFpbnModGhpcywgbikpIHx8IChlLnR5cGUgPSByLm9yaWdUeXBlLCB0ID0gci5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGUudHlwZSA9IGkpLCB0IH0gfSB9KSwgay5mbi5leHRlbmQoeyBvbjogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHsgcmV0dXJuIEFlKHRoaXMsIGUsIHQsIG4sIHIpIH0sIG9uZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHsgcmV0dXJuIEFlKHRoaXMsIGUsIHQsIG4sIHIsIDEpIH0sIG9mZjogZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIsIGk7IGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5oYW5kbGVPYmopIHJldHVybiByID0gZS5oYW5kbGVPYmosIGsoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKHIubmFtZXNwYWNlID8gci5vcmlnVHlwZSArIFwiLlwiICsgci5uYW1lc3BhY2UgOiByLm9yaWdUeXBlLCByLnNlbGVjdG9yLCByLmhhbmRsZXIpLCB0aGlzOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSkgeyBmb3IgKGkgaW4gZSkgdGhpcy5vZmYoaSwgdCwgZVtpXSk7IHJldHVybiB0aGlzIH0gcmV0dXJuICExICE9PSB0ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCB8fCAobiA9IHQsIHQgPSB2b2lkIDApLCAhMSA9PT0gbiAmJiAobiA9IFNlKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgay5ldmVudC5yZW1vdmUodGhpcywgZSwgbiwgdCkgfSkgfSB9KTsgdmFyIGplID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksIHFlID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksIExlID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSwgSGUgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7IGZ1bmN0aW9uIE9lKGUsIHQpIHsgcmV0dXJuIEEoZSwgXCJ0YWJsZVwiKSAmJiBBKDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IHQuZmlyc3RDaGlsZCwgXCJ0clwiKSAmJiBrKGUpLmNoaWxkcmVuKFwidGJvZHlcIilbMF0gfHwgZSB9IGZ1bmN0aW9uIFBlKGUpIHsgcmV0dXJuIGUudHlwZSA9IChudWxsICE9PSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpICsgXCIvXCIgKyBlLnR5cGUsIGUgfSBmdW5jdGlvbiBSZShlKSB7IHJldHVybiBcInRydWUvXCIgPT09IChlLnR5cGUgfHwgXCJcIikuc2xpY2UoMCwgNSkgPyBlLnR5cGUgPSBlLnR5cGUuc2xpY2UoNSkgOiBlLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksIGUgfSBmdW5jdGlvbiBNZShlLCB0KSB7IHZhciBuLCByLCBpLCBvLCBhLCBzLCB1LCBsOyBpZiAoMSA9PT0gdC5ub2RlVHlwZSkgeyBpZiAoUS5oYXNEYXRhKGUpICYmIChvID0gUS5hY2Nlc3MoZSksIGEgPSBRLnNldCh0LCBvKSwgbCA9IG8uZXZlbnRzKSkgZm9yIChpIGluIGRlbGV0ZSBhLmhhbmRsZSwgYS5ldmVudHMgPSB7fSwgbCkgZm9yIChuID0gMCwgciA9IGxbaV0ubGVuZ3RoOyBuIDwgcjsgbisrKWsuZXZlbnQuYWRkKHQsIGksIGxbaV1bbl0pOyBKLmhhc0RhdGEoZSkgJiYgKHMgPSBKLmFjY2VzcyhlKSwgdSA9IGsuZXh0ZW5kKHt9LCBzKSwgSi5zZXQodCwgdSkpIH0gfSBmdW5jdGlvbiBJZShuLCByLCBpLCBvKSB7IHIgPSBnLmFwcGx5KFtdLCByKTsgdmFyIGUsIHQsIGEsIHMsIHUsIGwsIGMgPSAwLCBmID0gbi5sZW5ndGgsIHAgPSBmIC0gMSwgZCA9IHJbMF0sIGggPSBtKGQpOyBpZiAoaCB8fCAxIDwgZiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkICYmICF5LmNoZWNrQ2xvbmUgJiYgTGUudGVzdChkKSkgcmV0dXJuIG4uZWFjaChmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IG4uZXEoZSk7IGggJiYgKHJbMF0gPSBkLmNhbGwodGhpcywgZSwgdC5odG1sKCkpKSwgSWUodCwgciwgaSwgbykgfSk7IGlmIChmICYmICh0ID0gKGUgPSB3ZShyLCBuWzBdLm93bmVyRG9jdW1lbnQsICExLCBuLCBvKSkuZmlyc3RDaGlsZCwgMSA9PT0gZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAoZSA9IHQpLCB0IHx8IG8pKSB7IGZvciAocyA9IChhID0gay5tYXAodmUoZSwgXCJzY3JpcHRcIiksIFBlKSkubGVuZ3RoOyBjIDwgZjsgYysrKXUgPSBlLCBjICE9PSBwICYmICh1ID0gay5jbG9uZSh1LCAhMCwgITApLCBzICYmIGsubWVyZ2UoYSwgdmUodSwgXCJzY3JpcHRcIikpKSwgaS5jYWxsKG5bY10sIHUsIGMpOyBpZiAocykgZm9yIChsID0gYVthLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIGsubWFwKGEsIFJlKSwgYyA9IDA7IGMgPCBzOyBjKyspdSA9IGFbY10sIGhlLnRlc3QodS50eXBlIHx8IFwiXCIpICYmICFRLmFjY2Vzcyh1LCBcImdsb2JhbEV2YWxcIikgJiYgay5jb250YWlucyhsLCB1KSAmJiAodS5zcmMgJiYgXCJtb2R1bGVcIiAhPT0gKHUudHlwZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID8gay5fZXZhbFVybCAmJiAhdS5ub01vZHVsZSAmJiBrLl9ldmFsVXJsKHUuc3JjLCB7IG5vbmNlOiB1Lm5vbmNlIHx8IHUuZ2V0QXR0cmlidXRlKFwibm9uY2VcIikgfSkgOiBiKHUudGV4dENvbnRlbnQucmVwbGFjZShIZSwgXCJcIiksIHUsIGwpKSB9IHJldHVybiBuIH0gZnVuY3Rpb24gV2UoZSwgdCwgbikgeyBmb3IgKHZhciByLCBpID0gdCA/IGsuZmlsdGVyKHQsIGUpIDogZSwgbyA9IDA7IG51bGwgIT0gKHIgPSBpW29dKTsgbysrKW4gfHwgMSAhPT0gci5ub2RlVHlwZSB8fCBrLmNsZWFuRGF0YSh2ZShyKSksIHIucGFyZW50Tm9kZSAmJiAobiAmJiBvZShyKSAmJiB5ZSh2ZShyLCBcInNjcmlwdFwiKSksIHIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyKSk7IHJldHVybiBlIH0gay5leHRlbmQoeyBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5yZXBsYWNlKGplLCBcIjwkMT48LyQyPlwiKSB9LCBjbG9uZTogZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8sIGEsIHMsIHUsIGwsIGMgPSBlLmNsb25lTm9kZSghMCksIGYgPSBvZShlKTsgaWYgKCEoeS5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBlLm5vZGVUeXBlICYmIDExICE9PSBlLm5vZGVUeXBlIHx8IGsuaXNYTUxEb2MoZSkpKSBmb3IgKGEgPSB2ZShjKSwgciA9IDAsIGkgPSAobyA9IHZlKGUpKS5sZW5ndGg7IHIgPCBpOyByKyspcyA9IG9bcl0sIHUgPSBhW3JdLCB2b2lkIDAsIFwiaW5wdXRcIiA9PT0gKGwgPSB1Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpICYmIHBlLnRlc3Qocy50eXBlKSA/IHUuY2hlY2tlZCA9IHMuY2hlY2tlZCA6IFwiaW5wdXRcIiAhPT0gbCAmJiBcInRleHRhcmVhXCIgIT09IGwgfHwgKHUuZGVmYXVsdFZhbHVlID0gcy5kZWZhdWx0VmFsdWUpOyBpZiAodCkgaWYgKG4pIGZvciAobyA9IG8gfHwgdmUoZSksIGEgPSBhIHx8IHZlKGMpLCByID0gMCwgaSA9IG8ubGVuZ3RoOyByIDwgaTsgcisrKU1lKG9bcl0sIGFbcl0pOyBlbHNlIE1lKGUsIGMpOyByZXR1cm4gMCA8IChhID0gdmUoYywgXCJzY3JpcHRcIikpLmxlbmd0aCAmJiB5ZShhLCAhZiAmJiB2ZShlLCBcInNjcmlwdFwiKSksIGMgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZSkgeyBmb3IgKHZhciB0LCBuLCByLCBpID0gay5ldmVudC5zcGVjaWFsLCBvID0gMDsgdm9pZCAwICE9PSAobiA9IGVbb10pOyBvKyspaWYgKEcobikpIHsgaWYgKHQgPSBuW1EuZXhwYW5kb10pIHsgaWYgKHQuZXZlbnRzKSBmb3IgKHIgaW4gdC5ldmVudHMpIGlbcl0gPyBrLmV2ZW50LnJlbW92ZShuLCByKSA6IGsucmVtb3ZlRXZlbnQobiwgciwgdC5oYW5kbGUpOyBuW1EuZXhwYW5kb10gPSB2b2lkIDAgfSBuW0ouZXhwYW5kb10gJiYgKG5bSi5leHBhbmRvXSA9IHZvaWQgMCkgfSB9IH0pLCBrLmZuLmV4dGVuZCh7IGRldGFjaDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFdlKHRoaXMsIGUsICEwKSB9LCByZW1vdmU6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBXZSh0aGlzLCBlKSB9LCB0ZXh0OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gXyh0aGlzLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdm9pZCAwID09PSBlID8gay50ZXh0KHRoaXMpIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24gKCkgeyAxICE9PSB0aGlzLm5vZGVUeXBlICYmIDExICE9PSB0aGlzLm5vZGVUeXBlICYmIDkgIT09IHRoaXMubm9kZVR5cGUgfHwgKHRoaXMudGV4dENvbnRlbnQgPSBlKSB9KSB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKSB9LCBhcHBlbmQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEllKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGUpIHsgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8IE9lKHRoaXMsIGUpLmFwcGVuZENoaWxkKGUpIH0pIH0sIHByZXBlbmQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEllKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGUpIHsgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkgeyB2YXIgdCA9IE9lKHRoaXMsIGUpOyB0Lmluc2VydEJlZm9yZShlLCB0LmZpcnN0Q2hpbGQpIH0gfSkgfSwgYmVmb3JlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBJZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7IHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpIH0pIH0sIGFmdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBJZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7IHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpIH0pIH0sIGVtcHR5OiBmdW5jdGlvbiAoKSB7IGZvciAodmFyIGUsIHQgPSAwOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykxID09PSBlLm5vZGVUeXBlICYmIChrLmNsZWFuRGF0YSh2ZShlLCAhMSkpLCBlLnRleHRDb250ZW50ID0gXCJcIik7IHJldHVybiB0aGlzIH0sIGNsb25lOiBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gZSA9IG51bGwgIT0gZSAmJiBlLCB0ID0gbnVsbCA9PSB0ID8gZSA6IHQsIHRoaXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGsuY2xvbmUodGhpcywgZSwgdCkgfSkgfSwgaHRtbDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF8odGhpcywgZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSB0aGlzWzBdIHx8IHt9LCBuID0gMCwgciA9IHRoaXMubGVuZ3RoOyBpZiAodm9pZCAwID09PSBlICYmIDEgPT09IHQubm9kZVR5cGUpIHJldHVybiB0LmlubmVySFRNTDsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgIXFlLnRlc3QoZSkgJiYgIWdlWyhkZS5leGVjKGUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHsgZSA9IGsuaHRtbFByZWZpbHRlcihlKTsgdHJ5IHsgZm9yICg7IG4gPCByOyBuKyspMSA9PT0gKHQgPSB0aGlzW25dIHx8IHt9KS5ub2RlVHlwZSAmJiAoay5jbGVhbkRhdGEodmUodCwgITEpKSwgdC5pbm5lckhUTUwgPSBlKTsgdCA9IDAgfSBjYXRjaCAoZSkgeyB9IH0gdCAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGUpIH0sIG51bGwsIGUsIGFyZ3VtZW50cy5sZW5ndGgpIH0sIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoKSB7IHZhciBuID0gW107IHJldHVybiBJZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gdGhpcy5wYXJlbnROb2RlOyBrLmluQXJyYXkodGhpcywgbikgPCAwICYmIChrLmNsZWFuRGF0YSh2ZSh0aGlzKSksIHQgJiYgdC5yZXBsYWNlQ2hpbGQoZSwgdGhpcykpIH0sIG4pIH0gfSksIGsuZWFjaCh7IGFwcGVuZFRvOiBcImFwcGVuZFwiLCBwcmVwZW5kVG86IFwicHJlcGVuZFwiLCBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsIGluc2VydEFmdGVyOiBcImFmdGVyXCIsIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIiB9LCBmdW5jdGlvbiAoZSwgYSkgeyBrLmZuW2VdID0gZnVuY3Rpb24gKGUpIHsgZm9yICh2YXIgdCwgbiA9IFtdLCByID0gayhlKSwgaSA9IHIubGVuZ3RoIC0gMSwgbyA9IDA7IG8gPD0gaTsgbysrKXQgPSBvID09PSBpID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBrKHJbb10pW2FdKHQpLCB1LmFwcGx5KG4sIHQuZ2V0KCkpOyByZXR1cm4gdGhpcy5wdXNoU3RhY2sobikgfSB9KTsgdmFyICRlID0gbmV3IFJlZ0V4cChcIl4oXCIgKyB0ZSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKSwgRmUgPSBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzsgcmV0dXJuIHQgJiYgdC5vcGVuZXIgfHwgKHQgPSBDKSwgdC5nZXRDb21wdXRlZFN0eWxlKGUpIH0sIEJlID0gbmV3IFJlZ0V4cChyZS5qb2luKFwifFwiKSwgXCJpXCIpOyBmdW5jdGlvbiBfZShlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzID0gZS5zdHlsZTsgcmV0dXJuIChuID0gbiB8fCBGZShlKSkgJiYgKFwiXCIgIT09IChhID0gbi5nZXRQcm9wZXJ0eVZhbHVlKHQpIHx8IG5bdF0pIHx8IG9lKGUpIHx8IChhID0gay5zdHlsZShlLCB0KSksICF5LnBpeGVsQm94U3R5bGVzKCkgJiYgJGUudGVzdChhKSAmJiBCZS50ZXN0KHQpICYmIChyID0gcy53aWR0aCwgaSA9IHMubWluV2lkdGgsIG8gPSBzLm1heFdpZHRoLCBzLm1pbldpZHRoID0gcy5tYXhXaWR0aCA9IHMud2lkdGggPSBhLCBhID0gbi53aWR0aCwgcy53aWR0aCA9IHIsIHMubWluV2lkdGggPSBpLCBzLm1heFdpZHRoID0gbykpLCB2b2lkIDAgIT09IGEgPyBhICsgXCJcIiA6IGEgfSBmdW5jdGlvbiB6ZShlLCB0KSB7IHJldHVybiB7IGdldDogZnVuY3Rpb24gKCkgeyBpZiAoIWUoKSkgcmV0dXJuICh0aGlzLmdldCA9IHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IGRlbGV0ZSB0aGlzLmdldCB9IH0gfSAhZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBlKCkgeyBpZiAodSkgeyBzLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDttYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIiwgdS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo2MCU7dG9wOjElXCIsIGllLmFwcGVuZENoaWxkKHMpLmFwcGVuZENoaWxkKHUpOyB2YXIgZSA9IEMuZ2V0Q29tcHV0ZWRTdHlsZSh1KTsgbiA9IFwiMSVcIiAhPT0gZS50b3AsIGEgPSAxMiA9PT0gdChlLm1hcmdpbkxlZnQpLCB1LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIiwgbyA9IDM2ID09PSB0KGUucmlnaHQpLCByID0gMzYgPT09IHQoZS53aWR0aCksIHUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGkgPSAxMiA9PT0gdCh1Lm9mZnNldFdpZHRoIC8gMyksIGllLnJlbW92ZUNoaWxkKHMpLCB1ID0gbnVsbCB9IH0gZnVuY3Rpb24gdChlKSB7IHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZSkpIH0gdmFyIG4sIHIsIGksIG8sIGEsIHMgPSBFLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHUgPSBFLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IHUuc3R5bGUgJiYgKHUuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCIsIHUuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCIsIHkuY2xlYXJDbG9uZVN0eWxlID0gXCJjb250ZW50LWJveFwiID09PSB1LnN0eWxlLmJhY2tncm91bmRDbGlwLCBrLmV4dGVuZCh5LCB7IGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBlKCksIHIgfSwgcGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGUoKSwgbyB9LCBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBlKCksIG4gfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlKCksIGEgfSwgc2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZSgpLCBpIH0gfSkpIH0oKTsgdmFyIFVlID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl0sIFhlID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLCBWZSA9IHt9OyBmdW5jdGlvbiBHZShlKSB7IHZhciB0ID0gay5jc3NQcm9wc1tlXSB8fCBWZVtlXTsgcmV0dXJuIHQgfHwgKGUgaW4gWGUgPyBlIDogVmVbZV0gPSBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSksIG4gPSBVZS5sZW5ndGg7IHdoaWxlIChuLS0pIGlmICgoZSA9IFVlW25dICsgdCkgaW4gWGUpIHJldHVybiBlIH0oZSkgfHwgZSkgfSB2YXIgWWUgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sIFFlID0gL14tLS8sIEplID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSwgS2UgPSB7IGxldHRlclNwYWNpbmc6IFwiMFwiLCBmb250V2VpZ2h0OiBcIjQwMFwiIH07IGZ1bmN0aW9uIFplKGUsIHQsIG4pIHsgdmFyIHIgPSBuZS5leGVjKHQpOyByZXR1cm4gciA/IE1hdGgubWF4KDAsIHJbMl0gLSAobiB8fCAwKSkgKyAoclszXSB8fCBcInB4XCIpIDogdCB9IGZ1bmN0aW9uIGV0KGUsIHQsIG4sIHIsIGksIG8pIHsgdmFyIGEgPSBcIndpZHRoXCIgPT09IHQgPyAxIDogMCwgcyA9IDAsIHUgPSAwOyBpZiAobiA9PT0gKHIgPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpKSByZXR1cm4gMDsgZm9yICg7IGEgPCA0OyBhICs9IDIpXCJtYXJnaW5cIiA9PT0gbiAmJiAodSArPSBrLmNzcyhlLCBuICsgcmVbYV0sICEwLCBpKSksIHIgPyAoXCJjb250ZW50XCIgPT09IG4gJiYgKHUgLT0gay5jc3MoZSwgXCJwYWRkaW5nXCIgKyByZVthXSwgITAsIGkpKSwgXCJtYXJnaW5cIiAhPT0gbiAmJiAodSAtPSBrLmNzcyhlLCBcImJvcmRlclwiICsgcmVbYV0gKyBcIldpZHRoXCIsICEwLCBpKSkpIDogKHUgKz0gay5jc3MoZSwgXCJwYWRkaW5nXCIgKyByZVthXSwgITAsIGkpLCBcInBhZGRpbmdcIiAhPT0gbiA/IHUgKz0gay5jc3MoZSwgXCJib3JkZXJcIiArIHJlW2FdICsgXCJXaWR0aFwiLCAhMCwgaSkgOiBzICs9IGsuY3NzKGUsIFwiYm9yZGVyXCIgKyByZVthXSArIFwiV2lkdGhcIiwgITAsIGkpKTsgcmV0dXJuICFyICYmIDAgPD0gbyAmJiAodSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdFswXS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKV0gLSBvIC0gdSAtIHMgLSAuNSkpIHx8IDApLCB1IH0gZnVuY3Rpb24gdHQoZSwgdCwgbikgeyB2YXIgciA9IEZlKGUpLCBpID0gKCF5LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgbikgJiYgXCJib3JkZXItYm94XCIgPT09IGsuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCByKSwgbyA9IGksIGEgPSBfZShlLCB0LCByKSwgcyA9IFwib2Zmc2V0XCIgKyB0WzBdLnRvVXBwZXJDYXNlKCkgKyB0LnNsaWNlKDEpOyBpZiAoJGUudGVzdChhKSkgeyBpZiAoIW4pIHJldHVybiBhOyBhID0gXCJhdXRvXCIgfSByZXR1cm4gKCF5LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaSB8fCBcImF1dG9cIiA9PT0gYSB8fCAhcGFyc2VGbG9hdChhKSAmJiBcImlubGluZVwiID09PSBrLmNzcyhlLCBcImRpc3BsYXlcIiwgITEsIHIpKSAmJiBlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICYmIChpID0gXCJib3JkZXItYm94XCIgPT09IGsuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCByKSwgKG8gPSBzIGluIGUpICYmIChhID0gZVtzXSkpLCAoYSA9IHBhcnNlRmxvYXQoYSkgfHwgMCkgKyBldChlLCB0LCBuIHx8IChpID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgbywgciwgYSkgKyBcInB4XCIgfSBmdW5jdGlvbiBudChlLCB0LCBuLCByLCBpKSB7IHJldHVybiBuZXcgbnQucHJvdG90eXBlLmluaXQoZSwgdCwgbiwgciwgaSkgfSBrLmV4dGVuZCh7IGNzc0hvb2tzOiB7IG9wYWNpdHk6IHsgZ2V0OiBmdW5jdGlvbiAoZSwgdCkgeyBpZiAodCkgeyB2YXIgbiA9IF9lKGUsIFwib3BhY2l0eVwiKTsgcmV0dXJuIFwiXCIgPT09IG4gPyBcIjFcIiA6IG4gfSB9IH0gfSwgY3NzTnVtYmVyOiB7IGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAhMCwgY29sdW1uQ291bnQ6ICEwLCBmaWxsT3BhY2l0eTogITAsIGZsZXhHcm93OiAhMCwgZmxleFNocmluazogITAsIGZvbnRXZWlnaHQ6ICEwLCBncmlkQXJlYTogITAsIGdyaWRDb2x1bW46ICEwLCBncmlkQ29sdW1uRW5kOiAhMCwgZ3JpZENvbHVtblN0YXJ0OiAhMCwgZ3JpZFJvdzogITAsIGdyaWRSb3dFbmQ6ICEwLCBncmlkUm93U3RhcnQ6ICEwLCBsaW5lSGVpZ2h0OiAhMCwgb3BhY2l0eTogITAsIG9yZGVyOiAhMCwgb3JwaGFuczogITAsIHdpZG93czogITAsIHpJbmRleDogITAsIHpvb206ICEwIH0sIGNzc1Byb3BzOiB7fSwgc3R5bGU6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IGlmIChlICYmIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiBlLnN0eWxlKSB7IHZhciBpLCBvLCBhLCBzID0gVih0KSwgdSA9IFFlLnRlc3QodCksIGwgPSBlLnN0eWxlOyBpZiAodSB8fCAodCA9IEdlKHMpKSwgYSA9IGsuY3NzSG9va3NbdF0gfHwgay5jc3NIb29rc1tzXSwgdm9pZCAwID09PSBuKSByZXR1cm4gYSAmJiBcImdldFwiIGluIGEgJiYgdm9pZCAwICE9PSAoaSA9IGEuZ2V0KGUsICExLCByKSkgPyBpIDogbFt0XTsgXCJzdHJpbmdcIiA9PT0gKG8gPSB0eXBlb2YgbikgJiYgKGkgPSBuZS5leGVjKG4pKSAmJiBpWzFdICYmIChuID0gbGUoZSwgdCwgaSksIG8gPSBcIm51bWJlclwiKSwgbnVsbCAhPSBuICYmIG4gPT0gbiAmJiAoXCJudW1iZXJcIiAhPT0gbyB8fCB1IHx8IChuICs9IGkgJiYgaVszXSB8fCAoay5jc3NOdW1iZXJbc10gPyBcIlwiIDogXCJweFwiKSksIHkuY2xlYXJDbG9uZVN0eWxlIHx8IFwiXCIgIT09IG4gfHwgMCAhPT0gdC5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSB8fCAobFt0XSA9IFwiaW5oZXJpdFwiKSwgYSAmJiBcInNldFwiIGluIGEgJiYgdm9pZCAwID09PSAobiA9IGEuc2V0KGUsIG4sIHIpKSB8fCAodSA/IGwuc2V0UHJvcGVydHkodCwgbikgOiBsW3RdID0gbikpIH0gfSwgY3NzOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikgeyB2YXIgaSwgbywgYSwgcyA9IFYodCk7IHJldHVybiBRZS50ZXN0KHQpIHx8ICh0ID0gR2UocykpLCAoYSA9IGsuY3NzSG9va3NbdF0gfHwgay5jc3NIb29rc1tzXSkgJiYgXCJnZXRcIiBpbiBhICYmIChpID0gYS5nZXQoZSwgITAsIG4pKSwgdm9pZCAwID09PSBpICYmIChpID0gX2UoZSwgdCwgcikpLCBcIm5vcm1hbFwiID09PSBpICYmIHQgaW4gS2UgJiYgKGkgPSBLZVt0XSksIFwiXCIgPT09IG4gfHwgbiA/IChvID0gcGFyc2VGbG9hdChpKSwgITAgPT09IG4gfHwgaXNGaW5pdGUobykgPyBvIHx8IDAgOiBpKSA6IGkgfSB9KSwgay5lYWNoKFtcImhlaWdodFwiLCBcIndpZHRoXCJdLCBmdW5jdGlvbiAoZSwgdSkgeyBrLmNzc0hvb2tzW3VdID0geyBnZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IGlmICh0KSByZXR1cm4gIVllLnRlc3Qoay5jc3MoZSwgXCJkaXNwbGF5XCIpKSB8fCBlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICYmIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0dChlLCB1LCBuKSA6IHVlKGUsIEplLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0dChlLCB1LCBuKSB9KSB9LCBzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpID0gRmUoZSksIG8gPSAheS5zY3JvbGxib3hTaXplKCkgJiYgXCJhYnNvbHV0ZVwiID09PSBpLnBvc2l0aW9uLCBhID0gKG8gfHwgbikgJiYgXCJib3JkZXItYm94XCIgPT09IGsuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBpKSwgcyA9IG4gPyBldChlLCB1LCBuLCBhLCBpKSA6IDA7IHJldHVybiBhICYmIG8gJiYgKHMgLT0gTWF0aC5jZWlsKGVbXCJvZmZzZXRcIiArIHVbMF0udG9VcHBlckNhc2UoKSArIHUuc2xpY2UoMSldIC0gcGFyc2VGbG9hdChpW3VdKSAtIGV0KGUsIHUsIFwiYm9yZGVyXCIsICExLCBpKSAtIC41KSksIHMgJiYgKHIgPSBuZS5leGVjKHQpKSAmJiBcInB4XCIgIT09IChyWzNdIHx8IFwicHhcIikgJiYgKGUuc3R5bGVbdV0gPSB0LCB0ID0gay5jc3MoZSwgdSkpLCBaZSgwLCB0LCBzKSB9IH0gfSksIGsuY3NzSG9va3MubWFyZ2luTGVmdCA9IHplKHkucmVsaWFibGVNYXJnaW5MZWZ0LCBmdW5jdGlvbiAoZSwgdCkgeyBpZiAodCkgcmV0dXJuIChwYXJzZUZsb2F0KF9lKGUsIFwibWFyZ2luTGVmdFwiKSkgfHwgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gdWUoZSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCB9KSkgKyBcInB4XCIgfSksIGsuZWFjaCh7IG1hcmdpbjogXCJcIiwgcGFkZGluZzogXCJcIiwgYm9yZGVyOiBcIldpZHRoXCIgfSwgZnVuY3Rpb24gKGksIG8pIHsgay5jc3NIb29rc1tpICsgb10gPSB7IGV4cGFuZDogZnVuY3Rpb24gKGUpIHsgZm9yICh2YXIgdCA9IDAsIG4gPSB7fSwgciA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlLnNwbGl0KFwiIFwiKSA6IFtlXTsgdCA8IDQ7IHQrKyluW2kgKyByZVt0XSArIG9dID0gclt0XSB8fCByW3QgLSAyXSB8fCByWzBdOyByZXR1cm4gbiB9IH0sIFwibWFyZ2luXCIgIT09IGkgJiYgKGsuY3NzSG9va3NbaSArIG9dLnNldCA9IFplKSB9KSwgay5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBfKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvID0ge30sIGEgPSAwOyBpZiAoQXJyYXkuaXNBcnJheSh0KSkgeyBmb3IgKHIgPSBGZShlKSwgaSA9IHQubGVuZ3RoOyBhIDwgaTsgYSsrKW9bdFthXV0gPSBrLmNzcyhlLCB0W2FdLCAhMSwgcik7IHJldHVybiBvIH0gcmV0dXJuIHZvaWQgMCAhPT0gbiA/IGsuc3R5bGUoZSwgdCwgbikgOiBrLmNzcyhlLCB0KSB9LCBlLCB0LCAxIDwgYXJndW1lbnRzLmxlbmd0aCkgfSB9KSwgKChrLlR3ZWVuID0gbnQpLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IG50LCBpbml0OiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSwgbykgeyB0aGlzLmVsZW0gPSBlLCB0aGlzLnByb3AgPSBuLCB0aGlzLmVhc2luZyA9IGkgfHwgay5lYXNpbmcuX2RlZmF1bHQsIHRoaXMub3B0aW9ucyA9IHQsIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCksIHRoaXMuZW5kID0gciwgdGhpcy51bml0ID0gbyB8fCAoay5jc3NOdW1iZXJbbl0gPyBcIlwiIDogXCJweFwiKSB9LCBjdXI6IGZ1bmN0aW9uICgpIHsgdmFyIGUgPSBudC5wcm9wSG9va3NbdGhpcy5wcm9wXTsgcmV0dXJuIGUgJiYgZS5nZXQgPyBlLmdldCh0aGlzKSA6IG50LnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcykgfSwgcnVuOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCwgbiA9IG50LnByb3BIb29rc1t0aGlzLnByb3BdOyByZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uID8gdGhpcy5wb3MgPSB0ID0gay5lYXNpbmdbdGhpcy5lYXNpbmddKGUsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIGUsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbikgOiB0aGlzLnBvcyA9IHQgPSBlLCB0aGlzLm5vdyA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogdCArIHRoaXMuc3RhcnQsIHRoaXMub3B0aW9ucy5zdGVwICYmIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyksIG4gJiYgbi5zZXQgPyBuLnNldCh0aGlzKSA6IG50LnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyksIHRoaXMgfSB9KS5pbml0LnByb3RvdHlwZSA9IG50LnByb3RvdHlwZSwgKG50LnByb3BIb29rcyA9IHsgX2RlZmF1bHQ6IHsgZ2V0OiBmdW5jdGlvbiAoZSkgeyB2YXIgdDsgcmV0dXJuIDEgIT09IGUuZWxlbS5ub2RlVHlwZSB8fCBudWxsICE9IGUuZWxlbVtlLnByb3BdICYmIG51bGwgPT0gZS5lbGVtLnN0eWxlW2UucHJvcF0gPyBlLmVsZW1bZS5wcm9wXSA6ICh0ID0gay5jc3MoZS5lbGVtLCBlLnByb3AsIFwiXCIpKSAmJiBcImF1dG9cIiAhPT0gdCA/IHQgOiAwIH0sIHNldDogZnVuY3Rpb24gKGUpIHsgay5meC5zdGVwW2UucHJvcF0gPyBrLmZ4LnN0ZXBbZS5wcm9wXShlKSA6IDEgIT09IGUuZWxlbS5ub2RlVHlwZSB8fCAhay5jc3NIb29rc1tlLnByb3BdICYmIG51bGwgPT0gZS5lbGVtLnN0eWxlW0dlKGUucHJvcCldID8gZS5lbGVtW2UucHJvcF0gPSBlLm5vdyA6IGsuc3R5bGUoZS5lbGVtLCBlLnByb3AsIGUubm93ICsgZS51bml0KSB9IH0gfSkuc2Nyb2xsVG9wID0gbnQucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7IHNldDogZnVuY3Rpb24gKGUpIHsgZS5lbGVtLm5vZGVUeXBlICYmIGUuZWxlbS5wYXJlbnROb2RlICYmIChlLmVsZW1bZS5wcm9wXSA9IGUubm93KSB9IH0sIGsuZWFzaW5nID0geyBsaW5lYXI6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlIH0sIHN3aW5nOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyIH0sIF9kZWZhdWx0OiBcInN3aW5nXCIgfSwgay5meCA9IG50LnByb3RvdHlwZS5pbml0LCBrLmZ4LnN0ZXAgPSB7fTsgdmFyIHJ0LCBpdCwgb3QsIGF0LCBzdCA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLywgdXQgPSAvcXVldWVIb29rcyQvOyBmdW5jdGlvbiBsdCgpIHsgaXQgJiYgKCExID09PSBFLmhpZGRlbiAmJiBDLnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IEMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGx0KSA6IEMuc2V0VGltZW91dChsdCwgay5meC5pbnRlcnZhbCksIGsuZngudGljaygpKSB9IGZ1bmN0aW9uIGN0KCkgeyByZXR1cm4gQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcnQgPSB2b2lkIDAgfSksIHJ0ID0gRGF0ZS5ub3coKSB9IGZ1bmN0aW9uIGZ0KGUsIHQpIHsgdmFyIG4sIHIgPSAwLCBpID0geyBoZWlnaHQ6IGUgfTsgZm9yICh0ID0gdCA/IDEgOiAwOyByIDwgNDsgciArPSAyIC0gdClpW1wibWFyZ2luXCIgKyAobiA9IHJlW3JdKV0gPSBpW1wicGFkZGluZ1wiICsgbl0gPSBlOyByZXR1cm4gdCAmJiAoaS5vcGFjaXR5ID0gaS53aWR0aCA9IGUpLCBpIH0gZnVuY3Rpb24gcHQoZSwgdCwgbikgeyBmb3IgKHZhciByLCBpID0gKGR0LnR3ZWVuZXJzW3RdIHx8IFtdKS5jb25jYXQoZHQudHdlZW5lcnNbXCIqXCJdKSwgbyA9IDAsIGEgPSBpLmxlbmd0aDsgbyA8IGE7IG8rKylpZiAociA9IGlbb10uY2FsbChuLCB0LCBlKSkgcmV0dXJuIHIgfSBmdW5jdGlvbiBkdChvLCBlLCB0KSB7IHZhciBuLCBhLCByID0gMCwgaSA9IGR0LnByZWZpbHRlcnMubGVuZ3RoLCBzID0gay5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7IGRlbGV0ZSB1LmVsZW0gfSksIHUgPSBmdW5jdGlvbiAoKSB7IGlmIChhKSByZXR1cm4gITE7IGZvciAodmFyIGUgPSBydCB8fCBjdCgpLCB0ID0gTWF0aC5tYXgoMCwgbC5zdGFydFRpbWUgKyBsLmR1cmF0aW9uIC0gZSksIG4gPSAxIC0gKHQgLyBsLmR1cmF0aW9uIHx8IDApLCByID0gMCwgaSA9IGwudHdlZW5zLmxlbmd0aDsgciA8IGk7IHIrKylsLnR3ZWVuc1tyXS5ydW4obik7IHJldHVybiBzLm5vdGlmeVdpdGgobywgW2wsIG4sIHRdKSwgbiA8IDEgJiYgaSA/IHQgOiAoaSB8fCBzLm5vdGlmeVdpdGgobywgW2wsIDEsIDBdKSwgcy5yZXNvbHZlV2l0aChvLCBbbF0pLCAhMSkgfSwgbCA9IHMucHJvbWlzZSh7IGVsZW06IG8sIHByb3BzOiBrLmV4dGVuZCh7fSwgZSksIG9wdHM6IGsuZXh0ZW5kKCEwLCB7IHNwZWNpYWxFYXNpbmc6IHt9LCBlYXNpbmc6IGsuZWFzaW5nLl9kZWZhdWx0IH0sIHQpLCBvcmlnaW5hbFByb3BlcnRpZXM6IGUsIG9yaWdpbmFsT3B0aW9uczogdCwgc3RhcnRUaW1lOiBydCB8fCBjdCgpLCBkdXJhdGlvbjogdC5kdXJhdGlvbiwgdHdlZW5zOiBbXSwgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuID0gay5Ud2VlbihvLCBsLm9wdHMsIGUsIHQsIGwub3B0cy5zcGVjaWFsRWFzaW5nW2VdIHx8IGwub3B0cy5lYXNpbmcpOyByZXR1cm4gbC50d2VlbnMucHVzaChuKSwgbiB9LCBzdG9wOiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IDAsIG4gPSBlID8gbC50d2VlbnMubGVuZ3RoIDogMDsgaWYgKGEpIHJldHVybiB0aGlzOyBmb3IgKGEgPSAhMDsgdCA8IG47IHQrKylsLnR3ZWVuc1t0XS5ydW4oMSk7IHJldHVybiBlID8gKHMubm90aWZ5V2l0aChvLCBbbCwgMSwgMF0pLCBzLnJlc29sdmVXaXRoKG8sIFtsLCBlXSkpIDogcy5yZWplY3RXaXRoKG8sIFtsLCBlXSksIHRoaXMgfSB9KSwgYyA9IGwucHJvcHM7IGZvciAoIWZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCByLCBpLCBvLCBhOyBmb3IgKG4gaW4gZSkgaWYgKGkgPSB0W3IgPSBWKG4pXSwgbyA9IGVbbl0sIEFycmF5LmlzQXJyYXkobykgJiYgKGkgPSBvWzFdLCBvID0gZVtuXSA9IG9bMF0pLCBuICE9PSByICYmIChlW3JdID0gbywgZGVsZXRlIGVbbl0pLCAoYSA9IGsuY3NzSG9va3Nbcl0pICYmIFwiZXhwYW5kXCIgaW4gYSkgZm9yIChuIGluIG8gPSBhLmV4cGFuZChvKSwgZGVsZXRlIGVbcl0sIG8pIG4gaW4gZSB8fCAoZVtuXSA9IG9bbl0sIHRbbl0gPSBpKTsgZWxzZSB0W3JdID0gaSB9KGMsIGwub3B0cy5zcGVjaWFsRWFzaW5nKTsgciA8IGk7IHIrKylpZiAobiA9IGR0LnByZWZpbHRlcnNbcl0uY2FsbChsLCBvLCBjLCBsLm9wdHMpKSByZXR1cm4gbShuLnN0b3ApICYmIChrLl9xdWV1ZUhvb2tzKGwuZWxlbSwgbC5vcHRzLnF1ZXVlKS5zdG9wID0gbi5zdG9wLmJpbmQobikpLCBuOyByZXR1cm4gay5tYXAoYywgcHQsIGwpLCBtKGwub3B0cy5zdGFydCkgJiYgbC5vcHRzLnN0YXJ0LmNhbGwobywgbCksIGwucHJvZ3Jlc3MobC5vcHRzLnByb2dyZXNzKS5kb25lKGwub3B0cy5kb25lLCBsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSwgay5meC50aW1lcihrLmV4dGVuZCh1LCB7IGVsZW06IG8sIGFuaW06IGwsIHF1ZXVlOiBsLm9wdHMucXVldWUgfSkpLCBsIH0gay5BbmltYXRpb24gPSBrLmV4dGVuZChkdCwgeyB0d2VlbmVyczogeyBcIipcIjogW2Z1bmN0aW9uIChlLCB0KSB7IHZhciBuID0gdGhpcy5jcmVhdGVUd2VlbihlLCB0KTsgcmV0dXJuIGxlKG4uZWxlbSwgZSwgbmUuZXhlYyh0KSwgbiksIG4gfV0gfSwgdHdlZW5lcjogZnVuY3Rpb24gKGUsIHQpIHsgbShlKSA/ICh0ID0gZSwgZSA9IFtcIipcIl0pIDogZSA9IGUubWF0Y2goUik7IGZvciAodmFyIG4sIHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBpOyByKyspbiA9IGVbcl0sIGR0LnR3ZWVuZXJzW25dID0gZHQudHdlZW5lcnNbbl0gfHwgW10sIGR0LnR3ZWVuZXJzW25dLnVuc2hpZnQodCkgfSwgcHJlZmlsdGVyczogW2Z1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzLCB1LCBsLCBjLCBmID0gXCJ3aWR0aFwiIGluIHQgfHwgXCJoZWlnaHRcIiBpbiB0LCBwID0gdGhpcywgZCA9IHt9LCBoID0gZS5zdHlsZSwgZyA9IGUubm9kZVR5cGUgJiYgc2UoZSksIHYgPSBRLmdldChlLCBcImZ4c2hvd1wiKTsgZm9yIChyIGluIG4ucXVldWUgfHwgKG51bGwgPT0gKGEgPSBrLl9xdWV1ZUhvb2tzKGUsIFwiZnhcIikpLnVucXVldWVkICYmIChhLnVucXVldWVkID0gMCwgcyA9IGEuZW1wdHkuZmlyZSwgYS5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkgeyBhLnVucXVldWVkIHx8IHMoKSB9KSwgYS51bnF1ZXVlZCsrICwgcC5hbHdheXMoZnVuY3Rpb24gKCkgeyBwLmFsd2F5cyhmdW5jdGlvbiAoKSB7IGEudW5xdWV1ZWQtLSAsIGsucXVldWUoZSwgXCJmeFwiKS5sZW5ndGggfHwgYS5lbXB0eS5maXJlKCkgfSkgfSkpLCB0KSBpZiAoaSA9IHRbcl0sIHN0LnRlc3QoaSkpIHsgaWYgKGRlbGV0ZSB0W3JdLCBvID0gbyB8fCBcInRvZ2dsZVwiID09PSBpLCBpID09PSAoZyA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7IGlmIChcInNob3dcIiAhPT0gaSB8fCAhdiB8fCB2b2lkIDAgPT09IHZbcl0pIGNvbnRpbnVlOyBnID0gITAgfSBkW3JdID0gdiAmJiB2W3JdIHx8IGsuc3R5bGUoZSwgcikgfSBpZiAoKHUgPSAhay5pc0VtcHR5T2JqZWN0KHQpKSB8fCAhay5pc0VtcHR5T2JqZWN0KGQpKSBmb3IgKHIgaW4gZiAmJiAxID09PSBlLm5vZGVUeXBlICYmIChuLm92ZXJmbG93ID0gW2gub3ZlcmZsb3csIGgub3ZlcmZsb3dYLCBoLm92ZXJmbG93WV0sIG51bGwgPT0gKGwgPSB2ICYmIHYuZGlzcGxheSkgJiYgKGwgPSBRLmdldChlLCBcImRpc3BsYXlcIikpLCBcIm5vbmVcIiA9PT0gKGMgPSBrLmNzcyhlLCBcImRpc3BsYXlcIikpICYmIChsID8gYyA9IGwgOiAoZmUoW2VdLCAhMCksIGwgPSBlLnN0eWxlLmRpc3BsYXkgfHwgbCwgYyA9IGsuY3NzKGUsIFwiZGlzcGxheVwiKSwgZmUoW2VdKSkpLCAoXCJpbmxpbmVcIiA9PT0gYyB8fCBcImlubGluZS1ibG9ja1wiID09PSBjICYmIG51bGwgIT0gbCkgJiYgXCJub25lXCIgPT09IGsuY3NzKGUsIFwiZmxvYXRcIikgJiYgKHUgfHwgKHAuZG9uZShmdW5jdGlvbiAoKSB7IGguZGlzcGxheSA9IGwgfSksIG51bGwgPT0gbCAmJiAoYyA9IGguZGlzcGxheSwgbCA9IFwibm9uZVwiID09PSBjID8gXCJcIiA6IGMpKSwgaC5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIikpLCBuLm92ZXJmbG93ICYmIChoLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgcC5hbHdheXMoZnVuY3Rpb24gKCkgeyBoLm92ZXJmbG93ID0gbi5vdmVyZmxvd1swXSwgaC5vdmVyZmxvd1ggPSBuLm92ZXJmbG93WzFdLCBoLm92ZXJmbG93WSA9IG4ub3ZlcmZsb3dbMl0gfSkpLCB1ID0gITEsIGQpIHUgfHwgKHYgPyBcImhpZGRlblwiIGluIHYgJiYgKGcgPSB2LmhpZGRlbikgOiB2ID0gUS5hY2Nlc3MoZSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiBsIH0pLCBvICYmICh2LmhpZGRlbiA9ICFnKSwgZyAmJiBmZShbZV0sICEwKSwgcC5kb25lKGZ1bmN0aW9uICgpIHsgZm9yIChyIGluIGcgfHwgZmUoW2VdKSwgUS5yZW1vdmUoZSwgXCJmeHNob3dcIiksIGQpIGsuc3R5bGUoZSwgciwgZFtyXSkgfSkpLCB1ID0gcHQoZyA/IHZbcl0gOiAwLCByLCBwKSwgciBpbiB2IHx8ICh2W3JdID0gdS5zdGFydCwgZyAmJiAodS5lbmQgPSB1LnN0YXJ0LCB1LnN0YXJ0ID0gMCkpIH1dLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uIChlLCB0KSB7IHQgPyBkdC5wcmVmaWx0ZXJzLnVuc2hpZnQoZSkgOiBkdC5wcmVmaWx0ZXJzLnB1c2goZSkgfSB9KSwgay5zcGVlZCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByID0gZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gay5leHRlbmQoe30sIGUpIDogeyBjb21wbGV0ZTogbiB8fCAhbiAmJiB0IHx8IG0oZSkgJiYgZSwgZHVyYXRpb246IGUsIGVhc2luZzogbiAmJiB0IHx8IHQgJiYgIW0odCkgJiYgdCB9OyByZXR1cm4gay5meC5vZmYgPyByLmR1cmF0aW9uID0gMCA6IFwibnVtYmVyXCIgIT0gdHlwZW9mIHIuZHVyYXRpb24gJiYgKHIuZHVyYXRpb24gaW4gay5meC5zcGVlZHMgPyByLmR1cmF0aW9uID0gay5meC5zcGVlZHNbci5kdXJhdGlvbl0gOiByLmR1cmF0aW9uID0gay5meC5zcGVlZHMuX2RlZmF1bHQpLCBudWxsICE9IHIucXVldWUgJiYgITAgIT09IHIucXVldWUgfHwgKHIucXVldWUgPSBcImZ4XCIpLCByLm9sZCA9IHIuY29tcGxldGUsIHIuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IG0oci5vbGQpICYmIHIub2xkLmNhbGwodGhpcyksIHIucXVldWUgJiYgay5kZXF1ZXVlKHRoaXMsIHIucXVldWUpIH0sIHIgfSwgay5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHJldHVybiB0aGlzLmZpbHRlcihzZSkuY3NzKFwib3BhY2l0eVwiLCAwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHQgfSwgZSwgbiwgcikgfSwgYW5pbWF0ZTogZnVuY3Rpb24gKHQsIGUsIG4sIHIpIHsgdmFyIGkgPSBrLmlzRW1wdHlPYmplY3QodCksIG8gPSBrLnNwZWVkKGUsIG4sIHIpLCBhID0gZnVuY3Rpb24gKCkgeyB2YXIgZSA9IGR0KHRoaXMsIGsuZXh0ZW5kKHt9LCB0KSwgbyk7IChpIHx8IFEuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSAmJiBlLnN0b3AoITApIH07IHJldHVybiBhLmZpbmlzaCA9IGEsIGkgfHwgITEgPT09IG8ucXVldWUgPyB0aGlzLmVhY2goYSkgOiB0aGlzLnF1ZXVlKG8ucXVldWUsIGEpIH0sIHN0b3A6IGZ1bmN0aW9uIChpLCBlLCBvKSB7IHZhciBhID0gZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlLnN0b3A7IGRlbGV0ZSBlLnN0b3AsIHQobykgfTsgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIGkgJiYgKG8gPSBlLCBlID0gaSwgaSA9IHZvaWQgMCksIGUgJiYgITEgIT09IGkgJiYgdGhpcy5xdWV1ZShpIHx8IFwiZnhcIiwgW10pLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyB2YXIgZSA9ICEwLCB0ID0gbnVsbCAhPSBpICYmIGkgKyBcInF1ZXVlSG9va3NcIiwgbiA9IGsudGltZXJzLCByID0gUS5nZXQodGhpcyk7IGlmICh0KSByW3RdICYmIHJbdF0uc3RvcCAmJiBhKHJbdF0pOyBlbHNlIGZvciAodCBpbiByKSByW3RdICYmIHJbdF0uc3RvcCAmJiB1dC50ZXN0KHQpICYmIGEoclt0XSk7IGZvciAodCA9IG4ubGVuZ3RoOyB0LS07KW5bdF0uZWxlbSAhPT0gdGhpcyB8fCBudWxsICE9IGkgJiYgblt0XS5xdWV1ZSAhPT0gaSB8fCAoblt0XS5hbmltLnN0b3AobyksIGUgPSAhMSwgbi5zcGxpY2UodCwgMSkpOyAhZSAmJiBvIHx8IGsuZGVxdWV1ZSh0aGlzLCBpKSB9KSB9LCBmaW5pc2g6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhMSAhPT0gYSAmJiAoYSA9IGEgfHwgXCJmeFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIGUsIHQgPSBRLmdldCh0aGlzKSwgbiA9IHRbYSArIFwicXVldWVcIl0sIHIgPSB0W2EgKyBcInF1ZXVlSG9va3NcIl0sIGkgPSBrLnRpbWVycywgbyA9IG4gPyBuLmxlbmd0aCA6IDA7IGZvciAodC5maW5pc2ggPSAhMCwgay5xdWV1ZSh0aGlzLCBhLCBbXSksIHIgJiYgci5zdG9wICYmIHIuc3RvcC5jYWxsKHRoaXMsICEwKSwgZSA9IGkubGVuZ3RoOyBlLS07KWlbZV0uZWxlbSA9PT0gdGhpcyAmJiBpW2VdLnF1ZXVlID09PSBhICYmIChpW2VdLmFuaW0uc3RvcCghMCksIGkuc3BsaWNlKGUsIDEpKTsgZm9yIChlID0gMDsgZSA8IG87IGUrKyluW2VdICYmIG5bZV0uZmluaXNoICYmIG5bZV0uZmluaXNoLmNhbGwodGhpcyk7IGRlbGV0ZSB0LmZpbmlzaCB9KSB9IH0pLCBrLmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uIChlLCByKSB7IHZhciBpID0gay5mbltyXTsgay5mbltyXSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiBudWxsID09IGUgfHwgXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoZnQociwgITApLCBlLCB0LCBuKSB9IH0pLCBrLmVhY2goeyBzbGlkZURvd246IGZ0KFwic2hvd1wiKSwgc2xpZGVVcDogZnQoXCJoaWRlXCIpLCBzbGlkZVRvZ2dsZTogZnQoXCJ0b2dnbGVcIiksIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LCBmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9IH0sIGZ1bmN0aW9uIChlLCByKSB7IGsuZm5bZV0gPSBmdW5jdGlvbiAoZSwgdCwgbikgeyByZXR1cm4gdGhpcy5hbmltYXRlKHIsIGUsIHQsIG4pIH0gfSksIGsudGltZXJzID0gW10sIGsuZngudGljayA9IGZ1bmN0aW9uICgpIHsgdmFyIGUsIHQgPSAwLCBuID0gay50aW1lcnM7IGZvciAocnQgPSBEYXRlLm5vdygpOyB0IDwgbi5sZW5ndGg7IHQrKykoZSA9IG5bdF0pKCkgfHwgblt0XSAhPT0gZSB8fCBuLnNwbGljZSh0LS0sIDEpOyBuLmxlbmd0aCB8fCBrLmZ4LnN0b3AoKSwgcnQgPSB2b2lkIDAgfSwgay5meC50aW1lciA9IGZ1bmN0aW9uIChlKSB7IGsudGltZXJzLnB1c2goZSksIGsuZnguc3RhcnQoKSB9LCBrLmZ4LmludGVydmFsID0gMTMsIGsuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7IGl0IHx8IChpdCA9ICEwLCBsdCgpKSB9LCBrLmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7IGl0ID0gbnVsbCB9LCBrLmZ4LnNwZWVkcyA9IHsgc2xvdzogNjAwLCBmYXN0OiAyMDAsIF9kZWZhdWx0OiA0MDAgfSwgay5mbi5kZWxheSA9IGZ1bmN0aW9uIChyLCBlKSB7IHJldHVybiByID0gay5meCAmJiBrLmZ4LnNwZWVkc1tyXSB8fCByLCBlID0gZSB8fCBcImZ4XCIsIHRoaXMucXVldWUoZSwgZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBDLnNldFRpbWVvdXQoZSwgcik7IHQuc3RvcCA9IGZ1bmN0aW9uICgpIHsgQy5jbGVhclRpbWVvdXQobikgfSB9KSB9LCBvdCA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBhdCA9IEUuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKS5hcHBlbmRDaGlsZChFLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLCBvdC50eXBlID0gXCJjaGVja2JveFwiLCB5LmNoZWNrT24gPSBcIlwiICE9PSBvdC52YWx1ZSwgeS5vcHRTZWxlY3RlZCA9IGF0LnNlbGVjdGVkLCAob3QgPSBFLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkudmFsdWUgPSBcInRcIiwgb3QudHlwZSA9IFwicmFkaW9cIiwgeS5yYWRpb1ZhbHVlID0gXCJ0XCIgPT09IG90LnZhbHVlOyB2YXIgaHQsIGd0ID0gay5leHByLmF0dHJIYW5kbGU7IGsuZm4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIF8odGhpcywgay5hdHRyLCBlLCB0LCAxIDwgYXJndW1lbnRzLmxlbmd0aCkgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGsucmVtb3ZlQXR0cih0aGlzLCBlKSB9KSB9IH0pLCBrLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvID0gZS5ub2RlVHlwZTsgaWYgKDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgPyBrLnByb3AoZSwgdCwgbikgOiAoMSA9PT0gbyAmJiBrLmlzWE1MRG9jKGUpIHx8IChpID0gay5hdHRySG9va3NbdC50b0xvd2VyQ2FzZSgpXSB8fCAoay5leHByLm1hdGNoLmJvb2wudGVzdCh0KSA/IGh0IDogdm9pZCAwKSksIHZvaWQgMCAhPT0gbiA/IG51bGwgPT09IG4gPyB2b2lkIGsucmVtb3ZlQXR0cihlLCB0KSA6IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogKGUuc2V0QXR0cmlidXRlKHQsIG4gKyBcIlwiKSwgbikgOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBudWxsID09IChyID0gay5maW5kLmF0dHIoZSwgdCkpID8gdm9pZCAwIDogcikgfSwgYXR0ckhvb2tzOiB7IHR5cGU6IHsgc2V0OiBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoIXkucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IHQgJiYgQShlLCBcImlucHV0XCIpKSB7IHZhciBuID0gZS52YWx1ZTsgcmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0KSwgbiAmJiAoZS52YWx1ZSA9IG4pLCB0IH0gfSB9IH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCByID0gMCwgaSA9IHQgJiYgdC5tYXRjaChSKTsgaWYgKGkgJiYgMSA9PT0gZS5ub2RlVHlwZSkgd2hpbGUgKG4gPSBpW3IrK10pIGUucmVtb3ZlQXR0cmlidXRlKG4pIH0gfSksIGh0ID0geyBzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiAhMSA9PT0gdCA/IGsucmVtb3ZlQXR0cihlLCBuKSA6IGUuc2V0QXR0cmlidXRlKG4sIG4pLCBuIH0gfSwgay5lYWNoKGsuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSwgZnVuY3Rpb24gKGUsIHQpIHsgdmFyIGEgPSBndFt0XSB8fCBrLmZpbmQuYXR0cjsgZ3RbdF0gPSBmdW5jdGlvbiAoZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IHQudG9Mb3dlckNhc2UoKTsgcmV0dXJuIG4gfHwgKGkgPSBndFtvXSwgZ3Rbb10gPSByLCByID0gbnVsbCAhPSBhKGUsIHQsIG4pID8gbyA6IG51bGwsIGd0W29dID0gaSksIHIgfSB9KTsgdmFyIHZ0ID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSwgeXQgPSAvXig/OmF8YXJlYSkkL2k7IGZ1bmN0aW9uIG10KGUpIHsgcmV0dXJuIChlLm1hdGNoKFIpIHx8IFtdKS5qb2luKFwiIFwiKSB9IGZ1bmN0aW9uIHh0KGUpIHsgcmV0dXJuIGUuZ2V0QXR0cmlidXRlICYmIGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiB9IGZ1bmN0aW9uIGJ0KGUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBlLm1hdGNoKFIpIHx8IFtdIH0gay5mbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gXyh0aGlzLCBrLnByb3AsIGUsIHQsIDEgPCBhcmd1bWVudHMubGVuZ3RoKSB9LCByZW1vdmVQcm9wOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgZGVsZXRlIHRoaXNbay5wcm9wRml4W2VdIHx8IGVdIH0pIH0gfSksIGsuZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8gPSBlLm5vZGVUeXBlOyBpZiAoMyAhPT0gbyAmJiA4ICE9PSBvICYmIDIgIT09IG8pIHJldHVybiAxID09PSBvICYmIGsuaXNYTUxEb2MoZSkgfHwgKHQgPSBrLnByb3BGaXhbdF0gfHwgdCwgaSA9IGsucHJvcEhvb2tzW3RdKSwgdm9pZCAwICE9PSBuID8gaSAmJiBcInNldFwiIGluIGkgJiYgdm9pZCAwICE9PSAociA9IGkuc2V0KGUsIG4sIHQpKSA/IHIgOiBlW3RdID0gbiA6IGkgJiYgXCJnZXRcIiBpbiBpICYmIG51bGwgIT09IChyID0gaS5nZXQoZSwgdCkpID8gciA6IGVbdF0gfSwgcHJvcEhvb2tzOiB7IHRhYkluZGV4OiB7IGdldDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBrLmZpbmQuYXR0cihlLCBcInRhYmluZGV4XCIpOyByZXR1cm4gdCA/IHBhcnNlSW50KHQsIDEwKSA6IHZ0LnRlc3QoZS5ub2RlTmFtZSkgfHwgeXQudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTEgfSB9IH0sIHByb3BGaXg6IHsgXCJmb3JcIjogXCJodG1sRm9yXCIsIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIiB9IH0pLCB5Lm9wdFNlbGVjdGVkIHx8IChrLnByb3BIb29rcy5zZWxlY3RlZCA9IHsgZ2V0OiBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGUucGFyZW50Tm9kZTsgcmV0dXJuIHQgJiYgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBudWxsIH0sIHNldDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBlLnBhcmVudE5vZGU7IHQgJiYgKHQuc2VsZWN0ZWRJbmRleCwgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KSB9IH0pLCBrLmVhY2goW1widGFiSW5kZXhcIiwgXCJyZWFkT25seVwiLCBcIm1heExlbmd0aFwiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2VsbFBhZGRpbmdcIiwgXCJyb3dTcGFuXCIsIFwiY29sU3BhblwiLCBcInVzZU1hcFwiLCBcImZyYW1lQm9yZGVyXCIsIFwiY29udGVudEVkaXRhYmxlXCJdLCBmdW5jdGlvbiAoKSB7IGsucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpcyB9KSwgay5mbi5leHRlbmQoeyBhZGRDbGFzczogZnVuY3Rpb24gKHQpIHsgdmFyIGUsIG4sIHIsIGksIG8sIGEsIHMsIHUgPSAwOyBpZiAobSh0KSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkgeyBrKHRoaXMpLmFkZENsYXNzKHQuY2FsbCh0aGlzLCBlLCB4dCh0aGlzKSkpIH0pOyBpZiAoKGUgPSBidCh0KSkubGVuZ3RoKSB3aGlsZSAobiA9IHRoaXNbdSsrXSkgaWYgKGkgPSB4dChuKSwgciA9IDEgPT09IG4ubm9kZVR5cGUgJiYgXCIgXCIgKyBtdChpKSArIFwiIFwiKSB7IGEgPSAwOyB3aGlsZSAobyA9IGVbYSsrXSkgci5pbmRleE9mKFwiIFwiICsgbyArIFwiIFwiKSA8IDAgJiYgKHIgKz0gbyArIFwiIFwiKTsgaSAhPT0gKHMgPSBtdChyKSkgJiYgbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzKSB9IHJldHVybiB0aGlzIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAodCkgeyB2YXIgZSwgbiwgciwgaSwgbywgYSwgcywgdSA9IDA7IGlmIChtKHQpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7IGsodGhpcykucmVtb3ZlQ2xhc3ModC5jYWxsKHRoaXMsIGUsIHh0KHRoaXMpKSkgfSk7IGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuYXR0cihcImNsYXNzXCIsIFwiXCIpOyBpZiAoKGUgPSBidCh0KSkubGVuZ3RoKSB3aGlsZSAobiA9IHRoaXNbdSsrXSkgaWYgKGkgPSB4dChuKSwgciA9IDEgPT09IG4ubm9kZVR5cGUgJiYgXCIgXCIgKyBtdChpKSArIFwiIFwiKSB7IGEgPSAwOyB3aGlsZSAobyA9IGVbYSsrXSkgd2hpbGUgKC0xIDwgci5pbmRleE9mKFwiIFwiICsgbyArIFwiIFwiKSkgciA9IHIucmVwbGFjZShcIiBcIiArIG8gKyBcIiBcIiwgXCIgXCIpOyBpICE9PSAocyA9IG10KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpIH0gcmV0dXJuIHRoaXMgfSwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChpLCB0KSB7IHZhciBvID0gdHlwZW9mIGksIGEgPSBcInN0cmluZ1wiID09PSBvIHx8IEFycmF5LmlzQXJyYXkoaSk7IHJldHVybiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCAmJiBhID8gdCA/IHRoaXMuYWRkQ2xhc3MoaSkgOiB0aGlzLnJlbW92ZUNsYXNzKGkpIDogbShpKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoZSkgeyBrKHRoaXMpLnRvZ2dsZUNsYXNzKGkuY2FsbCh0aGlzLCBlLCB4dCh0aGlzKSwgdCksIHQpIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIGUsIHQsIG4sIHI7IGlmIChhKSB7IHQgPSAwLCBuID0gayh0aGlzKSwgciA9IGJ0KGkpOyB3aGlsZSAoZSA9IHJbdCsrXSkgbi5oYXNDbGFzcyhlKSA/IG4ucmVtb3ZlQ2xhc3MoZSkgOiBuLmFkZENsYXNzKGUpIH0gZWxzZSB2b2lkIDAgIT09IGkgJiYgXCJib29sZWFuXCIgIT09IG8gfHwgKChlID0geHQodGhpcykpICYmIFEuc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBlKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBlIHx8ICExID09PSBpID8gXCJcIiA6IFEuZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiKSkgfSkgfSwgaGFzQ2xhc3M6IGZ1bmN0aW9uIChlKSB7IHZhciB0LCBuLCByID0gMDsgdCA9IFwiIFwiICsgZSArIFwiIFwiOyB3aGlsZSAobiA9IHRoaXNbcisrXSkgaWYgKDEgPT09IG4ubm9kZVR5cGUgJiYgLTEgPCAoXCIgXCIgKyBtdCh4dChuKSkgKyBcIiBcIikuaW5kZXhPZih0KSkgcmV0dXJuICEwOyByZXR1cm4gITEgfSB9KTsgdmFyIHd0ID0gL1xcci9nOyBrLmZuLmV4dGVuZCh7IHZhbDogZnVuY3Rpb24gKG4pIHsgdmFyIHIsIGUsIGksIHQgPSB0aGlzWzBdOyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gbShuKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7IHZhciB0OyAxID09PSB0aGlzLm5vZGVUeXBlICYmIChudWxsID09ICh0ID0gaSA/IG4uY2FsbCh0aGlzLCBlLCBrKHRoaXMpLnZhbCgpKSA6IG4pID8gdCA9IFwiXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gdCArPSBcIlwiIDogQXJyYXkuaXNBcnJheSh0KSAmJiAodCA9IGsubWFwKHQsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBudWxsID09IGUgPyBcIlwiIDogZSArIFwiXCIgfSkpLCAociA9IGsudmFsSG9va3NbdGhpcy50eXBlXSB8fCBrLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pICYmIFwic2V0XCIgaW4gciAmJiB2b2lkIDAgIT09IHIuc2V0KHRoaXMsIHQsIFwidmFsdWVcIikgfHwgKHRoaXMudmFsdWUgPSB0KSkgfSkpIDogdCA/IChyID0gay52YWxIb29rc1t0LnR5cGVdIHx8IGsudmFsSG9va3NbdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJnZXRcIiBpbiByICYmIHZvaWQgMCAhPT0gKGUgPSByLmdldCh0LCBcInZhbHVlXCIpKSA/IGUgOiBcInN0cmluZ1wiID09IHR5cGVvZiAoZSA9IHQudmFsdWUpID8gZS5yZXBsYWNlKHd0LCBcIlwiKSA6IG51bGwgPT0gZSA/IFwiXCIgOiBlIDogdm9pZCAwIH0gfSksIGsuZXh0ZW5kKHsgdmFsSG9va3M6IHsgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24gKGUpIHsgdmFyIHQgPSBrLmZpbmQuYXR0cihlLCBcInZhbHVlXCIpOyByZXR1cm4gbnVsbCAhPSB0ID8gdCA6IG10KGsudGV4dChlKSkgfSB9LCBzZWxlY3Q6IHsgZ2V0OiBmdW5jdGlvbiAoZSkgeyB2YXIgdCwgbiwgciwgaSA9IGUub3B0aW9ucywgbyA9IGUuc2VsZWN0ZWRJbmRleCwgYSA9IFwic2VsZWN0LW9uZVwiID09PSBlLnR5cGUsIHMgPSBhID8gbnVsbCA6IFtdLCB1ID0gYSA/IG8gKyAxIDogaS5sZW5ndGg7IGZvciAociA9IG8gPCAwID8gdSA6IGEgPyBvIDogMDsgciA8IHU7IHIrKylpZiAoKChuID0gaVtyXSkuc2VsZWN0ZWQgfHwgciA9PT0gbykgJiYgIW4uZGlzYWJsZWQgJiYgKCFuLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIUEobi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkgeyBpZiAodCA9IGsobikudmFsKCksIGEpIHJldHVybiB0OyBzLnB1c2godCkgfSByZXR1cm4gcyB9LCBzZXQ6IGZ1bmN0aW9uIChlLCB0KSB7IHZhciBuLCByLCBpID0gZS5vcHRpb25zLCBvID0gay5tYWtlQXJyYXkodCksIGEgPSBpLmxlbmd0aDsgd2hpbGUgKGEtLSkgKChyID0gaVthXSkuc2VsZWN0ZWQgPSAtMSA8IGsuaW5BcnJheShrLnZhbEhvb2tzLm9wdGlvbi5nZXQociksIG8pKSAmJiAobiA9ICEwKTsgcmV0dXJuIG4gfHwgKGUuc2VsZWN0ZWRJbmRleCA9IC0xKSwgbyB9IH0gfSB9KSwgay5lYWNoKFtcInJhZGlvXCIsIFwiY2hlY2tib3hcIl0sIGZ1bmN0aW9uICgpIHsgay52YWxIb29rc1t0aGlzXSA9IHsgc2V0OiBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIGUuY2hlY2tlZCA9IC0xIDwgay5pbkFycmF5KGsoZSkudmFsKCksIHQpIH0gfSwgeS5jaGVja09uIHx8IChrLnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZSB9KSB9KSwgeS5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiBDOyB2YXIgVHQgPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sIEN0ID0gZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9OyBrLmV4dGVuZChrLmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhLCBzLCB1LCBsLCBjLCBmLCBwID0gW24gfHwgRV0sIGQgPSB2LmNhbGwoZSwgXCJ0eXBlXCIpID8gZS50eXBlIDogZSwgaCA9IHYuY2FsbChlLCBcIm5hbWVzcGFjZVwiKSA/IGUubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdOyBpZiAobyA9IGYgPSBhID0gbiA9IG4gfHwgRSwgMyAhPT0gbi5ub2RlVHlwZSAmJiA4ICE9PSBuLm5vZGVUeXBlICYmICFUdC50ZXN0KGQgKyBrLmV2ZW50LnRyaWdnZXJlZCkgJiYgKC0xIDwgZC5pbmRleE9mKFwiLlwiKSAmJiAoZCA9IChoID0gZC5zcGxpdChcIi5cIikpLnNoaWZ0KCksIGguc29ydCgpKSwgdSA9IGQuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIGQsIChlID0gZVtrLmV4cGFuZG9dID8gZSA6IG5ldyBrLkV2ZW50KGQsIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgZSkpLmlzVHJpZ2dlciA9IHIgPyAyIDogMywgZS5uYW1lc3BhY2UgPSBoLmpvaW4oXCIuXCIpLCBlLnJuYW1lc3BhY2UgPSBlLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsLCBlLnJlc3VsdCA9IHZvaWQgMCwgZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gbiksIHQgPSBudWxsID09IHQgPyBbZV0gOiBrLm1ha2VBcnJheSh0LCBbZV0pLCBjID0gay5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCByIHx8ICFjLnRyaWdnZXIgfHwgITEgIT09IGMudHJpZ2dlci5hcHBseShuLCB0KSkpIHsgaWYgKCFyICYmICFjLm5vQnViYmxlICYmICF4KG4pKSB7IGZvciAocyA9IGMuZGVsZWdhdGVUeXBlIHx8IGQsIFR0LnRlc3QocyArIGQpIHx8IChvID0gby5wYXJlbnROb2RlKTsgbzsgbyA9IG8ucGFyZW50Tm9kZSlwLnB1c2gobyksIGEgPSBvOyBhID09PSAobi5vd25lckRvY3VtZW50IHx8IEUpICYmIHAucHVzaChhLmRlZmF1bHRWaWV3IHx8IGEucGFyZW50V2luZG93IHx8IEMpIH0gaSA9IDA7IHdoaWxlICgobyA9IHBbaSsrXSkgJiYgIWUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkgZiA9IG8sIGUudHlwZSA9IDEgPCBpID8gcyA6IGMuYmluZFR5cGUgfHwgZCwgKGwgPSAoUS5nZXQobywgXCJldmVudHNcIikgfHwge30pW2UudHlwZV0gJiYgUS5nZXQobywgXCJoYW5kbGVcIikpICYmIGwuYXBwbHkobywgdCksIChsID0gdSAmJiBvW3VdKSAmJiBsLmFwcGx5ICYmIEcobykgJiYgKGUucmVzdWx0ID0gbC5hcHBseShvLCB0KSwgITEgPT09IGUucmVzdWx0ICYmIGUucHJldmVudERlZmF1bHQoKSk7IHJldHVybiBlLnR5cGUgPSBkLCByIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgYy5fZGVmYXVsdCAmJiAhMSAhPT0gYy5fZGVmYXVsdC5hcHBseShwLnBvcCgpLCB0KSB8fCAhRyhuKSB8fCB1ICYmIG0obltkXSkgJiYgIXgobikgJiYgKChhID0gblt1XSkgJiYgKG5bdV0gPSBudWxsKSwgay5ldmVudC50cmlnZ2VyZWQgPSBkLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5hZGRFdmVudExpc3RlbmVyKGQsIEN0KSwgbltkXSgpLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsIEN0KSwgay5ldmVudC50cmlnZ2VyZWQgPSB2b2lkIDAsIGEgJiYgKG5bdV0gPSBhKSksIGUucmVzdWx0IH0gfSwgc2ltdWxhdGU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByID0gay5leHRlbmQobmV3IGsuRXZlbnQsIG4sIHsgdHlwZTogZSwgaXNTaW11bGF0ZWQ6ICEwIH0pOyBrLmV2ZW50LnRyaWdnZXIociwgbnVsbCwgdCkgfSB9KSwgay5mbi5leHRlbmQoeyB0cmlnZ2VyOiBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgay5ldmVudC50cmlnZ2VyKGUsIHQsIHRoaXMpIH0pIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiA9IHRoaXNbMF07IGlmIChuKSByZXR1cm4gay5ldmVudC50cmlnZ2VyKGUsIHQsIG4sICEwKSB9IH0pLCB5LmZvY3VzaW4gfHwgay5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24gKG4sIHIpIHsgdmFyIGkgPSBmdW5jdGlvbiAoZSkgeyBrLmV2ZW50LnNpbXVsYXRlKHIsIGUudGFyZ2V0LCBrLmV2ZW50LmZpeChlKSkgfTsgay5ldmVudC5zcGVjaWFsW3JdID0geyBzZXR1cDogZnVuY3Rpb24gKCkgeyB2YXIgZSA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLCB0ID0gUS5hY2Nlc3MoZSwgcik7IHQgfHwgZS5hZGRFdmVudExpc3RlbmVyKG4sIGksICEwKSwgUS5hY2Nlc3MoZSwgciwgKHQgfHwgMCkgKyAxKSB9LCB0ZWFyZG93bjogZnVuY3Rpb24gKCkgeyB2YXIgZSA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLCB0ID0gUS5hY2Nlc3MoZSwgcikgLSAxOyB0ID8gUS5hY2Nlc3MoZSwgciwgdCkgOiAoZS5yZW1vdmVFdmVudExpc3RlbmVyKG4sIGksICEwKSwgUS5yZW1vdmUoZSwgcikpIH0gfSB9KTsgdmFyIEV0ID0gQy5sb2NhdGlvbiwga3QgPSBEYXRlLm5vdygpLCBTdCA9IC9cXD8vOyBrLnBhcnNlWE1MID0gZnVuY3Rpb24gKGUpIHsgdmFyIHQ7IGlmICghZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gbnVsbDsgdHJ5IHsgdCA9IChuZXcgQy5ET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhlLCBcInRleHQveG1sXCIpIH0gY2F0Y2ggKGUpIHsgdCA9IHZvaWQgMCB9IHJldHVybiB0ICYmICF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoIHx8IGsuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyBlKSwgdCB9OyB2YXIgTnQgPSAvXFxbXFxdJC8sIEF0ID0gL1xccj9cXG4vZywgRHQgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksIGp0ID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pOyBmdW5jdGlvbiBxdChuLCBlLCByLCBpKSB7IHZhciB0OyBpZiAoQXJyYXkuaXNBcnJheShlKSkgay5lYWNoKGUsIGZ1bmN0aW9uIChlLCB0KSB7IHIgfHwgTnQudGVzdChuKSA/IGkobiwgdCkgOiBxdChuICsgXCJbXCIgKyAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBudWxsICE9IHQgPyBlIDogXCJcIikgKyBcIl1cIiwgdCwgciwgaSkgfSk7IGVsc2UgaWYgKHIgfHwgXCJvYmplY3RcIiAhPT0gdyhlKSkgaShuLCBlKTsgZWxzZSBmb3IgKHQgaW4gZSkgcXQobiArIFwiW1wiICsgdCArIFwiXVwiLCBlW3RdLCByLCBpKSB9IGsucGFyYW0gPSBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiwgciA9IFtdLCBpID0gZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBtKHQpID8gdCgpIDogdDsgcltyLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChudWxsID09IG4gPyBcIlwiIDogbikgfTsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIFwiXCI7IGlmIChBcnJheS5pc0FycmF5KGUpIHx8IGUuanF1ZXJ5ICYmICFrLmlzUGxhaW5PYmplY3QoZSkpIGsuZWFjaChlLCBmdW5jdGlvbiAoKSB7IGkodGhpcy5uYW1lLCB0aGlzLnZhbHVlKSB9KTsgZWxzZSBmb3IgKG4gaW4gZSkgcXQobiwgZVtuXSwgdCwgaSk7IHJldHVybiByLmpvaW4oXCImXCIpIH0sIGsuZm4uZXh0ZW5kKHsgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7IHJldHVybiBrLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSkgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHsgdmFyIGUgPSBrLnByb3AodGhpcywgXCJlbGVtZW50c1wiKTsgcmV0dXJuIGUgPyBrLm1ha2VBcnJheShlKSA6IHRoaXMgfSkuZmlsdGVyKGZ1bmN0aW9uICgpIHsgdmFyIGUgPSB0aGlzLnR5cGU7IHJldHVybiB0aGlzLm5hbWUgJiYgIWsodGhpcykuaXMoXCI6ZGlzYWJsZWRcIikgJiYganQudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhRHQudGVzdChlKSAmJiAodGhpcy5jaGVja2VkIHx8ICFwZS50ZXN0KGUpKSB9KS5tYXAoZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4gPSBrKHRoaXMpLnZhbCgpOyByZXR1cm4gbnVsbCA9PSBuID8gbnVsbCA6IEFycmF5LmlzQXJyYXkobikgPyBrLm1hcChuLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4geyBuYW1lOiB0Lm5hbWUsIHZhbHVlOiBlLnJlcGxhY2UoQXQsIFwiXFxyXFxuXCIpIH0gfSkgOiB7IG5hbWU6IHQubmFtZSwgdmFsdWU6IG4ucmVwbGFjZShBdCwgXCJcXHJcXG5cIikgfSB9KS5nZXQoKSB9IH0pOyB2YXIgTHQgPSAvJTIwL2csIEh0ID0gLyMuKiQvLCBPdCA9IC8oWz8mXSlfPVteJl0qLywgUHQgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLCBSdCA9IC9eKD86R0VUfEhFQUQpJC8sIE10ID0gL15cXC9cXC8vLCBJdCA9IHt9LCBXdCA9IHt9LCAkdCA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLCBGdCA9IEUuY3JlYXRlRWxlbWVudChcImFcIik7IGZ1bmN0aW9uIEJ0KG8pIHsgcmV0dXJuIGZ1bmN0aW9uIChlLCB0KSB7IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gXCIqXCIpOyB2YXIgbiwgciA9IDAsIGkgPSBlLnRvTG93ZXJDYXNlKCkubWF0Y2goUikgfHwgW107IGlmIChtKHQpKSB3aGlsZSAobiA9IGlbcisrXSkgXCIrXCIgPT09IG5bMF0gPyAobiA9IG4uc2xpY2UoMSkgfHwgXCIqXCIsIChvW25dID0gb1tuXSB8fCBbXSkudW5zaGlmdCh0KSkgOiAob1tuXSA9IG9bbl0gfHwgW10pLnB1c2godCkgfSB9IGZ1bmN0aW9uIF90KHQsIGksIG8sIGEpIHsgdmFyIHMgPSB7fSwgdSA9IHQgPT09IFd0OyBmdW5jdGlvbiBsKGUpIHsgdmFyIHI7IHJldHVybiBzW2VdID0gITAsIGsuZWFjaCh0W2VdIHx8IFtdLCBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiA9IHQoaSwgbywgYSk7IHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiBuIHx8IHUgfHwgc1tuXSA/IHUgPyAhKHIgPSBuKSA6IHZvaWQgMCA6IChpLmRhdGFUeXBlcy51bnNoaWZ0KG4pLCBsKG4pLCAhMSkgfSksIHIgfSByZXR1cm4gbChpLmRhdGFUeXBlc1swXSkgfHwgIXNbXCIqXCJdICYmIGwoXCIqXCIpIH0gZnVuY3Rpb24genQoZSwgdCkgeyB2YXIgbiwgciwgaSA9IGsuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9OyBmb3IgKG4gaW4gdCkgdm9pZCAwICE9PSB0W25dICYmICgoaVtuXSA/IGUgOiByIHx8IChyID0ge30pKVtuXSA9IHRbbl0pOyByZXR1cm4gciAmJiBrLmV4dGVuZCghMCwgZSwgciksIGUgfSBGdC5ocmVmID0gRXQuaHJlZiwgay5leHRlbmQoeyBhY3RpdmU6IDAsIGxhc3RNb2RpZmllZDoge30sIGV0YWc6IHt9LCBhamF4U2V0dGluZ3M6IHsgdXJsOiBFdC5ocmVmLCB0eXBlOiBcIkdFVFwiLCBpc0xvY2FsOiAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLy50ZXN0KEV0LnByb3RvY29sKSwgZ2xvYmFsOiAhMCwgcHJvY2Vzc0RhdGE6ICEwLCBhc3luYzogITAsIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLCBhY2NlcHRzOiB7IFwiKlwiOiAkdCwgdGV4dDogXCJ0ZXh0L3BsYWluXCIsIGh0bWw6IFwidGV4dC9odG1sXCIsIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIgfSwgY29udGVudHM6IHsgeG1sOiAvXFxieG1sXFxiLywgaHRtbDogL1xcYmh0bWwvLCBqc29uOiAvXFxianNvblxcYi8gfSwgcmVzcG9uc2VGaWVsZHM6IHsgeG1sOiBcInJlc3BvbnNlWE1MXCIsIHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsIGpzb246IFwicmVzcG9uc2VKU09OXCIgfSwgY29udmVydGVyczogeyBcIiogdGV4dFwiOiBTdHJpbmcsIFwidGV4dCBodG1sXCI6ICEwLCBcInRleHQganNvblwiOiBKU09OLnBhcnNlLCBcInRleHQgeG1sXCI6IGsucGFyc2VYTUwgfSwgZmxhdE9wdGlvbnM6IHsgdXJsOiAhMCwgY29udGV4dDogITAgfSB9LCBhamF4U2V0dXA6IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiB0ID8genQoenQoZSwgay5hamF4U2V0dGluZ3MpLCB0KSA6IHp0KGsuYWpheFNldHRpbmdzLCBlKSB9LCBhamF4UHJlZmlsdGVyOiBCdChJdCksIGFqYXhUcmFuc3BvcnQ6IEJ0KFd0KSwgYWpheDogZnVuY3Rpb24gKGUsIHQpIHsgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAodCA9IGUsIGUgPSB2b2lkIDApLCB0ID0gdCB8fCB7fTsgdmFyIGMsIGYsIHAsIG4sIGQsIHIsIGgsIGcsIGksIG8sIHYgPSBrLmFqYXhTZXR1cCh7fSwgdCksIHkgPSB2LmNvbnRleHQgfHwgdiwgbSA9IHYuY29udGV4dCAmJiAoeS5ub2RlVHlwZSB8fCB5LmpxdWVyeSkgPyBrKHkpIDogay5ldmVudCwgeCA9IGsuRGVmZXJyZWQoKSwgYiA9IGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIHcgPSB2LnN0YXR1c0NvZGUgfHwge30sIGEgPSB7fSwgcyA9IHt9LCB1ID0gXCJjYW5jZWxlZFwiLCBUID0geyByZWFkeVN0YXRlOiAwLCBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKGUpIHsgdmFyIHQ7IGlmIChoKSB7IGlmICghbikgeyBuID0ge307IHdoaWxlICh0ID0gUHQuZXhlYyhwKSkgblt0WzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gPSAoblt0WzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gfHwgW10pLmNvbmNhdCh0WzJdKSB9IHQgPSBuW2UudG9Mb3dlckNhc2UoKSArIFwiIFwiXSB9IHJldHVybiBudWxsID09IHQgPyBudWxsIDogdC5qb2luKFwiLCBcIikgfSwgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBoID8gcCA6IG51bGwgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIG51bGwgPT0gaCAmJiAoZSA9IHNbZS50b0xvd2VyQ2FzZSgpXSA9IHNbZS50b0xvd2VyQ2FzZSgpXSB8fCBlLCBhW2VdID0gdCksIHRoaXMgfSwgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG51bGwgPT0gaCAmJiAodi5taW1lVHlwZSA9IGUpLCB0aGlzIH0sIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIChlKSB7IHZhciB0OyBpZiAoZSkgaWYgKGgpIFQuYWx3YXlzKGVbVC5zdGF0dXNdKTsgZWxzZSBmb3IgKHQgaW4gZSkgd1t0XSA9IFt3W3RdLCBlW3RdXTsgcmV0dXJuIHRoaXMgfSwgYWJvcnQ6IGZ1bmN0aW9uIChlKSB7IHZhciB0ID0gZSB8fCB1OyByZXR1cm4gYyAmJiBjLmFib3J0KHQpLCBsKDAsIHQpLCB0aGlzIH0gfTsgaWYgKHgucHJvbWlzZShUKSwgdi51cmwgPSAoKGUgfHwgdi51cmwgfHwgRXQuaHJlZikgKyBcIlwiKS5yZXBsYWNlKE10LCBFdC5wcm90b2NvbCArIFwiLy9cIiksIHYudHlwZSA9IHQubWV0aG9kIHx8IHQudHlwZSB8fCB2Lm1ldGhvZCB8fCB2LnR5cGUsIHYuZGF0YVR5cGVzID0gKHYuZGF0YVR5cGUgfHwgXCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goUikgfHwgW1wiXCJdLCBudWxsID09IHYuY3Jvc3NEb21haW4pIHsgciA9IEUuY3JlYXRlRWxlbWVudChcImFcIik7IHRyeSB7IHIuaHJlZiA9IHYudXJsLCByLmhyZWYgPSByLmhyZWYsIHYuY3Jvc3NEb21haW4gPSBGdC5wcm90b2NvbCArIFwiLy9cIiArIEZ0Lmhvc3QgIT0gci5wcm90b2NvbCArIFwiLy9cIiArIHIuaG9zdCB9IGNhdGNoIChlKSB7IHYuY3Jvc3NEb21haW4gPSAhMCB9IH0gaWYgKHYuZGF0YSAmJiB2LnByb2Nlc3NEYXRhICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIHYuZGF0YSAmJiAodi5kYXRhID0gay5wYXJhbSh2LmRhdGEsIHYudHJhZGl0aW9uYWwpKSwgX3QoSXQsIHYsIHQsIFQpLCBoKSByZXR1cm4gVDsgZm9yIChpIGluIChnID0gay5ldmVudCAmJiB2Lmdsb2JhbCkgJiYgMCA9PSBrLmFjdGl2ZSsrICYmIGsuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSwgdi50eXBlID0gdi50eXBlLnRvVXBwZXJDYXNlKCksIHYuaGFzQ29udGVudCA9ICFSdC50ZXN0KHYudHlwZSksIGYgPSB2LnVybC5yZXBsYWNlKEh0LCBcIlwiKSwgdi5oYXNDb250ZW50ID8gdi5kYXRhICYmIHYucHJvY2Vzc0RhdGEgJiYgMCA9PT0gKHYuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiAodi5kYXRhID0gdi5kYXRhLnJlcGxhY2UoTHQsIFwiK1wiKSkgOiAobyA9IHYudXJsLnNsaWNlKGYubGVuZ3RoKSwgdi5kYXRhICYmICh2LnByb2Nlc3NEYXRhIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIHYuZGF0YSkgJiYgKGYgKz0gKFN0LnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIHYuZGF0YSwgZGVsZXRlIHYuZGF0YSksICExID09PSB2LmNhY2hlICYmIChmID0gZi5yZXBsYWNlKE90LCBcIiQxXCIpLCBvID0gKFN0LnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIGt0KysgKyBvKSwgdi51cmwgPSBmICsgbyksIHYuaWZNb2RpZmllZCAmJiAoay5sYXN0TW9kaWZpZWRbZl0gJiYgVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgay5sYXN0TW9kaWZpZWRbZl0pLCBrLmV0YWdbZl0gJiYgVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCBrLmV0YWdbZl0pKSwgKHYuZGF0YSAmJiB2Lmhhc0NvbnRlbnQgJiYgITEgIT09IHYuY29udGVudFR5cGUgfHwgdC5jb250ZW50VHlwZSkgJiYgVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIHYuY29udGVudFR5cGUpLCBULnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgdi5kYXRhVHlwZXNbMF0gJiYgdi5hY2NlcHRzW3YuZGF0YVR5cGVzWzBdXSA/IHYuYWNjZXB0c1t2LmRhdGFUeXBlc1swXV0gKyAoXCIqXCIgIT09IHYuZGF0YVR5cGVzWzBdID8gXCIsIFwiICsgJHQgKyBcIjsgcT0wLjAxXCIgOiBcIlwiKSA6IHYuYWNjZXB0c1tcIipcIl0pLCB2LmhlYWRlcnMpIFQuc2V0UmVxdWVzdEhlYWRlcihpLCB2LmhlYWRlcnNbaV0pOyBpZiAodi5iZWZvcmVTZW5kICYmICghMSA9PT0gdi5iZWZvcmVTZW5kLmNhbGwoeSwgVCwgdikgfHwgaCkpIHJldHVybiBULmFib3J0KCk7IGlmICh1ID0gXCJhYm9ydFwiLCBiLmFkZCh2LmNvbXBsZXRlKSwgVC5kb25lKHYuc3VjY2VzcyksIFQuZmFpbCh2LmVycm9yKSwgYyA9IF90KFd0LCB2LCB0LCBUKSkgeyBpZiAoVC5yZWFkeVN0YXRlID0gMSwgZyAmJiBtLnRyaWdnZXIoXCJhamF4U2VuZFwiLCBbVCwgdl0pLCBoKSByZXR1cm4gVDsgdi5hc3luYyAmJiAwIDwgdi50aW1lb3V0ICYmIChkID0gQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgVC5hYm9ydChcInRpbWVvdXRcIikgfSwgdi50aW1lb3V0KSk7IHRyeSB7IGggPSAhMSwgYy5zZW5kKGEsIGwpIH0gY2F0Y2ggKGUpIHsgaWYgKGgpIHRocm93IGU7IGwoLTEsIGUpIH0gfSBlbHNlIGwoLTEsIFwiTm8gVHJhbnNwb3J0XCIpOyBmdW5jdGlvbiBsKGUsIHQsIG4sIHIpIHsgdmFyIGksIG8sIGEsIHMsIHUsIGwgPSB0OyBoIHx8IChoID0gITAsIGQgJiYgQy5jbGVhclRpbWVvdXQoZCksIGMgPSB2b2lkIDAsIHAgPSByIHx8IFwiXCIsIFQucmVhZHlTdGF0ZSA9IDAgPCBlID8gNCA6IDAsIGkgPSAyMDAgPD0gZSAmJiBlIDwgMzAwIHx8IDMwNCA9PT0gZSwgbiAmJiAocyA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzID0gZS5jb250ZW50cywgdSA9IGUuZGF0YVR5cGVzOyB3aGlsZSAoXCIqXCIgPT09IHVbMF0pIHUuc2hpZnQoKSwgdm9pZCAwID09PSByICYmIChyID0gZS5taW1lVHlwZSB8fCB0LmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKTsgaWYgKHIpIGZvciAoaSBpbiBzKSBpZiAoc1tpXSAmJiBzW2ldLnRlc3QocikpIHsgdS51bnNoaWZ0KGkpOyBicmVhayB9IGlmICh1WzBdIGluIG4pIG8gPSB1WzBdOyBlbHNlIHsgZm9yIChpIGluIG4pIHsgaWYgKCF1WzBdIHx8IGUuY29udmVydGVyc1tpICsgXCIgXCIgKyB1WzBdXSkgeyBvID0gaTsgYnJlYWsgfSBhIHx8IChhID0gaSkgfSBvID0gbyB8fCBhIH0gaWYgKG8pIHJldHVybiBvICE9PSB1WzBdICYmIHUudW5zaGlmdChvKSwgbltvXSB9KHYsIFQsIG4pKSwgcyA9IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhLCBzLCB1LCBsID0ge30sIGMgPSBlLmRhdGFUeXBlcy5zbGljZSgpOyBpZiAoY1sxXSkgZm9yIChhIGluIGUuY29udmVydGVycykgbFthLnRvTG93ZXJDYXNlKCldID0gZS5jb252ZXJ0ZXJzW2FdOyBvID0gYy5zaGlmdCgpOyB3aGlsZSAobykgaWYgKGUucmVzcG9uc2VGaWVsZHNbb10gJiYgKG5bZS5yZXNwb25zZUZpZWxkc1tvXV0gPSB0KSwgIXUgJiYgciAmJiBlLmRhdGFGaWx0ZXIgJiYgKHQgPSBlLmRhdGFGaWx0ZXIodCwgZS5kYXRhVHlwZSkpLCB1ID0gbywgbyA9IGMuc2hpZnQoKSkgaWYgKFwiKlwiID09PSBvKSBvID0gdTsgZWxzZSBpZiAoXCIqXCIgIT09IHUgJiYgdSAhPT0gbykgeyBpZiAoIShhID0gbFt1ICsgXCIgXCIgKyBvXSB8fCBsW1wiKiBcIiArIG9dKSkgZm9yIChpIGluIGwpIGlmICgocyA9IGkuc3BsaXQoXCIgXCIpKVsxXSA9PT0gbyAmJiAoYSA9IGxbdSArIFwiIFwiICsgc1swXV0gfHwgbFtcIiogXCIgKyBzWzBdXSkpIHsgITAgPT09IGEgPyBhID0gbFtpXSA6ICEwICE9PSBsW2ldICYmIChvID0gc1swXSwgYy51bnNoaWZ0KHNbMV0pKTsgYnJlYWsgfSBpZiAoITAgIT09IGEpIGlmIChhICYmIGVbXCJ0aHJvd3NcIl0pIHQgPSBhKHQpOyBlbHNlIHRyeSB7IHQgPSBhKHQpIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGEgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyB1ICsgXCIgdG8gXCIgKyBvIH0gfSB9IHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogdCB9IH0odiwgcywgVCwgaSksIGkgPyAodi5pZk1vZGlmaWVkICYmICgodSA9IFQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpKSAmJiAoay5sYXN0TW9kaWZpZWRbZl0gPSB1KSwgKHUgPSBULmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSkgJiYgKGsuZXRhZ1tmXSA9IHUpKSwgMjA0ID09PSBlIHx8IFwiSEVBRFwiID09PSB2LnR5cGUgPyBsID0gXCJub2NvbnRlbnRcIiA6IDMwNCA9PT0gZSA/IGwgPSBcIm5vdG1vZGlmaWVkXCIgOiAobCA9IHMuc3RhdGUsIG8gPSBzLmRhdGEsIGkgPSAhKGEgPSBzLmVycm9yKSkpIDogKGEgPSBsLCAhZSAmJiBsIHx8IChsID0gXCJlcnJvclwiLCBlIDwgMCAmJiAoZSA9IDApKSksIFQuc3RhdHVzID0gZSwgVC5zdGF0dXNUZXh0ID0gKHQgfHwgbCkgKyBcIlwiLCBpID8geC5yZXNvbHZlV2l0aCh5LCBbbywgbCwgVF0pIDogeC5yZWplY3RXaXRoKHksIFtULCBsLCBhXSksIFQuc3RhdHVzQ29kZSh3KSwgdyA9IHZvaWQgMCwgZyAmJiBtLnRyaWdnZXIoaSA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtULCB2LCBpID8gbyA6IGFdKSwgYi5maXJlV2l0aCh5LCBbVCwgbF0pLCBnICYmIChtLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW1QsIHZdKSwgLS1rLmFjdGl2ZSB8fCBrLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpIH0gcmV0dXJuIFQgfSwgZ2V0SlNPTjogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIGsuZ2V0KGUsIHQsIG4sIFwianNvblwiKSB9LCBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiBrLmdldChlLCB2b2lkIDAsIHQsIFwic2NyaXB0XCIpIH0gfSksIGsuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbiAoZSwgaSkgeyBrW2ldID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHsgcmV0dXJuIG0odCkgJiYgKHIgPSByIHx8IG4sIG4gPSB0LCB0ID0gdm9pZCAwKSwgay5hamF4KGsuZXh0ZW5kKHsgdXJsOiBlLCB0eXBlOiBpLCBkYXRhVHlwZTogciwgZGF0YTogdCwgc3VjY2VzczogbiB9LCBrLmlzUGxhaW5PYmplY3QoZSkgJiYgZSkpIH0gfSksIGsuX2V2YWxVcmwgPSBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gay5hamF4KHsgdXJsOiBlLCB0eXBlOiBcIkdFVFwiLCBkYXRhVHlwZTogXCJzY3JpcHRcIiwgY2FjaGU6ICEwLCBhc3luYzogITEsIGdsb2JhbDogITEsIGNvbnZlcnRlcnM6IHsgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiAoKSB7IH0gfSwgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGUpIHsgay5nbG9iYWxFdmFsKGUsIHQpIH0gfSkgfSwgay5mbi5leHRlbmQoeyB3cmFwQWxsOiBmdW5jdGlvbiAoZSkgeyB2YXIgdDsgcmV0dXJuIHRoaXNbMF0gJiYgKG0oZSkgJiYgKGUgPSBlLmNhbGwodGhpc1swXSkpLCB0ID0gayhlLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIHQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCB0Lm1hcChmdW5jdGlvbiAoKSB7IHZhciBlID0gdGhpczsgd2hpbGUgKGUuZmlyc3RFbGVtZW50Q2hpbGQpIGUgPSBlLmZpcnN0RWxlbWVudENoaWxkOyByZXR1cm4gZSB9KS5hcHBlbmQodGhpcykpLCB0aGlzIH0sIHdyYXBJbm5lcjogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG0obikgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHsgayh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsIGUpKSB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHZhciBlID0gayh0aGlzKSwgdCA9IGUuY29udGVudHMoKTsgdC5sZW5ndGggPyB0LndyYXBBbGwobikgOiBlLmFwcGVuZChuKSB9KSB9LCB3cmFwOiBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IG0odCk7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHsgayh0aGlzKS53cmFwQWxsKG4gPyB0LmNhbGwodGhpcywgZSkgOiB0KSB9KSB9LCB1bndyYXA6IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24gKCkgeyBrKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2RlcykgfSksIHRoaXMgfSB9KSwgay5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuICFrLmV4cHIucHNldWRvcy52aXNpYmxlKGUpIH0sIGsuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gISEoZS5vZmZzZXRXaWR0aCB8fCBlLm9mZnNldEhlaWdodCB8fCBlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSB9LCBrLmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiBuZXcgQy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH0gfTsgdmFyIFV0ID0geyAwOiAyMDAsIDEyMjM6IDIwNCB9LCBYdCA9IGsuYWpheFNldHRpbmdzLnhocigpOyB5LmNvcnMgPSAhIVh0ICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gWHQsIHkuYWpheCA9IFh0ID0gISFYdCwgay5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChpKSB7IHZhciBvLCBhOyBpZiAoeS5jb3JzIHx8IFh0ICYmICFpLmNyb3NzRG9tYWluKSByZXR1cm4geyBzZW5kOiBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiwgciA9IGkueGhyKCk7IGlmIChyLm9wZW4oaS50eXBlLCBpLnVybCwgaS5hc3luYywgaS51c2VybmFtZSwgaS5wYXNzd29yZCksIGkueGhyRmllbGRzKSBmb3IgKG4gaW4gaS54aHJGaWVsZHMpIHJbbl0gPSBpLnhockZpZWxkc1tuXTsgZm9yIChuIGluIGkubWltZVR5cGUgJiYgci5vdmVycmlkZU1pbWVUeXBlICYmIHIub3ZlcnJpZGVNaW1lVHlwZShpLm1pbWVUeXBlKSwgaS5jcm9zc0RvbWFpbiB8fCBlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSB8fCAoZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCIpLCBlKSByLnNldFJlcXVlc3RIZWFkZXIobiwgZVtuXSk7IG8gPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBvICYmIChvID0gYSA9IHIub25sb2FkID0gci5vbmVycm9yID0gci5vbmFib3J0ID0gci5vbnRpbWVvdXQgPSByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIFwiYWJvcnRcIiA9PT0gZSA/IHIuYWJvcnQoKSA6IFwiZXJyb3JcIiA9PT0gZSA/IFwibnVtYmVyXCIgIT0gdHlwZW9mIHIuc3RhdHVzID8gdCgwLCBcImVycm9yXCIpIDogdChyLnN0YXR1cywgci5zdGF0dXNUZXh0KSA6IHQoVXRbci5zdGF0dXNdIHx8IHIuc3RhdHVzLCByLnN0YXR1c1RleHQsIFwidGV4dFwiICE9PSAoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIHIucmVzcG9uc2VUZXh0ID8geyBiaW5hcnk6IHIucmVzcG9uc2UgfSA6IHsgdGV4dDogci5yZXNwb25zZVRleHQgfSwgci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIH0gfSwgci5vbmxvYWQgPSBvKCksIGEgPSByLm9uZXJyb3IgPSByLm9udGltZW91dCA9IG8oXCJlcnJvclwiKSwgdm9pZCAwICE9PSByLm9uYWJvcnQgPyByLm9uYWJvcnQgPSBhIDogci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IDQgPT09IHIucmVhZHlTdGF0ZSAmJiBDLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBvICYmIGEoKSB9KSB9LCBvID0gbyhcImFib3J0XCIpOyB0cnkgeyByLnNlbmQoaS5oYXNDb250ZW50ICYmIGkuZGF0YSB8fCBudWxsKSB9IGNhdGNoIChlKSB7IGlmIChvKSB0aHJvdyBlIH0gfSwgYWJvcnQ6IGZ1bmN0aW9uICgpIHsgbyAmJiBvKCkgfSB9IH0pLCBrLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24gKGUpIHsgZS5jcm9zc0RvbWFpbiAmJiAoZS5jb250ZW50cy5zY3JpcHQgPSAhMSkgfSksIGsuYWpheFNldHVwKHsgYWNjZXB0czogeyBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiLyB9LCBjb252ZXJ0ZXJzOiB7IFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGsuZ2xvYmFsRXZhbChlKSwgZSB9IH0gfSksIGsuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAoZSkgeyB2b2lkIDAgPT09IGUuY2FjaGUgJiYgKGUuY2FjaGUgPSAhMSksIGUuY3Jvc3NEb21haW4gJiYgKGUudHlwZSA9IFwiR0VUXCIpIH0pLCBrLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKG4pIHsgdmFyIHIsIGk7IGlmIChuLmNyb3NzRG9tYWluIHx8IG4uc2NyaXB0QXR0cnMpIHJldHVybiB7IHNlbmQ6IGZ1bmN0aW9uIChlLCB0KSB7IHIgPSBrKFwiPHNjcmlwdD5cIikuYXR0cihuLnNjcmlwdEF0dHJzIHx8IHt9KS5wcm9wKHsgY2hhcnNldDogbi5zY3JpcHRDaGFyc2V0LCBzcmM6IG4udXJsIH0pLm9uKFwibG9hZCBlcnJvclwiLCBpID0gZnVuY3Rpb24gKGUpIHsgci5yZW1vdmUoKSwgaSA9IG51bGwsIGUgJiYgdChcImVycm9yXCIgPT09IGUudHlwZSA/IDQwNCA6IDIwMCwgZS50eXBlKSB9KSwgRS5oZWFkLmFwcGVuZENoaWxkKHJbMF0pIH0sIGFib3J0OiBmdW5jdGlvbiAoKSB7IGkgJiYgaSgpIH0gfSB9KTsgdmFyIFZ0LCBHdCA9IFtdLCBZdCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87IGsuYWpheFNldHVwKHsganNvbnA6IFwiY2FsbGJhY2tcIiwganNvbnBDYWxsYmFjazogZnVuY3Rpb24gKCkgeyB2YXIgZSA9IEd0LnBvcCgpIHx8IGsuZXhwYW5kbyArIFwiX1wiICsga3QrKzsgcmV0dXJuIHRoaXNbZV0gPSAhMCwgZSB9IH0pLCBrLmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhID0gITEgIT09IGUuanNvbnAgJiYgKFl0LnRlc3QoZS51cmwpID8gXCJ1cmxcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuZGF0YSAmJiAwID09PSAoZS5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIFl0LnRlc3QoZS5kYXRhKSAmJiBcImRhdGFcIik7IGlmIChhIHx8IFwianNvbnBcIiA9PT0gZS5kYXRhVHlwZXNbMF0pIHJldHVybiByID0gZS5qc29ucENhbGxiYWNrID0gbShlLmpzb25wQ2FsbGJhY2spID8gZS5qc29ucENhbGxiYWNrKCkgOiBlLmpzb25wQ2FsbGJhY2ssIGEgPyBlW2FdID0gZVthXS5yZXBsYWNlKFl0LCBcIiQxXCIgKyByKSA6ICExICE9PSBlLmpzb25wICYmIChlLnVybCArPSAoU3QudGVzdChlLnVybCkgPyBcIiZcIiA6IFwiP1wiKSArIGUuanNvbnAgKyBcIj1cIiArIHIpLCBlLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG8gfHwgay5lcnJvcihyICsgXCIgd2FzIG5vdCBjYWxsZWRcIiksIG9bMF0gfSwgZS5kYXRhVHlwZXNbMF0gPSBcImpzb25cIiwgaSA9IENbcl0sIENbcl0gPSBmdW5jdGlvbiAoKSB7IG8gPSBhcmd1bWVudHMgfSwgbi5hbHdheXMoZnVuY3Rpb24gKCkgeyB2b2lkIDAgPT09IGkgPyBrKEMpLnJlbW92ZVByb3AocikgOiBDW3JdID0gaSwgZVtyXSAmJiAoZS5qc29ucENhbGxiYWNrID0gdC5qc29ucENhbGxiYWNrLCBHdC5wdXNoKHIpKSwgbyAmJiBtKGkpICYmIGkob1swXSksIG8gPSBpID0gdm9pZCAwIH0pLCBcInNjcmlwdFwiIH0pLCB5LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICgoVnQgPSBFLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5KS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCIsIDIgPT09IFZ0LmNoaWxkTm9kZXMubGVuZ3RoKSwgay5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoZSwgdCwgbikgeyByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSA/IFtdIDogKFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9ICExKSwgdCB8fCAoeS5jcmVhdGVIVE1MRG9jdW1lbnQgPyAoKHIgPSAodCA9IEUuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpKS5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSkuaHJlZiA9IEUubG9jYXRpb24uaHJlZiwgdC5oZWFkLmFwcGVuZENoaWxkKHIpKSA6IHQgPSBFKSwgbyA9ICFuICYmIFtdLCAoaSA9IEQuZXhlYyhlKSkgPyBbdC5jcmVhdGVFbGVtZW50KGlbMV0pXSA6IChpID0gd2UoW2VdLCB0LCBvKSwgbyAmJiBvLmxlbmd0aCAmJiBrKG8pLnJlbW92ZSgpLCBrLm1lcmdlKFtdLCBpLmNoaWxkTm9kZXMpKSk7IHZhciByLCBpLCBvIH0sIGsuZm4ubG9hZCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhID0gdGhpcywgcyA9IGUuaW5kZXhPZihcIiBcIik7IHJldHVybiAtMSA8IHMgJiYgKHIgPSBtdChlLnNsaWNlKHMpKSwgZSA9IGUuc2xpY2UoMCwgcykpLCBtKHQpID8gKG4gPSB0LCB0ID0gdm9pZCAwKSA6IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiAoaSA9IFwiUE9TVFwiKSwgMCA8IGEubGVuZ3RoICYmIGsuYWpheCh7IHVybDogZSwgdHlwZTogaSB8fCBcIkdFVFwiLCBkYXRhVHlwZTogXCJodG1sXCIsIGRhdGE6IHQgfSkuZG9uZShmdW5jdGlvbiAoZSkgeyBvID0gYXJndW1lbnRzLCBhLmh0bWwociA/IGsoXCI8ZGl2PlwiKS5hcHBlbmQoay5wYXJzZUhUTUwoZSkpLmZpbmQocikgOiBlKSB9KS5hbHdheXMobiAmJiBmdW5jdGlvbiAoZSwgdCkgeyBhLmVhY2goZnVuY3Rpb24gKCkgeyBuLmFwcGx5KHRoaXMsIG8gfHwgW2UucmVzcG9uc2VUZXh0LCB0LCBlXSkgfSkgfSksIHRoaXMgfSwgay5lYWNoKFtcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiXSwgZnVuY3Rpb24gKGUsIHQpIHsgay5mblt0XSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLm9uKHQsIGUpIH0gfSksIGsuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGsuZ3JlcChrLnRpbWVycywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQgPT09IGUuZWxlbSB9KS5sZW5ndGggfSwgay5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8sIGEsIHMsIHUsIGwgPSBrLmNzcyhlLCBcInBvc2l0aW9uXCIpLCBjID0gayhlKSwgZiA9IHt9OyBcInN0YXRpY1wiID09PSBsICYmIChlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiKSwgcyA9IGMub2Zmc2V0KCksIG8gPSBrLmNzcyhlLCBcInRvcFwiKSwgdSA9IGsuY3NzKGUsIFwibGVmdFwiKSwgKFwiYWJzb2x1dGVcIiA9PT0gbCB8fCBcImZpeGVkXCIgPT09IGwpICYmIC0xIDwgKG8gKyB1KS5pbmRleE9mKFwiYXV0b1wiKSA/IChhID0gKHIgPSBjLnBvc2l0aW9uKCkpLnRvcCwgaSA9IHIubGVmdCkgOiAoYSA9IHBhcnNlRmxvYXQobykgfHwgMCwgaSA9IHBhcnNlRmxvYXQodSkgfHwgMCksIG0odCkgJiYgKHQgPSB0LmNhbGwoZSwgbiwgay5leHRlbmQoe30sIHMpKSksIG51bGwgIT0gdC50b3AgJiYgKGYudG9wID0gdC50b3AgLSBzLnRvcCArIGEpLCBudWxsICE9IHQubGVmdCAmJiAoZi5sZWZ0ID0gdC5sZWZ0IC0gcy5sZWZ0ICsgaSksIFwidXNpbmdcIiBpbiB0ID8gdC51c2luZy5jYWxsKGUsIGYpIDogYy5jc3MoZikgfSB9LCBrLmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24gKHQpIHsgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2b2lkIDAgPT09IHQgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7IGsub2Zmc2V0LnNldE9mZnNldCh0aGlzLCB0LCBlKSB9KTsgdmFyIGUsIG4sIHIgPSB0aGlzWzBdOyByZXR1cm4gciA/IHIuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPyAoZSA9IHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSByLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsIHsgdG9wOiBlLnRvcCArIG4ucGFnZVlPZmZzZXQsIGxlZnQ6IGUubGVmdCArIG4ucGFnZVhPZmZzZXQgfSkgOiB7IHRvcDogMCwgbGVmdDogMCB9IDogdm9pZCAwIH0sIHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7IGlmICh0aGlzWzBdKSB7IHZhciBlLCB0LCBuLCByID0gdGhpc1swXSwgaSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07IGlmIChcImZpeGVkXCIgPT09IGsuY3NzKHIsIFwicG9zaXRpb25cIikpIHQgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyBlbHNlIHsgdCA9IHRoaXMub2Zmc2V0KCksIG4gPSByLm93bmVyRG9jdW1lbnQsIGUgPSByLm9mZnNldFBhcmVudCB8fCBuLmRvY3VtZW50RWxlbWVudDsgd2hpbGUgKGUgJiYgKGUgPT09IG4uYm9keSB8fCBlID09PSBuLmRvY3VtZW50RWxlbWVudCkgJiYgXCJzdGF0aWNcIiA9PT0gay5jc3MoZSwgXCJwb3NpdGlvblwiKSkgZSA9IGUucGFyZW50Tm9kZTsgZSAmJiBlICE9PSByICYmIDEgPT09IGUubm9kZVR5cGUgJiYgKChpID0gayhlKS5vZmZzZXQoKSkudG9wICs9IGsuY3NzKGUsIFwiYm9yZGVyVG9wV2lkdGhcIiwgITApLCBpLmxlZnQgKz0gay5jc3MoZSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgITApKSB9IHJldHVybiB7IHRvcDogdC50b3AgLSBpLnRvcCAtIGsuY3NzKHIsIFwibWFyZ2luVG9wXCIsICEwKSwgbGVmdDogdC5sZWZ0IC0gaS5sZWZ0IC0gay5jc3MociwgXCJtYXJnaW5MZWZ0XCIsICEwKSB9IH0gfSwgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7IHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQ7IHdoaWxlIChlICYmIFwic3RhdGljXCIgPT09IGsuY3NzKGUsIFwicG9zaXRpb25cIikpIGUgPSBlLm9mZnNldFBhcmVudDsgcmV0dXJuIGUgfHwgaWUgfSkgfSB9KSwgay5lYWNoKHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiAodCwgaSkgeyB2YXIgbyA9IFwicGFnZVlPZmZzZXRcIiA9PT0gaTsgay5mblt0XSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByOyBpZiAoeChlKSA/IHIgPSBlIDogOSA9PT0gZS5ub2RlVHlwZSAmJiAociA9IGUuZGVmYXVsdFZpZXcpLCB2b2lkIDAgPT09IG4pIHJldHVybiByID8gcltpXSA6IGVbdF07IHIgPyByLnNjcm9sbFRvKG8gPyByLnBhZ2VYT2Zmc2V0IDogbiwgbyA/IG4gOiByLnBhZ2VZT2Zmc2V0KSA6IGVbdF0gPSBuIH0sIHQsIGUsIGFyZ3VtZW50cy5sZW5ndGgpIH0gfSksIGsuZWFjaChbXCJ0b3BcIiwgXCJsZWZ0XCJdLCBmdW5jdGlvbiAoZSwgbikgeyBrLmNzc0hvb2tzW25dID0gemUoeS5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbiAoZSwgdCkgeyBpZiAodCkgcmV0dXJuIHQgPSBfZShlLCBuKSwgJGUudGVzdCh0KSA/IGsoZSkucG9zaXRpb24oKVtuXSArIFwicHhcIiA6IHQgfSkgfSksIGsuZWFjaCh7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiAoYSwgcykgeyBrLmVhY2goeyBwYWRkaW5nOiBcImlubmVyXCIgKyBhLCBjb250ZW50OiBzLCBcIlwiOiBcIm91dGVyXCIgKyBhIH0sIGZ1bmN0aW9uIChyLCBvKSB7IGsuZm5bb10gPSBmdW5jdGlvbiAoZSwgdCkgeyB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKHIgfHwgXCJib29sZWFuXCIgIT0gdHlwZW9mIGUpLCBpID0gciB8fCAoITAgPT09IGUgfHwgITAgPT09IHQgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7IHJldHVybiBfKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7IHZhciByOyByZXR1cm4geChlKSA/IDAgPT09IG8uaW5kZXhPZihcIm91dGVyXCIpID8gZVtcImlubmVyXCIgKyBhXSA6IGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBhXSA6IDkgPT09IGUubm9kZVR5cGUgPyAociA9IGUuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChlLmJvZHlbXCJzY3JvbGxcIiArIGFdLCByW1wic2Nyb2xsXCIgKyBhXSwgZS5ib2R5W1wib2Zmc2V0XCIgKyBhXSwgcltcIm9mZnNldFwiICsgYV0sIHJbXCJjbGllbnRcIiArIGFdKSkgOiB2b2lkIDAgPT09IG4gPyBrLmNzcyhlLCB0LCBpKSA6IGsuc3R5bGUoZSwgdCwgbiwgaSkgfSwgcywgbiA/IGUgOiB2b2lkIDAsIG4pIH0gfSkgfSksIGsuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChlLCBuKSB7IGsuZm5bbl0gPSBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gMCA8IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9uKG4sIG51bGwsIGUsIHQpIDogdGhpcy50cmlnZ2VyKG4pIH0gfSksIGsuZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uIChlLCB0KSB7IHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZSkubW91c2VsZWF2ZSh0IHx8IGUpIH0gfSksIGsuZm4uZXh0ZW5kKHsgYmluZDogZnVuY3Rpb24gKGUsIHQsIG4pIHsgcmV0dXJuIHRoaXMub24oZSwgbnVsbCwgdCwgbikgfSwgdW5iaW5kOiBmdW5jdGlvbiAoZSwgdCkgeyByZXR1cm4gdGhpcy5vZmYoZSwgbnVsbCwgdCkgfSwgZGVsZWdhdGU6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7IHJldHVybiB0aGlzLm9uKHQsIGUsIG4sIHIpIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7IHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5vZmYoZSwgXCIqKlwiKSA6IHRoaXMub2ZmKHQsIGUgfHwgXCIqKlwiLCBuKSB9IH0pLCBrLnByb3h5ID0gZnVuY3Rpb24gKGUsIHQpIHsgdmFyIG4sIHIsIGk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gZVt0XSwgdCA9IGUsIGUgPSBuKSwgbShlKSkgcmV0dXJuIHIgPSBzLmNhbGwoYXJndW1lbnRzLCAyKSwgKGkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlLmFwcGx5KHQgfHwgdGhpcywgci5jb25jYXQocy5jYWxsKGFyZ3VtZW50cykpKSB9KS5ndWlkID0gZS5ndWlkID0gZS5ndWlkIHx8IGsuZ3VpZCsrICwgaSB9LCBrLmhvbGRSZWFkeSA9IGZ1bmN0aW9uIChlKSB7IGUgPyBrLnJlYWR5V2FpdCsrIDogay5yZWFkeSghMCkgfSwgay5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgay5wYXJzZUpTT04gPSBKU09OLnBhcnNlLCBrLm5vZGVOYW1lID0gQSwgay5pc0Z1bmN0aW9uID0gbSwgay5pc1dpbmRvdyA9IHgsIGsuY2FtZWxDYXNlID0gViwgay50eXBlID0gdywgay5ub3cgPSBEYXRlLm5vdywgay5pc051bWVyaWMgPSBmdW5jdGlvbiAoZSkgeyB2YXIgdCA9IGsudHlwZShlKTsgcmV0dXJuIChcIm51bWJlclwiID09PSB0IHx8IFwic3RyaW5nXCIgPT09IHQpICYmICFpc05hTihlIC0gcGFyc2VGbG9hdChlKSkgfSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGsgfSk7IHZhciBRdCA9IEMualF1ZXJ5LCBKdCA9IEMuJDsgcmV0dXJuIGsubm9Db25mbGljdCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBDLiQgPT09IGsgJiYgKEMuJCA9IEp0KSwgZSAmJiBDLmpRdWVyeSA9PT0gayAmJiAoQy5qUXVlcnkgPSBRdCksIGsgfSwgZSB8fCAoQy5qUXVlcnkgPSBDLiQgPSBrKSwgayB9KTsiLCIvKiEgalF1ZXJ5IFZhbGlkYXRpb24gUGx1Z2luIC0gdjEuMTcuMCAtIDcvMjkvMjAxN1xyXG4gKiBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1xyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgSsO2cm4gWmFlZmZlcmVyOyBMaWNlbnNlZCBNSVQgKi9cclxuIWZ1bmN0aW9uIChhKSB7IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wianF1ZXJ5XCJdLCBhKSA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0gYShyZXF1aXJlKFwianF1ZXJ5XCIpKSA6IGEoalF1ZXJ5KSB9KGZ1bmN0aW9uIChhKSB7IGEuZXh0ZW5kKGEuZm4sIHsgdmFsaWRhdGU6IGZ1bmN0aW9uIChiKSB7IGlmICghdGhpcy5sZW5ndGgpIHJldHVybiB2b2lkIChiICYmIGIuZGVidWcgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKFwiTm90aGluZyBzZWxlY3RlZCwgY2FuJ3QgdmFsaWRhdGUsIHJldHVybmluZyBub3RoaW5nLlwiKSk7IHZhciBjID0gYS5kYXRhKHRoaXNbMF0sIFwidmFsaWRhdG9yXCIpOyByZXR1cm4gYyA/IGMgOiAodGhpcy5hdHRyKFwibm92YWxpZGF0ZVwiLCBcIm5vdmFsaWRhdGVcIiksIGMgPSBuZXcgYS52YWxpZGF0b3IoYiwgdGhpc1swXSksIGEuZGF0YSh0aGlzWzBdLCBcInZhbGlkYXRvclwiLCBjKSwgYy5zZXR0aW5ncy5vbnN1Ym1pdCAmJiAodGhpcy5vbihcImNsaWNrLnZhbGlkYXRlXCIsIFwiOnN1Ym1pdFwiLCBmdW5jdGlvbiAoYikgeyBjLnN1Ym1pdEJ1dHRvbiA9IGIuY3VycmVudFRhcmdldCwgYSh0aGlzKS5oYXNDbGFzcyhcImNhbmNlbFwiKSAmJiAoYy5jYW5jZWxTdWJtaXQgPSAhMCksIHZvaWQgMCAhPT0gYSh0aGlzKS5hdHRyKFwiZm9ybW5vdmFsaWRhdGVcIikgJiYgKGMuY2FuY2VsU3VibWl0ID0gITApIH0pLCB0aGlzLm9uKFwic3VibWl0LnZhbGlkYXRlXCIsIGZ1bmN0aW9uIChiKSB7IGZ1bmN0aW9uIGQoKSB7IHZhciBkLCBlOyByZXR1cm4gYy5zdWJtaXRCdXR0b24gJiYgKGMuc2V0dGluZ3Muc3VibWl0SGFuZGxlciB8fCBjLmZvcm1TdWJtaXR0ZWQpICYmIChkID0gYShcIjxpbnB1dCB0eXBlPSdoaWRkZW4nLz5cIikuYXR0cihcIm5hbWVcIiwgYy5zdWJtaXRCdXR0b24ubmFtZSkudmFsKGEoYy5zdWJtaXRCdXR0b24pLnZhbCgpKS5hcHBlbmRUbyhjLmN1cnJlbnRGb3JtKSksICFjLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgfHwgKGUgPSBjLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIuY2FsbChjLCBjLmN1cnJlbnRGb3JtLCBiKSwgZCAmJiBkLnJlbW92ZSgpLCB2b2lkIDAgIT09IGUgJiYgZSkgfSByZXR1cm4gYy5zZXR0aW5ncy5kZWJ1ZyAmJiBiLnByZXZlbnREZWZhdWx0KCksIGMuY2FuY2VsU3VibWl0ID8gKGMuY2FuY2VsU3VibWl0ID0gITEsIGQoKSkgOiBjLmZvcm0oKSA/IGMucGVuZGluZ1JlcXVlc3QgPyAoYy5mb3JtU3VibWl0dGVkID0gITAsICExKSA6IGQoKSA6IChjLmZvY3VzSW52YWxpZCgpLCAhMSkgfSkpLCBjKSB9LCB2YWxpZDogZnVuY3Rpb24gKCkgeyB2YXIgYiwgYywgZDsgcmV0dXJuIGEodGhpc1swXSkuaXMoXCJmb3JtXCIpID8gYiA9IHRoaXMudmFsaWRhdGUoKS5mb3JtKCkgOiAoZCA9IFtdLCBiID0gITAsIGMgPSBhKHRoaXNbMF0uZm9ybSkudmFsaWRhdGUoKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgYiA9IGMuZWxlbWVudCh0aGlzKSAmJiBiLCBiIHx8IChkID0gZC5jb25jYXQoYy5lcnJvckxpc3QpKSB9KSwgYy5lcnJvckxpc3QgPSBkKSwgYiB9LCBydWxlczogZnVuY3Rpb24gKGIsIGMpIHsgdmFyIGQsIGUsIGYsIGcsIGgsIGksIGogPSB0aGlzWzBdOyBpZiAobnVsbCAhPSBqICYmICghai5mb3JtICYmIGouaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmIChqLmZvcm0gPSB0aGlzLmNsb3Nlc3QoXCJmb3JtXCIpWzBdLCBqLm5hbWUgPSB0aGlzLmF0dHIoXCJuYW1lXCIpKSwgbnVsbCAhPSBqLmZvcm0pKSB7IGlmIChiKSBzd2l0Y2ggKGQgPSBhLmRhdGEoai5mb3JtLCBcInZhbGlkYXRvclwiKS5zZXR0aW5ncywgZSA9IGQucnVsZXMsIGYgPSBhLnZhbGlkYXRvci5zdGF0aWNSdWxlcyhqKSwgYikgeyBjYXNlIFwiYWRkXCI6IGEuZXh0ZW5kKGYsIGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoYykpLCBkZWxldGUgZi5tZXNzYWdlcywgZVtqLm5hbWVdID0gZiwgYy5tZXNzYWdlcyAmJiAoZC5tZXNzYWdlc1tqLm5hbWVdID0gYS5leHRlbmQoZC5tZXNzYWdlc1tqLm5hbWVdLCBjLm1lc3NhZ2VzKSk7IGJyZWFrOyBjYXNlIFwicmVtb3ZlXCI6IHJldHVybiBjID8gKGkgPSB7fSwgYS5lYWNoKGMuc3BsaXQoL1xccy8pLCBmdW5jdGlvbiAoYSwgYikgeyBpW2JdID0gZltiXSwgZGVsZXRlIGZbYl0gfSksIGkpIDogKGRlbGV0ZSBlW2oubmFtZV0sIGYpIH1yZXR1cm4gZyA9IGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGVzKGEuZXh0ZW5kKHt9LCBhLnZhbGlkYXRvci5jbGFzc1J1bGVzKGopLCBhLnZhbGlkYXRvci5hdHRyaWJ1dGVSdWxlcyhqKSwgYS52YWxpZGF0b3IuZGF0YVJ1bGVzKGopLCBhLnZhbGlkYXRvci5zdGF0aWNSdWxlcyhqKSksIGopLCBnLnJlcXVpcmVkICYmIChoID0gZy5yZXF1aXJlZCwgZGVsZXRlIGcucmVxdWlyZWQsIGcgPSBhLmV4dGVuZCh7IHJlcXVpcmVkOiBoIH0sIGcpKSwgZy5yZW1vdGUgJiYgKGggPSBnLnJlbW90ZSwgZGVsZXRlIGcucmVtb3RlLCBnID0gYS5leHRlbmQoZywgeyByZW1vdGU6IGggfSkpLCBnIH0gfSB9KSwgYS5leHRlbmQoYS5leHByLnBzZXVkb3MgfHwgYS5leHByW1wiOlwiXSwgeyBibGFuazogZnVuY3Rpb24gKGIpIHsgcmV0dXJuICFhLnRyaW0oXCJcIiArIGEoYikudmFsKCkpIH0sIGZpbGxlZDogZnVuY3Rpb24gKGIpIHsgdmFyIGMgPSBhKGIpLnZhbCgpOyByZXR1cm4gbnVsbCAhPT0gYyAmJiAhIWEudHJpbShcIlwiICsgYykgfSwgdW5jaGVja2VkOiBmdW5jdGlvbiAoYikgeyByZXR1cm4gIWEoYikucHJvcChcImNoZWNrZWRcIikgfSB9KSwgYS52YWxpZGF0b3IgPSBmdW5jdGlvbiAoYiwgYykgeyB0aGlzLnNldHRpbmdzID0gYS5leHRlbmQoITAsIHt9LCBhLnZhbGlkYXRvci5kZWZhdWx0cywgYiksIHRoaXMuY3VycmVudEZvcm0gPSBjLCB0aGlzLmluaXQoKSB9LCBhLnZhbGlkYXRvci5mb3JtYXQgPSBmdW5jdGlvbiAoYiwgYykgeyByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IGZ1bmN0aW9uICgpIHsgdmFyIGMgPSBhLm1ha2VBcnJheShhcmd1bWVudHMpOyByZXR1cm4gYy51bnNoaWZ0KGIpLCBhLnZhbGlkYXRvci5mb3JtYXQuYXBwbHkodGhpcywgYykgfSA6IHZvaWQgMCA9PT0gYyA/IGIgOiAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgKGMgPSBhLm1ha2VBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpKSwgYy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgKGMgPSBbY10pLCBhLmVhY2goYywgZnVuY3Rpb24gKGEsIGMpIHsgYiA9IGIucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXHtcIiArIGEgKyBcIlxcXFx9XCIsIFwiZ1wiKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYyB9KSB9KSwgYikgfSwgYS5leHRlbmQoYS52YWxpZGF0b3IsIHsgZGVmYXVsdHM6IHsgbWVzc2FnZXM6IHt9LCBncm91cHM6IHt9LCBydWxlczoge30sIGVycm9yQ2xhc3M6IFwiZXJyb3JcIiwgcGVuZGluZ0NsYXNzOiBcInBlbmRpbmdcIiwgdmFsaWRDbGFzczogXCJ2YWxpZFwiLCBlcnJvckVsZW1lbnQ6IFwibGFiZWxcIiwgZm9jdXNDbGVhbnVwOiAhMSwgZm9jdXNJbnZhbGlkOiAhMCwgZXJyb3JDb250YWluZXI6IGEoW10pLCBlcnJvckxhYmVsQ29udGFpbmVyOiBhKFtdKSwgb25zdWJtaXQ6ICEwLCBpZ25vcmU6IFwiOmhpZGRlblwiLCBpZ25vcmVUaXRsZTogITEsIG9uZm9jdXNpbjogZnVuY3Rpb24gKGEpIHsgdGhpcy5sYXN0QWN0aXZlID0gYSwgdGhpcy5zZXR0aW5ncy5mb2N1c0NsZWFudXAgJiYgKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgJiYgdGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKHRoaXMsIGEsIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcywgdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKSwgdGhpcy5oaWRlVGhlc2UodGhpcy5lcnJvcnNGb3IoYSkpKSB9LCBvbmZvY3Vzb3V0OiBmdW5jdGlvbiAoYSkgeyB0aGlzLmNoZWNrYWJsZShhKSB8fCAhKGEubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCkgJiYgdGhpcy5vcHRpb25hbChhKSB8fCB0aGlzLmVsZW1lbnQoYSkgfSwgb25rZXl1cDogZnVuY3Rpb24gKGIsIGMpIHsgdmFyIGQgPSBbMTYsIDE3LCAxOCwgMjAsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQ1LCAxNDQsIDIyNV07IDkgPT09IGMud2hpY2ggJiYgXCJcIiA9PT0gdGhpcy5lbGVtZW50VmFsdWUoYikgfHwgYS5pbkFycmF5KGMua2V5Q29kZSwgZCkgIT09IC0xIHx8IChiLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgYi5uYW1lIGluIHRoaXMuaW52YWxpZCkgJiYgdGhpcy5lbGVtZW50KGIpIH0sIG9uY2xpY2s6IGZ1bmN0aW9uIChhKSB7IGEubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCA/IHRoaXMuZWxlbWVudChhKSA6IGEucGFyZW50Tm9kZS5uYW1lIGluIHRoaXMuc3VibWl0dGVkICYmIHRoaXMuZWxlbWVudChhLnBhcmVudE5vZGUpIH0sIGhpZ2hsaWdodDogZnVuY3Rpb24gKGIsIGMsIGQpIHsgXCJyYWRpb1wiID09PSBiLnR5cGUgPyB0aGlzLmZpbmRCeU5hbWUoYi5uYW1lKS5hZGRDbGFzcyhjKS5yZW1vdmVDbGFzcyhkKSA6IGEoYikuYWRkQ2xhc3MoYykucmVtb3ZlQ2xhc3MoZCkgfSwgdW5oaWdobGlnaHQ6IGZ1bmN0aW9uIChiLCBjLCBkKSB7IFwicmFkaW9cIiA9PT0gYi50eXBlID8gdGhpcy5maW5kQnlOYW1lKGIubmFtZSkucmVtb3ZlQ2xhc3MoYykuYWRkQ2xhc3MoZCkgOiBhKGIpLnJlbW92ZUNsYXNzKGMpLmFkZENsYXNzKGQpIH0gfSwgc2V0RGVmYXVsdHM6IGZ1bmN0aW9uIChiKSB7IGEuZXh0ZW5kKGEudmFsaWRhdG9yLmRlZmF1bHRzLCBiKSB9LCBtZXNzYWdlczogeyByZXF1aXJlZDogXCJUaGlzIGZpZWxkIGlzIHJlcXVpcmVkLlwiLCByZW1vdGU6IFwiUGxlYXNlIGZpeCB0aGlzIGZpZWxkLlwiLCBlbWFpbDogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlwiLCB1cmw6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgVVJMLlwiLCBkYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUuXCIsIGRhdGVJU086IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZGF0ZSAoSVNPKS5cIiwgbnVtYmVyOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIG51bWJlci5cIiwgZGlnaXRzOiBcIlBsZWFzZSBlbnRlciBvbmx5IGRpZ2l0cy5cIiwgZXF1YWxUbzogXCJQbGVhc2UgZW50ZXIgdGhlIHNhbWUgdmFsdWUgYWdhaW4uXCIsIG1heGxlbmd0aDogYS52YWxpZGF0b3IuZm9ybWF0KFwiUGxlYXNlIGVudGVyIG5vIG1vcmUgdGhhbiB7MH0gY2hhcmFjdGVycy5cIiksIG1pbmxlbmd0aDogYS52YWxpZGF0b3IuZm9ybWF0KFwiUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLlwiKSwgcmFuZ2VsZW5ndGg6IGEudmFsaWRhdG9yLmZvcm1hdChcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0gY2hhcmFjdGVycyBsb25nLlwiKSwgcmFuZ2U6IGEudmFsaWRhdG9yLmZvcm1hdChcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0uXCIpLCBtYXg6IGEudmFsaWRhdG9yLmZvcm1hdChcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uXCIpLCBtaW46IGEudmFsaWRhdG9yLmZvcm1hdChcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7MH0uXCIpLCBzdGVwOiBhLnZhbGlkYXRvci5mb3JtYXQoXCJQbGVhc2UgZW50ZXIgYSBtdWx0aXBsZSBvZiB7MH0uXCIpIH0sIGF1dG9DcmVhdGVSYW5nZXM6ICExLCBwcm90b3R5cGU6IHsgaW5pdDogZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBiKGIpIHsgIXRoaXMuZm9ybSAmJiB0aGlzLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAmJiAodGhpcy5mb3JtID0gYSh0aGlzKS5jbG9zZXN0KFwiZm9ybVwiKVswXSwgdGhpcy5uYW1lID0gYSh0aGlzKS5hdHRyKFwibmFtZVwiKSk7IHZhciBjID0gYS5kYXRhKHRoaXMuZm9ybSwgXCJ2YWxpZGF0b3JcIiksIGQgPSBcIm9uXCIgKyBiLnR5cGUucmVwbGFjZSgvXnZhbGlkYXRlLywgXCJcIiksIGUgPSBjLnNldHRpbmdzOyBlW2RdICYmICFhKHRoaXMpLmlzKGUuaWdub3JlKSAmJiBlW2RdLmNhbGwoYywgdGhpcywgYikgfSB0aGlzLmxhYmVsQ29udGFpbmVyID0gYSh0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIpLCB0aGlzLmVycm9yQ29udGV4dCA9IHRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoICYmIHRoaXMubGFiZWxDb250YWluZXIgfHwgYSh0aGlzLmN1cnJlbnRGb3JtKSwgdGhpcy5jb250YWluZXJzID0gYSh0aGlzLnNldHRpbmdzLmVycm9yQ29udGFpbmVyKS5hZGQodGhpcy5zZXR0aW5ncy5lcnJvckxhYmVsQ29udGFpbmVyKSwgdGhpcy5zdWJtaXR0ZWQgPSB7fSwgdGhpcy52YWx1ZUNhY2hlID0ge30sIHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwLCB0aGlzLnBlbmRpbmcgPSB7fSwgdGhpcy5pbnZhbGlkID0ge30sIHRoaXMucmVzZXQoKTsgdmFyIGMsIGQgPSB0aGlzLmdyb3VwcyA9IHt9OyBhLmVhY2godGhpcy5zZXR0aW5ncy5ncm91cHMsIGZ1bmN0aW9uIChiLCBjKSB7IFwic3RyaW5nXCIgPT0gdHlwZW9mIGMgJiYgKGMgPSBjLnNwbGl0KC9cXHMvKSksIGEuZWFjaChjLCBmdW5jdGlvbiAoYSwgYykgeyBkW2NdID0gYiB9KSB9KSwgYyA9IHRoaXMuc2V0dGluZ3MucnVsZXMsIGEuZWFjaChjLCBmdW5jdGlvbiAoYiwgZCkgeyBjW2JdID0gYS52YWxpZGF0b3Iubm9ybWFsaXplUnVsZShkKSB9KSwgYSh0aGlzLmN1cnJlbnRGb3JtKS5vbihcImZvY3VzaW4udmFsaWRhdGUgZm9jdXNvdXQudmFsaWRhdGUga2V5dXAudmFsaWRhdGVcIiwgXCI6dGV4dCwgW3R5cGU9J3Bhc3N3b3JkJ10sIFt0eXBlPSdmaWxlJ10sIHNlbGVjdCwgdGV4dGFyZWEsIFt0eXBlPSdudW1iZXInXSwgW3R5cGU9J3NlYXJjaCddLCBbdHlwZT0ndGVsJ10sIFt0eXBlPSd1cmwnXSwgW3R5cGU9J2VtYWlsJ10sIFt0eXBlPSdkYXRldGltZSddLCBbdHlwZT0nZGF0ZSddLCBbdHlwZT0nbW9udGgnXSwgW3R5cGU9J3dlZWsnXSwgW3R5cGU9J3RpbWUnXSwgW3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sIFt0eXBlPSdyYW5nZSddLCBbdHlwZT0nY29sb3InXSwgW3R5cGU9J3JhZGlvJ10sIFt0eXBlPSdjaGVja2JveCddLCBbY29udGVudGVkaXRhYmxlXSwgW3R5cGU9J2J1dHRvbiddXCIsIGIpLm9uKFwiY2xpY2sudmFsaWRhdGVcIiwgXCJzZWxlY3QsIG9wdGlvbiwgW3R5cGU9J3JhZGlvJ10sIFt0eXBlPSdjaGVja2JveCddXCIsIGIpLCB0aGlzLnNldHRpbmdzLmludmFsaWRIYW5kbGVyICYmIGEodGhpcy5jdXJyZW50Rm9ybSkub24oXCJpbnZhbGlkLWZvcm0udmFsaWRhdGVcIiwgdGhpcy5zZXR0aW5ncy5pbnZhbGlkSGFuZGxlcikgfSwgZm9ybTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaGVja0Zvcm0oKSwgYS5leHRlbmQodGhpcy5zdWJtaXR0ZWQsIHRoaXMuZXJyb3JNYXApLCB0aGlzLmludmFsaWQgPSBhLmV4dGVuZCh7fSwgdGhpcy5lcnJvck1hcCksIHRoaXMudmFsaWQoKSB8fCBhKHRoaXMuY3VycmVudEZvcm0pLnRyaWdnZXJIYW5kbGVyKFwiaW52YWxpZC1mb3JtXCIsIFt0aGlzXSksIHRoaXMuc2hvd0Vycm9ycygpLCB0aGlzLnZhbGlkKCkgfSwgY2hlY2tGb3JtOiBmdW5jdGlvbiAoKSB7IHRoaXMucHJlcGFyZUZvcm0oKTsgZm9yICh2YXIgYSA9IDAsIGIgPSB0aGlzLmN1cnJlbnRFbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTsgYlthXTsgYSsrKXRoaXMuY2hlY2soYlthXSk7IHJldHVybiB0aGlzLnZhbGlkKCkgfSwgZWxlbWVudDogZnVuY3Rpb24gKGIpIHsgdmFyIGMsIGQsIGUgPSB0aGlzLmNsZWFuKGIpLCBmID0gdGhpcy52YWxpZGF0aW9uVGFyZ2V0Rm9yKGUpLCBnID0gdGhpcywgaCA9ICEwOyByZXR1cm4gdm9pZCAwID09PSBmID8gZGVsZXRlIHRoaXMuaW52YWxpZFtlLm5hbWVdIDogKHRoaXMucHJlcGFyZUVsZW1lbnQoZiksIHRoaXMuY3VycmVudEVsZW1lbnRzID0gYShmKSwgZCA9IHRoaXMuZ3JvdXBzW2YubmFtZV0sIGQgJiYgYS5lYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoYSwgYikgeyBiID09PSBkICYmIGEgIT09IGYubmFtZSAmJiAoZSA9IGcudmFsaWRhdGlvblRhcmdldEZvcihnLmNsZWFuKGcuZmluZEJ5TmFtZShhKSkpLCBlICYmIGUubmFtZSBpbiBnLmludmFsaWQgJiYgKGcuY3VycmVudEVsZW1lbnRzLnB1c2goZSksIGggPSBnLmNoZWNrKGUpICYmIGgpKSB9KSwgYyA9IHRoaXMuY2hlY2soZikgIT09ICExLCBoID0gaCAmJiBjLCBjID8gdGhpcy5pbnZhbGlkW2YubmFtZV0gPSAhMSA6IHRoaXMuaW52YWxpZFtmLm5hbWVdID0gITAsIHRoaXMubnVtYmVyT2ZJbnZhbGlkcygpIHx8ICh0aGlzLnRvSGlkZSA9IHRoaXMudG9IaWRlLmFkZCh0aGlzLmNvbnRhaW5lcnMpKSwgdGhpcy5zaG93RXJyb3JzKCksIGEoYikuYXR0cihcImFyaWEtaW52YWxpZFwiLCAhYykpLCBoIH0sIHNob3dFcnJvcnM6IGZ1bmN0aW9uIChiKSB7IGlmIChiKSB7IHZhciBjID0gdGhpczsgYS5leHRlbmQodGhpcy5lcnJvck1hcCwgYiksIHRoaXMuZXJyb3JMaXN0ID0gYS5tYXAodGhpcy5lcnJvck1hcCwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHsgbWVzc2FnZTogYSwgZWxlbWVudDogYy5maW5kQnlOYW1lKGIpWzBdIH0gfSksIHRoaXMuc3VjY2Vzc0xpc3QgPSBhLmdyZXAodGhpcy5zdWNjZXNzTGlzdCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICEoYS5uYW1lIGluIGIpIH0pIH0gdGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzID8gdGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzLmNhbGwodGhpcywgdGhpcy5lcnJvck1hcCwgdGhpcy5lcnJvckxpc3QpIDogdGhpcy5kZWZhdWx0U2hvd0Vycm9ycygpIH0sIHJlc2V0Rm9ybTogZnVuY3Rpb24gKCkgeyBhLmZuLnJlc2V0Rm9ybSAmJiBhKHRoaXMuY3VycmVudEZvcm0pLnJlc2V0Rm9ybSgpLCB0aGlzLmludmFsaWQgPSB7fSwgdGhpcy5zdWJtaXR0ZWQgPSB7fSwgdGhpcy5wcmVwYXJlRm9ybSgpLCB0aGlzLmhpZGVFcnJvcnMoKTsgdmFyIGIgPSB0aGlzLmVsZW1lbnRzKCkucmVtb3ZlRGF0YShcInByZXZpb3VzVmFsdWVcIikucmVtb3ZlQXR0cihcImFyaWEtaW52YWxpZFwiKTsgdGhpcy5yZXNldEVsZW1lbnRzKGIpIH0sIHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uIChhKSB7IHZhciBiOyBpZiAodGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodCkgZm9yIChiID0gMDsgYVtiXTsgYisrKXRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCh0aGlzLCBhW2JdLCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIFwiXCIpLCB0aGlzLmZpbmRCeU5hbWUoYVtiXS5uYW1lKS5yZW1vdmVDbGFzcyh0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MpOyBlbHNlIGEucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MpIH0sIG51bWJlck9mSW52YWxpZHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub2JqZWN0TGVuZ3RoKHRoaXMuaW52YWxpZCkgfSwgb2JqZWN0TGVuZ3RoOiBmdW5jdGlvbiAoYSkgeyB2YXIgYiwgYyA9IDA7IGZvciAoYiBpbiBhKSB2b2lkIDAgIT09IGFbYl0gJiYgbnVsbCAhPT0gYVtiXSAmJiBhW2JdICE9PSAhMSAmJiBjKys7IHJldHVybiBjIH0sIGhpZGVFcnJvcnM6IGZ1bmN0aW9uICgpIHsgdGhpcy5oaWRlVGhlc2UodGhpcy50b0hpZGUpIH0sIGhpZGVUaGVzZTogZnVuY3Rpb24gKGEpIHsgYS5ub3QodGhpcy5jb250YWluZXJzKS50ZXh0KFwiXCIpLCB0aGlzLmFkZFdyYXBwZXIoYSkuaGlkZSgpIH0sIHZhbGlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAwID09PSB0aGlzLnNpemUoKSB9LCBzaXplOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVycm9yTGlzdC5sZW5ndGggfSwgZm9jdXNJbnZhbGlkOiBmdW5jdGlvbiAoKSB7IGlmICh0aGlzLnNldHRpbmdzLmZvY3VzSW52YWxpZCkgdHJ5IHsgYSh0aGlzLmZpbmRMYXN0QWN0aXZlKCkgfHwgdGhpcy5lcnJvckxpc3QubGVuZ3RoICYmIHRoaXMuZXJyb3JMaXN0WzBdLmVsZW1lbnQgfHwgW10pLmZpbHRlcihcIjp2aXNpYmxlXCIpLmZvY3VzKCkudHJpZ2dlcihcImZvY3VzaW5cIikgfSBjYXRjaCAoYikgeyB9IH0sIGZpbmRMYXN0QWN0aXZlOiBmdW5jdGlvbiAoKSB7IHZhciBiID0gdGhpcy5sYXN0QWN0aXZlOyByZXR1cm4gYiAmJiAxID09PSBhLmdyZXAodGhpcy5lcnJvckxpc3QsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmVsZW1lbnQubmFtZSA9PT0gYi5uYW1lIH0pLmxlbmd0aCAmJiBiIH0sIGVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7IHZhciBiID0gdGhpcywgYyA9IHt9OyByZXR1cm4gYSh0aGlzLmN1cnJlbnRGb3JtKS5maW5kKFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFtjb250ZW50ZWRpdGFibGVdXCIpLm5vdChcIjpzdWJtaXQsIDpyZXNldCwgOmltYWdlLCA6ZGlzYWJsZWRcIikubm90KHRoaXMuc2V0dGluZ3MuaWdub3JlKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyB2YXIgZCA9IHRoaXMubmFtZSB8fCBhKHRoaXMpLmF0dHIoXCJuYW1lXCIpOyByZXR1cm4gIWQgJiYgYi5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKFwiJW8gaGFzIG5vIG5hbWUgYXNzaWduZWRcIiwgdGhpcyksIHRoaXMuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmICh0aGlzLmZvcm0gPSBhKHRoaXMpLmNsb3Nlc3QoXCJmb3JtXCIpWzBdLCB0aGlzLm5hbWUgPSBkKSwgIShkIGluIGMgfHwgIWIub2JqZWN0TGVuZ3RoKGEodGhpcykucnVsZXMoKSkpICYmIChjW2RdID0gITAsICEwKSB9KSB9LCBjbGVhbjogZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGEoYilbMF0gfSwgZXJyb3JzOiBmdW5jdGlvbiAoKSB7IHZhciBiID0gdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKTsgcmV0dXJuIGEodGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIi5cIiArIGIsIHRoaXMuZXJyb3JDb250ZXh0KSB9LCByZXNldEludGVybmFsczogZnVuY3Rpb24gKCkgeyB0aGlzLnN1Y2Nlc3NMaXN0ID0gW10sIHRoaXMuZXJyb3JMaXN0ID0gW10sIHRoaXMuZXJyb3JNYXAgPSB7fSwgdGhpcy50b1Nob3cgPSBhKFtdKSwgdGhpcy50b0hpZGUgPSBhKFtdKSB9LCByZXNldDogZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0SW50ZXJuYWxzKCksIHRoaXMuY3VycmVudEVsZW1lbnRzID0gYShbXSkgfSwgcHJlcGFyZUZvcm06IGZ1bmN0aW9uICgpIHsgdGhpcy5yZXNldCgpLCB0aGlzLnRvSGlkZSA9IHRoaXMuZXJyb3JzKCkuYWRkKHRoaXMuY29udGFpbmVycykgfSwgcHJlcGFyZUVsZW1lbnQ6IGZ1bmN0aW9uIChhKSB7IHRoaXMucmVzZXQoKSwgdGhpcy50b0hpZGUgPSB0aGlzLmVycm9yc0ZvcihhKSB9LCBlbGVtZW50VmFsdWU6IGZ1bmN0aW9uIChiKSB7IHZhciBjLCBkLCBlID0gYShiKSwgZiA9IGIudHlwZTsgcmV0dXJuIFwicmFkaW9cIiA9PT0gZiB8fCBcImNoZWNrYm94XCIgPT09IGYgPyB0aGlzLmZpbmRCeU5hbWUoYi5uYW1lKS5maWx0ZXIoXCI6Y2hlY2tlZFwiKS52YWwoKSA6IFwibnVtYmVyXCIgPT09IGYgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYi52YWxpZGl0eSA/IGIudmFsaWRpdHkuYmFkSW5wdXQgPyBcIk5hTlwiIDogZS52YWwoKSA6IChjID0gYi5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgPyBlLnRleHQoKSA6IGUudmFsKCksIFwiZmlsZVwiID09PSBmID8gXCJDOlxcXFxmYWtlcGF0aFxcXFxcIiA9PT0gYy5zdWJzdHIoMCwgMTIpID8gYy5zdWJzdHIoMTIpIDogKGQgPSBjLmxhc3RJbmRleE9mKFwiL1wiKSwgZCA+PSAwID8gYy5zdWJzdHIoZCArIDEpIDogKGQgPSBjLmxhc3RJbmRleE9mKFwiXFxcXFwiKSwgZCA+PSAwID8gYy5zdWJzdHIoZCArIDEpIDogYykpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZSgvXFxyL2csIFwiXCIpIDogYykgfSwgY2hlY2s6IGZ1bmN0aW9uIChiKSB7IGIgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IodGhpcy5jbGVhbihiKSk7IHZhciBjLCBkLCBlLCBmLCBnID0gYShiKS5ydWxlcygpLCBoID0gYS5tYXAoZywgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIgfSkubGVuZ3RoLCBpID0gITEsIGogPSB0aGlzLmVsZW1lbnRWYWx1ZShiKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZy5ub3JtYWxpemVyID8gZiA9IGcubm9ybWFsaXplciA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5zZXR0aW5ncy5ub3JtYWxpemVyICYmIChmID0gdGhpcy5zZXR0aW5ncy5ub3JtYWxpemVyKSwgZikgeyBpZiAoaiA9IGYuY2FsbChiLCBqKSwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgaikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBub3JtYWxpemVyIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgdmFsdWUuXCIpOyBkZWxldGUgZy5ub3JtYWxpemVyIH0gZm9yIChkIGluIGcpIHsgZSA9IHsgbWV0aG9kOiBkLCBwYXJhbWV0ZXJzOiBnW2RdIH07IHRyeSB7IGlmIChjID0gYS52YWxpZGF0b3IubWV0aG9kc1tkXS5jYWxsKHRoaXMsIGosIGIsIGUucGFyYW1ldGVycyksIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiID09PSBjICYmIDEgPT09IGgpIHsgaSA9ICEwOyBjb250aW51ZSB9IGlmIChpID0gITEsIFwicGVuZGluZ1wiID09PSBjKSByZXR1cm4gdm9pZCAodGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QodGhpcy5lcnJvcnNGb3IoYikpKTsgaWYgKCFjKSByZXR1cm4gdGhpcy5mb3JtYXRBbmRBZGQoYiwgZSksICExIH0gY2F0Y2ggKGspIHsgdGhyb3cgdGhpcy5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyhcIkV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXCIgKyBiLmlkICsgXCIsIGNoZWNrIHRoZSAnXCIgKyBlLm1ldGhvZCArIFwiJyBtZXRob2QuXCIsIGspLCBrIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChrLm1lc3NhZ2UgKz0gXCIuICBFeGNlcHRpb24gb2NjdXJyZWQgd2hlbiBjaGVja2luZyBlbGVtZW50IFwiICsgYi5pZCArIFwiLCBjaGVjayB0aGUgJ1wiICsgZS5tZXRob2QgKyBcIicgbWV0aG9kLlwiKSwgayB9IH0gaWYgKCFpKSByZXR1cm4gdGhpcy5vYmplY3RMZW5ndGgoZykgJiYgdGhpcy5zdWNjZXNzTGlzdC5wdXNoKGIpLCAhMCB9LCBjdXN0b21EYXRhTWVzc2FnZTogZnVuY3Rpb24gKGIsIGMpIHsgcmV0dXJuIGEoYikuZGF0YShcIm1zZ1wiICsgYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGMuc3Vic3RyaW5nKDEpLnRvTG93ZXJDYXNlKCkpIHx8IGEoYikuZGF0YShcIm1zZ1wiKSB9LCBjdXN0b21NZXNzYWdlOiBmdW5jdGlvbiAoYSwgYikgeyB2YXIgYyA9IHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbYV07IHJldHVybiBjICYmIChjLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBjIDogY1tiXSkgfSwgZmluZERlZmluZWQ6IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspaWYgKHZvaWQgMCAhPT0gYXJndW1lbnRzW2FdKSByZXR1cm4gYXJndW1lbnRzW2FdIH0sIGRlZmF1bHRNZXNzYWdlOiBmdW5jdGlvbiAoYiwgYykgeyBcInN0cmluZ1wiID09IHR5cGVvZiBjICYmIChjID0geyBtZXRob2Q6IGMgfSk7IHZhciBkID0gdGhpcy5maW5kRGVmaW5lZCh0aGlzLmN1c3RvbU1lc3NhZ2UoYi5uYW1lLCBjLm1ldGhvZCksIHRoaXMuY3VzdG9tRGF0YU1lc3NhZ2UoYiwgYy5tZXRob2QpLCAhdGhpcy5zZXR0aW5ncy5pZ25vcmVUaXRsZSAmJiBiLnRpdGxlIHx8IHZvaWQgMCwgYS52YWxpZGF0b3IubWVzc2FnZXNbYy5tZXRob2RdLCBcIjxzdHJvbmc+V2FybmluZzogTm8gbWVzc2FnZSBkZWZpbmVkIGZvciBcIiArIGIubmFtZSArIFwiPC9zdHJvbmc+XCIpLCBlID0gL1xcJD9cXHsoXFxkKylcXH0vZzsgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZCA/IGQgPSBkLmNhbGwodGhpcywgYy5wYXJhbWV0ZXJzLCBiKSA6IGUudGVzdChkKSAmJiAoZCA9IGEudmFsaWRhdG9yLmZvcm1hdChkLnJlcGxhY2UoZSwgXCJ7JDF9XCIpLCBjLnBhcmFtZXRlcnMpKSwgZCB9LCBmb3JtYXRBbmRBZGQ6IGZ1bmN0aW9uIChhLCBiKSB7IHZhciBjID0gdGhpcy5kZWZhdWx0TWVzc2FnZShhLCBiKTsgdGhpcy5lcnJvckxpc3QucHVzaCh7IG1lc3NhZ2U6IGMsIGVsZW1lbnQ6IGEsIG1ldGhvZDogYi5tZXRob2QgfSksIHRoaXMuZXJyb3JNYXBbYS5uYW1lXSA9IGMsIHRoaXMuc3VibWl0dGVkW2EubmFtZV0gPSBjIH0sIGFkZFdyYXBwZXI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0aGlzLnNldHRpbmdzLndyYXBwZXIgJiYgKGEgPSBhLmFkZChhLnBhcmVudCh0aGlzLnNldHRpbmdzLndyYXBwZXIpKSksIGEgfSwgZGVmYXVsdFNob3dFcnJvcnM6IGZ1bmN0aW9uICgpIHsgdmFyIGEsIGIsIGM7IGZvciAoYSA9IDA7IHRoaXMuZXJyb3JMaXN0W2FdOyBhKyspYyA9IHRoaXMuZXJyb3JMaXN0W2FdLCB0aGlzLnNldHRpbmdzLmhpZ2hsaWdodCAmJiB0aGlzLnNldHRpbmdzLmhpZ2hsaWdodC5jYWxsKHRoaXMsIGMuZWxlbWVudCwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MpLCB0aGlzLnNob3dMYWJlbChjLmVsZW1lbnQsIGMubWVzc2FnZSk7IGlmICh0aGlzLmVycm9yTGlzdC5sZW5ndGggJiYgKHRoaXMudG9TaG93ID0gdGhpcy50b1Nob3cuYWRkKHRoaXMuY29udGFpbmVycykpLCB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MpIGZvciAoYSA9IDA7IHRoaXMuc3VjY2Vzc0xpc3RbYV07IGErKyl0aGlzLnNob3dMYWJlbCh0aGlzLnN1Y2Nlc3NMaXN0W2FdKTsgaWYgKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQpIGZvciAoYSA9IDAsIGIgPSB0aGlzLnZhbGlkRWxlbWVudHMoKTsgYlthXTsgYSsrKXRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCh0aGlzLCBiW2FdLCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyk7IHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUubm90KHRoaXMudG9TaG93KSwgdGhpcy5oaWRlRXJyb3JzKCksIHRoaXMuYWRkV3JhcHBlcih0aGlzLnRvU2hvdykuc2hvdygpIH0sIHZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRzLm5vdCh0aGlzLmludmFsaWRFbGVtZW50cygpKSB9LCBpbnZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGEodGhpcy5lcnJvckxpc3QpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVsZW1lbnQgfSkgfSwgc2hvd0xhYmVsOiBmdW5jdGlvbiAoYiwgYykgeyB2YXIgZCwgZSwgZiwgZywgaCA9IHRoaXMuZXJyb3JzRm9yKGIpLCBpID0gdGhpcy5pZE9yTmFtZShiKSwgaiA9IGEoYikuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIik7IGgubGVuZ3RoID8gKGgucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKS5hZGRDbGFzcyh0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MpLCBoLmh0bWwoYykpIDogKGggPSBhKFwiPFwiICsgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIj5cIikuYXR0cihcImlkXCIsIGkgKyBcIi1lcnJvclwiKS5hZGRDbGFzcyh0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MpLmh0bWwoYyB8fCBcIlwiKSwgZCA9IGgsIHRoaXMuc2V0dGluZ3Mud3JhcHBlciAmJiAoZCA9IGguaGlkZSgpLnNob3coKS53cmFwKFwiPFwiICsgdGhpcy5zZXR0aW5ncy53cmFwcGVyICsgXCIvPlwiKS5wYXJlbnQoKSksIHRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoID8gdGhpcy5sYWJlbENvbnRhaW5lci5hcHBlbmQoZCkgOiB0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50ID8gdGhpcy5zZXR0aW5ncy5lcnJvclBsYWNlbWVudC5jYWxsKHRoaXMsIGQsIGEoYikpIDogZC5pbnNlcnRBZnRlcihiKSwgaC5pcyhcImxhYmVsXCIpID8gaC5hdHRyKFwiZm9yXCIsIGkpIDogMCA9PT0gaC5wYXJlbnRzKFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YShpKSArIFwiJ11cIikubGVuZ3RoICYmIChmID0gaC5hdHRyKFwiaWRcIiksIGogPyBqLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgdGhpcy5lc2NhcGVDc3NNZXRhKGYpICsgXCJcXFxcYlwiKSkgfHwgKGogKz0gXCIgXCIgKyBmKSA6IGogPSBmLCBhKGIpLmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGopLCBlID0gdGhpcy5ncm91cHNbYi5uYW1lXSwgZSAmJiAoZyA9IHRoaXMsIGEuZWFjaChnLmdyb3VwcywgZnVuY3Rpb24gKGIsIGMpIHsgYyA9PT0gZSAmJiBhKFwiW25hbWU9J1wiICsgZy5lc2NhcGVDc3NNZXRhKGIpICsgXCInXVwiLCBnLmN1cnJlbnRGb3JtKS5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiLCBoLmF0dHIoXCJpZFwiKSkgfSkpKSksICFjICYmIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyAmJiAoaC50ZXh0KFwiXCIpLCBcInN0cmluZ1wiID09IHR5cGVvZiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MgPyBoLmFkZENsYXNzKHRoaXMuc2V0dGluZ3Muc3VjY2VzcykgOiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MoaCwgYikpLCB0aGlzLnRvU2hvdyA9IHRoaXMudG9TaG93LmFkZChoKSB9LCBlcnJvcnNGb3I6IGZ1bmN0aW9uIChiKSB7IHZhciBjID0gdGhpcy5lc2NhcGVDc3NNZXRhKHRoaXMuaWRPck5hbWUoYikpLCBkID0gYShiKS5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgZSA9IFwibGFiZWxbZm9yPSdcIiArIGMgKyBcIiddLCBsYWJlbFtmb3I9J1wiICsgYyArIFwiJ10gKlwiOyByZXR1cm4gZCAmJiAoZSA9IGUgKyBcIiwgI1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKGQpLnJlcGxhY2UoL1xccysvZywgXCIsICNcIikpLCB0aGlzLmVycm9ycygpLmZpbHRlcihlKSB9LCBlc2NhcGVDc3NNZXRhOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5yZXBsYWNlKC8oW1xcXFwhXCIjJCUmJygpKissLlxcLzo7PD0+P0BcXFtcXF1eYHt8fX5dKS9nLCBcIlxcXFwkMVwiKSB9LCBpZE9yTmFtZTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRoaXMuZ3JvdXBzW2EubmFtZV0gfHwgKHRoaXMuY2hlY2thYmxlKGEpID8gYS5uYW1lIDogYS5pZCB8fCBhLm5hbWUpIH0sIHZhbGlkYXRpb25UYXJnZXRGb3I6IGZ1bmN0aW9uIChiKSB7IHJldHVybiB0aGlzLmNoZWNrYWJsZShiKSAmJiAoYiA9IHRoaXMuZmluZEJ5TmFtZShiLm5hbWUpKSwgYShiKS5ub3QodGhpcy5zZXR0aW5ncy5pZ25vcmUpWzBdIH0sIGNoZWNrYWJsZTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9yYWRpb3xjaGVja2JveC9pLnRlc3QoYS50eXBlKSB9LCBmaW5kQnlOYW1lOiBmdW5jdGlvbiAoYikgeyByZXR1cm4gYSh0aGlzLmN1cnJlbnRGb3JtKS5maW5kKFwiW25hbWU9J1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKGIpICsgXCInXVwiKSB9LCBnZXRMZW5ndGg6IGZ1bmN0aW9uIChiLCBjKSB7IHN3aXRjaCAoYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7IGNhc2UgXCJzZWxlY3RcIjogcmV0dXJuIGEoXCJvcHRpb246c2VsZWN0ZWRcIiwgYykubGVuZ3RoOyBjYXNlIFwiaW5wdXRcIjogaWYgKHRoaXMuY2hlY2thYmxlKGMpKSByZXR1cm4gdGhpcy5maW5kQnlOYW1lKGMubmFtZSkuZmlsdGVyKFwiOmNoZWNrZWRcIikubGVuZ3RoIH1yZXR1cm4gYi5sZW5ndGggfSwgZGVwZW5kOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gIXRoaXMuZGVwZW5kVHlwZXNbdHlwZW9mIGFdIHx8IHRoaXMuZGVwZW5kVHlwZXNbdHlwZW9mIGFdKGEsIGIpIH0sIGRlcGVuZFR5cGVzOiB7IFwiYm9vbGVhblwiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSB9LCBzdHJpbmc6IGZ1bmN0aW9uIChiLCBjKSB7IHJldHVybiAhIWEoYiwgYy5mb3JtKS5sZW5ndGggfSwgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYShiKSB9IH0sIG9wdGlvbmFsOiBmdW5jdGlvbiAoYikgeyB2YXIgYyA9IHRoaXMuZWxlbWVudFZhbHVlKGIpOyByZXR1cm4gIWEudmFsaWRhdG9yLm1ldGhvZHMucmVxdWlyZWQuY2FsbCh0aGlzLCBjLCBiKSAmJiBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIiB9LCBzdGFydFJlcXVlc3Q6IGZ1bmN0aW9uIChiKSB7IHRoaXMucGVuZGluZ1tiLm5hbWVdIHx8ICh0aGlzLnBlbmRpbmdSZXF1ZXN0KysgLCBhKGIpLmFkZENsYXNzKHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzKSwgdGhpcy5wZW5kaW5nW2IubmFtZV0gPSAhMCkgfSwgc3RvcFJlcXVlc3Q6IGZ1bmN0aW9uIChiLCBjKSB7IHRoaXMucGVuZGluZ1JlcXVlc3QtLSAsIHRoaXMucGVuZGluZ1JlcXVlc3QgPCAwICYmICh0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gMCksIGRlbGV0ZSB0aGlzLnBlbmRpbmdbYi5uYW1lXSwgYShiKS5yZW1vdmVDbGFzcyh0aGlzLnNldHRpbmdzLnBlbmRpbmdDbGFzcyksIGMgJiYgMCA9PT0gdGhpcy5wZW5kaW5nUmVxdWVzdCAmJiB0aGlzLmZvcm1TdWJtaXR0ZWQgJiYgdGhpcy5mb3JtKCkgPyAoYSh0aGlzLmN1cnJlbnRGb3JtKS5zdWJtaXQoKSwgdGhpcy5zdWJtaXRCdXR0b24gJiYgYShcImlucHV0OmhpZGRlbltuYW1lPSdcIiArIHRoaXMuc3VibWl0QnV0dG9uLm5hbWUgKyBcIiddXCIsIHRoaXMuY3VycmVudEZvcm0pLnJlbW92ZSgpLCB0aGlzLmZvcm1TdWJtaXR0ZWQgPSAhMSkgOiAhYyAmJiAwID09PSB0aGlzLnBlbmRpbmdSZXF1ZXN0ICYmIHRoaXMuZm9ybVN1Ym1pdHRlZCAmJiAoYSh0aGlzLmN1cnJlbnRGb3JtKS50cmlnZ2VySGFuZGxlcihcImludmFsaWQtZm9ybVwiLCBbdGhpc10pLCB0aGlzLmZvcm1TdWJtaXR0ZWQgPSAhMSkgfSwgcHJldmlvdXNWYWx1ZTogZnVuY3Rpb24gKGIsIGMpIHsgcmV0dXJuIGMgPSBcInN0cmluZ1wiID09IHR5cGVvZiBjICYmIGMgfHwgXCJyZW1vdGVcIiwgYS5kYXRhKGIsIFwicHJldmlvdXNWYWx1ZVwiKSB8fCBhLmRhdGEoYiwgXCJwcmV2aW91c1ZhbHVlXCIsIHsgb2xkOiBudWxsLCB2YWxpZDogITAsIG1lc3NhZ2U6IHRoaXMuZGVmYXVsdE1lc3NhZ2UoYiwgeyBtZXRob2Q6IGMgfSkgfSkgfSwgZGVzdHJveTogZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpLCBhKHRoaXMuY3VycmVudEZvcm0pLm9mZihcIi52YWxpZGF0ZVwiKS5yZW1vdmVEYXRhKFwidmFsaWRhdG9yXCIpLmZpbmQoXCIudmFsaWRhdGUtZXF1YWxUby1ibHVyXCIpLm9mZihcIi52YWxpZGF0ZS1lcXVhbFRvXCIpLnJlbW92ZUNsYXNzKFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIpIH0gfSwgY2xhc3NSdWxlU2V0dGluZ3M6IHsgcmVxdWlyZWQ6IHsgcmVxdWlyZWQ6ICEwIH0sIGVtYWlsOiB7IGVtYWlsOiAhMCB9LCB1cmw6IHsgdXJsOiAhMCB9LCBkYXRlOiB7IGRhdGU6ICEwIH0sIGRhdGVJU086IHsgZGF0ZUlTTzogITAgfSwgbnVtYmVyOiB7IG51bWJlcjogITAgfSwgZGlnaXRzOiB7IGRpZ2l0czogITAgfSwgY3JlZGl0Y2FyZDogeyBjcmVkaXRjYXJkOiAhMCB9IH0sIGFkZENsYXNzUnVsZXM6IGZ1bmN0aW9uIChiLCBjKSB7IGIuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IHRoaXMuY2xhc3NSdWxlU2V0dGluZ3NbYl0gPSBjIDogYS5leHRlbmQodGhpcy5jbGFzc1J1bGVTZXR0aW5ncywgYikgfSwgY2xhc3NSdWxlczogZnVuY3Rpb24gKGIpIHsgdmFyIGMgPSB7fSwgZCA9IGEoYikuYXR0cihcImNsYXNzXCIpOyByZXR1cm4gZCAmJiBhLmVhY2goZC5zcGxpdChcIiBcIiksIGZ1bmN0aW9uICgpIHsgdGhpcyBpbiBhLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5ncyAmJiBhLmV4dGVuZChjLCBhLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5nc1t0aGlzXSkgfSksIGMgfSwgbm9ybWFsaXplQXR0cmlidXRlUnVsZTogZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgL21pbnxtYXh8c3RlcC8udGVzdChjKSAmJiAobnVsbCA9PT0gYiB8fCAvbnVtYmVyfHJhbmdlfHRleHQvLnRlc3QoYikpICYmIChkID0gTnVtYmVyKGQpLCBpc05hTihkKSAmJiAoZCA9IHZvaWQgMCkpLCBkIHx8IDAgPT09IGQgPyBhW2NdID0gZCA6IGIgPT09IGMgJiYgXCJyYW5nZVwiICE9PSBiICYmIChhW2NdID0gITApIH0sIGF0dHJpYnV0ZVJ1bGVzOiBmdW5jdGlvbiAoYikgeyB2YXIgYywgZCwgZSA9IHt9LCBmID0gYShiKSwgZyA9IGIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTsgZm9yIChjIGluIGEudmFsaWRhdG9yLm1ldGhvZHMpIFwicmVxdWlyZWRcIiA9PT0gYyA/IChkID0gYi5nZXRBdHRyaWJ1dGUoYyksIFwiXCIgPT09IGQgJiYgKGQgPSAhMCksIGQgPSAhIWQpIDogZCA9IGYuYXR0cihjKSwgdGhpcy5ub3JtYWxpemVBdHRyaWJ1dGVSdWxlKGUsIGcsIGMsIGQpOyByZXR1cm4gZS5tYXhsZW5ndGggJiYgLy0xfDIxNDc0ODM2NDd8NTI0Mjg4Ly50ZXN0KGUubWF4bGVuZ3RoKSAmJiBkZWxldGUgZS5tYXhsZW5ndGgsIGUgfSwgZGF0YVJ1bGVzOiBmdW5jdGlvbiAoYikgeyB2YXIgYywgZCwgZSA9IHt9LCBmID0gYShiKSwgZyA9IGIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTsgZm9yIChjIGluIGEudmFsaWRhdG9yLm1ldGhvZHMpIGQgPSBmLmRhdGEoXCJydWxlXCIgKyBjLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYy5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKSksIHRoaXMubm9ybWFsaXplQXR0cmlidXRlUnVsZShlLCBnLCBjLCBkKTsgcmV0dXJuIGUgfSwgc3RhdGljUnVsZXM6IGZ1bmN0aW9uIChiKSB7IHZhciBjID0ge30sIGQgPSBhLmRhdGEoYi5mb3JtLCBcInZhbGlkYXRvclwiKTsgcmV0dXJuIGQuc2V0dGluZ3MucnVsZXMgJiYgKGMgPSBhLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKGQuc2V0dGluZ3MucnVsZXNbYi5uYW1lXSkgfHwge30pLCBjIH0sIG5vcm1hbGl6ZVJ1bGVzOiBmdW5jdGlvbiAoYiwgYykgeyByZXR1cm4gYS5lYWNoKGIsIGZ1bmN0aW9uIChkLCBlKSB7IGlmIChlID09PSAhMSkgcmV0dXJuIHZvaWQgZGVsZXRlIGJbZF07IGlmIChlLnBhcmFtIHx8IGUuZGVwZW5kcykgeyB2YXIgZiA9ICEwOyBzd2l0Y2ggKHR5cGVvZiBlLmRlcGVuZHMpIHsgY2FzZSBcInN0cmluZ1wiOiBmID0gISFhKGUuZGVwZW5kcywgYy5mb3JtKS5sZW5ndGg7IGJyZWFrOyBjYXNlIFwiZnVuY3Rpb25cIjogZiA9IGUuZGVwZW5kcy5jYWxsKGMsIGMpIH1mID8gYltkXSA9IHZvaWQgMCA9PT0gZS5wYXJhbSB8fCBlLnBhcmFtIDogKGEuZGF0YShjLmZvcm0sIFwidmFsaWRhdG9yXCIpLnJlc2V0RWxlbWVudHMoYShjKSksIGRlbGV0ZSBiW2RdKSB9IH0pLCBhLmVhY2goYiwgZnVuY3Rpb24gKGQsIGUpIHsgYltkXSA9IGEuaXNGdW5jdGlvbihlKSAmJiBcIm5vcm1hbGl6ZXJcIiAhPT0gZCA/IGUoYykgOiBlIH0pLCBhLmVhY2goW1wibWlubGVuZ3RoXCIsIFwibWF4bGVuZ3RoXCJdLCBmdW5jdGlvbiAoKSB7IGJbdGhpc10gJiYgKGJbdGhpc10gPSBOdW1iZXIoYlt0aGlzXSkpIH0pLCBhLmVhY2goW1wicmFuZ2VsZW5ndGhcIiwgXCJyYW5nZVwiXSwgZnVuY3Rpb24gKCkgeyB2YXIgYzsgYlt0aGlzXSAmJiAoYS5pc0FycmF5KGJbdGhpc10pID8gYlt0aGlzXSA9IFtOdW1iZXIoYlt0aGlzXVswXSksIE51bWJlcihiW3RoaXNdWzFdKV0gOiBcInN0cmluZ1wiID09IHR5cGVvZiBiW3RoaXNdICYmIChjID0gYlt0aGlzXS5yZXBsYWNlKC9bXFxbXFxdXS9nLCBcIlwiKS5zcGxpdCgvW1xccyxdKy8pLCBiW3RoaXNdID0gW051bWJlcihjWzBdKSwgTnVtYmVyKGNbMV0pXSkpIH0pLCBhLnZhbGlkYXRvci5hdXRvQ3JlYXRlUmFuZ2VzICYmIChudWxsICE9IGIubWluICYmIG51bGwgIT0gYi5tYXggJiYgKGIucmFuZ2UgPSBbYi5taW4sIGIubWF4XSwgZGVsZXRlIGIubWluLCBkZWxldGUgYi5tYXgpLCBudWxsICE9IGIubWlubGVuZ3RoICYmIG51bGwgIT0gYi5tYXhsZW5ndGggJiYgKGIucmFuZ2VsZW5ndGggPSBbYi5taW5sZW5ndGgsIGIubWF4bGVuZ3RoXSwgZGVsZXRlIGIubWlubGVuZ3RoLCBkZWxldGUgYi5tYXhsZW5ndGgpKSwgYiB9LCBub3JtYWxpemVSdWxlOiBmdW5jdGlvbiAoYikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYikgeyB2YXIgYyA9IHt9OyBhLmVhY2goYi5zcGxpdCgvXFxzLyksIGZ1bmN0aW9uICgpIHsgY1t0aGlzXSA9ICEwIH0pLCBiID0gYyB9IHJldHVybiBiIH0sIGFkZE1ldGhvZDogZnVuY3Rpb24gKGIsIGMsIGQpIHsgYS52YWxpZGF0b3IubWV0aG9kc1tiXSA9IGMsIGEudmFsaWRhdG9yLm1lc3NhZ2VzW2JdID0gdm9pZCAwICE9PSBkID8gZCA6IGEudmFsaWRhdG9yLm1lc3NhZ2VzW2JdLCBjLmxlbmd0aCA8IDMgJiYgYS52YWxpZGF0b3IuYWRkQ2xhc3NSdWxlcyhiLCBhLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKGIpKSB9LCBtZXRob2RzOiB7IHJlcXVpcmVkOiBmdW5jdGlvbiAoYiwgYywgZCkgeyBpZiAoIXRoaXMuZGVwZW5kKGQsIGMpKSByZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7IGlmIChcInNlbGVjdFwiID09PSBjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHsgdmFyIGUgPSBhKGMpLnZhbCgpOyByZXR1cm4gZSAmJiBlLmxlbmd0aCA+IDAgfSByZXR1cm4gdGhpcy5jaGVja2FibGUoYykgPyB0aGlzLmdldExlbmd0aChiLCBjKSA+IDAgOiBiLmxlbmd0aCA+IDAgfSwgZW1haWw6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLnRlc3QoYSkgfSwgdXJsOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gdGhpcy5vcHRpb25hbChiKSB8fCAvXig/Oig/Oig/Omh0dHBzP3xmdHApOik/XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16XFx1MDBhMS1cXHVmZmZmMC05XS0qKSpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSspKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0tKikqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSooPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH0pKS4/KSg/OjpcXGR7Miw1fSk/KD86W1xcLz8jXVxcUyopPyQvaS50ZXN0KGEpIH0sIGRhdGU6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8ICEvSW52YWxpZHxOYU4vLnRlc3QobmV3IERhdGUoYSkudG9TdHJpbmcoKSkgfSwgZGF0ZUlTTzogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRoaXMub3B0aW9uYWwoYikgfHwgL15cXGR7NH1bXFwvXFwtXSgwP1sxLTldfDFbMDEyXSlbXFwvXFwtXSgwP1sxLTldfFsxMl1bMC05XXwzWzAxXSkkLy50ZXN0KGEpIH0sIG51bWJlcjogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRoaXMub3B0aW9uYWwoYikgfHwgL14oPzotP1xcZCt8LT9cXGR7MSwzfSg/OixcXGR7M30pKyk/KD86XFwuXFxkKyk/JC8udGVzdChhKSB9LCBkaWdpdHM6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IC9eXFxkKyQvLnRlc3QoYSkgfSwgbWlubGVuZ3RoOiBmdW5jdGlvbiAoYiwgYywgZCkgeyB2YXIgZSA9IGEuaXNBcnJheShiKSA/IGIubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoYiwgYyk7IHJldHVybiB0aGlzLm9wdGlvbmFsKGMpIHx8IGUgPj0gZCB9LCBtYXhsZW5ndGg6IGZ1bmN0aW9uIChiLCBjLCBkKSB7IHZhciBlID0gYS5pc0FycmF5KGIpID8gYi5sZW5ndGggOiB0aGlzLmdldExlbmd0aChiLCBjKTsgcmV0dXJuIHRoaXMub3B0aW9uYWwoYykgfHwgZSA8PSBkIH0sIHJhbmdlbGVuZ3RoOiBmdW5jdGlvbiAoYiwgYywgZCkgeyB2YXIgZSA9IGEuaXNBcnJheShiKSA/IGIubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoYiwgYyk7IHJldHVybiB0aGlzLm9wdGlvbmFsKGMpIHx8IGUgPj0gZFswXSAmJiBlIDw9IGRbMV0gfSwgbWluOiBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gdGhpcy5vcHRpb25hbChiKSB8fCBhID49IGMgfSwgbWF4OiBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gdGhpcy5vcHRpb25hbChiKSB8fCBhIDw9IGMgfSwgcmFuZ2U6IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiB0aGlzLm9wdGlvbmFsKGIpIHx8IGEgPj0gY1swXSAmJiBhIDw9IGNbMV0gfSwgc3RlcDogZnVuY3Rpb24gKGIsIGMsIGQpIHsgdmFyIGUsIGYgPSBhKGMpLmF0dHIoXCJ0eXBlXCIpLCBnID0gXCJTdGVwIGF0dHJpYnV0ZSBvbiBpbnB1dCB0eXBlIFwiICsgZiArIFwiIGlzIG5vdCBzdXBwb3J0ZWQuXCIsIGggPSBbXCJ0ZXh0XCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIl0sIGkgPSBuZXcgUmVnRXhwKFwiXFxcXGJcIiArIGYgKyBcIlxcXFxiXCIpLCBqID0gZiAmJiAhaS50ZXN0KGguam9pbigpKSwgayA9IGZ1bmN0aW9uIChhKSB7IHZhciBiID0gKFwiXCIgKyBhKS5tYXRjaCgvKD86XFwuKFxcZCspKT8kLyk7IHJldHVybiBiICYmIGJbMV0gPyBiWzFdLmxlbmd0aCA6IDAgfSwgbCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBNYXRoLnJvdW5kKGEgKiBNYXRoLnBvdygxMCwgZSkpIH0sIG0gPSAhMDsgaWYgKGopIHRocm93IG5ldyBFcnJvcihnKTsgcmV0dXJuIGUgPSBrKGQpLCAoayhiKSA+IGUgfHwgbChiKSAlIGwoZCkgIT09IDApICYmIChtID0gITEpLCB0aGlzLm9wdGlvbmFsKGMpIHx8IG0gfSwgZXF1YWxUbzogZnVuY3Rpb24gKGIsIGMsIGQpIHsgdmFyIGUgPSBhKGQpOyByZXR1cm4gdGhpcy5zZXR0aW5ncy5vbmZvY3Vzb3V0ICYmIGUubm90KFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiKS5sZW5ndGggJiYgZS5hZGRDbGFzcyhcInZhbGlkYXRlLWVxdWFsVG8tYmx1clwiKS5vbihcImJsdXIudmFsaWRhdGUtZXF1YWxUb1wiLCBmdW5jdGlvbiAoKSB7IGEoYykudmFsaWQoKSB9KSwgYiA9PT0gZS52YWwoKSB9LCByZW1vdGU6IGZ1bmN0aW9uIChiLCBjLCBkLCBlKSB7IGlmICh0aGlzLm9wdGlvbmFsKGMpKSByZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7IGUgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGUgfHwgXCJyZW1vdGVcIjsgdmFyIGYsIGcsIGgsIGkgPSB0aGlzLnByZXZpb3VzVmFsdWUoYywgZSk7IHJldHVybiB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV0gfHwgKHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbYy5uYW1lXSA9IHt9KSwgaS5vcmlnaW5hbE1lc3NhZ2UgPSBpLm9yaWdpbmFsTWVzc2FnZSB8fCB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV1bZV0sIHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbYy5uYW1lXVtlXSA9IGkubWVzc2FnZSwgZCA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGQgJiYgeyB1cmw6IGQgfSB8fCBkLCBoID0gYS5wYXJhbShhLmV4dGVuZCh7IGRhdGE6IGIgfSwgZC5kYXRhKSksIGkub2xkID09PSBoID8gaS52YWxpZCA6IChpLm9sZCA9IGgsIGYgPSB0aGlzLCB0aGlzLnN0YXJ0UmVxdWVzdChjKSwgZyA9IHt9LCBnW2MubmFtZV0gPSBiLCBhLmFqYXgoYS5leHRlbmQoITAsIHsgbW9kZTogXCJhYm9ydFwiLCBwb3J0OiBcInZhbGlkYXRlXCIgKyBjLm5hbWUsIGRhdGFUeXBlOiBcImpzb25cIiwgZGF0YTogZywgY29udGV4dDogZi5jdXJyZW50Rm9ybSwgc3VjY2VzczogZnVuY3Rpb24gKGEpIHsgdmFyIGQsIGcsIGgsIGogPSBhID09PSAhMCB8fCBcInRydWVcIiA9PT0gYTsgZi5zZXR0aW5ncy5tZXNzYWdlc1tjLm5hbWVdW2VdID0gaS5vcmlnaW5hbE1lc3NhZ2UsIGogPyAoaCA9IGYuZm9ybVN1Ym1pdHRlZCwgZi5yZXNldEludGVybmFscygpLCBmLnRvSGlkZSA9IGYuZXJyb3JzRm9yKGMpLCBmLmZvcm1TdWJtaXR0ZWQgPSBoLCBmLnN1Y2Nlc3NMaXN0LnB1c2goYyksIGYuaW52YWxpZFtjLm5hbWVdID0gITEsIGYuc2hvd0Vycm9ycygpKSA6IChkID0ge30sIGcgPSBhIHx8IGYuZGVmYXVsdE1lc3NhZ2UoYywgeyBtZXRob2Q6IGUsIHBhcmFtZXRlcnM6IGIgfSksIGRbYy5uYW1lXSA9IGkubWVzc2FnZSA9IGcsIGYuaW52YWxpZFtjLm5hbWVdID0gITAsIGYuc2hvd0Vycm9ycyhkKSksIGkudmFsaWQgPSBqLCBmLnN0b3BSZXF1ZXN0KGMsIGopIH0gfSwgZCkpLCBcInBlbmRpbmdcIikgfSB9IH0pOyB2YXIgYiwgYyA9IHt9OyByZXR1cm4gYS5hamF4UHJlZmlsdGVyID8gYS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChhLCBiLCBkKSB7IHZhciBlID0gYS5wb3J0OyBcImFib3J0XCIgPT09IGEubW9kZSAmJiAoY1tlXSAmJiBjW2VdLmFib3J0KCksIGNbZV0gPSBkKSB9KSA6IChiID0gYS5hamF4LCBhLmFqYXggPSBmdW5jdGlvbiAoZCkgeyB2YXIgZSA9IChcIm1vZGVcIiBpbiBkID8gZCA6IGEuYWpheFNldHRpbmdzKS5tb2RlLCBmID0gKFwicG9ydFwiIGluIGQgPyBkIDogYS5hamF4U2V0dGluZ3MpLnBvcnQ7IHJldHVybiBcImFib3J0XCIgPT09IGUgPyAoY1tmXSAmJiBjW2ZdLmFib3J0KCksIGNbZl0gPSBiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGNbZl0pIDogYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0pLCBhIH0pOyIsIi8qISBqUXVlcnkgJiBaZXB0byBMYXp5IHYxLjcuNiAtIGh0dHA6Ly9qcXVlcnkuZWlzYmVoci5kZS9sYXp5IC0gTUlUJkdQTC0yLjAgbGljZW5zZSAtIENvcHlyaWdodCAyMDEyLTIwMTcgRGFuaWVsICdFaXNiZWhyJyBLZXJuICovXHJcbiFmdW5jdGlvbiAodCwgZSkgeyBcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gcihyLCBhLCBpLCB1LCBsKSB7IGZ1bmN0aW9uIGYoKSB7IEwgPSB0LmRldmljZVBpeGVsUmF0aW8gPiAxLCBpID0gYyhpKSwgYS5kZWxheSA+PSAwICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBzKCEwKSB9LCBhLmRlbGF5KSwgKGEuZGVsYXkgPCAwIHx8IGEuY29tYmluZWQpICYmICh1LmUgPSB2KGEudGhyb3R0bGUsIGZ1bmN0aW9uICh0KSB7IFwicmVzaXplXCIgPT09IHQudHlwZSAmJiAodyA9IEIgPSAtMSksIHModC5hbGwpIH0pLCB1LmEgPSBmdW5jdGlvbiAodCkgeyB0ID0gYyh0KSwgaS5wdXNoLmFwcGx5KGksIHQpIH0sIHUuZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGkgPSBuKGkpLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAhbih0aGlzKS5kYXRhKGEubG9hZGVkTmFtZSkgfSkgfSwgdS5mID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB7IHZhciByID0gaS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyA9PT0gdFtlXSB9KTsgci5sZW5ndGggJiYgcyghMSwgcikgfSB9LCBzKCksIG4oYS5hcHBlbmRTY3JvbGwpLm9uKFwic2Nyb2xsLlwiICsgbCArIFwiIHJlc2l6ZS5cIiArIGwsIHUuZSkpIH0gZnVuY3Rpb24gYyh0KSB7IHZhciBpID0gYS5kZWZhdWx0SW1hZ2UsIG8gPSBhLnBsYWNlaG9sZGVyLCB1ID0gYS5pbWFnZUJhc2UsIGwgPSBhLnNyY3NldEF0dHJpYnV0ZSwgZiA9IGEubG9hZGVyQXR0cmlidXRlLCBjID0gYS5fZiB8fCB7fTsgdCA9IG4odCkuZmlsdGVyKGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBuKHRoaXMpLCByID0gbSh0aGlzKTsgcmV0dXJuICF0LmRhdGEoYS5oYW5kbGVkTmFtZSkgJiYgKHQuYXR0cihhLmF0dHJpYnV0ZSkgfHwgdC5hdHRyKGwpIHx8IHQuYXR0cihmKSB8fCBjW3JdICE9PSBlKSB9KS5kYXRhKFwicGx1Z2luX1wiICsgYS5uYW1lLCByKTsgZm9yICh2YXIgcyA9IDAsIGQgPSB0Lmxlbmd0aDsgcyA8IGQ7IHMrKykgeyB2YXIgQSA9IG4odFtzXSksIGcgPSBtKHRbc10pLCBoID0gQS5hdHRyKGEuaW1hZ2VCYXNlQXR0cmlidXRlKSB8fCB1OyBnID09PSBOICYmIGggJiYgQS5hdHRyKGwpICYmIEEuYXR0cihsLCBiKEEuYXR0cihsKSwgaCkpLCBjW2ddID09PSBlIHx8IEEuYXR0cihmKSB8fCBBLmF0dHIoZiwgY1tnXSksIGcgPT09IE4gJiYgaSAmJiAhQS5hdHRyKEUpID8gQS5hdHRyKEUsIGkpIDogZyA9PT0gTiB8fCAhbyB8fCBBLmNzcyhPKSAmJiBcIm5vbmVcIiAhPT0gQS5jc3MoTykgfHwgQS5jc3MoTywgXCJ1cmwoJ1wiICsgbyArIFwiJylcIikgfSByZXR1cm4gdCB9IGZ1bmN0aW9uIHModCwgZSkgeyBpZiAoIWkubGVuZ3RoKSByZXR1cm4gdm9pZCAoYS5hdXRvRGVzdHJveSAmJiByLmRlc3Ryb3koKSk7IGZvciAodmFyIG8gPSBlIHx8IGksIHUgPSAhMSwgbCA9IGEuaW1hZ2VCYXNlIHx8IFwiXCIsIGYgPSBhLnNyY3NldEF0dHJpYnV0ZSwgYyA9IGEuaGFuZGxlZE5hbWUsIHMgPSAwOyBzIDwgby5sZW5ndGg7IHMrKylpZiAodCB8fCBlIHx8IEEob1tzXSkpIHsgdmFyIGcgPSBuKG9bc10pLCBoID0gbShvW3NdKSwgYiA9IGcuYXR0cihhLmF0dHJpYnV0ZSksIHYgPSBnLmF0dHIoYS5pbWFnZUJhc2VBdHRyaWJ1dGUpIHx8IGwsIHAgPSBnLmF0dHIoYS5sb2FkZXJBdHRyaWJ1dGUpOyBnLmRhdGEoYykgfHwgYS52aXNpYmxlT25seSAmJiAhZy5pcyhcIjp2aXNpYmxlXCIpIHx8ICEoKGIgfHwgZy5hdHRyKGYpKSAmJiAoaCA9PT0gTiAmJiAodiArIGIgIT09IGcuYXR0cihFKSB8fCBnLmF0dHIoZikgIT09IGcuYXR0cihGKSkgfHwgaCAhPT0gTiAmJiB2ICsgYiAhPT0gZy5jc3MoTykpIHx8IHApIHx8ICh1ID0gITAsIGcuZGF0YShjLCAhMCksIGQoZywgaCwgdiwgcCkpIH0gdSAmJiAoaSA9IG4oaSkuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFuKHRoaXMpLmRhdGEoYykgfSkpIH0gZnVuY3Rpb24gZCh0LCBlLCByLCBpKSB7ICsrejsgdmFyIG8gPSBmdW5jdGlvbiAoKSB7IHkoXCJvbkVycm9yXCIsIHQpLCBwKCksIG8gPSBuLm5vb3AgfTsgeShcImJlZm9yZUxvYWRcIiwgdCk7IHZhciB1ID0gYS5hdHRyaWJ1dGUsIGwgPSBhLnNyY3NldEF0dHJpYnV0ZSwgZiA9IGEuc2l6ZXNBdHRyaWJ1dGUsIGMgPSBhLnJldGluYUF0dHJpYnV0ZSwgcyA9IGEucmVtb3ZlQXR0cmlidXRlLCBkID0gYS5sb2FkZWROYW1lLCBBID0gdC5hdHRyKGMpOyBpZiAoaSkgeyB2YXIgZyA9IGZ1bmN0aW9uICgpIHsgcyAmJiB0LnJlbW92ZUF0dHIoYS5sb2FkZXJBdHRyaWJ1dGUpLCB0LmRhdGEoZCwgITApLCB5KFQsIHQpLCBzZXRUaW1lb3V0KHAsIDEpLCBnID0gbi5ub29wIH07IHQub2ZmKEkpLm9uZShJLCBvKS5vbmUoRCwgZyksIHkoaSwgdCwgZnVuY3Rpb24gKGUpIHsgZSA/ICh0Lm9mZihEKSwgZygpKSA6ICh0Lm9mZihJKSwgbygpKSB9KSB8fCB0LnRyaWdnZXIoSSkgfSBlbHNlIHsgdmFyIGggPSBuKG5ldyBJbWFnZSk7IGgub25lKEksIG8pLm9uZShELCBmdW5jdGlvbiAoKSB7IHQuaGlkZSgpLCBlID09PSBOID8gdC5hdHRyKEMsIGguYXR0cihDKSkuYXR0cihGLCBoLmF0dHIoRikpLmF0dHIoRSwgaC5hdHRyKEUpKSA6IHQuY3NzKE8sIFwidXJsKCdcIiArIGguYXR0cihFKSArIFwiJylcIiksIHRbYS5lZmZlY3RdKGEuZWZmZWN0VGltZSksIHMgJiYgKHQucmVtb3ZlQXR0cih1ICsgXCIgXCIgKyBsICsgXCIgXCIgKyBjICsgXCIgXCIgKyBhLmltYWdlQmFzZUF0dHJpYnV0ZSksIGYgIT09IEMgJiYgdC5yZW1vdmVBdHRyKGYpKSwgdC5kYXRhKGQsICEwKSwgeShULCB0KSwgaC5yZW1vdmUoKSwgcCgpIH0pOyB2YXIgbSA9IChMICYmIEEgPyBBIDogdC5hdHRyKHUpKSB8fCBcIlwiOyBoLmF0dHIoQywgdC5hdHRyKGYpKS5hdHRyKEYsIHQuYXR0cihsKSkuYXR0cihFLCBtID8gciArIG0gOiBudWxsKSwgaC5jb21wbGV0ZSAmJiBoLnRyaWdnZXIoRCkgfSB9IGZ1bmN0aW9uIEEodCkgeyB2YXIgZSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSBhLnNjcm9sbERpcmVjdGlvbiwgbiA9IGEudGhyZXNob2xkLCBpID0gaCgpICsgbiA+IGUudG9wICYmIC1uIDwgZS5ib3R0b20sIG8gPSBnKCkgKyBuID4gZS5sZWZ0ICYmIC1uIDwgZS5yaWdodDsgcmV0dXJuIFwidmVydGljYWxcIiA9PT0gciA/IGkgOiBcImhvcml6b250YWxcIiA9PT0gciA/IG8gOiBpICYmIG8gfSBmdW5jdGlvbiBnKCkgeyByZXR1cm4gdyA+PSAwID8gdyA6IHcgPSBuKHQpLndpZHRoKCkgfSBmdW5jdGlvbiBoKCkgeyByZXR1cm4gQiA+PSAwID8gQiA6IEIgPSBuKHQpLmhlaWdodCgpIH0gZnVuY3Rpb24gbSh0KSB7IHJldHVybiB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSB9IGZ1bmN0aW9uIGIodCwgZSkgeyBpZiAoZSkgeyB2YXIgciA9IHQuc3BsaXQoXCIsXCIpOyB0ID0gXCJcIjsgZm9yICh2YXIgYSA9IDAsIG4gPSByLmxlbmd0aDsgYSA8IG47IGErKyl0ICs9IGUgKyByW2FdLnRyaW0oKSArIChhICE9PSBuIC0gMSA/IFwiLFwiIDogXCJcIikgfSByZXR1cm4gdCB9IGZ1bmN0aW9uIHYodCwgZSkgeyB2YXIgbiwgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAobywgdSkgeyBmdW5jdGlvbiBsKCkgeyBpID0gK25ldyBEYXRlLCBlLmNhbGwociwgbykgfSB2YXIgZiA9ICtuZXcgRGF0ZSAtIGk7IG4gJiYgY2xlYXJUaW1lb3V0KG4pLCBmID4gdCB8fCAhYS5lbmFibGVUaHJvdHRsZSB8fCB1ID8gbCgpIDogbiA9IHNldFRpbWVvdXQobCwgdCAtIGYpIH0gfSBmdW5jdGlvbiBwKCkgeyAtLXosIGkubGVuZ3RoIHx8IHogfHwgeShcIm9uRmluaXNoZWRBbGxcIikgfSBmdW5jdGlvbiB5KHQsIGUsIG4pIHsgcmV0dXJuICEhKHQgPSBhW3RdKSAmJiAodC5hcHBseShyLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCAhMCkgfSB2YXIgeiA9IDAsIHcgPSAtMSwgQiA9IC0xLCBMID0gITEsIFQgPSBcImFmdGVyTG9hZFwiLCBEID0gXCJsb2FkXCIsIEkgPSBcImVycm9yXCIsIE4gPSBcImltZ1wiLCBFID0gXCJzcmNcIiwgRiA9IFwic3Jjc2V0XCIsIEMgPSBcInNpemVzXCIsIE8gPSBcImJhY2tncm91bmQtaW1hZ2VcIjsgXCJldmVudFwiID09PSBhLmJpbmQgfHwgbyA/IGYoKSA6IG4odCkub24oRCArIFwiLlwiICsgbCwgZikgfSBmdW5jdGlvbiBhKGEsIG8pIHsgdmFyIHUgPSB0aGlzLCBsID0gbi5leHRlbmQoe30sIHUuY29uZmlnLCBvKSwgZiA9IHt9LCBjID0gbC5uYW1lICsgXCItXCIgKyArK2k7IHJldHVybiB1LmNvbmZpZyA9IGZ1bmN0aW9uICh0LCByKSB7IHJldHVybiByID09PSBlID8gbFt0XSA6IChsW3RdID0gciwgdSkgfSwgdS5hZGRJdGVtcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmLmEgJiYgZi5hKFwic3RyaW5nXCIgPT09IG4udHlwZSh0KSA/IG4odCkgOiB0KSwgdSB9LCB1LmdldEl0ZW1zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5nID8gZi5nKCkgOiB7fSB9LCB1LnVwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmLmUgJiYgZi5lKHt9LCAhdCksIHUgfSwgdS5mb3JjZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmLmYgJiYgZi5mKFwic3RyaW5nXCIgPT09IG4udHlwZSh0KSA/IG4odCkgOiB0KSwgdSB9LCB1LmxvYWRBbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmLmUgJiYgZi5lKHsgYWxsOiAhMCB9LCAhMCksIHUgfSwgdS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbihsLmFwcGVuZFNjcm9sbCkub2ZmKFwiLlwiICsgYywgZi5lKSwgbih0KS5vZmYoXCIuXCIgKyBjKSwgZiA9IHt9LCBlIH0sIHIodSwgbCwgYSwgZiwgYyksIGwuY2hhaW5hYmxlID8gYSA6IHUgfSB2YXIgbiA9IHQualF1ZXJ5IHx8IHQuWmVwdG8sIGkgPSAwLCBvID0gITE7IG4uZm4uTGF6eSA9IG4uZm4ubGF6eSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgYSh0aGlzLCB0KSB9LCBuLkxhenkgPSBuLmxhenkgPSBmdW5jdGlvbiAodCwgciwgaSkgeyBpZiAobi5pc0Z1bmN0aW9uKHIpICYmIChpID0gciwgciA9IFtdKSwgbi5pc0Z1bmN0aW9uKGkpKSB7IHQgPSBuLmlzQXJyYXkodCkgPyB0IDogW3RdLCByID0gbi5pc0FycmF5KHIpID8gciA6IFtyXTsgZm9yICh2YXIgbyA9IGEucHJvdG90eXBlLmNvbmZpZywgdSA9IG8uX2YgfHwgKG8uX2YgPSB7fSksIGwgPSAwLCBmID0gdC5sZW5ndGg7IGwgPCBmOyBsKyspKG9bdFtsXV0gPT09IGUgfHwgbi5pc0Z1bmN0aW9uKG9bdFtsXV0pKSAmJiAob1t0W2xdXSA9IGkpOyBmb3IgKHZhciBjID0gMCwgcyA9IHIubGVuZ3RoOyBjIDwgczsgYysrKXVbcltjXV0gPSB0WzBdIH0gfSwgYS5wcm90b3R5cGUuY29uZmlnID0geyBuYW1lOiBcImxhenlcIiwgY2hhaW5hYmxlOiAhMCwgYXV0b0Rlc3Ryb3k6ICEwLCBiaW5kOiBcImxvYWRcIiwgdGhyZXNob2xkOiA1MDAsIHZpc2libGVPbmx5OiAhMSwgYXBwZW5kU2Nyb2xsOiB0LCBzY3JvbGxEaXJlY3Rpb246IFwiYm90aFwiLCBpbWFnZUJhc2U6IG51bGwsIGRlZmF1bHRJbWFnZTogXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFQLy8vd0FBQUNINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQ1JBRUFPdz09XCIsIHBsYWNlaG9sZGVyOiBudWxsLCBkZWxheTogLTEsIGNvbWJpbmVkOiAhMSwgYXR0cmlidXRlOiBcImRhdGEtc3JjXCIsIHNyY3NldEF0dHJpYnV0ZTogXCJkYXRhLXNyY3NldFwiLCBzaXplc0F0dHJpYnV0ZTogXCJkYXRhLXNpemVzXCIsIHJldGluYUF0dHJpYnV0ZTogXCJkYXRhLXJldGluYVwiLCBsb2FkZXJBdHRyaWJ1dGU6IFwiZGF0YS1sb2FkZXJcIiwgaW1hZ2VCYXNlQXR0cmlidXRlOiBcImRhdGEtaW1hZ2ViYXNlXCIsIHJlbW92ZUF0dHJpYnV0ZTogITAsIGhhbmRsZWROYW1lOiBcImhhbmRsZWRcIiwgbG9hZGVkTmFtZTogXCJsb2FkZWRcIiwgZWZmZWN0OiBcInNob3dcIiwgZWZmZWN0VGltZTogMCwgZW5hYmxlVGhyb3R0bGU6ICEwLCB0aHJvdHRsZTogMjUwLCBiZWZvcmVMb2FkOiBlLCBhZnRlckxvYWQ6IGUsIG9uRXJyb3I6IGUsIG9uRmluaXNoZWRBbGw6IGUgfSwgbih0KS5vbihcImxvYWRcIiwgZnVuY3Rpb24gKCkgeyBvID0gITAgfSkgfSh3aW5kb3cpOyIsIi8qISB0b29sdGlwc3RlciB2NC4yLjUgKi8hZnVuY3Rpb24gKGEsIGIpIHsgXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbXCJqcXVlcnlcIl0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBiKGEpIH0pIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0gYihyZXF1aXJlKFwianF1ZXJ5XCIpKSA6IGIoalF1ZXJ5KSB9KHRoaXMsIGZ1bmN0aW9uIChhKSB7XHJcbiAgICBmdW5jdGlvbiBiKGEpIHsgdGhpcy4kY29udGFpbmVyLCB0aGlzLmNvbnN0cmFpbnRzID0gbnVsbCwgdGhpcy5fXyR0b29sdGlwLCB0aGlzLl9faW5pdChhKSB9IGZ1bmN0aW9uIGMoYiwgYykgeyB2YXIgZCA9ICEwOyByZXR1cm4gYS5lYWNoKGIsIGZ1bmN0aW9uIChhLCBlKSB7IHJldHVybiB2b2lkIDAgPT09IGNbYV0gfHwgYlthXSAhPT0gY1thXSA/IChkID0gITEsICExKSA6IHZvaWQgMCB9KSwgZCB9IGZ1bmN0aW9uIGQoYikgeyB2YXIgYyA9IGIuYXR0cihcImlkXCIpLCBkID0gYyA/IGgud2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpIDogbnVsbDsgcmV0dXJuIGQgPyBkID09PSBiWzBdIDogYS5jb250YWlucyhoLndpbmRvdy5kb2N1bWVudC5ib2R5LCBiWzBdKSB9IGZ1bmN0aW9uIGUoKSB7IGlmICghZykgcmV0dXJuICExOyB2YXIgYSA9IGcuZG9jdW1lbnQuYm9keSB8fCBnLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYiA9IGEuc3R5bGUsIGMgPSBcInRyYW5zaXRpb25cIiwgZCA9IFtcIk1velwiLCBcIldlYmtpdFwiLCBcIktodG1sXCIsIFwiT1wiLCBcIm1zXCJdOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYltjXSkgcmV0dXJuICEwOyBjID0gYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGMuc3Vic3RyKDEpOyBmb3IgKHZhciBlID0gMDsgZSA8IGQubGVuZ3RoOyBlKyspaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGJbZFtlXSArIGNdKSByZXR1cm4gITA7IHJldHVybiAhMSB9IHZhciBmID0geyBhbmltYXRpb246IFwiZmFkZVwiLCBhbmltYXRpb25EdXJhdGlvbjogMzUwLCBjb250ZW50OiBudWxsLCBjb250ZW50QXNIVE1MOiAhMSwgY29udGVudENsb25pbmc6ICExLCBkZWJ1ZzogITAsIGRlbGF5OiAzMDAsIGRlbGF5VG91Y2g6IFszMDAsIDUwMF0sIGZ1bmN0aW9uSW5pdDogbnVsbCwgZnVuY3Rpb25CZWZvcmU6IG51bGwsIGZ1bmN0aW9uUmVhZHk6IG51bGwsIGZ1bmN0aW9uQWZ0ZXI6IG51bGwsIGZ1bmN0aW9uRm9ybWF0OiBudWxsLCBJRW1pbjogNiwgaW50ZXJhY3RpdmU6ICExLCBtdWx0aXBsZTogITEsIHBhcmVudDogbnVsbCwgcGx1Z2luczogW1wic2lkZVRpcFwiXSwgcmVwb3NpdGlvbk9uU2Nyb2xsOiAhMSwgcmVzdG9yYXRpb246IFwibm9uZVwiLCBzZWxmRGVzdHJ1Y3Rpb246ICEwLCB0aGVtZTogW10sIHRpbWVyOiAwLCB0cmFja2VySW50ZXJ2YWw6IDUwMCwgdHJhY2tPcmlnaW46ICExLCB0cmFja1Rvb2x0aXA6ICExLCB0cmlnZ2VyOiBcImhvdmVyXCIsIHRyaWdnZXJDbG9zZTogeyBjbGljazogITEsIG1vdXNlbGVhdmU6ICExLCBvcmlnaW5DbGljazogITEsIHNjcm9sbDogITEsIHRhcDogITEsIHRvdWNobGVhdmU6ICExIH0sIHRyaWdnZXJPcGVuOiB7IGNsaWNrOiAhMSwgbW91c2VlbnRlcjogITEsIHRhcDogITEsIHRvdWNoc3RhcnQ6ICExIH0sIHVwZGF0ZUFuaW1hdGlvbjogXCJyb3RhdGVcIiwgekluZGV4OiA5OTk5OTk5IH0sIGcgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBudWxsLCBoID0geyBoYXNUb3VjaENhcGFiaWxpdHk6ICEoIWcgfHwgIShcIm9udG91Y2hzdGFydFwiIGluIGcgfHwgZy5Eb2N1bWVudFRvdWNoICYmIGcuZG9jdW1lbnQgaW5zdGFuY2VvZiBnLkRvY3VtZW50VG91Y2ggfHwgZy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMpKSwgaGFzVHJhbnNpdGlvbnM6IGUoKSwgSUU6ICExLCBzZW1WZXI6IFwiNC4yLjVcIiwgd2luZG93OiBnIH0sIGkgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX18kZW1pdHRlclByaXZhdGUgPSBhKHt9KSwgdGhpcy5fXyRlbWl0dGVyUHVibGljID0gYSh7fSksIHRoaXMuX19pbnN0YW5jZXNMYXRlc3RBcnIgPSBbXSwgdGhpcy5fX3BsdWdpbnMgPSB7fSwgdGhpcy5fZW52ID0gaCB9OyBpLnByb3RvdHlwZSA9IHsgX19icmlkZ2U6IGZ1bmN0aW9uIChiLCBjLCBkKSB7IGlmICghY1tkXSkgeyB2YXIgZSA9IGZ1bmN0aW9uICgpIHsgfTsgZS5wcm90b3R5cGUgPSBiOyB2YXIgZyA9IG5ldyBlOyBnLl9faW5pdCAmJiBnLl9faW5pdChjKSwgYS5lYWNoKGIsIGZ1bmN0aW9uIChhLCBiKSB7IDAgIT0gYS5pbmRleE9mKFwiX19cIikgJiYgKGNbYV0gPyBmLmRlYnVnICYmIGNvbnNvbGUubG9nKFwiVGhlIFwiICsgYSArIFwiIG1ldGhvZCBvZiB0aGUgXCIgKyBkICsgXCIgcGx1Z2luIGNvbmZsaWN0cyB3aXRoIGFub3RoZXIgcGx1Z2luIG9yIG5hdGl2ZSBtZXRob2RzXCIpIDogKGNbYV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnW2FdLmFwcGx5KGcsIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKSB9LCBjW2FdLmJyaWRnZWQgPSBnKSkgfSksIGNbZF0gPSBnIH0gcmV0dXJuIHRoaXMgfSwgX19zZXRXaW5kb3c6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBoLndpbmRvdyA9IGEsIHRoaXMgfSwgX2dldFJ1bGVyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbmV3IGIoYSkgfSwgX29mZjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vZmYuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIF9vbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vbi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSwgX29uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vbmUuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIF9wbHVnaW46IGZ1bmN0aW9uIChiKSB7IHZhciBjID0gdGhpczsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGIpIHsgdmFyIGQgPSBiLCBlID0gbnVsbDsgcmV0dXJuIGQuaW5kZXhPZihcIi5cIikgPiAwID8gZSA9IGMuX19wbHVnaW5zW2RdIDogYS5lYWNoKGMuX19wbHVnaW5zLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5uYW1lLnN1YnN0cmluZyhiLm5hbWUubGVuZ3RoIC0gZC5sZW5ndGggLSAxKSA9PSBcIi5cIiArIGQgPyAoZSA9IGIsICExKSA6IHZvaWQgMCB9KSwgZSB9IGlmIChiLm5hbWUuaW5kZXhPZihcIi5cIikgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW5zIG11c3QgYmUgbmFtZXNwYWNlZFwiKTsgcmV0dXJuIGMuX19wbHVnaW5zW2IubmFtZV0gPSBiLCBiLmNvcmUgJiYgYy5fX2JyaWRnZShiLmNvcmUsIGMsIGIubmFtZSksIHRoaXMgfSwgX3RyaWdnZXI6IGZ1bmN0aW9uICgpIHsgdmFyIGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTsgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGFbMF0gJiYgKGFbMF0gPSB7IHR5cGU6IGFbMF0gfSksIHRoaXMuX18kZW1pdHRlclByaXZhdGUudHJpZ2dlci5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLCBhKSwgdGhpcy5fXyRlbWl0dGVyUHVibGljLnRyaWdnZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBhKSwgdGhpcyB9LCBpbnN0YW5jZXM6IGZ1bmN0aW9uIChiKSB7IHZhciBjID0gW10sIGQgPSBiIHx8IFwiLnRvb2x0aXBzdGVyZWRcIjsgcmV0dXJuIGEoZCkuZWFjaChmdW5jdGlvbiAoKSB7IHZhciBiID0gYSh0aGlzKSwgZCA9IGIuZGF0YShcInRvb2x0aXBzdGVyLW5zXCIpOyBkICYmIGEuZWFjaChkLCBmdW5jdGlvbiAoYSwgZCkgeyBjLnB1c2goYi5kYXRhKGQpKSB9KSB9KSwgYyB9LCBpbnN0YW5jZXNMYXRlc3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19pbnN0YW5jZXNMYXRlc3RBcnIgfSwgb2ZmOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub2ZmLmFwcGx5KHRoaXMuX18kZW1pdHRlclB1YmxpYywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIG9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub24uYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSwgb25lOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub25lLmFwcGx5KHRoaXMuX18kZW1pdHRlclB1YmxpYywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIG9yaWdpbnM6IGZ1bmN0aW9uIChiKSB7IHZhciBjID0gYiA/IGIgKyBcIiBcIiA6IFwiXCI7IHJldHVybiBhKGMgKyBcIi50b29sdGlwc3RlcmVkXCIpLnRvQXJyYXkoKSB9LCBzZXREZWZhdWx0czogZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGEuZXh0ZW5kKGYsIGIpLCB0aGlzIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMudHJpZ2dlckhhbmRsZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSB9LCBhLnRvb2x0aXBzdGVyID0gbmV3IGksIGEuVG9vbHRpcHN0ZXIgPSBmdW5jdGlvbiAoYiwgYykgeyB0aGlzLl9fY2FsbGJhY2tzID0geyBjbG9zZTogW10sIG9wZW46IFtdIH0sIHRoaXMuX19jbG9zaW5nVGltZSwgdGhpcy5fX0NvbnRlbnQsIHRoaXMuX19jb250ZW50QmNyLCB0aGlzLl9fZGVzdHJveWVkID0gITEsIHRoaXMuX18kZW1pdHRlclByaXZhdGUgPSBhKHt9KSwgdGhpcy5fXyRlbWl0dGVyUHVibGljID0gYSh7fSksIHRoaXMuX19lbmFibGVkID0gITAsIHRoaXMuX19nYXJiYWdlQ29sbGVjdG9yLCB0aGlzLl9fR2VvbWV0cnksIHRoaXMuX19sYXN0UG9zaXRpb24sIHRoaXMuX19uYW1lc3BhY2UgPSBcInRvb2x0aXBzdGVyLVwiICsgTWF0aC5yb3VuZCgxZTYgKiBNYXRoLnJhbmRvbSgpKSwgdGhpcy5fX29wdGlvbnMsIHRoaXMuX18kb3JpZ2luUGFyZW50cywgdGhpcy5fX3BvaW50ZXJJc092ZXJPcmlnaW4gPSAhMSwgdGhpcy5fX3ByZXZpb3VzVGhlbWVzID0gW10sIHRoaXMuX19zdGF0ZSA9IFwiY2xvc2VkXCIsIHRoaXMuX190aW1lb3V0cyA9IHsgY2xvc2U6IFtdLCBvcGVuOiBudWxsIH0sIHRoaXMuX190b3VjaEV2ZW50cyA9IFtdLCB0aGlzLl9fdHJhY2tlciA9IG51bGwsIHRoaXMuXyRvcmlnaW4sIHRoaXMuXyR0b29sdGlwLCB0aGlzLl9faW5pdChiLCBjKSB9LCBhLlRvb2x0aXBzdGVyLnByb3RvdHlwZSA9IHsgX19pbml0OiBmdW5jdGlvbiAoYiwgYykgeyB2YXIgZCA9IHRoaXM7IGlmIChkLl8kb3JpZ2luID0gYShiKSwgZC5fX29wdGlvbnMgPSBhLmV4dGVuZCghMCwge30sIGYsIGMpLCBkLl9fb3B0aW9uc0Zvcm1hdCgpLCAhaC5JRSB8fCBoLklFID49IGQuX19vcHRpb25zLklFbWluKSB7IHZhciBlID0gbnVsbDsgaWYgKHZvaWQgMCA9PT0gZC5fJG9yaWdpbi5kYXRhKFwidG9vbHRpcHN0ZXItaW5pdGlhbFRpdGxlXCIpICYmIChlID0gZC5fJG9yaWdpbi5hdHRyKFwidGl0bGVcIiksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IG51bGwpLCBkLl8kb3JpZ2luLmRhdGEoXCJ0b29sdGlwc3Rlci1pbml0aWFsVGl0bGVcIiwgZSkpLCBudWxsICE9PSBkLl9fb3B0aW9ucy5jb250ZW50KSBkLl9fY29udGVudFNldChkLl9fb3B0aW9ucy5jb250ZW50KTsgZWxzZSB7IHZhciBnLCBpID0gZC5fJG9yaWdpbi5hdHRyKFwiZGF0YS10b29sdGlwLWNvbnRlbnRcIik7IGkgJiYgKGcgPSBhKGkpKSwgZyAmJiBnWzBdID8gZC5fX2NvbnRlbnRTZXQoZy5maXJzdCgpKSA6IGQuX19jb250ZW50U2V0KGUpIH0gZC5fJG9yaWdpbi5yZW1vdmVBdHRyKFwidGl0bGVcIikuYWRkQ2xhc3MoXCJ0b29sdGlwc3RlcmVkXCIpLCBkLl9fcHJlcGFyZU9yaWdpbigpLCBkLl9fcHJlcGFyZUdDKCksIGEuZWFjaChkLl9fb3B0aW9ucy5wbHVnaW5zLCBmdW5jdGlvbiAoYSwgYikgeyBkLl9wbHVnKGIpIH0pLCBoLmhhc1RvdWNoQ2FwYWJpbGl0eSAmJiBhKGgud2luZG93LmRvY3VtZW50LmJvZHkpLm9uKFwidG91Y2htb3ZlLlwiICsgZC5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuXCIsIGZ1bmN0aW9uIChhKSB7IGQuX3RvdWNoUmVjb3JkRXZlbnQoYSkgfSksIGQuX29uKFwiY3JlYXRlZFwiLCBmdW5jdGlvbiAoKSB7IGQuX19wcmVwYXJlVG9vbHRpcCgpIH0pLl9vbihcInJlcG9zaXRpb25lZFwiLCBmdW5jdGlvbiAoYSkgeyBkLl9fbGFzdFBvc2l0aW9uID0gYS5wb3NpdGlvbiB9KSB9IGVsc2UgZC5fX29wdGlvbnMuZGlzYWJsZWQgPSAhMCB9LCBfX2NvbnRlbnRJbnNlcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGEgPSB0aGlzLCBiID0gYS5fJHRvb2x0aXAuZmluZChcIi50b29sdGlwc3Rlci1jb250ZW50XCIpLCBjID0gYS5fX0NvbnRlbnQsIGQgPSBmdW5jdGlvbiAoYSkgeyBjID0gYSB9OyByZXR1cm4gYS5fdHJpZ2dlcih7IHR5cGU6IFwiZm9ybWF0XCIsIGNvbnRlbnQ6IGEuX19Db250ZW50LCBmb3JtYXQ6IGQgfSksIGEuX19vcHRpb25zLmZ1bmN0aW9uRm9ybWF0ICYmIChjID0gYS5fX29wdGlvbnMuZnVuY3Rpb25Gb3JtYXQuY2FsbChhLCBhLCB7IG9yaWdpbjogYS5fJG9yaWdpblswXSB9LCBhLl9fQ29udGVudCkpLCBcInN0cmluZ1wiICE9IHR5cGVvZiBjIHx8IGEuX19vcHRpb25zLmNvbnRlbnRBc0hUTUwgPyBiLmVtcHR5KCkuYXBwZW5kKGMpIDogYi50ZXh0KGMpLCBhIH0sIF9fY29udGVudFNldDogZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIgaW5zdGFuY2VvZiBhICYmIHRoaXMuX19vcHRpb25zLmNvbnRlbnRDbG9uaW5nICYmIChiID0gYi5jbG9uZSghMCkpLCB0aGlzLl9fQ29udGVudCA9IGIsIHRoaXMuX3RyaWdnZXIoeyB0eXBlOiBcInVwZGF0ZWRcIiwgY29udGVudDogYiB9KSwgdGhpcyB9LCBfX2Rlc3Ryb3lFcnJvcjogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHRvb2x0aXAgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBjYW5ub3QgZXhlY3V0ZSB5b3VyIG1ldGhvZCBjYWxsLlwiKSB9LCBfX2dlb21ldHJ5OiBmdW5jdGlvbiAoKSB7IHZhciBiID0gdGhpcywgYyA9IGIuXyRvcmlnaW4sIGQgPSBiLl8kb3JpZ2luLmlzKFwiYXJlYVwiKTsgaWYgKGQpIHsgdmFyIGUgPSBiLl8kb3JpZ2luLnBhcmVudCgpLmF0dHIoXCJuYW1lXCIpOyBjID0gYSgnaW1nW3VzZW1hcD1cIiMnICsgZSArICdcIl0nKSB9IHZhciBmID0gY1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZyA9IGEoaC53aW5kb3cuZG9jdW1lbnQpLCBpID0gYShoLndpbmRvdyksIGogPSBjLCBrID0geyBhdmFpbGFibGU6IHsgZG9jdW1lbnQ6IG51bGwsIHdpbmRvdzogbnVsbCB9LCBkb2N1bWVudDogeyBzaXplOiB7IGhlaWdodDogZy5oZWlnaHQoKSwgd2lkdGg6IGcud2lkdGgoKSB9IH0sIHdpbmRvdzogeyBzY3JvbGw6IHsgbGVmdDogaC53aW5kb3cuc2Nyb2xsWCB8fCBoLndpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgdG9wOiBoLndpbmRvdy5zY3JvbGxZIHx8IGgud2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfSwgc2l6ZTogeyBoZWlnaHQ6IGkuaGVpZ2h0KCksIHdpZHRoOiBpLndpZHRoKCkgfSB9LCBvcmlnaW46IHsgZml4ZWRMaW5lYWdlOiAhMSwgb2Zmc2V0OiB7fSwgc2l6ZTogeyBoZWlnaHQ6IGYuYm90dG9tIC0gZi50b3AsIHdpZHRoOiBmLnJpZ2h0IC0gZi5sZWZ0IH0sIHVzZW1hcEltYWdlOiBkID8gY1swXSA6IG51bGwsIHdpbmRvd09mZnNldDogeyBib3R0b206IGYuYm90dG9tLCBsZWZ0OiBmLmxlZnQsIHJpZ2h0OiBmLnJpZ2h0LCB0b3A6IGYudG9wIH0gfSB9OyBpZiAoZCkgeyB2YXIgbCA9IGIuXyRvcmlnaW4uYXR0cihcInNoYXBlXCIpLCBtID0gYi5fJG9yaWdpbi5hdHRyKFwiY29vcmRzXCIpOyBpZiAobSAmJiAobSA9IG0uc3BsaXQoXCIsXCIpLCBhLm1hcChtLCBmdW5jdGlvbiAoYSwgYikgeyBtW2JdID0gcGFyc2VJbnQoYSkgfSkpLCBcImRlZmF1bHRcIiAhPSBsKSBzd2l0Y2ggKGwpIHsgY2FzZSBcImNpcmNsZVwiOiB2YXIgbiA9IG1bMF0sIG8gPSBtWzFdLCBwID0gbVsyXSwgcSA9IG8gLSBwLCByID0gbiAtIHA7IGsub3JpZ2luLnNpemUuaGVpZ2h0ID0gMiAqIHAsIGsub3JpZ2luLnNpemUud2lkdGggPSBrLm9yaWdpbi5zaXplLmhlaWdodCwgay5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQgKz0gciwgay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCArPSBxOyBicmVhazsgY2FzZSBcInJlY3RcIjogdmFyIHMgPSBtWzBdLCB0ID0gbVsxXSwgdSA9IG1bMl0sIHYgPSBtWzNdOyBrLm9yaWdpbi5zaXplLmhlaWdodCA9IHYgLSB0LCBrLm9yaWdpbi5zaXplLndpZHRoID0gdSAtIHMsIGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0ICs9IHMsIGsub3JpZ2luLndpbmRvd09mZnNldC50b3AgKz0gdDsgYnJlYWs7IGNhc2UgXCJwb2x5XCI6IGZvciAodmFyIHcgPSAwLCB4ID0gMCwgeSA9IDAsIHogPSAwLCBBID0gXCJldmVuXCIsIEIgPSAwOyBCIDwgbS5sZW5ndGg7IEIrKykgeyB2YXIgQyA9IG1bQl07IFwiZXZlblwiID09IEEgPyAoQyA+IHkgJiYgKHkgPSBDLCAwID09PSBCICYmICh3ID0geSkpLCB3ID4gQyAmJiAodyA9IEMpLCBBID0gXCJvZGRcIikgOiAoQyA+IHogJiYgKHogPSBDLCAxID09IEIgJiYgKHggPSB6KSksIHggPiBDICYmICh4ID0gQyksIEEgPSBcImV2ZW5cIikgfSBrLm9yaWdpbi5zaXplLmhlaWdodCA9IHogLSB4LCBrLm9yaWdpbi5zaXplLndpZHRoID0geSAtIHcsIGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0ICs9IHcsIGsub3JpZ2luLndpbmRvd09mZnNldC50b3AgKz0geCB9IH0gdmFyIEQgPSBmdW5jdGlvbiAoYSkgeyBrLm9yaWdpbi5zaXplLmhlaWdodCA9IGEuaGVpZ2h0LCBrLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCA9IGEubGVmdCwgay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCA9IGEudG9wLCBrLm9yaWdpbi5zaXplLndpZHRoID0gYS53aWR0aCB9OyBmb3IgKGIuX3RyaWdnZXIoeyB0eXBlOiBcImdlb21ldHJ5XCIsIGVkaXQ6IEQsIGdlb21ldHJ5OiB7IGhlaWdodDogay5vcmlnaW4uc2l6ZS5oZWlnaHQsIGxlZnQ6IGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0LCB0b3A6IGsub3JpZ2luLndpbmRvd09mZnNldC50b3AsIHdpZHRoOiBrLm9yaWdpbi5zaXplLndpZHRoIH0gfSksIGsub3JpZ2luLndpbmRvd09mZnNldC5yaWdodCA9IGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0ICsgay5vcmlnaW4uc2l6ZS53aWR0aCwgay5vcmlnaW4ud2luZG93T2Zmc2V0LmJvdHRvbSA9IGsub3JpZ2luLndpbmRvd09mZnNldC50b3AgKyBrLm9yaWdpbi5zaXplLmhlaWdodCwgay5vcmlnaW4ub2Zmc2V0LmxlZnQgPSBrLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCArIGsud2luZG93LnNjcm9sbC5sZWZ0LCBrLm9yaWdpbi5vZmZzZXQudG9wID0gay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCArIGsud2luZG93LnNjcm9sbC50b3AsIGsub3JpZ2luLm9mZnNldC5ib3R0b20gPSBrLm9yaWdpbi5vZmZzZXQudG9wICsgay5vcmlnaW4uc2l6ZS5oZWlnaHQsIGsub3JpZ2luLm9mZnNldC5yaWdodCA9IGsub3JpZ2luLm9mZnNldC5sZWZ0ICsgay5vcmlnaW4uc2l6ZS53aWR0aCwgay5hdmFpbGFibGUuZG9jdW1lbnQgPSB7IGJvdHRvbTogeyBoZWlnaHQ6IGsuZG9jdW1lbnQuc2l6ZS5oZWlnaHQgLSBrLm9yaWdpbi5vZmZzZXQuYm90dG9tLCB3aWR0aDogay5kb2N1bWVudC5zaXplLndpZHRoIH0sIGxlZnQ6IHsgaGVpZ2h0OiBrLmRvY3VtZW50LnNpemUuaGVpZ2h0LCB3aWR0aDogay5vcmlnaW4ub2Zmc2V0LmxlZnQgfSwgcmlnaHQ6IHsgaGVpZ2h0OiBrLmRvY3VtZW50LnNpemUuaGVpZ2h0LCB3aWR0aDogay5kb2N1bWVudC5zaXplLndpZHRoIC0gay5vcmlnaW4ub2Zmc2V0LnJpZ2h0IH0sIHRvcDogeyBoZWlnaHQ6IGsub3JpZ2luLm9mZnNldC50b3AsIHdpZHRoOiBrLmRvY3VtZW50LnNpemUud2lkdGggfSB9LCBrLmF2YWlsYWJsZS53aW5kb3cgPSB7IGJvdHRvbTogeyBoZWlnaHQ6IE1hdGgubWF4KGsud2luZG93LnNpemUuaGVpZ2h0IC0gTWF0aC5tYXgoay5vcmlnaW4ud2luZG93T2Zmc2V0LmJvdHRvbSwgMCksIDApLCB3aWR0aDogay53aW5kb3cuc2l6ZS53aWR0aCB9LCBsZWZ0OiB7IGhlaWdodDogay53aW5kb3cuc2l6ZS5oZWlnaHQsIHdpZHRoOiBNYXRoLm1heChrLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCwgMCkgfSwgcmlnaHQ6IHsgaGVpZ2h0OiBrLndpbmRvdy5zaXplLmhlaWdodCwgd2lkdGg6IE1hdGgubWF4KGsud2luZG93LnNpemUud2lkdGggLSBNYXRoLm1heChrLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQsIDApLCAwKSB9LCB0b3A6IHsgaGVpZ2h0OiBNYXRoLm1heChrLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wLCAwKSwgd2lkdGg6IGsud2luZG93LnNpemUud2lkdGggfSB9OyBcImh0bWxcIiAhPSBqWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKTspIHsgaWYgKFwiZml4ZWRcIiA9PSBqLmNzcyhcInBvc2l0aW9uXCIpKSB7IGsub3JpZ2luLmZpeGVkTGluZWFnZSA9ICEwOyBicmVhayB9IGogPSBqLnBhcmVudCgpIH0gcmV0dXJuIGsgfSwgX19vcHRpb25zRm9ybWF0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiAmJiAodGhpcy5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gPSBbdGhpcy5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIHRoaXMuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uXSksIFwibnVtYmVyXCIgPT0gdHlwZW9mIHRoaXMuX19vcHRpb25zLmRlbGF5ICYmICh0aGlzLl9fb3B0aW9ucy5kZWxheSA9IFt0aGlzLl9fb3B0aW9ucy5kZWxheSwgdGhpcy5fX29wdGlvbnMuZGVsYXldKSwgXCJudW1iZXJcIiA9PSB0eXBlb2YgdGhpcy5fX29wdGlvbnMuZGVsYXlUb3VjaCAmJiAodGhpcy5fX29wdGlvbnMuZGVsYXlUb3VjaCA9IFt0aGlzLl9fb3B0aW9ucy5kZWxheVRvdWNoLCB0aGlzLl9fb3B0aW9ucy5kZWxheVRvdWNoXSksIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMuX19vcHRpb25zLnRoZW1lICYmICh0aGlzLl9fb3B0aW9ucy50aGVtZSA9IFt0aGlzLl9fb3B0aW9ucy50aGVtZV0pLCBudWxsID09PSB0aGlzLl9fb3B0aW9ucy5wYXJlbnQgPyB0aGlzLl9fb3B0aW9ucy5wYXJlbnQgPSBhKGgud2luZG93LmRvY3VtZW50LmJvZHkpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5fX29wdGlvbnMucGFyZW50ICYmICh0aGlzLl9fb3B0aW9ucy5wYXJlbnQgPSBhKHRoaXMuX19vcHRpb25zLnBhcmVudCkpLCBcImhvdmVyXCIgPT0gdGhpcy5fX29wdGlvbnMudHJpZ2dlciA/ICh0aGlzLl9fb3B0aW9ucy50cmlnZ2VyT3BlbiA9IHsgbW91c2VlbnRlcjogITAsIHRvdWNoc3RhcnQ6ICEwIH0sIHRoaXMuX19vcHRpb25zLnRyaWdnZXJDbG9zZSA9IHsgbW91c2VsZWF2ZTogITAsIG9yaWdpbkNsaWNrOiAhMCwgdG91Y2hsZWF2ZTogITAgfSkgOiBcImNsaWNrXCIgPT0gdGhpcy5fX29wdGlvbnMudHJpZ2dlciAmJiAodGhpcy5fX29wdGlvbnMudHJpZ2dlck9wZW4gPSB7IGNsaWNrOiAhMCwgdGFwOiAhMCB9LCB0aGlzLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UgPSB7IGNsaWNrOiAhMCwgdGFwOiAhMCB9KSwgdGhpcy5fdHJpZ2dlcihcIm9wdGlvbnNcIiksIHRoaXMgfSwgX19wcmVwYXJlR0M6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSB0aGlzOyByZXR1cm4gYi5fX29wdGlvbnMuc2VsZkRlc3RydWN0aW9uID8gYi5fX2dhcmJhZ2VDb2xsZWN0b3IgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHZhciBjID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7IGIuX190b3VjaEV2ZW50cyA9IGEuZ3JlcChiLl9fdG91Y2hFdmVudHMsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjIC0gYS50aW1lID4gNmU0IH0pLCBkKGIuXyRvcmlnaW4pIHx8IGIuY2xvc2UoZnVuY3Rpb24gKCkgeyBiLmRlc3Ryb3koKSB9KSB9LCAyZTQpIDogY2xlYXJJbnRlcnZhbChiLl9fZ2FyYmFnZUNvbGxlY3RvciksIGIgfSwgX19wcmVwYXJlT3JpZ2luOiBmdW5jdGlvbiAoKSB7IHZhciBhID0gdGhpczsgaWYgKGEuXyRvcmlnaW4ub2ZmKFwiLlwiICsgYS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuXCIpLCBoLmhhc1RvdWNoQ2FwYWJpbGl0eSAmJiBhLl8kb3JpZ2luLm9uKFwidG91Y2hzdGFydC5cIiArIGEuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyT3BlbiB0b3VjaGVuZC5cIiArIGEuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyT3BlbiB0b3VjaGNhbmNlbC5cIiArIGEuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyT3BlblwiLCBmdW5jdGlvbiAoYikgeyBhLl90b3VjaFJlY29yZEV2ZW50KGIpIH0pLCBhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi5jbGljayB8fCBhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi50YXAgJiYgaC5oYXNUb3VjaENhcGFiaWxpdHkpIHsgdmFyIGIgPSBcIlwiOyBhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi5jbGljayAmJiAoYiArPSBcImNsaWNrLlwiICsgYS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuIFwiKSwgYS5fX29wdGlvbnMudHJpZ2dlck9wZW4udGFwICYmIGguaGFzVG91Y2hDYXBhYmlsaXR5ICYmIChiICs9IFwidG91Y2hlbmQuXCIgKyBhLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlck9wZW5cIiksIGEuXyRvcmlnaW4ub24oYiwgZnVuY3Rpb24gKGIpIHsgYS5fdG91Y2hJc01lYW5pbmdmdWxFdmVudChiKSAmJiBhLl9vcGVuKGIpIH0pIH0gaWYgKGEuX19vcHRpb25zLnRyaWdnZXJPcGVuLm1vdXNlZW50ZXIgfHwgYS5fX29wdGlvbnMudHJpZ2dlck9wZW4udG91Y2hzdGFydCAmJiBoLmhhc1RvdWNoQ2FwYWJpbGl0eSkgeyB2YXIgYiA9IFwiXCI7IGEuX19vcHRpb25zLnRyaWdnZXJPcGVuLm1vdXNlZW50ZXIgJiYgKGIgKz0gXCJtb3VzZWVudGVyLlwiICsgYS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuIFwiKSwgYS5fX29wdGlvbnMudHJpZ2dlck9wZW4udG91Y2hzdGFydCAmJiBoLmhhc1RvdWNoQ2FwYWJpbGl0eSAmJiAoYiArPSBcInRvdWNoc3RhcnQuXCIgKyBhLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlck9wZW5cIiksIGEuXyRvcmlnaW4ub24oYiwgZnVuY3Rpb24gKGIpIHsgIWEuX3RvdWNoSXNUb3VjaEV2ZW50KGIpICYmIGEuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGIpIHx8IChhLl9fcG9pbnRlcklzT3Zlck9yaWdpbiA9ICEwLCBhLl9vcGVuU2hvcnRseShiKSkgfSkgfSBpZiAoYS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm1vdXNlbGVhdmUgfHwgYS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLnRvdWNobGVhdmUgJiYgaC5oYXNUb3VjaENhcGFiaWxpdHkpIHsgdmFyIGIgPSBcIlwiOyBhLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UubW91c2VsZWF2ZSAmJiAoYiArPSBcIm1vdXNlbGVhdmUuXCIgKyBhLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlck9wZW4gXCIpLCBhLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudG91Y2hsZWF2ZSAmJiBoLmhhc1RvdWNoQ2FwYWJpbGl0eSAmJiAoYiArPSBcInRvdWNoZW5kLlwiICsgYS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuIHRvdWNoY2FuY2VsLlwiICsgYS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuXCIpLCBhLl8kb3JpZ2luLm9uKGIsIGZ1bmN0aW9uIChiKSB7IGEuX3RvdWNoSXNNZWFuaW5nZnVsRXZlbnQoYikgJiYgKGEuX19wb2ludGVySXNPdmVyT3JpZ2luID0gITEpIH0pIH0gcmV0dXJuIGEgfSwgX19wcmVwYXJlVG9vbHRpcDogZnVuY3Rpb24gKCkgeyB2YXIgYiA9IHRoaXMsIGMgPSBiLl9fb3B0aW9ucy5pbnRlcmFjdGl2ZSA/IFwiYXV0b1wiIDogXCJcIjsgcmV0dXJuIGIuXyR0b29sdGlwLmF0dHIoXCJpZFwiLCBiLl9fbmFtZXNwYWNlKS5jc3MoeyBcInBvaW50ZXItZXZlbnRzXCI6IGMsIHpJbmRleDogYi5fX29wdGlvbnMuekluZGV4IH0pLCBhLmVhY2goYi5fX3ByZXZpb3VzVGhlbWVzLCBmdW5jdGlvbiAoYSwgYykgeyBiLl8kdG9vbHRpcC5yZW1vdmVDbGFzcyhjKSB9KSwgYS5lYWNoKGIuX19vcHRpb25zLnRoZW1lLCBmdW5jdGlvbiAoYSwgYykgeyBiLl8kdG9vbHRpcC5hZGRDbGFzcyhjKSB9KSwgYi5fX3ByZXZpb3VzVGhlbWVzID0gYS5tZXJnZShbXSwgYi5fX29wdGlvbnMudGhlbWUpLCBiIH0sIF9fc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24gKGIpIHsgdmFyIGMgPSB0aGlzOyBpZiAoYy5fX29wdGlvbnMudHJpZ2dlckNsb3NlLnNjcm9sbCkgYy5fY2xvc2UoYik7IGVsc2UgaWYgKGQoYy5fJG9yaWdpbikgJiYgZChjLl8kdG9vbHRpcCkpIHsgdmFyIGUgPSBudWxsOyBpZiAoYi50YXJnZXQgPT09IGgud2luZG93LmRvY3VtZW50KSBjLl9fR2VvbWV0cnkub3JpZ2luLmZpeGVkTGluZWFnZSB8fCBjLl9fb3B0aW9ucy5yZXBvc2l0aW9uT25TY3JvbGwgJiYgYy5yZXBvc2l0aW9uKGIpOyBlbHNlIHsgZSA9IGMuX19nZW9tZXRyeSgpOyB2YXIgZiA9ICExOyBpZiAoXCJmaXhlZFwiICE9IGMuXyRvcmlnaW4uY3NzKFwicG9zaXRpb25cIikgJiYgYy5fXyRvcmlnaW5QYXJlbnRzLmVhY2goZnVuY3Rpb24gKGIsIGMpIHsgdmFyIGQgPSBhKGMpLCBnID0gZC5jc3MoXCJvdmVyZmxvdy14XCIpLCBoID0gZC5jc3MoXCJvdmVyZmxvdy15XCIpOyBpZiAoXCJ2aXNpYmxlXCIgIT0gZyB8fCBcInZpc2libGVcIiAhPSBoKSB7IHZhciBpID0gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgaWYgKFwidmlzaWJsZVwiICE9IGcgJiYgKGUub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0IDwgaS5sZWZ0IHx8IGUub3JpZ2luLndpbmRvd09mZnNldC5yaWdodCA+IGkucmlnaHQpKSByZXR1cm4gZiA9ICEwLCAhMTsgaWYgKFwidmlzaWJsZVwiICE9IGggJiYgKGUub3JpZ2luLndpbmRvd09mZnNldC50b3AgPCBpLnRvcCB8fCBlLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tID4gaS5ib3R0b20pKSByZXR1cm4gZiA9ICEwLCAhMSB9IHJldHVybiBcImZpeGVkXCIgPT0gZC5jc3MoXCJwb3NpdGlvblwiKSA/ICExIDogdm9pZCAwIH0pLCBmKSBjLl8kdG9vbHRpcC5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpOyBlbHNlIGlmIChjLl8kdG9vbHRpcC5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKSwgYy5fX29wdGlvbnMucmVwb3NpdGlvbk9uU2Nyb2xsKSBjLnJlcG9zaXRpb24oYik7IGVsc2UgeyB2YXIgZyA9IGUub3JpZ2luLm9mZnNldC5sZWZ0IC0gYy5fX0dlb21ldHJ5Lm9yaWdpbi5vZmZzZXQubGVmdCwgaSA9IGUub3JpZ2luLm9mZnNldC50b3AgLSBjLl9fR2VvbWV0cnkub3JpZ2luLm9mZnNldC50b3A7IGMuXyR0b29sdGlwLmNzcyh7IGxlZnQ6IGMuX19sYXN0UG9zaXRpb24uY29vcmQubGVmdCArIGcsIHRvcDogYy5fX2xhc3RQb3NpdGlvbi5jb29yZC50b3AgKyBpIH0pIH0gfSBjLl90cmlnZ2VyKHsgdHlwZTogXCJzY3JvbGxcIiwgZXZlbnQ6IGIsIGdlbzogZSB9KSB9IHJldHVybiBjIH0sIF9fc3RhdGVTZXQ6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0aGlzLl9fc3RhdGUgPSBhLCB0aGlzLl90cmlnZ2VyKHsgdHlwZTogXCJzdGF0ZVwiLCBzdGF0ZTogYSB9KSwgdGhpcyB9LCBfX3RpbWVvdXRzQ2xlYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dHMub3BlbiksIHRoaXMuX190aW1lb3V0cy5vcGVuID0gbnVsbCwgYS5lYWNoKHRoaXMuX190aW1lb3V0cy5jbG9zZSwgZnVuY3Rpb24gKGEsIGIpIHsgY2xlYXJUaW1lb3V0KGIpIH0pLCB0aGlzLl9fdGltZW91dHMuY2xvc2UgPSBbXSwgdGhpcyB9LCBfX3RyYWNrZXJTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgYSA9IHRoaXMsIGIgPSBhLl8kdG9vbHRpcC5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIik7IHJldHVybiBhLl9fb3B0aW9ucy50cmFja1Rvb2x0aXAgJiYgKGEuX19jb250ZW50QmNyID0gYlswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIGEuX190cmFja2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBpZiAoZChhLl8kb3JpZ2luKSAmJiBkKGEuXyR0b29sdGlwKSkgeyBpZiAoYS5fX29wdGlvbnMudHJhY2tPcmlnaW4pIHsgdmFyIGUgPSBhLl9fZ2VvbWV0cnkoKSwgZiA9ICExOyBjKGUub3JpZ2luLnNpemUsIGEuX19HZW9tZXRyeS5vcmlnaW4uc2l6ZSkgJiYgKGEuX19HZW9tZXRyeS5vcmlnaW4uZml4ZWRMaW5lYWdlID8gYyhlLm9yaWdpbi53aW5kb3dPZmZzZXQsIGEuX19HZW9tZXRyeS5vcmlnaW4ud2luZG93T2Zmc2V0KSAmJiAoZiA9ICEwKSA6IGMoZS5vcmlnaW4ub2Zmc2V0LCBhLl9fR2VvbWV0cnkub3JpZ2luLm9mZnNldCkgJiYgKGYgPSAhMCkpLCBmIHx8IChhLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UubW91c2VsZWF2ZSA/IGEuX2Nsb3NlKCkgOiBhLnJlcG9zaXRpb24oKSkgfSBpZiAoYS5fX29wdGlvbnMudHJhY2tUb29sdGlwKSB7IHZhciBnID0gYlswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgZy5oZWlnaHQgPT09IGEuX19jb250ZW50QmNyLmhlaWdodCAmJiBnLndpZHRoID09PSBhLl9fY29udGVudEJjci53aWR0aCB8fCAoYS5yZXBvc2l0aW9uKCksIGEuX19jb250ZW50QmNyID0gZykgfSB9IGVsc2UgYS5fY2xvc2UoKSB9LCBhLl9fb3B0aW9ucy50cmFja2VySW50ZXJ2YWwpLCBhIH0sIF9jbG9zZTogZnVuY3Rpb24gKGIsIGMsIGQpIHsgdmFyIGUgPSB0aGlzLCBmID0gITA7IGlmIChlLl90cmlnZ2VyKHsgdHlwZTogXCJjbG9zZVwiLCBldmVudDogYiwgc3RvcDogZnVuY3Rpb24gKCkgeyBmID0gITEgfSB9KSwgZiB8fCBkKSB7IGMgJiYgZS5fX2NhbGxiYWNrcy5jbG9zZS5wdXNoKGMpLCBlLl9fY2FsbGJhY2tzLm9wZW4gPSBbXSwgZS5fX3RpbWVvdXRzQ2xlYXIoKTsgdmFyIGcgPSBmdW5jdGlvbiAoKSB7IGEuZWFjaChlLl9fY2FsbGJhY2tzLmNsb3NlLCBmdW5jdGlvbiAoYSwgYykgeyBjLmNhbGwoZSwgZSwgeyBldmVudDogYiwgb3JpZ2luOiBlLl8kb3JpZ2luWzBdIH0pIH0pLCBlLl9fY2FsbGJhY2tzLmNsb3NlID0gW10gfTsgaWYgKFwiY2xvc2VkXCIgIT0gZS5fX3N0YXRlKSB7IHZhciBpID0gITAsIGogPSBuZXcgRGF0ZSwgayA9IGouZ2V0VGltZSgpLCBsID0gayArIGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzFdOyBpZiAoXCJkaXNhcHBlYXJpbmdcIiA9PSBlLl9fc3RhdGUgJiYgbCA+IGUuX19jbG9zaW5nVGltZSAmJiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSA+IDAgJiYgKGkgPSAhMSksIGkpIHsgZS5fX2Nsb3NpbmdUaW1lID0gbCwgXCJkaXNhcHBlYXJpbmdcIiAhPSBlLl9fc3RhdGUgJiYgZS5fX3N0YXRlU2V0KFwiZGlzYXBwZWFyaW5nXCIpOyB2YXIgbSA9IGZ1bmN0aW9uICgpIHsgY2xlYXJJbnRlcnZhbChlLl9fdHJhY2tlciksIGUuX3RyaWdnZXIoeyB0eXBlOiBcImNsb3NpbmdcIiwgZXZlbnQ6IGIgfSksIGUuXyR0b29sdGlwLm9mZihcIi5cIiArIGUuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyQ2xvc2VcIikucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3Rlci1keWluZ1wiKSwgYShoLndpbmRvdykub2ZmKFwiLlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZVwiKSwgZS5fXyRvcmlnaW5QYXJlbnRzLmVhY2goZnVuY3Rpb24gKGIsIGMpIHsgYShjKS5vZmYoXCJzY3JvbGwuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlXCIpIH0pLCBlLl9fJG9yaWdpblBhcmVudHMgPSBudWxsLCBhKGgud2luZG93LmRvY3VtZW50LmJvZHkpLm9mZihcIi5cIiArIGUuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyQ2xvc2VcIiksIGUuXyRvcmlnaW4ub2ZmKFwiLlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZVwiKSwgZS5fb2ZmKFwiZGlzbWlzc2FibGVcIiksIGUuX19zdGF0ZVNldChcImNsb3NlZFwiKSwgZS5fdHJpZ2dlcih7IHR5cGU6IFwiYWZ0ZXJcIiwgZXZlbnQ6IGIgfSksIGUuX19vcHRpb25zLmZ1bmN0aW9uQWZ0ZXIgJiYgZS5fX29wdGlvbnMuZnVuY3Rpb25BZnRlci5jYWxsKGUsIGUsIHsgZXZlbnQ6IGIsIG9yaWdpbjogZS5fJG9yaWdpblswXSB9KSwgZygpIH07IGguaGFzVHJhbnNpdGlvbnMgPyAoZS5fJHRvb2x0aXAuY3NzKHsgXCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSArIFwibXNcIiwgXCItbXMtYW5pbWF0aW9uLWR1cmF0aW9uXCI6IGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzFdICsgXCJtc1wiLCBcIi1vLWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSArIFwibXNcIiwgXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSArIFwibXNcIiwgXCJhbmltYXRpb24tZHVyYXRpb25cIjogZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV0gKyBcIm1zXCIsIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSArIFwibXNcIiB9KSwgZS5fJHRvb2x0aXAuY2xlYXJRdWV1ZSgpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItc2hvd1wiKS5hZGRDbGFzcyhcInRvb2x0aXBzdGVyLWR5aW5nXCIpLCBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSA+IDAgJiYgZS5fJHRvb2x0aXAuZGVsYXkoZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV0pLCBlLl8kdG9vbHRpcC5xdWV1ZShtKSkgOiBlLl8kdG9vbHRpcC5zdG9wKCkuZmFkZU91dChlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSwgbSkgfSB9IGVsc2UgZygpIH0gcmV0dXJuIGUgfSwgX29mZjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vZmYuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIF9vbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vbi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSwgX29uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vbmUuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLCB0aGlzIH0sIF9vcGVuOiBmdW5jdGlvbiAoYiwgYykgeyB2YXIgZSA9IHRoaXM7IGlmICghZS5fX2Rlc3Ryb3lpbmcgJiYgZChlLl8kb3JpZ2luKSAmJiBlLl9fZW5hYmxlZCkgeyB2YXIgZiA9ICEwOyBpZiAoXCJjbG9zZWRcIiA9PSBlLl9fc3RhdGUgJiYgKGUuX3RyaWdnZXIoeyB0eXBlOiBcImJlZm9yZVwiLCBldmVudDogYiwgc3RvcDogZnVuY3Rpb24gKCkgeyBmID0gITEgfSB9KSwgZiAmJiBlLl9fb3B0aW9ucy5mdW5jdGlvbkJlZm9yZSAmJiAoZiA9IGUuX19vcHRpb25zLmZ1bmN0aW9uQmVmb3JlLmNhbGwoZSwgZSwgeyBldmVudDogYiwgb3JpZ2luOiBlLl8kb3JpZ2luWzBdIH0pKSksIGYgIT09ICExICYmIG51bGwgIT09IGUuX19Db250ZW50KSB7IGMgJiYgZS5fX2NhbGxiYWNrcy5vcGVuLnB1c2goYyksIGUuX19jYWxsYmFja3MuY2xvc2UgPSBbXSwgZS5fX3RpbWVvdXRzQ2xlYXIoKTsgdmFyIGcsIGkgPSBmdW5jdGlvbiAoKSB7IFwic3RhYmxlXCIgIT0gZS5fX3N0YXRlICYmIGUuX19zdGF0ZVNldChcInN0YWJsZVwiKSwgYS5lYWNoKGUuX19jYWxsYmFja3Mub3BlbiwgZnVuY3Rpb24gKGEsIGIpIHsgYi5jYWxsKGUsIGUsIHsgb3JpZ2luOiBlLl8kb3JpZ2luWzBdLCB0b29sdGlwOiBlLl8kdG9vbHRpcFswXSB9KSB9KSwgZS5fX2NhbGxiYWNrcy5vcGVuID0gW10gfTsgaWYgKFwiY2xvc2VkXCIgIT09IGUuX19zdGF0ZSkgZyA9IDAsIFwiZGlzYXBwZWFyaW5nXCIgPT09IGUuX19zdGF0ZSA/IChlLl9fc3RhdGVTZXQoXCJhcHBlYXJpbmdcIiksIGguaGFzVHJhbnNpdGlvbnMgPyAoZS5fJHRvb2x0aXAuY2xlYXJRdWV1ZSgpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItZHlpbmdcIikuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci1zaG93XCIpLCBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSA+IDAgJiYgZS5fJHRvb2x0aXAuZGVsYXkoZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMF0pLCBlLl8kdG9vbHRpcC5xdWV1ZShpKSkgOiBlLl8kdG9vbHRpcC5zdG9wKCkuZmFkZUluKGkpKSA6IFwic3RhYmxlXCIgPT0gZS5fX3N0YXRlICYmIGkoKTsgZWxzZSB7IGlmIChlLl9fc3RhdGVTZXQoXCJhcHBlYXJpbmdcIiksIGcgPSBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSwgZS5fX2NvbnRlbnRJbnNlcnQoKSwgZS5yZXBvc2l0aW9uKGIsICEwKSwgaC5oYXNUcmFuc2l0aW9ucyA/IChlLl8kdG9vbHRpcC5hZGRDbGFzcyhcInRvb2x0aXBzdGVyLVwiICsgZS5fX29wdGlvbnMuYW5pbWF0aW9uKS5hZGRDbGFzcyhcInRvb2x0aXBzdGVyLWluaXRpYWxcIikuY3NzKHsgXCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSArIFwibXNcIiwgXCItbXMtYW5pbWF0aW9uLWR1cmF0aW9uXCI6IGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdICsgXCJtc1wiLCBcIi1vLWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSArIFwibXNcIiwgXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSArIFwibXNcIiwgXCJhbmltYXRpb24tZHVyYXRpb25cIjogZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMF0gKyBcIm1zXCIsIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiOiBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSArIFwibXNcIiB9KSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IFwiY2xvc2VkXCIgIT0gZS5fX3N0YXRlICYmIChlLl8kdG9vbHRpcC5hZGRDbGFzcyhcInRvb2x0aXBzdGVyLXNob3dcIikucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3Rlci1pbml0aWFsXCIpLCBlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSA+IDAgJiYgZS5fJHRvb2x0aXAuZGVsYXkoZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMF0pLCBlLl8kdG9vbHRpcC5xdWV1ZShpKSkgfSwgMCkpIDogZS5fJHRvb2x0aXAuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIikuZmFkZUluKGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdLCBpKSwgZS5fX3RyYWNrZXJTdGFydCgpLCBhKGgud2luZG93KS5vbihcInJlc2l6ZS5cIiArIGUuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyQ2xvc2VcIiwgZnVuY3Rpb24gKGIpIHsgdmFyIGMgPSBhKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpOyAoYy5pcyhcImlucHV0XCIpIHx8IGMuaXMoXCJ0ZXh0YXJlYVwiKSkgJiYgYS5jb250YWlucyhlLl8kdG9vbHRpcFswXSwgY1swXSkgfHwgZS5yZXBvc2l0aW9uKGIpIH0pLm9uKFwic2Nyb2xsLlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZVwiLCBmdW5jdGlvbiAoYSkgeyBlLl9fc2Nyb2xsSGFuZGxlcihhKSB9KSwgZS5fXyRvcmlnaW5QYXJlbnRzID0gZS5fJG9yaWdpbi5wYXJlbnRzKCksIGUuX18kb3JpZ2luUGFyZW50cy5lYWNoKGZ1bmN0aW9uIChiLCBjKSB7IGEoYykub24oXCJzY3JvbGwuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlXCIsIGZ1bmN0aW9uIChhKSB7IGUuX19zY3JvbGxIYW5kbGVyKGEpIH0pIH0pLCBlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UubW91c2VsZWF2ZSB8fCBlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudG91Y2hsZWF2ZSAmJiBoLmhhc1RvdWNoQ2FwYWJpbGl0eSkgeyBlLl9vbihcImRpc21pc3NhYmxlXCIsIGZ1bmN0aW9uIChhKSB7IGEuZGlzbWlzc2FibGUgPyBhLmRlbGF5ID8gKG0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZS5fY2xvc2UoYS5ldmVudCkgfSwgYS5kZWxheSksIGUuX190aW1lb3V0cy5jbG9zZS5wdXNoKG0pKSA6IGUuX2Nsb3NlKGEpIDogY2xlYXJUaW1lb3V0KG0pIH0pOyB2YXIgaiA9IGUuXyRvcmlnaW4sIGsgPSBcIlwiLCBsID0gXCJcIiwgbSA9IG51bGw7IGUuX19vcHRpb25zLmludGVyYWN0aXZlICYmIChqID0gai5hZGQoZS5fJHRvb2x0aXApKSwgZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm1vdXNlbGVhdmUgJiYgKGsgKz0gXCJtb3VzZWVudGVyLlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZSBcIiwgbCArPSBcIm1vdXNlbGVhdmUuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlIFwiKSwgZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLnRvdWNobGVhdmUgJiYgaC5oYXNUb3VjaENhcGFiaWxpdHkgJiYgKGsgKz0gXCJ0b3VjaHN0YXJ0LlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZVwiLCBsICs9IFwidG91Y2hlbmQuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlIHRvdWNoY2FuY2VsLlwiICsgZS5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJDbG9zZVwiKSwgai5vbihsLCBmdW5jdGlvbiAoYSkgeyBpZiAoZS5fdG91Y2hJc1RvdWNoRXZlbnQoYSkgfHwgIWUuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGEpKSB7IHZhciBiID0gXCJtb3VzZWxlYXZlXCIgPT0gYS50eXBlID8gZS5fX29wdGlvbnMuZGVsYXkgOiBlLl9fb3B0aW9ucy5kZWxheVRvdWNoOyBlLl90cmlnZ2VyKHsgZGVsYXk6IGJbMV0sIGRpc21pc3NhYmxlOiAhMCwgZXZlbnQ6IGEsIHR5cGU6IFwiZGlzbWlzc2FibGVcIiB9KSB9IH0pLm9uKGssIGZ1bmN0aW9uIChhKSB7ICFlLl90b3VjaElzVG91Y2hFdmVudChhKSAmJiBlLl90b3VjaElzRW11bGF0ZWRFdmVudChhKSB8fCBlLl90cmlnZ2VyKHsgZGlzbWlzc2FibGU6ICExLCBldmVudDogYSwgdHlwZTogXCJkaXNtaXNzYWJsZVwiIH0pIH0pIH0gZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm9yaWdpbkNsaWNrICYmIGUuXyRvcmlnaW4ub24oXCJjbGljay5cIiArIGUuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyQ2xvc2VcIiwgZnVuY3Rpb24gKGEpIHsgZS5fdG91Y2hJc1RvdWNoRXZlbnQoYSkgfHwgZS5fdG91Y2hJc0VtdWxhdGVkRXZlbnQoYSkgfHwgZS5fY2xvc2UoYSkgfSksIChlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UuY2xpY2sgfHwgZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLnRhcCAmJiBoLmhhc1RvdWNoQ2FwYWJpbGl0eSkgJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmIChcImNsb3NlZFwiICE9IGUuX19zdGF0ZSkgeyB2YXIgYiA9IFwiXCIsIGMgPSBhKGgud2luZG93LmRvY3VtZW50LmJvZHkpOyBlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UuY2xpY2sgJiYgKGIgKz0gXCJjbGljay5cIiArIGUuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyQ2xvc2UgXCIpLCBlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudGFwICYmIGguaGFzVG91Y2hDYXBhYmlsaXR5ICYmIChiICs9IFwidG91Y2hlbmQuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlXCIpLCBjLm9uKGIsIGZ1bmN0aW9uIChiKSB7IGUuX3RvdWNoSXNNZWFuaW5nZnVsRXZlbnQoYikgJiYgKGUuX3RvdWNoUmVjb3JkRXZlbnQoYiksIGUuX19vcHRpb25zLmludGVyYWN0aXZlICYmIGEuY29udGFpbnMoZS5fJHRvb2x0aXBbMF0sIGIudGFyZ2V0KSB8fCBlLl9jbG9zZShiKSkgfSksIGUuX19vcHRpb25zLnRyaWdnZXJDbG9zZS50YXAgJiYgaC5oYXNUb3VjaENhcGFiaWxpdHkgJiYgYy5vbihcInRvdWNoc3RhcnQuXCIgKyBlLl9fbmFtZXNwYWNlICsgXCItdHJpZ2dlckNsb3NlXCIsIGZ1bmN0aW9uIChhKSB7IGUuX3RvdWNoUmVjb3JkRXZlbnQoYSkgfSkgfSB9LCAwKSwgZS5fdHJpZ2dlcihcInJlYWR5XCIpLCBlLl9fb3B0aW9ucy5mdW5jdGlvblJlYWR5ICYmIGUuX19vcHRpb25zLmZ1bmN0aW9uUmVhZHkuY2FsbChlLCBlLCB7IG9yaWdpbjogZS5fJG9yaWdpblswXSwgdG9vbHRpcDogZS5fJHRvb2x0aXBbMF0gfSkgfSBpZiAoZS5fX29wdGlvbnMudGltZXIgPiAwKSB7IHZhciBtID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGUuX2Nsb3NlKCkgfSwgZS5fX29wdGlvbnMudGltZXIgKyBnKTsgZS5fX3RpbWVvdXRzLmNsb3NlLnB1c2gobSkgfSB9IH0gcmV0dXJuIGUgfSwgX29wZW5TaG9ydGx5OiBmdW5jdGlvbiAoYSkgeyB2YXIgYiA9IHRoaXMsIGMgPSAhMDsgaWYgKFwic3RhYmxlXCIgIT0gYi5fX3N0YXRlICYmIFwiYXBwZWFyaW5nXCIgIT0gYi5fX3N0YXRlICYmICFiLl9fdGltZW91dHMub3BlbiAmJiAoYi5fdHJpZ2dlcih7IHR5cGU6IFwic3RhcnRcIiwgZXZlbnQ6IGEsIHN0b3A6IGZ1bmN0aW9uICgpIHsgYyA9ICExIH0gfSksIGMpKSB7IHZhciBkID0gMCA9PSBhLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID8gYi5fX29wdGlvbnMuZGVsYXlUb3VjaCA6IGIuX19vcHRpb25zLmRlbGF5OyBkWzBdID8gYi5fX3RpbWVvdXRzLm9wZW4gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgYi5fX3RpbWVvdXRzLm9wZW4gPSBudWxsLCBiLl9fcG9pbnRlcklzT3Zlck9yaWdpbiAmJiBiLl90b3VjaElzTWVhbmluZ2Z1bEV2ZW50KGEpID8gKGIuX3RyaWdnZXIoXCJzdGFydGVuZFwiKSwgYi5fb3BlbihhKSkgOiBiLl90cmlnZ2VyKFwic3RhcnRjYW5jZWxcIikgfSwgZFswXSkgOiAoYi5fdHJpZ2dlcihcInN0YXJ0ZW5kXCIpLCBiLl9vcGVuKGEpKSB9IHJldHVybiBiIH0sIF9vcHRpb25zRXh0cmFjdDogZnVuY3Rpb24gKGIsIGMpIHsgdmFyIGQgPSB0aGlzLCBlID0gYS5leHRlbmQoITAsIHt9LCBjKSwgZiA9IGQuX19vcHRpb25zW2JdOyByZXR1cm4gZiB8fCAoZiA9IHt9LCBhLmVhY2goYywgZnVuY3Rpb24gKGEsIGIpIHsgdmFyIGMgPSBkLl9fb3B0aW9uc1thXTsgdm9pZCAwICE9PSBjICYmIChmW2FdID0gYykgfSkpLCBhLmVhY2goZSwgZnVuY3Rpb24gKGIsIGMpIHsgdm9pZCAwICE9PSBmW2JdICYmIChcIm9iamVjdFwiICE9IHR5cGVvZiBjIHx8IGMgaW5zdGFuY2VvZiBBcnJheSB8fCBudWxsID09IGMgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZltiXSB8fCBmW2JdIGluc3RhbmNlb2YgQXJyYXkgfHwgbnVsbCA9PSBmW2JdID8gZVtiXSA9IGZbYl0gOiBhLmV4dGVuZChlW2JdLCBmW2JdKSkgfSksIGUgfSwgX3BsdWc6IGZ1bmN0aW9uIChiKSB7IHZhciBjID0gYS50b29sdGlwc3Rlci5fcGx1Z2luKGIpOyBpZiAoIWMpIHRocm93IG5ldyBFcnJvcignVGhlIFwiJyArIGIgKyAnXCIgcGx1Z2luIGlzIG5vdCBkZWZpbmVkJyk7IHJldHVybiBjLmluc3RhbmNlICYmIGEudG9vbHRpcHN0ZXIuX19icmlkZ2UoYy5pbnN0YW5jZSwgdGhpcywgYy5uYW1lKSwgdGhpcyB9LCBfdG91Y2hJc0VtdWxhdGVkRXZlbnQ6IGZ1bmN0aW9uIChhKSB7IGZvciAodmFyIGIgPSAhMSwgYyA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpLCBkID0gdGhpcy5fX3RvdWNoRXZlbnRzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7IHZhciBlID0gdGhpcy5fX3RvdWNoRXZlbnRzW2RdOyBpZiAoIShjIC0gZS50aW1lIDwgNTAwKSkgYnJlYWs7IGUudGFyZ2V0ID09PSBhLnRhcmdldCAmJiAoYiA9ICEwKSB9IHJldHVybiBiIH0sIF90b3VjaElzTWVhbmluZ2Z1bEV2ZW50OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdGhpcy5fdG91Y2hJc1RvdWNoRXZlbnQoYSkgJiYgIXRoaXMuX3RvdWNoU3dpcGVkKGEudGFyZ2V0KSB8fCAhdGhpcy5fdG91Y2hJc1RvdWNoRXZlbnQoYSkgJiYgIXRoaXMuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGEpIH0sIF90b3VjaElzVG91Y2hFdmVudDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIDAgPT0gYS50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSB9LCBfdG91Y2hSZWNvcmRFdmVudDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRoaXMuX3RvdWNoSXNUb3VjaEV2ZW50KGEpICYmIChhLnRpbWUgPSAobmV3IERhdGUpLmdldFRpbWUoKSwgdGhpcy5fX3RvdWNoRXZlbnRzLnB1c2goYSkpLCB0aGlzIH0sIF90b3VjaFN3aXBlZDogZnVuY3Rpb24gKGEpIHsgZm9yICh2YXIgYiA9ICExLCBjID0gdGhpcy5fX3RvdWNoRXZlbnRzLmxlbmd0aCAtIDE7IGMgPj0gMDsgYy0tKSB7IHZhciBkID0gdGhpcy5fX3RvdWNoRXZlbnRzW2NdOyBpZiAoXCJ0b3VjaG1vdmVcIiA9PSBkLnR5cGUpIHsgYiA9ICEwOyBicmVhayB9IGlmIChcInRvdWNoc3RhcnRcIiA9PSBkLnR5cGUgJiYgYSA9PT0gZC50YXJnZXQpIGJyZWFrIH0gcmV0dXJuIGIgfSwgX3RyaWdnZXI6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTsgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGJbMF0gJiYgKGJbMF0gPSB7IHR5cGU6IGJbMF0gfSksIGJbMF0uaW5zdGFuY2UgPSB0aGlzLCBiWzBdLm9yaWdpbiA9IHRoaXMuXyRvcmlnaW4gPyB0aGlzLl8kb3JpZ2luWzBdIDogbnVsbCwgYlswXS50b29sdGlwID0gdGhpcy5fJHRvb2x0aXAgPyB0aGlzLl8kdG9vbHRpcFswXSA6IG51bGwsIHRoaXMuX18kZW1pdHRlclByaXZhdGUudHJpZ2dlci5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLCBiKSwgYS50b29sdGlwc3Rlci5fdHJpZ2dlci5hcHBseShhLnRvb2x0aXBzdGVyLCBiKSwgdGhpcy5fXyRlbWl0dGVyUHVibGljLnRyaWdnZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBiKSwgdGhpcyB9LCBfdW5wbHVnOiBmdW5jdGlvbiAoYikgeyB2YXIgYyA9IHRoaXM7IGlmIChjW2JdKSB7IHZhciBkID0gYS50b29sdGlwc3Rlci5fcGx1Z2luKGIpOyBkLmluc3RhbmNlICYmIGEuZWFjaChkLmluc3RhbmNlLCBmdW5jdGlvbiAoYSwgZCkgeyBjW2FdICYmIGNbYV0uYnJpZGdlZCA9PT0gY1tiXSAmJiBkZWxldGUgY1thXSB9KSwgY1tiXS5fX2Rlc3Ryb3kgJiYgY1tiXS5fX2Rlc3Ryb3koKSwgZGVsZXRlIGNbYl0gfSByZXR1cm4gYyB9LCBjbG9zZTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRoaXMuX19kZXN0cm95ZWQgPyB0aGlzLl9fZGVzdHJveUVycm9yKCkgOiB0aGlzLl9jbG9zZShudWxsLCBhKSwgdGhpcyB9LCBjb250ZW50OiBmdW5jdGlvbiAoYSkgeyB2YXIgYiA9IHRoaXM7IGlmICh2b2lkIDAgPT09IGEpIHJldHVybiBiLl9fQ29udGVudDsgaWYgKGIuX19kZXN0cm95ZWQpIGIuX19kZXN0cm95RXJyb3IoKTsgZWxzZSBpZiAoYi5fX2NvbnRlbnRTZXQoYSksIG51bGwgIT09IGIuX19Db250ZW50KSB7IGlmIChcImNsb3NlZFwiICE9PSBiLl9fc3RhdGUgJiYgKGIuX19jb250ZW50SW5zZXJ0KCksIGIucmVwb3NpdGlvbigpLCBiLl9fb3B0aW9ucy51cGRhdGVBbmltYXRpb24pKSBpZiAoaC5oYXNUcmFuc2l0aW9ucykgeyB2YXIgYyA9IGIuX19vcHRpb25zLnVwZGF0ZUFuaW1hdGlvbjsgYi5fJHRvb2x0aXAuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci11cGRhdGUtXCIgKyBjKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IFwiY2xvc2VkXCIgIT0gYi5fX3N0YXRlICYmIGIuXyR0b29sdGlwLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItdXBkYXRlLVwiICsgYykgfSwgMWUzKSB9IGVsc2UgYi5fJHRvb2x0aXAuZmFkZVRvKDIwMCwgLjUsIGZ1bmN0aW9uICgpIHsgXCJjbG9zZWRcIiAhPSBiLl9fc3RhdGUgJiYgYi5fJHRvb2x0aXAuZmFkZVRvKDIwMCwgMSkgfSkgfSBlbHNlIGIuX2Nsb3NlKCk7IHJldHVybiBiIH0sIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSB0aGlzOyBpZiAoYi5fX2Rlc3Ryb3llZCkgYi5fX2Rlc3Ryb3lFcnJvcigpOyBlbHNlIHsgXCJjbG9zZWRcIiAhPSBiLl9fc3RhdGUgPyBiLm9wdGlvbihcImFuaW1hdGlvbkR1cmF0aW9uXCIsIDApLl9jbG9zZShudWxsLCBudWxsLCAhMCkgOiBiLl9fdGltZW91dHNDbGVhcigpLCBiLl90cmlnZ2VyKFwiZGVzdHJveVwiKSwgYi5fX2Rlc3Ryb3llZCA9ICEwLCBiLl8kb3JpZ2luLnJlbW92ZURhdGEoYi5fX25hbWVzcGFjZSkub2ZmKFwiLlwiICsgYi5fX25hbWVzcGFjZSArIFwiLXRyaWdnZXJPcGVuXCIpLCBhKGgud2luZG93LmRvY3VtZW50LmJvZHkpLm9mZihcIi5cIiArIGIuX19uYW1lc3BhY2UgKyBcIi10cmlnZ2VyT3BlblwiKTsgdmFyIGMgPSBiLl8kb3JpZ2luLmRhdGEoXCJ0b29sdGlwc3Rlci1uc1wiKTsgaWYgKGMpIGlmICgxID09PSBjLmxlbmd0aCkgeyB2YXIgZCA9IG51bGw7IFwicHJldmlvdXNcIiA9PSBiLl9fb3B0aW9ucy5yZXN0b3JhdGlvbiA/IGQgPSBiLl8kb3JpZ2luLmRhdGEoXCJ0b29sdGlwc3Rlci1pbml0aWFsVGl0bGVcIikgOiBcImN1cnJlbnRcIiA9PSBiLl9fb3B0aW9ucy5yZXN0b3JhdGlvbiAmJiAoZCA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGIuX19Db250ZW50ID8gYi5fX0NvbnRlbnQgOiBhKFwiPGRpdj48L2Rpdj5cIikuYXBwZW5kKGIuX19Db250ZW50KS5odG1sKCkpLCBkICYmIGIuXyRvcmlnaW4uYXR0cihcInRpdGxlXCIsIGQpLCBiLl8kb3JpZ2luLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXJlZFwiKSwgYi5fJG9yaWdpbi5yZW1vdmVEYXRhKFwidG9vbHRpcHN0ZXItbnNcIikucmVtb3ZlRGF0YShcInRvb2x0aXBzdGVyLWluaXRpYWxUaXRsZVwiKSB9IGVsc2UgYyA9IGEuZ3JlcChjLCBmdW5jdGlvbiAoYSwgYykgeyByZXR1cm4gYSAhPT0gYi5fX25hbWVzcGFjZSB9KSwgYi5fJG9yaWdpbi5kYXRhKFwidG9vbHRpcHN0ZXItbnNcIiwgYyk7IGIuX3RyaWdnZXIoXCJkZXN0cm95ZWRcIiksIGIuX29mZigpLCBiLm9mZigpLCBiLl9fQ29udGVudCA9IG51bGwsIGIuX18kZW1pdHRlclByaXZhdGUgPSBudWxsLCBiLl9fJGVtaXR0ZXJQdWJsaWMgPSBudWxsLCBiLl9fb3B0aW9ucy5wYXJlbnQgPSBudWxsLCBiLl8kb3JpZ2luID0gbnVsbCwgYi5fJHRvb2x0aXAgPSBudWxsLCBhLnRvb2x0aXBzdGVyLl9faW5zdGFuY2VzTGF0ZXN0QXJyID0gYS5ncmVwKGEudG9vbHRpcHN0ZXIuX19pbnN0YW5jZXNMYXRlc3RBcnIsIGZ1bmN0aW9uIChhLCBjKSB7IHJldHVybiBiICE9PSBhIH0pLCBjbGVhckludGVydmFsKGIuX19nYXJiYWdlQ29sbGVjdG9yKSB9IHJldHVybiBiIH0sIGRpc2FibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19kZXN0cm95ZWQgPyAodGhpcy5fX2Rlc3Ryb3lFcnJvcigpLCB0aGlzKSA6ICh0aGlzLl9jbG9zZSgpLCB0aGlzLl9fZW5hYmxlZCA9ICExLCB0aGlzKSB9LCBlbGVtZW50T3JpZ2luOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fZGVzdHJveWVkID8gdm9pZCB0aGlzLl9fZGVzdHJveUVycm9yKCkgOiB0aGlzLl8kb3JpZ2luWzBdIH0sIGVsZW1lbnRUb29sdGlwOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl8kdG9vbHRpcCA/IHRoaXMuXyR0b29sdGlwWzBdIDogbnVsbCB9LCBlbmFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19lbmFibGVkID0gITAsIHRoaXMgfSwgaGlkZTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRoaXMuY2xvc2UoYSkgfSwgaW5zdGFuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfSwgb2ZmOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fZGVzdHJveWVkIHx8IHRoaXMuX18kZW1pdHRlclB1YmxpYy5vZmYuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSwgb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19kZXN0cm95ZWQgPyB0aGlzLl9fZGVzdHJveUVycm9yKCkgOiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub24uYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSwgb25lOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fZGVzdHJveWVkID8gdGhpcy5fX2Rlc3Ryb3lFcnJvcigpIDogdGhpcy5fXyRlbWl0dGVyUHVibGljLm9uZS5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKSwgdGhpcyB9LCBvcGVuOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdGhpcy5fX2Rlc3Ryb3llZCA/IHRoaXMuX19kZXN0cm95RXJyb3IoKSA6IHRoaXMuX29wZW4obnVsbCwgYSksIHRoaXMgfSwgb3B0aW9uOiBmdW5jdGlvbiAoYiwgYykgeyByZXR1cm4gdm9pZCAwID09PSBjID8gdGhpcy5fX29wdGlvbnNbYl0gOiAodGhpcy5fX2Rlc3Ryb3llZCA/IHRoaXMuX19kZXN0cm95RXJyb3IoKSA6ICh0aGlzLl9fb3B0aW9uc1tiXSA9IGMsIHRoaXMuX19vcHRpb25zRm9ybWF0KCksIGEuaW5BcnJheShiLCBbXCJ0cmlnZ2VyXCIsIFwidHJpZ2dlckNsb3NlXCIsIFwidHJpZ2dlck9wZW5cIl0pID49IDAgJiYgdGhpcy5fX3ByZXBhcmVPcmlnaW4oKSwgXCJzZWxmRGVzdHJ1Y3Rpb25cIiA9PT0gYiAmJiB0aGlzLl9fcHJlcGFyZUdDKCkpLCB0aGlzKSB9LCByZXBvc2l0aW9uOiBmdW5jdGlvbiAoYSwgYikgeyB2YXIgYyA9IHRoaXM7IHJldHVybiBjLl9fZGVzdHJveWVkID8gYy5fX2Rlc3Ryb3lFcnJvcigpIDogXCJjbG9zZWRcIiAhPSBjLl9fc3RhdGUgJiYgZChjLl8kb3JpZ2luKSAmJiAoYiB8fCBkKGMuXyR0b29sdGlwKSkgJiYgKGIgfHwgYy5fJHRvb2x0aXAuZGV0YWNoKCksIGMuX19HZW9tZXRyeSA9IGMuX19nZW9tZXRyeSgpLCBjLl90cmlnZ2VyKHsgdHlwZTogXCJyZXBvc2l0aW9uXCIsIGV2ZW50OiBhLCBoZWxwZXI6IHsgZ2VvOiBjLl9fR2VvbWV0cnkgfSB9KSksIGMgfSwgc2hvdzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRoaXMub3BlbihhKSB9LCBzdGF0dXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZGVzdHJveWVkOiB0aGlzLl9fZGVzdHJveWVkLCBlbmFibGVkOiB0aGlzLl9fZW5hYmxlZCwgb3BlbjogXCJjbG9zZWRcIiAhPT0gdGhpcy5fX3N0YXRlLCBzdGF0ZTogdGhpcy5fX3N0YXRlIH0gfSwgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19kZXN0cm95ZWQgPyB0aGlzLl9fZGVzdHJveUVycm9yKCkgOiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMudHJpZ2dlckhhbmRsZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksIHRoaXMgfSB9LCBhLmZuLnRvb2x0aXBzdGVyID0gZnVuY3Rpb24gKCkgeyB2YXIgYiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpLCBjID0gXCJZb3UgYXJlIHVzaW5nIGEgc2luZ2xlIEhUTUwgZWxlbWVudCBhcyBjb250ZW50IGZvciBzZXZlcmFsIHRvb2x0aXBzLiBZb3UgcHJvYmFibHkgd2FudCB0byBzZXQgdGhlIGNvbnRlbnRDbG9uaW5nIG9wdGlvbiB0byBUUlVFLlwiOyBpZiAoMCA9PT0gdGhpcy5sZW5ndGgpIHJldHVybiB0aGlzOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYlswXSkgeyB2YXIgZCA9IFwiIyokfiZcIjsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHZhciBlID0gYSh0aGlzKS5kYXRhKFwidG9vbHRpcHN0ZXItbnNcIiksIGYgPSBlID8gYSh0aGlzKS5kYXRhKGVbMF0pIDogbnVsbDsgaWYgKCFmKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FsbGVkIFRvb2x0aXBzdGVyJ3MgXFxcIlwiICsgYlswXSArICdcIiBtZXRob2Qgb24gYW4gdW5pbml0aWFsaXplZCBlbGVtZW50Jyk7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGZbYlswXV0pIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXRob2QgXCInICsgYlswXSArICdcIicpOyB0aGlzLmxlbmd0aCA+IDEgJiYgXCJjb250ZW50XCIgPT0gYlswXSAmJiAoYlsxXSBpbnN0YW5jZW9mIGEgfHwgXCJvYmplY3RcIiA9PSB0eXBlb2YgYlsxXSAmJiBudWxsICE9IGJbMV0gJiYgYlsxXS50YWdOYW1lKSAmJiAhZi5fX29wdGlvbnMuY29udGVudENsb25pbmcgJiYgZi5fX29wdGlvbnMuZGVidWcgJiYgY29uc29sZS5sb2coYyk7IHZhciBnID0gZltiWzBdXShiWzFdLCBiWzJdKTsgcmV0dXJuIGcgIT09IGYgfHwgXCJpbnN0YW5jZVwiID09PSBiWzBdID8gKGQgPSBnLCAhMSkgOiB2b2lkIDAgfSksIFwiIyokfiZcIiAhPT0gZCA/IGQgOiB0aGlzIH0gYS50b29sdGlwc3Rlci5fX2luc3RhbmNlc0xhdGVzdEFyciA9IFtdOyB2YXIgZSA9IGJbMF0gJiYgdm9pZCAwICE9PSBiWzBdLm11bHRpcGxlLCBnID0gZSAmJiBiWzBdLm11bHRpcGxlIHx8ICFlICYmIGYubXVsdGlwbGUsIGggPSBiWzBdICYmIHZvaWQgMCAhPT0gYlswXS5jb250ZW50LCBpID0gaCAmJiBiWzBdLmNvbnRlbnQgfHwgIWggJiYgZi5jb250ZW50LCBqID0gYlswXSAmJiB2b2lkIDAgIT09IGJbMF0uY29udGVudENsb25pbmcsIGsgPSBqICYmIGJbMF0uY29udGVudENsb25pbmcgfHwgIWogJiYgZi5jb250ZW50Q2xvbmluZywgbCA9IGJbMF0gJiYgdm9pZCAwICE9PSBiWzBdLmRlYnVnLCBtID0gbCAmJiBiWzBdLmRlYnVnIHx8ICFsICYmIGYuZGVidWc7IHJldHVybiB0aGlzLmxlbmd0aCA+IDEgJiYgKGkgaW5zdGFuY2VvZiBhIHx8IFwib2JqZWN0XCIgPT0gdHlwZW9mIGkgJiYgbnVsbCAhPSBpICYmIGkudGFnTmFtZSkgJiYgIWsgJiYgbSAmJiBjb25zb2xlLmxvZyhjKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIGMgPSAhMSwgZCA9IGEodGhpcyksIGUgPSBkLmRhdGEoXCJ0b29sdGlwc3Rlci1uc1wiKSwgZiA9IG51bGw7IGUgPyBnID8gYyA9ICEwIDogbSAmJiAoY29uc29sZS5sb2coXCJUb29sdGlwc3Rlcjogb25lIG9yIG1vcmUgdG9vbHRpcHMgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQgYmVsb3cuIElnbm9yaW5nLlwiKSwgY29uc29sZS5sb2codGhpcykpIDogYyA9ICEwLCBjICYmIChmID0gbmV3IGEuVG9vbHRpcHN0ZXIodGhpcywgYlswXSksIGUgfHwgKGUgPSBbXSksIGUucHVzaChmLl9fbmFtZXNwYWNlKSwgZC5kYXRhKFwidG9vbHRpcHN0ZXItbnNcIiwgZSksIGQuZGF0YShmLl9fbmFtZXNwYWNlLCBmKSwgZi5fX29wdGlvbnMuZnVuY3Rpb25Jbml0ICYmIGYuX19vcHRpb25zLmZ1bmN0aW9uSW5pdC5jYWxsKGYsIGYsIHsgb3JpZ2luOiB0aGlzIH0pLCBmLl90cmlnZ2VyKFwiaW5pdFwiKSksIGEudG9vbHRpcHN0ZXIuX19pbnN0YW5jZXNMYXRlc3RBcnIucHVzaChmKSB9KSwgdGhpcyB9LCBiLnByb3RvdHlwZSA9IHsgX19pbml0OiBmdW5jdGlvbiAoYikgeyB0aGlzLl9fJHRvb2x0aXAgPSBiLCB0aGlzLl9fJHRvb2x0aXAuY3NzKHsgbGVmdDogMCwgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsIHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogMCB9KS5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpLCB0aGlzLiRjb250YWluZXIgPSBhKCc8ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItcnVsZXJcIj48L2Rpdj4nKS5hcHBlbmQodGhpcy5fXyR0b29sdGlwKS5hcHBlbmRUbyhoLndpbmRvdy5kb2N1bWVudC5ib2R5KSB9LCBfX2ZvcmNlUmVkcmF3OiBmdW5jdGlvbiAoKSB7IHZhciBhID0gdGhpcy5fXyR0b29sdGlwLnBhcmVudCgpOyB0aGlzLl9fJHRvb2x0aXAuZGV0YWNoKCksIHRoaXMuX18kdG9vbHRpcC5hcHBlbmRUbyhhKSB9LCBjb25zdHJhaW46IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0aGlzLmNvbnN0cmFpbnRzID0geyB3aWR0aDogYSwgaGVpZ2h0OiBiIH0sIHRoaXMuX18kdG9vbHRpcC5jc3MoeyBkaXNwbGF5OiBcImJsb2NrXCIsIGhlaWdodDogXCJcIiwgb3ZlcmZsb3c6IFwiYXV0b1wiLCB3aWR0aDogYSB9KSwgdGhpcyB9LCBkZXN0cm95OiBmdW5jdGlvbiAoKSB7IHRoaXMuX18kdG9vbHRpcC5kZXRhY2goKS5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIikuY3NzKHsgZGlzcGxheTogXCJcIiwgb3ZlcmZsb3c6IFwiXCIgfSksIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKSB9LCBmcmVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnN0cmFpbnRzID0gbnVsbCwgdGhpcy5fXyR0b29sdGlwLmNzcyh7IGRpc3BsYXk6IFwiXCIsIGhlaWdodDogXCJcIiwgb3ZlcmZsb3c6IFwidmlzaWJsZVwiLCB3aWR0aDogXCJcIiB9KSwgdGhpcyB9LCBtZWFzdXJlOiBmdW5jdGlvbiAoKSB7IHRoaXMuX19mb3JjZVJlZHJhdygpOyB2YXIgYSA9IHRoaXMuX18kdG9vbHRpcFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYiA9IHsgc2l6ZTogeyBoZWlnaHQ6IGEuaGVpZ2h0IHx8IGEuYm90dG9tIC0gYS50b3AsIHdpZHRoOiBhLndpZHRoIHx8IGEucmlnaHQgLSBhLmxlZnQgfSB9OyBpZiAodGhpcy5jb25zdHJhaW50cykgeyB2YXIgYyA9IHRoaXMuX18kdG9vbHRpcC5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIiksIGQgPSB0aGlzLl9fJHRvb2x0aXAub3V0ZXJIZWlnaHQoKSwgZSA9IGNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGYgPSB7IGhlaWdodDogZCA8PSB0aGlzLmNvbnN0cmFpbnRzLmhlaWdodCwgd2lkdGg6IGEud2lkdGggPD0gdGhpcy5jb25zdHJhaW50cy53aWR0aCAmJiBlLndpZHRoID49IGNbMF0uc2Nyb2xsV2lkdGggLSAxIH07IGIuZml0cyA9IGYuaGVpZ2h0ICYmIGYud2lkdGggfSByZXR1cm4gaC5JRSAmJiBoLklFIDw9IDExICYmIGIuc2l6ZS53aWR0aCAhPT0gaC53aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICYmIChiLnNpemUud2lkdGggPSBNYXRoLmNlaWwoYi5zaXplLndpZHRoKSArIDEpLCBiIH0gfTsgdmFyIGogPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7IC0xICE9IGouaW5kZXhPZihcIm1zaWVcIikgPyBoLklFID0gcGFyc2VJbnQoai5zcGxpdChcIm1zaWVcIilbMV0pIDogLTEgIT09IGoudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwidHJpZGVudFwiKSAmJiAtMSAhPT0gai5pbmRleE9mKFwiIHJ2OjExXCIpID8gaC5JRSA9IDExIDogLTEgIT0gai50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJlZGdlL1wiKSAmJiAoaC5JRSA9IHBhcnNlSW50KGoudG9Mb3dlckNhc2UoKS5zcGxpdChcImVkZ2UvXCIpWzFdKSk7IHZhciBrID0gXCJ0b29sdGlwc3Rlci5zaWRlVGlwXCI7IHJldHVybiBhLnRvb2x0aXBzdGVyLl9wbHVnaW4oe1xyXG4gICAgICAgIG5hbWU6IGssIGluc3RhbmNlOiB7XHJcbiAgICAgICAgICAgIF9fZGVmYXVsdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgYXJyb3c6ICEwLCBkaXN0YW5jZTogNiwgZnVuY3Rpb25Qb3NpdGlvbjogbnVsbCwgbWF4V2lkdGg6IG51bGwsIG1pbkludGVyc2VjdGlvbjogMTYsIG1pbldpZHRoOiAwLCBwb3NpdGlvbjogbnVsbCwgc2lkZTogXCJ0b3BcIiwgdmlld3BvcnRBd2FyZTogITAgfSB9LCBfX2luaXQ6IGZ1bmN0aW9uIChhKSB7IHZhciBiID0gdGhpczsgYi5fX2luc3RhbmNlID0gYSwgYi5fX25hbWVzcGFjZSA9IFwidG9vbHRpcHN0ZXItc2lkZVRpcC1cIiArIE1hdGgucm91bmQoMWU2ICogTWF0aC5yYW5kb20oKSksIGIuX19wcmV2aW91c1N0YXRlID0gXCJjbG9zZWRcIiwgYi5fX29wdGlvbnMsIGIuX19vcHRpb25zRm9ybWF0KCksIGIuX19pbnN0YW5jZS5fb24oXCJzdGF0ZS5cIiArIGIuX19uYW1lc3BhY2UsIGZ1bmN0aW9uIChhKSB7IFwiY2xvc2VkXCIgPT0gYS5zdGF0ZSA/IGIuX19jbG9zZSgpIDogXCJhcHBlYXJpbmdcIiA9PSBhLnN0YXRlICYmIFwiY2xvc2VkXCIgPT0gYi5fX3ByZXZpb3VzU3RhdGUgJiYgYi5fX2NyZWF0ZSgpLCBiLl9fcHJldmlvdXNTdGF0ZSA9IGEuc3RhdGUgfSksIGIuX19pbnN0YW5jZS5fb24oXCJvcHRpb25zLlwiICsgYi5fX25hbWVzcGFjZSwgZnVuY3Rpb24gKCkgeyBiLl9fb3B0aW9uc0Zvcm1hdCgpIH0pLCBiLl9faW5zdGFuY2UuX29uKFwicmVwb3NpdGlvbi5cIiArIGIuX19uYW1lc3BhY2UsIGZ1bmN0aW9uIChhKSB7IGIuX19yZXBvc2l0aW9uKGEuZXZlbnQsIGEuaGVscGVyKSB9KSB9LCBfX2Nsb3NlOiBmdW5jdGlvbiAoKSB7IHRoaXMuX19pbnN0YW5jZS5jb250ZW50KCkgaW5zdGFuY2VvZiBhICYmIHRoaXMuX19pbnN0YW5jZS5jb250ZW50KCkuZGV0YWNoKCksIHRoaXMuX19pbnN0YW5jZS5fJHRvb2x0aXAucmVtb3ZlKCksIHRoaXMuX19pbnN0YW5jZS5fJHRvb2x0aXAgPSBudWxsIH0sIF9fY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGEoJzxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1iYXNlIHRvb2x0aXBzdGVyLXNpZGV0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItYm94XCI+PGRpdiBjbGFzcz1cInRvb2x0aXBzdGVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItYXJyb3dcIj48ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItYXJyb3ctdW5jcm9wcGVkXCI+PGRpdiBjbGFzcz1cInRvb2x0aXBzdGVyLWFycm93LWJvcmRlclwiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1hcnJvdy1iYWNrZ3JvdW5kXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+Jyk7IHRoaXMuX19vcHRpb25zLmFycm93IHx8IGIuZmluZChcIi50b29sdGlwc3Rlci1ib3hcIikuY3NzKFwibWFyZ2luXCIsIDApLmVuZCgpLmZpbmQoXCIudG9vbHRpcHN0ZXItYXJyb3dcIikuaGlkZSgpLCB0aGlzLl9fb3B0aW9ucy5taW5XaWR0aCAmJiBiLmNzcyhcIm1pbi13aWR0aFwiLCB0aGlzLl9fb3B0aW9ucy5taW5XaWR0aCArIFwicHhcIiksIHRoaXMuX19vcHRpb25zLm1heFdpZHRoICYmIGIuY3NzKFwibWF4LXdpZHRoXCIsIHRoaXMuX19vcHRpb25zLm1heFdpZHRoICsgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faW5zdGFuY2UuXyR0b29sdGlwID0gYiwgdGhpcy5fX2luc3RhbmNlLl90cmlnZ2VyKFwiY3JlYXRlZFwiKVxyXG4gICAgICAgICAgICB9LCBfX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHsgdGhpcy5fX2luc3RhbmNlLl9vZmYoXCIuXCIgKyBzZWxmLl9fbmFtZXNwYWNlKSB9LCBfX29wdGlvbnNGb3JtYXQ6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSB0aGlzOyBpZiAoYi5fX29wdGlvbnMgPSBiLl9faW5zdGFuY2UuX29wdGlvbnNFeHRyYWN0KGssIGIuX19kZWZhdWx0cygpKSwgYi5fX29wdGlvbnMucG9zaXRpb24gJiYgKGIuX19vcHRpb25zLnNpZGUgPSBiLl9fb3B0aW9ucy5wb3NpdGlvbiksIFwib2JqZWN0XCIgIT0gdHlwZW9mIGIuX19vcHRpb25zLmRpc3RhbmNlICYmIChiLl9fb3B0aW9ucy5kaXN0YW5jZSA9IFtiLl9fb3B0aW9ucy5kaXN0YW5jZV0pLCBiLl9fb3B0aW9ucy5kaXN0YW5jZS5sZW5ndGggPCA0ICYmICh2b2lkIDAgPT09IGIuX19vcHRpb25zLmRpc3RhbmNlWzFdICYmIChiLl9fb3B0aW9ucy5kaXN0YW5jZVsxXSA9IGIuX19vcHRpb25zLmRpc3RhbmNlWzBdKSwgdm9pZCAwID09PSBiLl9fb3B0aW9ucy5kaXN0YW5jZVsyXSAmJiAoYi5fX29wdGlvbnMuZGlzdGFuY2VbMl0gPSBiLl9fb3B0aW9ucy5kaXN0YW5jZVswXSksIHZvaWQgMCA9PT0gYi5fX29wdGlvbnMuZGlzdGFuY2VbM10gJiYgKGIuX19vcHRpb25zLmRpc3RhbmNlWzNdID0gYi5fX29wdGlvbnMuZGlzdGFuY2VbMV0pLCBiLl9fb3B0aW9ucy5kaXN0YW5jZSA9IHsgdG9wOiBiLl9fb3B0aW9ucy5kaXN0YW5jZVswXSwgcmlnaHQ6IGIuX19vcHRpb25zLmRpc3RhbmNlWzFdLCBib3R0b206IGIuX19vcHRpb25zLmRpc3RhbmNlWzJdLCBsZWZ0OiBiLl9fb3B0aW9ucy5kaXN0YW5jZVszXSB9KSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYi5fX29wdGlvbnMuc2lkZSkgeyB2YXIgYyA9IHsgdG9wOiBcImJvdHRvbVwiLCByaWdodDogXCJsZWZ0XCIsIGJvdHRvbTogXCJ0b3BcIiwgbGVmdDogXCJyaWdodFwiIH07IGIuX19vcHRpb25zLnNpZGUgPSBbYi5fX29wdGlvbnMuc2lkZSwgY1tiLl9fb3B0aW9ucy5zaWRlXV0sIFwibGVmdFwiID09IGIuX19vcHRpb25zLnNpZGVbMF0gfHwgXCJyaWdodFwiID09IGIuX19vcHRpb25zLnNpZGVbMF0gPyBiLl9fb3B0aW9ucy5zaWRlLnB1c2goXCJ0b3BcIiwgXCJib3R0b21cIikgOiBiLl9fb3B0aW9ucy5zaWRlLnB1c2goXCJyaWdodFwiLCBcImxlZnRcIikgfSA2ID09PSBhLnRvb2x0aXBzdGVyLl9lbnYuSUUgJiYgYi5fX29wdGlvbnMuYXJyb3cgIT09ICEwICYmIChiLl9fb3B0aW9ucy5hcnJvdyA9ICExKSB9LCBfX3JlcG9zaXRpb246IGZ1bmN0aW9uIChiLCBjKSB7IHZhciBkLCBlID0gdGhpcywgZiA9IGUuX190YXJnZXRGaW5kKGMpLCBnID0gW107IGUuX19pbnN0YW5jZS5fJHRvb2x0aXAuZGV0YWNoKCk7IHZhciBoID0gZS5fX2luc3RhbmNlLl8kdG9vbHRpcC5jbG9uZSgpLCBpID0gYS50b29sdGlwc3Rlci5fZ2V0UnVsZXIoaCksIGogPSAhMSwgayA9IGUuX19pbnN0YW5jZS5vcHRpb24oXCJhbmltYXRpb25cIik7IHN3aXRjaCAoayAmJiBoLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItXCIgKyBrKSwgYS5lYWNoKFtcIndpbmRvd1wiLCBcImRvY3VtZW50XCJdLCBmdW5jdGlvbiAoZCwgaykgeyB2YXIgbCA9IG51bGw7IGlmIChlLl9faW5zdGFuY2UuX3RyaWdnZXIoeyBjb250YWluZXI6IGssIGhlbHBlcjogYywgc2F0aXNmaWVkOiBqLCB0YWtlVGVzdDogZnVuY3Rpb24gKGEpIHsgbCA9IGEgfSwgcmVzdWx0czogZywgdHlwZTogXCJwb3NpdGlvblRlc3RcIiB9KSwgMSA9PSBsIHx8IDAgIT0gbCAmJiAwID09IGogJiYgKFwid2luZG93XCIgIT0gayB8fCBlLl9fb3B0aW9ucy52aWV3cG9ydEF3YXJlKSkgZm9yICh2YXIgZCA9IDA7IGQgPCBlLl9fb3B0aW9ucy5zaWRlLmxlbmd0aDsgZCsrKSB7IHZhciBtID0geyBob3Jpem9udGFsOiAwLCB2ZXJ0aWNhbDogMCB9LCBuID0gZS5fX29wdGlvbnMuc2lkZVtkXTsgXCJ0b3BcIiA9PSBuIHx8IFwiYm90dG9tXCIgPT0gbiA/IG0udmVydGljYWwgPSBlLl9fb3B0aW9ucy5kaXN0YW5jZVtuXSA6IG0uaG9yaXpvbnRhbCA9IGUuX19vcHRpb25zLmRpc3RhbmNlW25dLCBlLl9fc2lkZUNoYW5nZShoLCBuKSwgYS5lYWNoKFtcIm5hdHVyYWxcIiwgXCJjb25zdHJhaW5lZFwiXSwgZnVuY3Rpb24gKGEsIGQpIHsgaWYgKGwgPSBudWxsLCBlLl9faW5zdGFuY2UuX3RyaWdnZXIoeyBjb250YWluZXI6IGssIGV2ZW50OiBiLCBoZWxwZXI6IGMsIG1vZGU6IGQsIHJlc3VsdHM6IGcsIHNhdGlzZmllZDogaiwgc2lkZTogbiwgdGFrZVRlc3Q6IGZ1bmN0aW9uIChhKSB7IGwgPSBhIH0sIHR5cGU6IFwicG9zaXRpb25UZXN0XCIgfSksIDEgPT0gbCB8fCAwICE9IGwgJiYgMCA9PSBqKSB7IHZhciBoID0geyBjb250YWluZXI6IGssIGRpc3RhbmNlOiBtLCBmaXRzOiBudWxsLCBtb2RlOiBkLCBvdXRlclNpemU6IG51bGwsIHNpZGU6IG4sIHNpemU6IG51bGwsIHRhcmdldDogZltuXSwgd2hvbGU6IG51bGwgfSwgbyA9IFwibmF0dXJhbFwiID09IGQgPyBpLmZyZWUoKSA6IGkuY29uc3RyYWluKGMuZ2VvLmF2YWlsYWJsZVtrXVtuXS53aWR0aCAtIG0uaG9yaXpvbnRhbCwgYy5nZW8uYXZhaWxhYmxlW2tdW25dLmhlaWdodCAtIG0udmVydGljYWwpLCBwID0gby5tZWFzdXJlKCk7IGlmIChoLnNpemUgPSBwLnNpemUsIGgub3V0ZXJTaXplID0geyBoZWlnaHQ6IHAuc2l6ZS5oZWlnaHQgKyBtLnZlcnRpY2FsLCB3aWR0aDogcC5zaXplLndpZHRoICsgbS5ob3Jpem9udGFsIH0sIFwibmF0dXJhbFwiID09IGQgPyBjLmdlby5hdmFpbGFibGVba11bbl0ud2lkdGggPj0gaC5vdXRlclNpemUud2lkdGggJiYgYy5nZW8uYXZhaWxhYmxlW2tdW25dLmhlaWdodCA+PSBoLm91dGVyU2l6ZS5oZWlnaHQgPyBoLmZpdHMgPSAhMCA6IGguZml0cyA9ICExIDogaC5maXRzID0gcC5maXRzLCBcIndpbmRvd1wiID09IGsgJiYgKGguZml0cyA/IFwidG9wXCIgPT0gbiB8fCBcImJvdHRvbVwiID09IG4gPyBoLndob2xlID0gYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5yaWdodCA+PSBlLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gJiYgYy5nZW8ud2luZG93LnNpemUud2lkdGggLSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQgPj0gZS5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uIDogaC53aG9sZSA9IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tID49IGUuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbiAmJiBjLmdlby53aW5kb3cuc2l6ZS5oZWlnaHQgLSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCA+PSBlLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gOiBoLndob2xlID0gITEpLCBnLnB1c2goaCksIGgud2hvbGUpIGogPSAhMDsgZWxzZSBpZiAoXCJuYXR1cmFsXCIgPT0gaC5tb2RlICYmIChoLmZpdHMgfHwgaC5zaXplLndpZHRoIDw9IGMuZ2VvLmF2YWlsYWJsZVtrXVtuXS53aWR0aCkpIHJldHVybiAhMSB9IH0pIH0gfSksIGUuX19pbnN0YW5jZS5fdHJpZ2dlcih7IGVkaXQ6IGZ1bmN0aW9uIChhKSB7IGcgPSBhIH0sIGV2ZW50OiBiLCBoZWxwZXI6IGMsIHJlc3VsdHM6IGcsIHR5cGU6IFwicG9zaXRpb25UZXN0ZWRcIiB9KSwgZy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IGlmIChhLndob2xlICYmICFiLndob2xlKSByZXR1cm4gLTE7IGlmICghYS53aG9sZSAmJiBiLndob2xlKSByZXR1cm4gMTsgaWYgKGEud2hvbGUgJiYgYi53aG9sZSkgeyB2YXIgYyA9IGUuX19vcHRpb25zLnNpZGUuaW5kZXhPZihhLnNpZGUpLCBkID0gZS5fX29wdGlvbnMuc2lkZS5pbmRleE9mKGIuc2lkZSk7IHJldHVybiBkID4gYyA/IC0xIDogYyA+IGQgPyAxIDogXCJuYXR1cmFsXCIgPT0gYS5tb2RlID8gLTEgOiAxIH0gaWYgKGEuZml0cyAmJiAhYi5maXRzKSByZXR1cm4gLTE7IGlmICghYS5maXRzICYmIGIuZml0cykgcmV0dXJuIDE7IGlmIChhLmZpdHMgJiYgYi5maXRzKSB7IHZhciBjID0gZS5fX29wdGlvbnMuc2lkZS5pbmRleE9mKGEuc2lkZSksIGQgPSBlLl9fb3B0aW9ucy5zaWRlLmluZGV4T2YoYi5zaWRlKTsgcmV0dXJuIGQgPiBjID8gLTEgOiBjID4gZCA/IDEgOiBcIm5hdHVyYWxcIiA9PSBhLm1vZGUgPyAtMSA6IDEgfSByZXR1cm4gXCJkb2N1bWVudFwiID09IGEuY29udGFpbmVyICYmIFwiYm90dG9tXCIgPT0gYS5zaWRlICYmIFwibmF0dXJhbFwiID09IGEubW9kZSA/IC0xIDogMSB9KSwgZCA9IGdbMF0sIGQuY29vcmQgPSB7fSwgZC5zaWRlKSB7IGNhc2UgXCJsZWZ0XCI6IGNhc2UgXCJyaWdodFwiOiBkLmNvb3JkLnRvcCA9IE1hdGguZmxvb3IoZC50YXJnZXQgLSBkLnNpemUuaGVpZ2h0IC8gMik7IGJyZWFrOyBjYXNlIFwiYm90dG9tXCI6IGNhc2UgXCJ0b3BcIjogZC5jb29yZC5sZWZ0ID0gTWF0aC5mbG9vcihkLnRhcmdldCAtIGQuc2l6ZS53aWR0aCAvIDIpIH1zd2l0Y2ggKGQuc2lkZSkgeyBjYXNlIFwibGVmdFwiOiBkLmNvb3JkLmxlZnQgPSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQgLSBkLm91dGVyU2l6ZS53aWR0aDsgYnJlYWs7IGNhc2UgXCJyaWdodFwiOiBkLmNvb3JkLmxlZnQgPSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnJpZ2h0ICsgZC5kaXN0YW5jZS5ob3Jpem9udGFsOyBicmVhazsgY2FzZSBcInRvcFwiOiBkLmNvb3JkLnRvcCA9IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wIC0gZC5vdXRlclNpemUuaGVpZ2h0OyBicmVhazsgY2FzZSBcImJvdHRvbVwiOiBkLmNvb3JkLnRvcCA9IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tICsgZC5kaXN0YW5jZS52ZXJ0aWNhbCB9XCJ3aW5kb3dcIiA9PSBkLmNvbnRhaW5lciA/IFwidG9wXCIgPT0gZC5zaWRlIHx8IFwiYm90dG9tXCIgPT0gZC5zaWRlID8gZC5jb29yZC5sZWZ0IDwgMCA/IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQgLSB0aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gPj0gMCA/IGQuY29vcmQubGVmdCA9IDAgOiBkLmNvb3JkLmxlZnQgPSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnJpZ2h0IC0gdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uIC0gMSA6IGQuY29vcmQubGVmdCA+IGMuZ2VvLndpbmRvdy5zaXplLndpZHRoIC0gZC5zaXplLndpZHRoICYmIChjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQgKyB0aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gPD0gYy5nZW8ud2luZG93LnNpemUud2lkdGggPyBkLmNvb3JkLmxlZnQgPSBjLmdlby53aW5kb3cuc2l6ZS53aWR0aCAtIGQuc2l6ZS53aWR0aCA6IGQuY29vcmQubGVmdCA9IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCArIHRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbiArIDEgLSBkLnNpemUud2lkdGgpIDogZC5jb29yZC50b3AgPCAwID8gYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5ib3R0b20gLSB0aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gPj0gMCA/IGQuY29vcmQudG9wID0gMCA6IGQuY29vcmQudG9wID0gYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5ib3R0b20gLSB0aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gLSAxIDogZC5jb29yZC50b3AgPiBjLmdlby53aW5kb3cuc2l6ZS5oZWlnaHQgLSBkLnNpemUuaGVpZ2h0ICYmIChjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCArIHRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbiA8PSBjLmdlby53aW5kb3cuc2l6ZS5oZWlnaHQgPyBkLmNvb3JkLnRvcCA9IGMuZ2VvLndpbmRvdy5zaXplLmhlaWdodCAtIGQuc2l6ZS5oZWlnaHQgOiBkLmNvb3JkLnRvcCA9IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wICsgdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uICsgMSAtIGQuc2l6ZS5oZWlnaHQpIDogKGQuY29vcmQubGVmdCA+IGMuZ2VvLndpbmRvdy5zaXplLndpZHRoIC0gZC5zaXplLndpZHRoICYmIChkLmNvb3JkLmxlZnQgPSBjLmdlby53aW5kb3cuc2l6ZS53aWR0aCAtIGQuc2l6ZS53aWR0aCksIGQuY29vcmQubGVmdCA8IDAgJiYgKGQuY29vcmQubGVmdCA9IDApKSwgZS5fX3NpZGVDaGFuZ2UoaCwgZC5zaWRlKSwgYy50b29sdGlwQ2xvbmUgPSBoWzBdLCBjLnRvb2x0aXBQYXJlbnQgPSBlLl9faW5zdGFuY2Uub3B0aW9uKFwicGFyZW50XCIpLnBhcmVudFswXSwgYy5tb2RlID0gZC5tb2RlLCBjLndob2xlID0gZC53aG9sZSwgYy5vcmlnaW4gPSBlLl9faW5zdGFuY2UuXyRvcmlnaW5bMF0sIGMudG9vbHRpcCA9IGUuX19pbnN0YW5jZS5fJHRvb2x0aXBbMF0sIGRlbGV0ZSBkLmNvbnRhaW5lciwgZGVsZXRlIGQuZml0cywgZGVsZXRlIGQubW9kZSwgZGVsZXRlIGQub3V0ZXJTaXplLCBkZWxldGUgZC53aG9sZSwgZC5kaXN0YW5jZSA9IGQuZGlzdGFuY2UuaG9yaXpvbnRhbCB8fCBkLmRpc3RhbmNlLnZlcnRpY2FsOyB2YXIgbCA9IGEuZXh0ZW5kKCEwLCB7fSwgZCk7IGlmIChlLl9faW5zdGFuY2UuX3RyaWdnZXIoeyBlZGl0OiBmdW5jdGlvbiAoYSkgeyBkID0gYSB9LCBldmVudDogYiwgaGVscGVyOiBjLCBwb3NpdGlvbjogbCwgdHlwZTogXCJwb3NpdGlvblwiIH0pLCBlLl9fb3B0aW9ucy5mdW5jdGlvblBvc2l0aW9uKSB7IHZhciBtID0gZS5fX29wdGlvbnMuZnVuY3Rpb25Qb3NpdGlvbi5jYWxsKGUsIGUuX19pbnN0YW5jZSwgYywgbCk7IG0gJiYgKGQgPSBtKSB9IGkuZGVzdHJveSgpOyB2YXIgbiwgbzsgXCJ0b3BcIiA9PSBkLnNpZGUgfHwgXCJib3R0b21cIiA9PSBkLnNpZGUgPyAobiA9IHsgcHJvcDogXCJsZWZ0XCIsIHZhbDogZC50YXJnZXQgLSBkLmNvb3JkLmxlZnQgfSwgbyA9IGQuc2l6ZS53aWR0aCAtIHRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbikgOiAobiA9IHsgcHJvcDogXCJ0b3BcIiwgdmFsOiBkLnRhcmdldCAtIGQuY29vcmQudG9wIH0sIG8gPSBkLnNpemUuaGVpZ2h0IC0gdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uKSwgbi52YWwgPCB0aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24gPyBuLnZhbCA9IHRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbiA6IG4udmFsID4gbyAmJiAobi52YWwgPSBvKTsgdmFyIHA7IHAgPSBjLmdlby5vcmlnaW4uZml4ZWRMaW5lYWdlID8gYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldCA6IHsgbGVmdDogYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0ICsgYy5nZW8ud2luZG93LnNjcm9sbC5sZWZ0LCB0b3A6IGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wICsgYy5nZW8ud2luZG93LnNjcm9sbC50b3AgfSwgZC5jb29yZCA9IHsgbGVmdDogcC5sZWZ0ICsgKGQuY29vcmQubGVmdCAtIGMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCksIHRvcDogcC50b3AgKyAoZC5jb29yZC50b3AgLSBjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCkgfSwgZS5fX3NpZGVDaGFuZ2UoZS5fX2luc3RhbmNlLl8kdG9vbHRpcCwgZC5zaWRlKSwgYy5nZW8ub3JpZ2luLmZpeGVkTGluZWFnZSA/IGUuX19pbnN0YW5jZS5fJHRvb2x0aXAuY3NzKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKSA6IGUuX19pbnN0YW5jZS5fJHRvb2x0aXAuY3NzKFwicG9zaXRpb25cIiwgXCJcIiksIGUuX19pbnN0YW5jZS5fJHRvb2x0aXAuY3NzKHsgbGVmdDogZC5jb29yZC5sZWZ0LCB0b3A6IGQuY29vcmQudG9wLCBoZWlnaHQ6IGQuc2l6ZS5oZWlnaHQsIHdpZHRoOiBkLnNpemUud2lkdGggfSkuZmluZChcIi50b29sdGlwc3Rlci1hcnJvd1wiKS5jc3MoeyBsZWZ0OiBcIlwiLCB0b3A6IFwiXCIgfSkuY3NzKG4ucHJvcCwgbi52YWwpLCBlLl9faW5zdGFuY2UuXyR0b29sdGlwLmFwcGVuZFRvKGUuX19pbnN0YW5jZS5vcHRpb24oXCJwYXJlbnRcIikpLCBlLl9faW5zdGFuY2UuX3RyaWdnZXIoeyB0eXBlOiBcInJlcG9zaXRpb25lZFwiLCBldmVudDogYiwgcG9zaXRpb246IGQgfSkgfSwgX19zaWRlQ2hhbmdlOiBmdW5jdGlvbiAoYSwgYikgeyBhLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItYm90dG9tXCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItbGVmdFwiKS5yZW1vdmVDbGFzcyhcInRvb2x0aXBzdGVyLXJpZ2h0XCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItdG9wXCIpLmFkZENsYXNzKFwidG9vbHRpcHN0ZXItXCIgKyBiKSB9LCBfX3RhcmdldEZpbmQ6IGZ1bmN0aW9uIChhKSB7IHZhciBiID0ge30sIGMgPSB0aGlzLl9faW5zdGFuY2UuXyRvcmlnaW5bMF0uZ2V0Q2xpZW50UmVjdHMoKTsgaWYgKGMubGVuZ3RoID4gMSkgeyB2YXIgZCA9IHRoaXMuX19pbnN0YW5jZS5fJG9yaWdpbi5jc3MoXCJvcGFjaXR5XCIpOyAxID09IGQgJiYgKHRoaXMuX19pbnN0YW5jZS5fJG9yaWdpbi5jc3MoXCJvcGFjaXR5XCIsIC45OSksIGMgPSB0aGlzLl9faW5zdGFuY2UuXyRvcmlnaW5bMF0uZ2V0Q2xpZW50UmVjdHMoKSwgdGhpcy5fX2luc3RhbmNlLl8kb3JpZ2luLmNzcyhcIm9wYWNpdHlcIiwgMSkpIH0gaWYgKGMubGVuZ3RoIDwgMikgYi50b3AgPSBNYXRoLmZsb29yKGEuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCArIGEuZ2VvLm9yaWdpbi5zaXplLndpZHRoIC8gMiksIGIuYm90dG9tID0gYi50b3AsIGIubGVmdCA9IE1hdGguZmxvb3IoYS5nZW8ub3JpZ2luLndpbmRvd09mZnNldC50b3AgKyBhLmdlby5vcmlnaW4uc2l6ZS5oZWlnaHQgLyAyKSwgYi5yaWdodCA9IGIubGVmdDsgZWxzZSB7IHZhciBlID0gY1swXTsgYi50b3AgPSBNYXRoLmZsb29yKGUubGVmdCArIChlLnJpZ2h0IC0gZS5sZWZ0KSAvIDIpLCBlID0gYy5sZW5ndGggPiAyID8gY1tNYXRoLmNlaWwoYy5sZW5ndGggLyAyKSAtIDFdIDogY1swXSwgYi5yaWdodCA9IE1hdGguZmxvb3IoZS50b3AgKyAoZS5ib3R0b20gLSBlLnRvcCkgLyAyKSwgZSA9IGNbYy5sZW5ndGggLSAxXSwgYi5ib3R0b20gPSBNYXRoLmZsb29yKGUubGVmdCArIChlLnJpZ2h0IC0gZS5sZWZ0KSAvIDIpLCBlID0gYy5sZW5ndGggPiAyID8gY1tNYXRoLmNlaWwoKGMubGVuZ3RoICsgMSkgLyAyKSAtIDFdIDogY1tjLmxlbmd0aCAtIDFdLCBiLmxlZnQgPSBNYXRoLmZsb29yKGUudG9wICsgKGUuYm90dG9tIC0gZS50b3ApIC8gMikgfSByZXR1cm4gYiB9XHJcbiAgICAgICAgfVxyXG4gICAgfSksIGFcclxufSk7IiwiLyohXHJcbiAqIGpRdWVyeSB0aHJvdHRsZSAvIGRlYm91bmNlIC0gdjEuMSAtIDMvNy8yMDEwXHJcbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vcHJvamVjdHMvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlLXBsdWdpbi9cclxuICogXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hblxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cclxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9hYm91dC9saWNlbnNlL1xyXG4gKi9cclxuXHJcbi8vIFNjcmlwdDogalF1ZXJ5IHRocm90dGxlIC8gZGVib3VuY2U6IFNvbWV0aW1lcywgbGVzcyBpcyBtb3JlIVxyXG4vL1xyXG4vLyAqVmVyc2lvbjogMS4xLCBMYXN0IHVwZGF0ZWQ6IDMvNy8yMDEwKlxyXG4vLyBcclxuLy8gUHJvamVjdCBIb21lIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UtcGx1Z2luL1xyXG4vLyBHaXRIdWIgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlL1xyXG4vLyBTb3VyY2UgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLXRocm90dGxlLWRlYm91bmNlLmpzXHJcbi8vIChNaW5pZmllZCkgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvcmF3L21hc3Rlci9qcXVlcnkuYmEtdGhyb3R0bGUtZGVib3VuY2UubWluLmpzICgwLjdrYilcclxuLy8gXHJcbi8vIEFib3V0OiBMaWNlbnNlXHJcbi8vIFxyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW4sXHJcbi8vIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxyXG4vLyBodHRwOi8vYmVuYWxtYW4uY29tL2Fib3V0L2xpY2Vuc2UvXHJcbi8vIFxyXG4vLyBBYm91dDogRXhhbXBsZXNcclxuLy8gXHJcbi8vIFRoZXNlIHdvcmtpbmcgZXhhbXBsZXMsIGNvbXBsZXRlIHdpdGggZnVsbHkgY29tbWVudGVkIGNvZGUsIGlsbHVzdHJhdGUgYSBmZXdcclxuLy8gd2F5cyBpbiB3aGljaCB0aGlzIHBsdWdpbiBjYW4gYmUgdXNlZC5cclxuLy8gXHJcbi8vIFRocm90dGxlIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS9leGFtcGxlcy90aHJvdHRsZS9cclxuLy8gRGVib3VuY2UgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlL2V4YW1wbGVzL2RlYm91bmNlL1xyXG4vLyBcclxuLy8gQWJvdXQ6IFN1cHBvcnQgYW5kIFRlc3RpbmdcclxuLy8gXHJcbi8vIEluZm9ybWF0aW9uIGFib3V0IHdoYXQgdmVyc2lvbiBvciB2ZXJzaW9ucyBvZiBqUXVlcnkgdGhpcyBwbHVnaW4gaGFzIGJlZW5cclxuLy8gdGVzdGVkIHdpdGgsIHdoYXQgYnJvd3NlcnMgaXQgaGFzIGJlZW4gdGVzdGVkIGluLCBhbmQgd2hlcmUgdGhlIHVuaXQgdGVzdHNcclxuLy8gcmVzaWRlIChzbyB5b3UgY2FuIHRlc3QgaXQgeW91cnNlbGYpLlxyXG4vLyBcclxuLy8galF1ZXJ5IFZlcnNpb25zIC0gbm9uZSwgMS4zLjIsIDEuNC4yXHJcbi8vIEJyb3dzZXJzIFRlc3RlZCAtIEludGVybmV0IEV4cGxvcmVyIDYtOCwgRmlyZWZveCAyLTMuNiwgU2FmYXJpIDMtNCwgQ2hyb21lIDQtNSwgT3BlcmEgOS42LTEwLjEuXHJcbi8vIFVuaXQgVGVzdHMgICAgICAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvdW5pdC9cclxuLy8gXHJcbi8vIEFib3V0OiBSZWxlYXNlIEhpc3RvcnlcclxuLy8gXHJcbi8vIDEuMSAtICgzLzcvMjAxMCkgRml4ZWQgYSBidWcgaW4gPGpRdWVyeS50aHJvdHRsZT4gd2hlcmUgdHJhaWxpbmcgY2FsbGJhY2tzXHJcbi8vICAgICAgIGV4ZWN1dGVkIGxhdGVyIHRoYW4gdGhleSBzaG91bGQuIFJld29ya2VkIGEgZmFpciBhbW91bnQgb2YgaW50ZXJuYWxcclxuLy8gICAgICAgbG9naWMgYXMgd2VsbC5cclxuLy8gMS4wIC0gKDMvNi8yMDEwKSBJbml0aWFsIHJlbGVhc2UgYXMgYSBzdGFuZC1hbG9uZSBwcm9qZWN0LiBNaWdyYXRlZCBvdmVyXHJcbi8vICAgICAgIGZyb20ganF1ZXJ5LW1pc2MgcmVwbyB2MC40IHRvIGpxdWVyeS10aHJvdHRsZSByZXBvIHYxLjAsIGFkZGVkIHRoZVxyXG4vLyAgICAgICBub190cmFpbGluZyB0aHJvdHRsZSBwYXJhbWV0ZXIgYW5kIGRlYm91bmNlIGZ1bmN0aW9uYWxpdHkuXHJcbi8vIFxyXG4vLyBUb3BpYzogTm90ZSBmb3Igbm9uLWpRdWVyeSB1c2Vyc1xyXG4vLyBcclxuLy8galF1ZXJ5IGlzbid0IGFjdHVhbGx5IHJlcXVpcmVkIGZvciB0aGlzIHBsdWdpbiwgYmVjYXVzZSBub3RoaW5nIGludGVybmFsXHJcbi8vIHVzZXMgYW55IGpRdWVyeSBtZXRob2RzIG9yIHByb3BlcnRpZXMuIGpRdWVyeSBpcyBqdXN0IHVzZWQgYXMgYSBuYW1lc3BhY2VcclxuLy8gdW5kZXIgd2hpY2ggdGhlc2UgbWV0aG9kcyBjYW4gZXhpc3QuXHJcbi8vIFxyXG4vLyBTaW5jZSBqUXVlcnkgaXNuJ3QgYWN0dWFsbHkgcmVxdWlyZWQgZm9yIHRoaXMgcGx1Z2luLCBpZiBqUXVlcnkgZG9lc24ndCBleGlzdFxyXG4vLyB3aGVuIHRoaXMgcGx1Z2luIGlzIGxvYWRlZCwgdGhlIG1ldGhvZCBkZXNjcmliZWQgYmVsb3cgd2lsbCBiZSBjcmVhdGVkIGluXHJcbi8vIHRoZSBgQ293Ym95YCBuYW1lc3BhY2UuIFVzYWdlIHdpbGwgYmUgZXhhY3RseSB0aGUgc2FtZSwgYnV0IGluc3RlYWQgb2ZcclxuLy8gJC5tZXRob2QoKSBvciBqUXVlcnkubWV0aG9kKCksIHlvdSdsbCBuZWVkIHRvIHVzZSBDb3dib3kubWV0aG9kKCkuXHJcblxyXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XHJcbiAgICAnJDpub211bmdlJzsgLy8gVXNlZCBieSBZVUkgY29tcHJlc3Nvci5cclxuXHJcbiAgICAvLyBTaW5jZSBqUXVlcnkgcmVhbGx5IGlzbid0IHJlcXVpcmVkIGZvciB0aGlzIHBsdWdpbiwgdXNlIGBqUXVlcnlgIGFzIHRoZVxyXG4gICAgLy8gbmFtZXNwYWNlIG9ubHkgaWYgaXQgYWxyZWFkeSBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIGBDb3dib3lgIG5hbWVzcGFjZSxcclxuICAgIC8vIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cclxuICAgIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuQ293Ym95IHx8ICh3aW5kb3cuQ293Ym95ID0ge30pLFxyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgcmVmZXJlbmNlLlxyXG4gICAgICAgIGpxX3Rocm90dGxlO1xyXG5cclxuICAgIC8vIE1ldGhvZDogalF1ZXJ5LnRocm90dGxlXHJcbiAgICAvLyBcclxuICAgIC8vIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xyXG4gICAgLy8gZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLiBJZiB5b3Ugd2FudCB0b1xyXG4gICAgLy8gcmF0ZS1saW1pdCBleGVjdXRpb24gb2YgYSBmdW5jdGlvbiB0byBhIHNpbmdsZSB0aW1lLCBzZWUgdGhlXHJcbiAgICAvLyA8alF1ZXJ5LmRlYm91bmNlPiBtZXRob2QuXHJcbiAgICAvLyBcclxuICAgIC8vIEluIHRoaXMgdmlzdWFsaXphdGlvbiwgfCBpcyBhIHRocm90dGxlZC1mdW5jdGlvbiBjYWxsIGFuZCBYIGlzIHRoZSBhY3R1YWxcclxuICAgIC8vIGNhbGxiYWNrIGV4ZWN1dGlvbjpcclxuICAgIC8vIFxyXG4gICAgLy8gPiBUaHJvdHRsZWQgd2l0aCBgbm9fdHJhaWxpbmdgIHNwZWNpZmllZCBhcyBmYWxzZSBvciB1bnNwZWNpZmllZDpcclxuICAgIC8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcclxuICAgIC8vID4gWCAgICBYICAgIFggICAgWCAgICBYICAgIFggICAgICAgIFggICAgWCAgICBYICAgIFggICAgWCAgICBYXHJcbiAgICAvLyA+IFxyXG4gICAgLy8gPiBUaHJvdHRsZWQgd2l0aCBgbm9fdHJhaWxpbmdgIHNwZWNpZmllZCBhcyB0cnVlOlxyXG4gICAgLy8gPiB8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8IChwYXVzZSkgfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fFxyXG4gICAgLy8gPiBYICAgIFggICAgWCAgICBYICAgIFggICAgICAgICAgICAgWCAgICBYICAgIFggICAgWCAgICBYXHJcbiAgICAvLyBcclxuICAgIC8vIFVzYWdlOlxyXG4gICAgLy8gXHJcbiAgICAvLyA+IHZhciB0aHJvdHRsZWQgPSBqUXVlcnkudGhyb3R0bGUoIGRlbGF5LCBbIG5vX3RyYWlsaW5nLCBdIGNhbGxiYWNrICk7XHJcbiAgICAvLyA+IFxyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIHRocm90dGxlZCApO1xyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgdGhyb3R0bGVkICk7XHJcbiAgICAvLyBcclxuICAgIC8vIFRoaXMgYWxzbyB3b3JrcyBpbiBqUXVlcnkgMS40KzpcclxuICAgIC8vIFxyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIGpRdWVyeS50aHJvdHRsZSggZGVsYXksIFsgbm9fdHJhaWxpbmcsIF0gY2FsbGJhY2sgKSApO1xyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgY2FsbGJhY2sgKTtcclxuICAgIC8vIFxyXG4gICAgLy8gQXJndW1lbnRzOlxyXG4gICAgLy8gXHJcbiAgICAvLyAgZGVsYXkgLSAoTnVtYmVyKSBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudFxyXG4gICAgLy8gICAgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXHJcbiAgICAvLyAgbm9fdHJhaWxpbmcgLSAoQm9vbGVhbikgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub190cmFpbGluZyBpc1xyXG4gICAgLy8gICAgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBvbmx5IGV4ZWN1dGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMgd2hpbGUgdGhlXHJcbiAgICAvLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub190cmFpbGluZyBpcyBmYWxzZSBvclxyXG4gICAgLy8gICAgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25lIGZpbmFsIHRpbWUgYWZ0ZXIgdGhlIGxhc3RcclxuICAgIC8vICAgIHRocm90dGxlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW5cclxuICAgIC8vICAgIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxyXG4gICAgLy8gIGNhbGxiYWNrIC0gKEZ1bmN0aW9uKSBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy5cclxuICAgIC8vICAgIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLCB0b1xyXG4gICAgLy8gICAgYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXHJcbiAgICAvLyBcclxuICAgIC8vIFJldHVybnM6XHJcbiAgICAvLyBcclxuICAgIC8vICAoRnVuY3Rpb24pIEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxyXG5cclxuICAgICQudGhyb3R0bGUgPSBqcV90aHJvdHRsZSA9IGZ1bmN0aW9uIChkZWxheSwgbm9fdHJhaWxpbmcsIGNhbGxiYWNrLCBkZWJvdW5jZV9tb2RlKSB7XHJcbiAgICAgICAgLy8gQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcclxuICAgICAgICAvLyBgY2FsbGJhY2tgIGlzIGV4ZWN1dGVkIGF0IHRoZSBwcm9wZXIgdGltZXMgaW4gYHRocm90dGxlYCBhbmQgYGVuZGBcclxuICAgICAgICAvLyBkZWJvdW5jZSBtb2Rlcy5cclxuICAgICAgICB2YXIgdGltZW91dF9pZCxcclxuXHJcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdGltZSBgY2FsbGJhY2tgIHdhcyBleGVjdXRlZC5cclxuICAgICAgICAgICAgbGFzdF9leGVjID0gMDtcclxuXHJcbiAgICAgICAgLy8gYG5vX3RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cclxuICAgICAgICBpZiAodHlwZW9mIG5vX3RyYWlsaW5nICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgZGVib3VuY2VfbW9kZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vX3RyYWlsaW5nO1xyXG4gICAgICAgICAgICBub190cmFpbGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcclxuICAgICAgICAvLyBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxyXG4gICAgICAgIC8vIGlzIGV4ZWN1dGVkLlxyXG4gICAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQgPSArbmV3IERhdGUoKSAtIGxhc3RfZXhlYyxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RfZXhlY2AgdGltZXN0YW1wLlxyXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjKCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdF9leGVjID0gK25ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBhcmdzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGBkZWJvdW5jZV9tb2RlYCBpcyB0cnVlIChhdF9iZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXHJcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dF9pZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZWJvdW5jZV9tb2RlICYmICF0aW1lb3V0X2lkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGBkZWJvdW5jZV9tb2RlYCBpcyB0cnVlIChhdF9iZWdpbiksIGV4ZWN1dGUgYGNhbGxiYWNrYC5cclxuICAgICAgICAgICAgICAgIGV4ZWMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXQuXHJcbiAgICAgICAgICAgIHRpbWVvdXRfaWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRfaWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlYm91bmNlX21vZGUgPT09IHVuZGVmaW5lZCAmJiBlbGFwc2VkID4gZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxyXG4gICAgICAgICAgICAgICAgLy8gYGNhbGxiYWNrYC5cclxuICAgICAgICAgICAgICAgIGV4ZWMoKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9fdHJhaWxpbmcgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cclxuICAgICAgICAgICAgICAgIC8vIGV4Y2VlZGVkLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYGRlbGF5YCBtcyBhZnRlciBtb3N0XHJcbiAgICAgICAgICAgICAgICAvLyByZWNlbnQgZXhlY3V0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBgZGVib3VuY2VfbW9kZWAgaXMgdHJ1ZSAoYXRfYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcclxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIGBkZWxheWAgbXMuXHJcbiAgICAgICAgICAgICAgICAvLyBcclxuICAgICAgICAgICAgICAgIC8vIElmIGBkZWJvdW5jZV9tb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxyXG4gICAgICAgICAgICAgICAgdGltZW91dF9pZCA9IHNldFRpbWVvdXQoZGVib3VuY2VfbW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VfbW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBndWlkIG9mIGB3cmFwcGVyYCBmdW5jdGlvbiB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBjYWxsYmFjaywgc29cclxuICAgICAgICAvLyBpdCBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgMS40KyAudW5iaW5kIG9yIC5kaWUgYnkgdXNpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgLy8gY2FsbGJhY2sgYXMgYSByZWZlcmVuY2UuXHJcbiAgICAgICAgaWYgKCQuZ3VpZCkge1xyXG4gICAgICAgICAgICB3cmFwcGVyLmd1aWQgPSBjYWxsYmFjay5ndWlkID0gY2FsbGJhY2suZ3VpZCB8fCAkLmd1aWQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cclxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTWV0aG9kOiBqUXVlcnkuZGVib3VuY2VcclxuICAgIC8vIFxyXG4gICAgLy8gRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxyXG4gICAgLy8gZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXHJcbiAgICAvLyB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLiBJZiB5b3Ugd2FudCB0b1xyXG4gICAgLy8gc2ltcGx5IHJhdGUtbGltaXQgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24sIHNlZSB0aGUgPGpRdWVyeS50aHJvdHRsZT5cclxuICAgIC8vIG1ldGhvZC5cclxuICAgIC8vIFxyXG4gICAgLy8gSW4gdGhpcyB2aXN1YWxpemF0aW9uLCB8IGlzIGEgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwgYW5kIFggaXMgdGhlIGFjdHVhbFxyXG4gICAgLy8gY2FsbGJhY2sgZXhlY3V0aW9uOlxyXG4gICAgLy8gXHJcbiAgICAvLyA+IERlYm91bmNlZCB3aXRoIGBhdF9iZWdpbmAgc3BlY2lmaWVkIGFzIGZhbHNlIG9yIHVuc3BlY2lmaWVkOlxyXG4gICAgLy8gPiB8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8IChwYXVzZSkgfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fFxyXG4gICAgLy8gPiAgICAgICAgICAgICAgICAgICAgICAgICAgWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhcclxuICAgIC8vID4gXHJcbiAgICAvLyA+IERlYm91bmNlZCB3aXRoIGBhdF9iZWdpbmAgc3BlY2lmaWVkIGFzIHRydWU6XHJcbiAgICAvLyA+IHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHwgKHBhdXNlKSB8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8XHJcbiAgICAvLyA+IFggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYXHJcbiAgICAvLyBcclxuICAgIC8vIFVzYWdlOlxyXG4gICAgLy8gXHJcbiAgICAvLyA+IHZhciBkZWJvdW5jZWQgPSBqUXVlcnkuZGVib3VuY2UoIGRlbGF5LCBbIGF0X2JlZ2luLCBdIGNhbGxiYWNrICk7XHJcbiAgICAvLyA+IFxyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIGRlYm91bmNlZCApO1xyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgZGVib3VuY2VkICk7XHJcbiAgICAvLyBcclxuICAgIC8vIFRoaXMgYWxzbyB3b3JrcyBpbiBqUXVlcnkgMS40KzpcclxuICAgIC8vIFxyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIGpRdWVyeS5kZWJvdW5jZSggZGVsYXksIFsgYXRfYmVnaW4sIF0gY2FsbGJhY2sgKSApO1xyXG4gICAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgY2FsbGJhY2sgKTtcclxuICAgIC8vIFxyXG4gICAgLy8gQXJndW1lbnRzOlxyXG4gICAgLy8gXHJcbiAgICAvLyAgZGVsYXkgLSAoTnVtYmVyKSBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudFxyXG4gICAgLy8gICAgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXHJcbiAgICAvLyAgYXRfYmVnaW4gLSAoQm9vbGVhbikgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBhdF9iZWdpbiBpcyBmYWxzZSBvclxyXG4gICAgLy8gICAgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kcyBhZnRlclxyXG4gICAgLy8gICAgdGhlIGxhc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIElmIGF0X2JlZ2luIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgYmVcclxuICAgIC8vICAgIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlXHJcbiAgICAvLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZVxyXG4gICAgLy8gICAgaW50ZXJuYWwgY291bnRlciBpcyByZXNldClcclxuICAgIC8vICBjYWxsYmFjayAtIChGdW5jdGlvbikgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuXHJcbiAgICAvLyAgICBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcywgdG9cclxuICAgIC8vICAgIGBjYWxsYmFja2Agd2hlbiB0aGUgZGVib3VuY2VkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxyXG4gICAgLy8gXHJcbiAgICAvLyBSZXR1cm5zOlxyXG4gICAgLy8gXHJcbiAgICAvLyAgKEZ1bmN0aW9uKSBBIG5ldywgZGVib3VuY2VkLCBmdW5jdGlvbi5cclxuXHJcbiAgICAkLmRlYm91bmNlID0gZnVuY3Rpb24gKGRlbGF5LCBhdF9iZWdpbiwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGpxX3Rocm90dGxlKGRlbGF5LCBhdF9iZWdpbiwgZmFsc2UpXHJcbiAgICAgICAgICAgIDoganFfdGhyb3R0bGUoZGVsYXksIGNhbGxiYWNrLCBhdF9iZWdpbiAhPT0gZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbn0pKHdpbmRvdyk7IiwiKGZ1bmN0aW9uICgkKSB7XHJcblxyXG4gICAgJC5mbi5zaHVmZmxlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgYWxsRWxlbXMgPSB0aGlzLmdldCgpLFxyXG4gICAgICAgICAgICBnZXRSYW5kb20gPSBmdW5jdGlvbiAobWF4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2h1ZmZsZWQgPSAkLm1hcChhbGxFbGVtcywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmRvbSA9IGdldFJhbmRvbShhbGxFbGVtcy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRFbCA9ICQoYWxsRWxlbXNbcmFuZG9tXSkuY2xvbmUodHJ1ZSlbMF07XHJcbiAgICAgICAgICAgICAgICBhbGxFbGVtcy5zcGxpY2UocmFuZG9tLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5kRWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aCgkKHNodWZmbGVkW2ldKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiAkKHNodWZmbGVkKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSkoalF1ZXJ5KTsiLCIvKiFcclxuICogQm93c2VyIC0gYSBicm93c2VyIGRldGVjdG9yXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm93c2VyXHJcbiAqIE1JVCBMaWNlbnNlIHwgKGMpIER1c3RpbiBEaWF6IDIwMTVcclxuICovXHJcbiAgXHJcbiFmdW5jdGlvbiAocm9vdCwgbmFtZSwgZGVmaW5pdGlvbikge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKG5hbWUsIGRlZmluaXRpb24pXHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3dbbmFtZV0gPSBkZWZpbml0aW9uKClcclxuICAgIH1cclxufSh0aGlzLCAnYm93c2VyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgICogU2VlIHVzZXJhZ2VudHMuanMgZm9yIGV4YW1wbGVzIG9mIG5hdmlnYXRvci51c2VyQWdlbnRcclxuICAgICAgKi9cclxuXHJcbiAgICB2YXIgdCA9IHRydWVcclxuXHJcbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Rmlyc3RNYXRjaChyZWdleCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsxXSkgfHwgJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRTZWNvbmRNYXRjaChyZWdleCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSkgfHwgJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW9zZGV2aWNlID0gZ2V0Rmlyc3RNYXRjaCgvKGlwb2R8aXBob25lfGlwYWQpL2kpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgLCBsaWtlQW5kcm9pZCA9IC9saWtlIGFuZHJvaWQvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIGFuZHJvaWQgPSAhbGlrZUFuZHJvaWQgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIG5leHVzTW9iaWxlID0gL25leHVzXFxzKlswLTZdXFxzKi9pLnRlc3QodWEpXHJcbiAgICAgICAgICAgICwgbmV4dXNUYWJsZXQgPSAhbmV4dXNNb2JpbGUgJiYgL25leHVzXFxzKlswLTldKy9pLnRlc3QodWEpXHJcbiAgICAgICAgICAgICwgY2hyb21lb3MgPSAvQ3JPUy8udGVzdCh1YSlcclxuICAgICAgICAgICAgLCBzaWxrID0gL3NpbGsvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIHNhaWxmaXNoID0gL3NhaWxmaXNoL2kudGVzdCh1YSlcclxuICAgICAgICAgICAgLCB0aXplbiA9IC90aXplbi9pLnRlc3QodWEpXHJcbiAgICAgICAgICAgICwgd2Vib3MgPSAvKHdlYnxocHcpKG98MClzL2kudGVzdCh1YSlcclxuICAgICAgICAgICAgLCB3aW5kb3dzcGhvbmUgPSAvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpXHJcbiAgICAgICAgICAgICwgc2Ftc3VuZ0Jyb3dzZXIgPSAvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIHdpbmRvd3MgPSAhd2luZG93c3Bob25lICYmIC93aW5kb3dzL2kudGVzdCh1YSlcclxuICAgICAgICAgICAgLCBtYWMgPSAhaW9zZGV2aWNlICYmICFzaWxrICYmIC9tYWNpbnRvc2gvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIGxpbnV4ID0gIWFuZHJvaWQgJiYgIXNhaWxmaXNoICYmICF0aXplbiAmJiAhd2Vib3MgJiYgL2xpbnV4L2kudGVzdCh1YSlcclxuICAgICAgICAgICAgLCBlZGdlVmVyc2lvbiA9IGdldFNlY29uZE1hdGNoKC9lZGcoW2VhXXxpb3MpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICAsIHZlcnNpb25JZGVudGlmaWVyID0gZ2V0Rmlyc3RNYXRjaCgvdmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgLCB0YWJsZXQgPSAvdGFibGV0L2kudGVzdCh1YSkgJiYgIS90YWJsZXQgcGMvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIG1vYmlsZSA9ICF0YWJsZXQgJiYgL1teLV1tb2JpL2kudGVzdCh1YSlcclxuICAgICAgICAgICAgLCB4Ym94ID0gL3hib3gvaS50ZXN0KHVhKVxyXG4gICAgICAgICAgICAsIHJlc3VsdFxyXG5cclxuICAgICAgICBpZiAoL29wZXJhL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgLy8gIGFuIG9sZCBPcGVyYVxyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnT3BlcmEnXHJcbiAgICAgICAgICAgICAgICAsIG9wZXJhOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/Om9wZXJhfG9wcnxvcGlvcylbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoL29wclxcL3xvcGlvcy9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIC8vIGEgbmV3IE9wZXJhXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdPcGVyYSdcclxuICAgICAgICAgICAgICAgICwgb3BlcmE6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9TYW1zdW5nQnJvd3Nlci9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkJ1xyXG4gICAgICAgICAgICAgICAgLCBzYW1zdW5nQnJvd3NlcjogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpTYW1zdW5nQnJvd3NlcilbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvV2hhbGUvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnTkFWRVIgV2hhbGUgYnJvd3NlcidcclxuICAgICAgICAgICAgICAgICwgd2hhbGU6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvTVpCcm93c2VyL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ01aIEJyb3dzZXInXHJcbiAgICAgICAgICAgICAgICAsIG16YnJvd3NlcjogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvY29hc3QvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnT3BlcmEgQ29hc3QnXHJcbiAgICAgICAgICAgICAgICAsIGNvYXN0OiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9mb2N1cy9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdGb2N1cydcclxuICAgICAgICAgICAgICAgICwgZm9jdXM6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgveWFicm93c2VyL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1lhbmRleCBCcm93c2VyJ1xyXG4gICAgICAgICAgICAgICAgLCB5YW5kZXhicm93c2VyOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvdWNicm93c2VyL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1VDIEJyb3dzZXInXHJcbiAgICAgICAgICAgICAgICAsIHVjYnJvd3NlcjogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvbXhpb3MvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWF4dGhvbidcclxuICAgICAgICAgICAgICAgICwgbWF4dGhvbjogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpteGlvcylbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9lcGlwaGFueS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdFcGlwaGFueSdcclxuICAgICAgICAgICAgICAgICwgZXBpcGhhbnk6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvcHVmZmluL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1B1ZmZpbidcclxuICAgICAgICAgICAgICAgICwgcHVmZmluOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9zbGVpcG5pci9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdTbGVpcG5pcidcclxuICAgICAgICAgICAgICAgICwgc2xlaXBuaXI6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvay1tZWxlb24vaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnSy1NZWxlb24nXHJcbiAgICAgICAgICAgICAgICAsIGtNZWxlb246IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3aW5kb3dzcGhvbmUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1dpbmRvd3MgUGhvbmUnXHJcbiAgICAgICAgICAgICAgICAsIG9zbmFtZTogJ1dpbmRvd3MgUGhvbmUnXHJcbiAgICAgICAgICAgICAgICAsIHdpbmRvd3NwaG9uZTogdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlZGdlVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1zZWRnZSA9IHRcclxuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZWRnZVZlcnNpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5tc2llID0gdFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9pZW1vYmlsZVxcLyhcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvbXNpZXx0cmlkZW50L2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ0ludGVybmV0IEV4cGxvcmVyJ1xyXG4gICAgICAgICAgICAgICAgLCBtc2llOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNocm9tZW9zKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdDaHJvbWUnXHJcbiAgICAgICAgICAgICAgICAsIG9zbmFtZTogJ0Nocm9tZSBPUydcclxuICAgICAgICAgICAgICAgICwgY2hyb21lb3M6IHRcclxuICAgICAgICAgICAgICAgICwgY2hyb21lQm9vazogdFxyXG4gICAgICAgICAgICAgICAgLCBjaHJvbWU6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICgvZWRnKFtlYV18aW9zKS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNyb3NvZnQgRWRnZSdcclxuICAgICAgICAgICAgICAgICwgbXNlZGdlOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGVkZ2VWZXJzaW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL3ZpdmFsZGkvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnVml2YWxkaSdcclxuICAgICAgICAgICAgICAgICwgdml2YWxkaTogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNhaWxmaXNoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdTYWlsZmlzaCdcclxuICAgICAgICAgICAgICAgICwgb3NuYW1lOiAnU2FpbGZpc2ggT1MnXHJcbiAgICAgICAgICAgICAgICAsIHNhaWxmaXNoOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NhaWxmaXNoXFxzP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL3NlYW1vbmtleVxcLy9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdTZWFNb25rZXknXHJcbiAgICAgICAgICAgICAgICAsIHNlYW1vbmtleTogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ0ZpcmVmb3gnXHJcbiAgICAgICAgICAgICAgICAsIGZpcmVmb3g6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpWyBcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgvXFwoKG1vYmlsZXx0YWJsZXQpO1teXFwpXSpydjpbXFxkXFwuXStcXCkvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpcmVmb3hvcyA9IHRcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5vc25hbWUgPSAnRmlyZWZveCBPUydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaWxrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbWF6b24gU2lsaydcclxuICAgICAgICAgICAgICAgICwgc2lsazogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9waGFudG9tL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1BoYW50b21KUydcclxuICAgICAgICAgICAgICAgICwgcGhhbnRvbTogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL3NsaW1lcmpzL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1NsaW1lckpTJ1xyXG4gICAgICAgICAgICAgICAgLCBzbGltZXI6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL2JsYWNrYmVycnl8XFxiYmJcXGQrL2kudGVzdCh1YSkgfHwgL3JpbVxcc3RhYmxldC9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdCbGFja0JlcnJ5J1xyXG4gICAgICAgICAgICAgICAgLCBvc25hbWU6ICdCbGFja0JlcnJ5IE9TJ1xyXG4gICAgICAgICAgICAgICAgLCBibGFja2JlcnJ5OiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlbXFxkXStcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2Vib3MpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1dlYk9TJ1xyXG4gICAgICAgICAgICAgICAgLCBvc25hbWU6ICdXZWJPUydcclxuICAgICAgICAgICAgICAgICwgd2Vib3M6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC90b3VjaHBhZFxcLy9pLnRlc3QodWEpICYmIChyZXN1bHQudG91Y2hwYWQgPSB0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvYmFkYS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdCYWRhJ1xyXG4gICAgICAgICAgICAgICAgLCBvc25hbWU6ICdCYWRhJ1xyXG4gICAgICAgICAgICAgICAgLCBiYWRhOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL2RvbGZpblxcLyhcXGQrKFxcLlxcZCspPykvaSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGl6ZW4pIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1RpemVuJ1xyXG4gICAgICAgICAgICAgICAgLCBvc25hbWU6ICdUaXplbidcclxuICAgICAgICAgICAgICAgICwgdGl6ZW46IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvcXVwemlsbGEvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnUXVwWmlsbGEnXHJcbiAgICAgICAgICAgICAgICAsIHF1cHppbGxhOiB0XHJcbiAgICAgICAgICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnF1cHppbGxhKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL2Nocm9taXVtL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ0Nocm9taXVtJ1xyXG4gICAgICAgICAgICAgICAgLCBjaHJvbWl1bTogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9jaHJvbWV8Y3Jpb3N8Y3Jtby9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdDaHJvbWUnXHJcbiAgICAgICAgICAgICAgICAsIGNocm9tZTogdFxyXG4gICAgICAgICAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYW5kcm9pZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5kcm9pZCdcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvc2FmYXJpfGFwcGxld2Via2l0L2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ1NhZmFyaSdcclxuICAgICAgICAgICAgICAgICwgc2FmYXJpOiB0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlcnNpb25JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW9zZGV2aWNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGlvc2RldmljZSA9PSAnaXBob25lJyA/ICdpUGhvbmUnIDogaW9zZGV2aWNlID09ICdpcGFkJyA/ICdpUGFkJyA6ICdpUG9kJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC9nb29nbGVib3QvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnR29vZ2xlYm90J1xyXG4gICAgICAgICAgICAgICAgLCBnb29nbGVib3Q6IHRcclxuICAgICAgICAgICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGdldEZpcnN0TWF0Y2goL14oLiopXFwvKC4qKSAvKSxcclxuICAgICAgICAgICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcLyguKikgLylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCB3ZWJraXQgb3IgZ2Vja28gZmxhZyBmb3IgYnJvd3NlcnMgYmFzZWQgb24gdGhlc2UgZW5naW5lc1xyXG4gICAgICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICBpZiAoLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkJsaW5rXCJcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ibGluayA9IHRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJXZWJraXRcIlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LndlYmtpdCA9IHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uICYmIHZlcnNpb25JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHQub3BlcmEgJiYgL2dlY2tvXFwvL2kudGVzdCh1YSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkdlY2tvXCJcclxuICAgICAgICAgICAgcmVzdWx0LmdlY2tvID0gdFxyXG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHJlc3VsdC52ZXJzaW9uIHx8IGdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IE9TIGZsYWdzIGZvciBwbGF0Zm9ybXMgdGhhdCBoYXZlIG11bHRpcGxlIGJyb3dzZXJzXHJcbiAgICAgICAgaWYgKCFyZXN1bHQud2luZG93c3Bob25lICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYW5kcm9pZCA9IHRcclxuICAgICAgICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdBbmRyb2lkJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdC53aW5kb3dzcGhvbmUgJiYgaW9zZGV2aWNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpb3NkZXZpY2VdID0gdFxyXG4gICAgICAgICAgICByZXN1bHQuaW9zID0gdFxyXG4gICAgICAgICAgICByZXN1bHQub3NuYW1lID0gJ2lPUydcclxuICAgICAgICB9IGVsc2UgaWYgKG1hYykge1xyXG4gICAgICAgICAgICByZXN1bHQubWFjID0gdFxyXG4gICAgICAgICAgICByZXN1bHQub3NuYW1lID0gJ21hY09TJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeGJveCkge1xyXG4gICAgICAgICAgICByZXN1bHQueGJveCA9IHRcclxuICAgICAgICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdYYm94J1xyXG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93cykge1xyXG4gICAgICAgICAgICByZXN1bHQud2luZG93cyA9IHRcclxuICAgICAgICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdXaW5kb3dzJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGludXgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmxpbnV4ID0gdFxyXG4gICAgICAgICAgICByZXN1bHQub3NuYW1lID0gJ0xpbnV4J1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93c1ZlcnNpb24ocykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ05UJzogcmV0dXJuICdOVCdcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1hQJzogcmV0dXJuICdYUCdcclxuICAgICAgICAgICAgICAgIGNhc2UgJ05UIDUuMCc6IHJldHVybiAnMjAwMCdcclxuICAgICAgICAgICAgICAgIGNhc2UgJ05UIDUuMSc6IHJldHVybiAnWFAnXHJcbiAgICAgICAgICAgICAgICBjYXNlICdOVCA1LjInOiByZXR1cm4gJzIwMDMnXHJcbiAgICAgICAgICAgICAgICBjYXNlICdOVCA2LjAnOiByZXR1cm4gJ1Zpc3RhJ1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTlQgNi4xJzogcmV0dXJuICc3J1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTlQgNi4yJzogcmV0dXJuICc4J1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTlQgNi4zJzogcmV0dXJuICc4LjEnXHJcbiAgICAgICAgICAgICAgICBjYXNlICdOVCAxMC4wJzogcmV0dXJuICcxMCdcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT1MgdmVyc2lvbiBleHRyYWN0aW9uXHJcbiAgICAgICAgdmFyIG9zVmVyc2lvbiA9ICcnO1xyXG4gICAgICAgIGlmIChyZXN1bHQud2luZG93cykge1xyXG4gICAgICAgICAgICBvc1ZlcnNpb24gPSBnZXRXaW5kb3dzVmVyc2lvbihnZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pKSlcclxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcclxuICAgICAgICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQubWFjKSB7XHJcbiAgICAgICAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL01hYyBPUyBYIChcXGQrKFtfXFwuXFxzXVxcZCspKikvaSk7XHJcbiAgICAgICAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xyXG4gICAgICAgICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSk7XHJcbiAgICAgICAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuZHJvaWQpIHtcclxuICAgICAgICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFwvLV0oXFxkKyhcXC5cXGQrKSopL2kpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XHJcbiAgICAgICAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpb3NcXC8oXFxkKyhcXC5cXGQrKSopL2kpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmJsYWNrYmVycnkpIHtcclxuICAgICAgICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvcmltXFxzdGFibGV0XFxzb3NcXHMoXFxkKyhcXC5cXGQrKSopL2kpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmJhZGEpIHtcclxuICAgICAgICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQudGl6ZW4pIHtcclxuICAgICAgICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFwvXFxzXShcXGQrKFxcLlxcZCspKikvaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvc1ZlcnNpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm9zdmVyc2lvbiA9IG9zVmVyc2lvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cclxuICAgICAgICB2YXIgb3NNYWpvclZlcnNpb24gPSAhcmVzdWx0LndpbmRvd3MgJiYgb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0YWJsZXRcclxuICAgICAgICAgICAgfHwgbmV4dXNUYWJsZXRcclxuICAgICAgICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGFkJ1xyXG4gICAgICAgICAgICB8fCAoYW5kcm9pZCAmJiAob3NNYWpvclZlcnNpb24gPT0gMyB8fCAob3NNYWpvclZlcnNpb24gPj0gNCAmJiAhbW9iaWxlKSkpXHJcbiAgICAgICAgICAgIHx8IHJlc3VsdC5zaWxrXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50YWJsZXQgPSB0XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgbW9iaWxlXHJcbiAgICAgICAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBob25lJ1xyXG4gICAgICAgICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwb2QnXHJcbiAgICAgICAgICAgIHx8IGFuZHJvaWRcclxuICAgICAgICAgICAgfHwgbmV4dXNNb2JpbGVcclxuICAgICAgICAgICAgfHwgcmVzdWx0LmJsYWNrYmVycnlcclxuICAgICAgICAgICAgfHwgcmVzdWx0LndlYm9zXHJcbiAgICAgICAgICAgIHx8IHJlc3VsdC5iYWRhXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5tb2JpbGUgPSB0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XHJcbiAgICAgICAgLy8gaHR0cDovL2RldmVsb3Blci55YWhvby5jb20veXVpL2FydGljbGVzL2dic1xyXG4gICAgICAgIGlmIChyZXN1bHQubXNlZGdlIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC55YW5kZXhicm93c2VyICYmIHJlc3VsdC52ZXJzaW9uID49IDE1KSB8fFxyXG4gICAgICAgICAgICAocmVzdWx0LnZpdmFsZGkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMS4wKSB8fFxyXG4gICAgICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5zYW1zdW5nQnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSA0KSB8fFxyXG4gICAgICAgICAgICAocmVzdWx0LndoYWxlICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICcxLjAnXSkgPT09IDEpIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQubXpicm93c2VyICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICc2LjAnXSkgPT09IDEpIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQuZm9jdXMgJiYgY29tcGFyZVZlcnNpb25zKFtyZXN1bHQudmVyc2lvbiwgJzEuMCddKSA9PT0gMSkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uID49IDIwLjApIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQuc2FmYXJpICYmIHJlc3VsdC52ZXJzaW9uID49IDYpIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA+PSA2KSB8fFxyXG4gICAgICAgICAgICAocmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSlcclxuICAgICAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzdWx0LmEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPCAxMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uIDwgMjAuMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPCA2KSB8fFxyXG4gICAgICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCkgfHxcclxuICAgICAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA8IDYpXHJcbiAgICAgICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPCAyMClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzdWx0LmMgPSB0XHJcbiAgICAgICAgfSBlbHNlIHJlc3VsdC54ID0gdFxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJvd3NlciA9IGRldGVjdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycgOiAnJylcclxuXHJcbiAgICBib3dzZXIudGVzdCA9IGZ1bmN0aW9uIChicm93c2VyTGlzdCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJvd3Nlckxpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGJyb3dzZXJJdGVtID0gYnJvd3Nlckxpc3RbaV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlckl0ZW0gaW4gYm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHZlcnNpb24gcHJlY2lzaW9ucyBjb3VudFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgIGdldFZlcnNpb25QcmVjaXNpb24oXCIxLjEwLjNcIikgLy8gM1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdmVyc2lvblxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbi5zcGxpdChcIi5cIikubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXk6Om1hcCBwb2x5ZmlsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpO1xyXG4gICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUubWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBpdGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3IoYXJyW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgYnJvd3NlciB2ZXJzaW9uIHdlaWdodFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjguMi4xLjkwJ10pICAgIC8vIDFcclxuICAgICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4wMTAuMi4xJywgJzEuMDkuMi4xLjkwJ10pOyAgLy8gMVxyXG4gICAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4xMC4yLjEnXSk7ICAgICAvLyAwXHJcbiAgICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjA4MDAuMiddKTsgICAgIC8vIC0xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gdmVyc2lvbnMgdmVyc2lvbnMgdG8gY29tcGFyZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbnMpIHtcclxuICAgICAgICAvLyAxKSBnZXQgY29tbW9uIHByZWNpc2lvbiBmb3IgYm90aCB2ZXJzaW9ucywgZm9yIGV4YW1wbGUgZm9yIFwiMTAuMFwiIGFuZCBcIjlcIiBpdCBzaG91bGQgYmUgMlxyXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1heChnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzBdKSwgZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uc1sxXSkpO1xyXG4gICAgICAgIHZhciBjaHVua3MgPSBtYXAodmVyc2lvbnMsIGZ1bmN0aW9uICh2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHByZWNpc2lvbiAtIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbik7XHJcblxyXG4gICAgICAgICAgICAvLyAyKSBcIjlcIiAtPiBcIjkuMFwiIChmb3IgcHJlY2lzaW9uID0gMilcclxuICAgICAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24gKyBuZXcgQXJyYXkoZGVsdGEgKyAxKS5qb2luKFwiLjBcIik7XHJcblxyXG4gICAgICAgICAgICAvLyAzKSBcIjkuMFwiIC0+IFtcIjAwMDAwMDAwMFwiXCIsIFwiMDAwMDAwMDA5XCJdXHJcbiAgICAgICAgICAgIHJldHVybiBtYXAodmVyc2lvbi5zcGxpdChcIi5cIiksIGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgyMCAtIGNodW5rLmxlbmd0aCkuam9pbihcIjBcIikgKyBjaHVuaztcclxuICAgICAgICAgICAgfSkucmV2ZXJzZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBpdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgYnkgcmV2ZXJzZWQgY2h1bmtzIGFycmF5XHJcbiAgICAgICAgd2hpbGUgKC0tcHJlY2lzaW9uID49IDApIHtcclxuICAgICAgICAgICAgLy8gNCkgY29tcGFyZTogXCIwMDAwMDAwMDlcIiA+IFwiMDAwMDAwMDEwXCIgPSBmYWxzZSAoYnV0IFwiOVwiID4gXCIxMFwiID0gdHJ1ZSlcclxuICAgICAgICAgICAgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID4gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID09PSBjaHVua3NbMV1bcHJlY2lzaW9uXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCB2ZXJzaW9uIGNodW5rcyBhcmUgc2FtZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYnJvd3NlciBpcyB1bnN1cHBvcnRlZFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3Nlcih7XHJcbiAgICAgKiAgICAgbXNpZTogXCIxMFwiLFxyXG4gICAgICogICAgIGZpcmVmb3g6IFwiMjNcIixcclxuICAgICAqICAgICBjaHJvbWU6IFwiMjlcIixcclxuICAgICAqICAgICBzYWZhcmk6IFwiNS4xXCIsXHJcbiAgICAgKiAgICAgb3BlcmE6IFwiMTZcIixcclxuICAgICAqICAgICBwaGFudG9tOiBcIjUzNFwiXHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3N0cmljdE1vZGUgPSBmYWxzZV0gZmxhZyB0byByZXR1cm4gZmFsc2UgaWYgYnJvd3NlciB3YXNuJ3QgZm91bmQgaW4gbWFwXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcclxuICAgICAgICB2YXIgX2Jvd3NlciA9IGJvd3NlcjtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdHJpY3RNb2RlIHBhcmFtIG9wdGlvbmFsIHdpdGggdWEgcGFyYW0gdXNhZ2VcclxuICAgICAgICBpZiAodHlwZW9mIHN0cmljdE1vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHVhID0gc3RyaWN0TW9kZTtcclxuICAgICAgICAgICAgc3RyaWN0TW9kZSA9IHZvaWQgKDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0cmljdE1vZGUgPT09IHZvaWQgKDApKSB7XHJcbiAgICAgICAgICAgIHN0cmljdE1vZGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVhKSB7XHJcbiAgICAgICAgICAgIF9ib3dzZXIgPSBkZXRlY3QodWEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnNpb24gPSBcIlwiICsgX2Jvd3Nlci52ZXJzaW9uO1xyXG4gICAgICAgIGZvciAodmFyIGJyb3dzZXIgaW4gbWluVmVyc2lvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG1pblZlcnNpb25zLmhhc093blByb3BlcnR5KGJyb3dzZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2Jvd3Nlclticm93c2VyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWluVmVyc2lvbnNbYnJvd3Nlcl0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBtaW5WZXJzaW9uIG1hcCBzaG91bGQgYmUgYSBzdHJpbmc6ICcgKyBicm93c2VyICsgJzogJyArIFN0cmluZyhtaW5WZXJzaW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciB2ZXJzaW9uIGFuZCBtaW4gc3VwcG9ydGVkIHZlcnNpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhbdmVyc2lvbiwgbWluVmVyc2lvbnNbYnJvd3Nlcl1dKSA8IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHJpY3RNb2RlOyAvLyBub3QgZm91bmRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGJyb3dzZXIgaXMgc3VwcG9ydGVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBtaW5WZXJzaW9ucyBtYXAgb2YgbWluaW1hbCB2ZXJzaW9uIHRvIGJyb3dzZXJcclxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2sobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpO1xyXG4gICAgfVxyXG5cclxuICAgIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3NlciA9IGlzVW5zdXBwb3J0ZWRCcm93c2VyO1xyXG4gICAgYm93c2VyLmNvbXBhcmVWZXJzaW9ucyA9IGNvbXBhcmVWZXJzaW9ucztcclxuICAgIGJvd3Nlci5jaGVjayA9IGNoZWNrO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTZXQgb3VyIGRldGVjdCBtZXRob2QgdG8gdGhlIG1haW4gYm93c2VyIG9iamVjdCBzbyB3ZSBjYW5cclxuICAgICAqIHJldXNlIGl0IHRvIHRlc3Qgb3RoZXIgdXNlciBhZ2VudHMuXHJcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgZnV0dXJlIHRlc3RzLlxyXG4gICAgICovXHJcbiAgICBib3dzZXIuX2RldGVjdCA9IGRldGVjdDtcclxuXHJcbiAgICAvKlxyXG4gICAgICogU2V0IG91ciBkZXRlY3QgcHVibGljIG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0XHJcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgYm93c2VyIGluIHNlcnZlciBzaWRlXHJcbiAgICAgKi9cclxuICAgIGJvd3Nlci5kZXRlY3QgPSBkZXRlY3Q7XHJcbiAgICByZXR1cm4gYm93c2VyXHJcbn0pOyIsIi8vIFByb21pc2UuZmluYWxseSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgaW4gTWljcm9zb2Z0IEVkZ2VcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9maW5hbGx5XHJcbmlmIChQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIC8vIEl0J3MgcmVwbGFjZWQgdW5jb25kaXRpb25hbGx5IHRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBiZWhhdmlvclxyXG4gICAgLy8gaW4gcHJvZ3JhbXMgZXZlbiBpZiB0aGVyZSdzIGV2ZXIgYSBuYXRpdmUgZmluYWxseS5cclxuICAgIHdpbmRvdy5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZnVuY3Rpb24gZmluYWxseVBvbHlmaWxsKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZWFzb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufSIsInZhciBsYXlvdXRyID0gd2luZG93LmxheW91dHIgfHwge307XHJcbntcclxuICAgIGxheW91dHIuc2l0ZU5hbWUgPSAnbGF5b3V0cic7XHJcblxyXG4gICAgbGF5b3V0ci50aHJvdHRsZUludGVydmFsID0gNTA7XHJcbiAgICBsYXlvdXRyLmRlYm91bmNlSW50ZXJ2YWwgPSA1MDtcclxuXHJcbiAgICBsYXlvdXRyLnRyYW5zaXRpb25UaW1lID0gNDAwO1xyXG4gICAgbGF5b3V0ci5mYWRlT3V0VGltZSA9IDUwMDtcclxuICAgIGxheW91dHIuaHRtbE92ZXJmbG93RW5hYmxlZCA9IHRydWU7XHJcbiAgICBsYXlvdXRyLnNtYWxsQnJlYWtwb2ludCA9IDczMjtcclxuICAgIGxheW91dHIuc2Nyb2xsYmFyV2lkdGggPSAwO1xyXG4gICAgbGF5b3V0ci5sb2FkaW5nQ291bnQgPSAwO1xyXG4gICAgbGF5b3V0ci5kb2N1bWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIGxheW91dHIuZnVsbHNjcmVlbiA9IGZhbHNlO1xyXG4gICAgbGF5b3V0ci5hamF4ID0gJ2Rpc3QvYWpheC8nO1xyXG4gICAgbGF5b3V0ci5hcnJvd0tleUxvY2tlZCA9IGZhbHNlO1xyXG4gICAgbGF5b3V0ci5zb3J0ID0gbmV3IEludGwuQ29sbGF0b3IodW5kZWZpbmVkLCB7IG51bWVyaWM6IHRydWUsIHNlbnNpdGl2aXR5OiAnYmFzZScgfSkuY29tcGFyZTtcclxuXHJcbiAgICBsYXlvdXRyLm5hdmlnYXRpb24gPSBbXTtcclxuICAgIGJvd3Nlci5kZXNrdG9wID0gIWJvd3Nlci5tb2JpbGUgJiYgIWJvd3Nlci50YWJsZXQ7XHJcblxyXG4gICAgbGV0IGwgPSB3aW5kb3cubG9jYXRpb24sXHJcbiAgICAgICAgc2VnbWVudENvdW50ID0gbC5vcmlnaW4uZW5kc1dpdGgoJ2dpdGh1Yi5pbycpID8gMSA6IDA7XHJcbiAgICBsYXlvdXRyLmhvc3QgPSBgJHtsLnByb3RvY29sfS8vJHtsLmhvc3RuYW1lfSR7bC5wb3J0ID8gYDoke2wucG9ydH1gIDogJyd9JHtsLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgMSArIHNlZ21lbnRDb3VudCkuam9pbignLycpfS9gO1xyXG5cclxuICAgIGxheW91dHIuYXdhaXRJbnRlcnZhbCA9IDUwO1xyXG4gICAgLy8gd2luZG93LkFyZWlvbiA9IEdob3N0bGFiXHJcbiAgICBsYXlvdXRyLmlzTG9jYWxob3N0ID0gd2luZG93LkFyZWlvbiB8fCBsLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBsLmhvc3RuYW1lID09PSAnMTI3LjAuMC4xJyB8fCBsLmhvc3RuYW1lID09PSAnMTkyLjE2OC40MC4xMDAnO1xyXG5cclxuICAgIGxheW91dHIuc2V0dGluZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2V0dGluZ3NcIikpO1xyXG4gICAgaWYgKGxheW91dHIuc2V0dGluZ3MgPT09IG51bGwpIGxheW91dHIuc2V0dGluZ3MgPSBbXTtcclxuICAgIGxheW91dHIudGhlbWUgPSAnbGlnaHQnO1xyXG4gICAgbGF5b3V0ci5zZXR0aW5ncy5mb3JFYWNoKChlbnRyeSkgPT4ge1xyXG4gICAgICAgIGlmIChlbnRyeS5uYW1lID09PSAndGhlbWUnKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIudGhlbWUgPSBlbnRyeS5pZC5zdWJzdHJpbmcoZW50cnkuaWQuaW5kZXhPZihcIi1cIikgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCgpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmh0bWwgPSAkKCdodG1sJyk7XHJcbiAgICAgICAgbGF5b3V0ci5oZWFkID0gJCgnaGVhZCcpO1xyXG4gICAgICAgIGxheW91dHIuYm9keSA9ICQoJ2JvZHknKTtcclxuICAgICAgICBsYXlvdXRyLm1haW4gPSAkKCdtYWluJyk7XHJcbiAgICAgICAgbGF5b3V0ci5jb250ZW50ID0gJCgnI2NvbnRlbnQgPiBkaXYnKTtcclxuICAgICAgICBsYXlvdXRyLmhlYWRlciA9ICQoJ2hlYWRlcicpO1xyXG4gICAgICAgIGxheW91dHIuZm9vdGVyID0gJCgnZm9vdGVyJyk7XHJcbiAgICAgICAgbGF5b3V0ci5sZWZ0ID0gJCgnI2xlZnQnKTtcclxuICAgICAgICBsYXlvdXRyLnJpZ2h0ID0gJCgnI3JpZ2h0Jyk7XHJcbiAgICAgICAgbGF5b3V0ci5sb2FkaW5nID0gJCgnI2xvYWRpbmcnKTtcclxuICAgICAgICBsYXlvdXRyLm92ZXJmbG93ID0gJCgnI292ZXJmbG93Jyk7XHJcbiAgICAgICAgbGF5b3V0ci5tb2RhbCA9ICQoJyNtb2RhbCcpO1xyXG4gICAgICAgIGxheW91dHIudGl0bGUgPSAkKCcjdGl0bGUnKTtcclxuICAgICAgICBsYXlvdXRyLmF1dGhlbnRpY2F0aW9uID0gJCgnI2F1dGhlbnRpY2F0aW9uJyk7XHJcbiAgICAgICAgbGF5b3V0ci51bmF1dGhlbnRpY2F0ZWQgPSBsYXlvdXRyLmF1dGhlbnRpY2F0aW9uLmNoaWxkcmVuKCcudW5hdXRoZW50aWNhdGVkJyk7XHJcbiAgICAgICAgbGF5b3V0ci5hdXRoZW50aWNhdGVkID0gbGF5b3V0ci5hdXRoZW50aWNhdGlvbi5jaGlsZHJlbignLmF1dGhlbnRpY2F0ZWQnKTtcclxuICAgICAgICBsYXlvdXRyLmF1dGhlbnRpY2F0ZWRMaW5rcyA9IGxheW91dHIuYXV0aGVudGljYXRpb24uZmluZCgnLmxpbmtzJyk7XHJcbiAgICAgICAgbGF5b3V0ci5jb29raWUgPSAkKCcjY29va2llJyk7XHJcbiAgICAgICAgbGF5b3V0ci5mb2N1cyA9ICQoJyNmb2N1cycpO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAoc2VhcmNoLCByZXBsYWNlbWVudCkge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQucmVwbGFjZShuZXcgUmVnRXhwKHNlYXJjaCwgJ2cnKSwgcmVwbGFjZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmd1aWQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHM0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcclxuICAgICAgICAgICAgICAgIC50b1N0cmluZygxNilcclxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYCR7czQoKSArIHM0KCl9LSR7czQoKX0tJHtzNCgpfS0ke3M0KCl9LSR7czQoKSArIHM0KCkgKyBzNCgpfWA7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuaXNTbWFsbEJyZWFrcG9pbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICQod2luZG93KS5vdXRlcldpZHRoKCkgPCA3MzIgfHwgbGF5b3V0ci5pc0FzaWRlTGVmdCgpICYmICFsYXlvdXRyLmlzQXNpZGVMZWZ0U2hyaW5rKCkgfHwgbGF5b3V0ci5pc0FzaWRlUmlnaHQoKSAmJiAhbGF5b3V0ci5pc0FzaWRlUmlnaHRTaHJpbmsoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0FzaWRlID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hc2lkZScpLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0FzaWRlTGVmdCA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXNpZGUnKSA9PT0gJ2xlZnQnO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmlzQXNpZGVSaWdodCA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXNpZGUnKSA9PT0gJ3JpZ2h0JztcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0FzaWRlTGVmdFNocmluayA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdsZWZ0LXNocmluaycpICYmIGxheW91dHIuaXNBc2lkZUxlZnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0FzaWRlUmlnaHRTaHJpbmsgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5oYXNDbGFzcygncmlnaHQtc2hyaW5rJykgJiYgbGF5b3V0ci5pc0FzaWRlUmlnaHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0FzaWRlTGVmdENsb3NlT25DbGlja091dHNpZGUgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5oYXNDbGFzcygnY2xvc2UtbGVmdC1jbGljay1vdXRzaWRlJyk7XHJcbiAgICB9O1xyXG4gICAgbGF5b3V0ci5pc0FzaWRlUmlnaHRDbG9zZU9uQ2xpY2tPdXRzaWRlID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuaGFzQ2xhc3MoJ2Nsb3NlLXJpZ2h0LWNsaWNrLW91dHNpZGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc01vZGFsID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuaGFzQ2xhc3MoJ21vZGFsJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuaXNNb2RhbEZvcm0gPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLW1vZGFsJykgPT09ICdmb3JtJztcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc01vZGFsSW1hZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLW1vZGFsJykgPT09ICdpbWFnZSc7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuaXNGb2N1cyA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdmb2N1cycpICYmIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWZvY3VzJykgPT09ICd0cnVlJztcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc1RUUyA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmhhc0NsYXNzKCd0dHMnKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc1RUU0VuYWJsZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5oYXNDbGFzcygndHRzJykgJiYgbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtdHRzJykgPT09ICd0cnVlJztcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0F1dGhlbnRpY2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hdXRoZW50aWNhdGlvbicpICE9PSAnJztcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc0xvYWRpbmcgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5oYXNDbGFzcygnbG9hZGluZycpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmlzU2Nyb2xsRGlzYWJsZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dHIuaHRtbC5oYXNDbGFzcygnc2Nyb2xsLWRpc2FibGVkJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuaXNDbG9zZUxlZnRQYWdlQ2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuaGFzQ2xhc3MoJ2Nsb3NlLWxlZnQtcGFnZS1jaGFuZ2UnKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5pc1RyYW5zaXRpb25zID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRyLmh0bWwuaGFzQ2xhc3MoJ3RyYW5zaXRpb25zJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuaXNTd2lwZSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdzd2lwZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmlzU2l0ZUxvYWRlZCA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdzaXRlLWxvYWRlZCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmNhcGl0YWxpemUgPSAoc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5zY3JvbGxUb3AgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxheW91dHIuYm9keS5zY3JvbGxUb3AoKSwgbGF5b3V0ci5tYWluLnNjcm9sbFRvcCgpLCBsYXlvdXRyLmh0bWwuc2Nyb2xsVG9wKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLnRyeVBhcnNlSW50ID0gKHN0ciwgZGVmYXVsdFZhbHVlKSA9PiB7XHJcbiAgICAgICAgbGV0IHJldFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIGlmIChzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IG51bGwgJiYgc3RyLmxlbmd0aCA+IDAgJiYgIWlzTmFOKHN0cikpIHtcclxuICAgICAgICAgICAgcmV0VmFsdWUgPSBwYXJzZUludChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIudHJ5UGFyc2VGbG9hdCA9IChzdHIsIGRlZmF1bHRWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGxldCByZXRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoc3RyICE9PSB1bmRlZmluZWQgJiYgc3RyICE9PSBudWxsICYmIHN0ci5sZW5ndGggPiAwICYmICFpc05hTihzdHIpKSB7XHJcbiAgICAgICAgICAgIHJldFZhbHVlID0gcGFyc2VGbG9hdChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIudHJ5UGFyc2VKU09OID0gKHN0ciwgZGVmYXVsdFZhbHVlKSA9PiB7XHJcbiAgICAgICAgbGV0IHJldFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldFZhbHVlID0gSlNPTi5wYXJzZShzdHIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmlzVHJ1ZSA9IChzdHIpID0+IHtcclxuICAgICAgICByZXR1cm4gc3RyID09PSAndHJ1ZSc7XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGJvd3Nlci5tc2VkZ2UpIHtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdtc2VkZ2UnKTsgLy8gdXNlZCBieSBsYXlvdXRyLmVuYWJsZVNjcm9sbCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3dzZXIubW9iaWxlKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnbW9iaWxlJyk7IC8vIGRpc2FibGVzIGZpeGVkIGZvb3RlclxyXG4gICAgICAgIH0gZWxzZSBpZiAoYm93c2VyLnRhYmxldCkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ3RhYmxldCcpOyAvLyBkb2VzIG5vdGhpbmcgY3VycmVudGx5XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdkZXNrdG9wJyk7IC8vIGVuYWJsZXMgaG92ZXIgZWZmZWN0c1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvd3Nlci5hbmRyb2lkKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnYW5kcm9pZCcpOyAvLyB1c2VkIGJ5IG1vZGFsXHJcbiAgICAgICAgfSBlbHNlIGlmIChib3dzZXIuaW9zKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnaW9zJyk7IC8vIHVzZWQgdG8gYXBwbHkgZm9jdXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChib3dzZXIubXNlZGdlKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgc21vb3RoIHNjcm9sbGluZywgc2luY2UgaXQgY2F1c2VzIGVsZW1lbnQganVtcGluZy9sYWdnaW5nIG9uIHNjcm9sbFxyXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTQxNjQ0OC9ob3ctdG8tZGlzYWJsZS1zbW9vdGgtc2Nyb2xsaW5nLWluLWllMTFcclxuICAgICAgICAgICAgbGF5b3V0ci5ib2R5Lm9uKFwibW91c2V3aGVlbFwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXlvdXRyLmlzTW9kYWwoKSAmJiBldmVudC5jdHJsS2V5ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhc2lkZSA9IHRhcmdldC5jbG9zZXN0KCdhc2lkZSA+IC5jb250ZW50JykgfHwgdGFyZ2V0LnBhcmVudHMoJ2FzaWRlIC5jb250ZW50JyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsRGVsdGEgPSBlLm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjcm9sbFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc2lkZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gYXNpZGUuc2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzaWRlLnNjcm9sbFRvcChjdXJyZW50U2Nyb2xsUG9zaXRpb24gLSB3aGVlbERlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBjdXJyZW50U2Nyb2xsUG9zaXRpb24gLSB3aGVlbERlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gYXQgc29tZSB6b29tIGxldmVscyBlZGdlL2llIG1ha2VzICQod2luZG93KSBoZWlnaGVyIHRoYW4gJChkb2N1bWVudClcclxuICAgICAgICAgICAgLy8gaXQgY2F1c2VzIGEgZ2FwIGJldHdlZW4gZm9vdGVyIGFuZCB0aGUgYm90dG9tIG9mICQod2luZG93KS5cclxuICAgICAgICAgICAgJCh3aW5kb3cpLnNjcm9sbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2VsZi5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCArICQod2luZG93KS5oZWlnaHQoKSA+PSAkKGRvY3VtZW50KS5oZWlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnc3VicGl4ZWwnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLnJlbW92ZUNsYXNzKCdzdWJwaXhlbCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSIsIntcclxuICAgIGxheW91dHIubG9hZCA9ICgoKSA9PiB7XHJcbiAgICAgICAgbGV0IF9sb2FkID0gKHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKHVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnbGluaycgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICdpbWcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnaW1nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnbGluaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbCA9ICdzdHlsZXNoZWV0JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ2ltZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnaW1nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2h0bWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNzczogX2xvYWQoJ2xpbmsnKSxcclxuICAgICAgICAgICAganM6IF9sb2FkKCdzY3JpcHQnKSxcclxuICAgICAgICAgICAgaW1nOiBfbG9hZCgnaW1nJyksXHJcbiAgICAgICAgICAgIGh0bWw6IF9sb2FkKCdodG1sJylcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxufSIsIntcclxuICAgIGxheW91dHIucHJvbWlzZUNTUyA9IGxheW91dHIubG9hZC5jc3MoYCR7bGF5b3V0ci5ob3N0fWRpc3QvY3NzL3RoZW1lLyR7bGF5b3V0ci50aGVtZX0uY3NzYCkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBjc3M6JywgZSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5mb290ZXIuaHRtbChgPHA+XFx1MDBBOSAke25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0gRnJlZGVyaWsgTmllbHNlbjwvcD5gKTtcclxuXHJcbiAgICAgICAgLy9sYXlvdXRyLnNldEh0bWxTY3JvbGwoKTsgLy8gb3V0Y29tbWVudCBpZiBpdCBjYW4gYmUgZGlzYWJsZWQgYXQgZmlyc3QgcGFnZSBsb2FkXHJcblxyXG4gICAgICAgIGxheW91dHIubG9hZC5odG1sKGAke2xheW91dHIuaG9zdH0ke2xheW91dHIuYWpheH1zdmcvYmFzZS5odG1sYCkudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgJChyZXNwb25zZSkucHJlcGVuZFRvKGxheW91dHIuYm9keSk7XHJcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgYmFzZSBzdmcgaHRtbCcsICdkYW5nZXInKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGJvd3Nlci5hbmRyb2lkKSB7XHJcbiAgICAgICAgICAgIC8vIGFuZHJvaWQgZG9lc24ndCBoYW5kbGUgdmggY29ycmVjdGx5LCBzbyBpdCBnZXRzIGNvbnZlcnRlZCB0byBweFxyXG4gICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXRyLmlzTW9kYWwoKSAmJiBsYXlvdXRyLmlzTW9kYWxJbWFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5tb2RhbC5maW5kKCcjbW9kYWwtaW1nJykuY3NzKCdtYXgtaGVpZ2h0Jywgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJCh3aW5kb3cpLmNsaWNrKChlKSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9ICQoZS50YXJnZXQpLFxyXG4gICAgICAgICAgICBtb2RhbCA9IHRhcmdldC5jbG9zZXN0KGxheW91dHIubW9kYWxbMF0pO1xyXG5cclxuICAgICAgICBpZiAoIWxheW91dHIuaXNMb2FkaW5nKCkgJiYgIWxheW91dHIuaXNGb2N1cygpKSB7XHJcbiAgICAgICAgICAgIGlmIChib3dzZXIuaW9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpb3MgYnJvd3NlcnMgZG9lc24ndCBhcHBseSA6Zm9jdXMgdG8gYnV0dG9ucyBpbiBtYW55IGNhc2VzLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmb3JjZXMgOmZvY3VzIHRvIGJlIGFwcGxpZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5wYXJlbnRzKCdidXR0b24nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGFyZW50cygnYnV0dG9uJykuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsb3Nlc3QoJ2J1dHRvbicpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGF5b3V0ci5pc0F1dGhlbnRpY2F0aW9uKCkgJiYgIXRhcmdldC5jbG9zZXN0KCcjYXV0aGVudGljYXRpb24nKS5sZW5ndGggJiYgIXRhcmdldC5jbG9zZXN0KCcjbW9kYWwnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWF1dGhlbnRpY2F0aW9uJywgJycpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGFsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGltYWdlID0gbGF5b3V0ci5pc01vZGFsSW1hZ2UoKSAmJiAhdGFyZ2V0LmNsb3Nlc3QoJyNtb2RhbC10b2dnbGUnKS5sZW5ndGggJiYgIXRhcmdldC5jbG9zZXN0KCcjbW9kYWwtdGl0bGUnKS5sZW5ndGggJiYgIXRhcmdldC5jbG9zZXN0KCcjbW9kYWwtZGVzY3JpcHRpb24nKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybSA9IGxheW91dHIuaXNNb2RhbEZvcm0oKSAmJiAhdGFyZ2V0LmNsb3Nlc3QoJyNtb2RhbCA+IGRpdiA+IGRpdiA+IGRpdicpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZSB8fCBmb3JtIHx8IHRhcmdldC5jbG9zZXN0KCcjbW9kYWwtY2xvc2UnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNsb3NlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBpc1NtYWxsQnJlYWtwb2ludCA9IGxheW91dHIuaXNTbWFsbEJyZWFrcG9pbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGF5b3V0ci5pc0FzaWRlTGVmdCgpICYmIChsYXlvdXRyLmlzQXNpZGVMZWZ0Q2xvc2VPbkNsaWNrT3V0c2lkZSgpIHx8IGlzU21hbGxCcmVha3BvaW50KSAmJiAhdGFyZ2V0LmNsb3Nlc3QoXCIjbGVmdFwiKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBsYXlvdXRyLmlzQXNpZGVSaWdodCgpICYmIChsYXlvdXRyLmlzQXNpZGVSaWdodENsb3NlT25DbGlja091dHNpZGUoKSB8fCBpc1NtYWxsQnJlYWtwb2ludCkgJiYgIXRhcmdldC5jbG9zZXN0KFwiI3JpZ2h0XCIpLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBub3RUYXJnZXQgPSAhdGFyZ2V0LmNsb3Nlc3QoXCIuYXNpZGVcIikubGVuZ3RoICYmICF0YXJnZXQuY2xvc2VzdCgnLnBvcHVwJykubGVuZ3RoICYmICF0YXJnZXQuY2xvc2VzdCgnI2Nvb2tpZScpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICgobGVmdCB8fCByaWdodCkgJiYgbm90VGFyZ2V0ICYmICFsYXlvdXRyLmlzTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5lbmFibGVTY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnRvZ2dsZUFzaWRlKHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLnByb21pc2VGb250ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIFdlYkZvbnQubG9hZCh7XHJcbiAgICAgICAgICAgIHR5cGVraXQ6IHtcclxuICAgICAgICAgICAgICAgIGlkOiBbJ2JoejNkeHgnXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5hY3RpdmU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgIC8vbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgZm9udHMnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgIH0pO1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5jb250ZW50TG9hZGVkID0gKGVsZW1lbnQpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmNoZWNrUmVzcG9uc2l2ZUJhY2tncm91bmQoZWxlbWVudC5maW5kKCcucmInKSk7XHJcbiAgICAgICAgbGF5b3V0ci5jaGVja0xhenkoZWxlbWVudC5maW5kKCcubGF6eScpKTtcclxuICAgICAgICBsYXlvdXRyLmNoZWNrQWNjb3JkaW9uKGVsZW1lbnQuZmluZCgnLmFjY29yZGlvbicpKTtcclxuICAgICAgICBsYXlvdXRyLmNoZWNrRHJvcGRvd24oZWxlbWVudC5maW5kKCdzZWxlY3QuZHJvcGRvd24nKSk7XHJcbiAgICAgICAgbGF5b3V0ci5jaGVja1Rvb2x0aXAoZWxlbWVudC5maW5kKCcudG9vbHRpcCcpKTtcclxuICAgICAgICBsYXlvdXRyLmNoZWNrQXNzaWdubWVudChlbGVtZW50LmZpbmQoJy5hc3NpZ25tZW50JykpO1xyXG4gICAgICAgIGxheW91dHIuY2hlY2tNYXRoKGVsZW1lbnQuZmluZCgnLm1hdGgnKSk7XHJcbiAgICAgICAgbGF5b3V0ci5jaGVja01lZGlhKGVsZW1lbnQuZmluZCgnYXVkaW8sIHZpZGVvJykpO1xyXG4gICAgICAgIGxheW91dHIuY2hlY2tNYXAoZWxlbWVudC5maW5kKCcubWFwJykpO1xyXG4gICAgICAgIGxheW91dHIuY2hlY2tEYXRhdGFibGUoZWxlbWVudC5maW5kKCcuZGF0YVRhYmxlJykpO1xyXG4gICAgICAgIGxheW91dHIuY2hlY2tTd2lwZXIoZWxlbWVudC5maW5kKCcuc3dpcGVyJykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLnBhZ2VMb2FkZWQgPSAoaW5pdGlhbCkgPT4ge1xyXG4gICAgICAgIGxldCBwcm9taXNlU2Nyb2xsVG9wID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLm1haW4uY3NzKCdvdmVyZmxvdycsICdhdXRvJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIubWFpbi5zY3JvbGxUb3AoMCk7XHJcbiAgICAgICAgICAgIGxheW91dHIubWFpbi5jc3MoJ292ZXJmbG93JywgJycpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5zY3JvbGxUb3AoMCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbCAmJiBsYXlvdXRyLmlzQ2xvc2VMZWZ0UGFnZUNoYW5nZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAyMDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluaXRpYWwpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucHJvbWlzZUZvbnQudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI3NpdGUnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnJlc3BvbnNpdmVIZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNvbnRlbnRMb2FkZWQobGF5b3V0ci5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2Nyb2xsID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNjcm9sbFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5lbmFibGVTY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9taXNlIHZlcnNpb24gZG9lc24ndCBhbHdheXMgc2Nyb2xsIHRvIGNvcnJlY3QgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAkLkRlZmVycmVkKChkZWZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsICE9PSBudWxsICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSBzY3JvbGwuaHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGxheW91dHIuYm9keVswXS5zY3JvbGxIZWlnaHQgPj0gc2Nyb2xsLnNjcm9sbFRvcCA/IHNjcm9sbC5zY3JvbGxUb3AgOiBsYXlvdXRyLmJvZHlbMF0uc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDAsIGRlZmVyLnJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuZG9uZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdzaXRlLWxvYWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykuc2Nyb2xsKCQudGhyb3R0bGUobGF5b3V0ci50aHJvdHRsZUludGVydmFsLCBmYWxzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5zZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSgkLnRocm90dGxlKGxheW91dHIudGhyb3R0bGVJbnRlcnZhbCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuY2hlY2tNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5zZXRIdG1sU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnNldFNjcm9sbFRvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuY29udGVudExvYWRlZChsYXlvdXRyLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5wYWdlRm9ybSA9ICgpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmFkZFZhbGlkYXRpb24oXHJcbiAgICAgICAgICAgIGxheW91dHIuY29udGVudC5maW5kKCcjZm9ybScpLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdE5hbWU6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IDJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsYXN0TmFtZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmxlbmd0aDogMlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlubGVuZ3RoOiAyXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZF9yZWdleDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbmZpcm1fcGFzc3dvcmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlcXVhbFRvOiBcIiNwYXNzd29yZFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW1haWw6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzE6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzI6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzM6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzQ6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzU6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duXzY6IFwicmVxdWlyZWRcIixcclxuICAgICAgICAgICAgICAgIGdlbmRlcjogXCJyZXF1aXJlZFwiLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJlc3RzOiBcInJlcXVpcmVkXCIsXHJcbiAgICAgICAgICAgICAgICBhZ3JlZTogXCJyZXF1aXJlZFwiLFxyXG4gICAgICAgICAgICAgICAgZm9udF9zaXplOiBcInJlcXVpcmVkXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlyc3ROYW1lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFwiUGxlYXNlIGVudGVyIHlvdXIgZmlyc3QgbmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmxlbmd0aDogXCJZb3VyIGZpcnN0IG5hbWUgbXVzdCBjb25zaXN0IG9mIGF0IGxlYXN0IDIgY2hhcmFjdGVyc1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGFzdE5hbWU6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJQbGVhc2UgZW50ZXIgeW91ciBsYXN0IG5hbWVcIixcclxuICAgICAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IFwiWW91ciBsYXN0IG5hbWUgbXVzdCBjb25zaXN0IG9mIGF0IGxlYXN0IDIgY2hhcmFjdGVyc1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJQbGVhc2UgZW50ZXIgYSB1c2VybmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmxlbmd0aDogXCJZb3VyIHVzZXJuYW1lIG11c3QgY29uc2lzdCBvZiBhdCBsZWFzdCAyIGNoYXJhY3RlcnNcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFwiUGxlYXNlIHByb3ZpZGUgYSBwYXNzd29yZFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29uZmlybV9wYXNzd29yZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBwcm92aWRlIGEgcGFzc3dvcmRcIixcclxuICAgICAgICAgICAgICAgICAgICBlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSBwYXNzd29yZCBhcyBhYm92ZVwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW1haWw6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fMTogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fMjogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fMzogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fNDogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fNTogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZHJvcGRvd25fNjogXCJQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZ2VuZGVyOiBcIlBsZWFzZSBzZWxlY3QgeW91ciBnZW5kZXJcIixcclxuICAgICAgICAgICAgICAgIGludGVyZXN0czogXCJQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSBpbnRlcmVzdFwiLFxyXG4gICAgICAgICAgICAgICAgYWdyZWU6IFwiUGxlYXNlIGFjY2VwdCBvdXIgcG9saWN5XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGV0IGZ1bGxzY3JlZW5TY3JvbGxUb3A7XHJcblxyXG4gICAgbGF5b3V0ci5yZXF1ZXN0RnVsbFNjcmVlbiA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIWxheW91dHIuZnVsbHNjcmVlbiAmJiBib3dzZXIuZGVza3RvcCkge1xyXG4gICAgICAgICAgICBmdWxsc2NyZWVuU2Nyb2xsVG9wID0gbGF5b3V0ci5zY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgaWYgKGxheW91dHIuZG9jdW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuZG9jdW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRyLmRvY3VtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuZG9jdW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheW91dHIuZG9jdW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuZG9jdW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRyLmRvY3VtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmRvY3VtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBmdWxsc2NyZWVuQ2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuZnVsbHNjcmVlbiA9ICFsYXlvdXRyLmZ1bGxzY3JlZW47XHJcbiAgICAgICAgaWYgKCFsYXlvdXRyLmZ1bGxzY3JlZW4gJiYgYm93c2VyLmRlc2t0b3ApIHtcclxuICAgICAgICAgICAgaWYgKGxheW91dHIuaXNNb2RhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmNsb3NlTW9kYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXlvdXRyLmJvZHkuc2Nyb2xsVG9wKGZ1bGxzY3JlZW5TY3JvbGxUb3ApO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwuc2Nyb2xsVG9wKGZ1bGxzY3JlZW5TY3JvbGxUb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBmdWxsc2NyZWVuQ2hhbmdlLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgZnVsbHNjcmVlbkNoYW5nZSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNGdWxsc2NyZWVuQ2hhbmdlJywgZnVsbHNjcmVlbkNoYW5nZSwgZmFsc2UpO1xyXG5cclxuICAgIGxheW91dHIuZXhpdEZ1bGxTY3JlZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGxheW91dHIuZnVsbHNjcmVlbiAmJiBib3dzZXIuZGVza3RvcCkge1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci50b2dnbGVGdWxsU2NyZWVuID0gKGVsZW1lbnQpID0+IHtcclxuICAgICAgICBpZiAobGF5b3V0ci5mdWxsc2NyZWVuKVxyXG4gICAgICAgICAgICBleGl0RnVsbFNjcmVlbigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmVxdWVzdEZ1bGxTY3JlZW4oZWxlbWVudCk7XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGV0IHNjcm9sbGJhcldpZHRoID0gKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuYm9keS5hcHBlbmQoJzxkaXYgaWQ9XCJzY3JvbGxiYXItd2lkdGhcIj48L2Rpdj4nKTtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGxheW91dHIuYm9keS5jaGlsZHJlbignI3Njcm9sbGJhci13aWR0aCcpO1xyXG4gICAgICAgIGVsZW1lbnQuY3NzKHtcclxuICAgICAgICAgICAgJ292ZXJmbG93JzogXCJzY3JvbGxcIixcclxuICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAnd2lkdGgnOiAnMTAwcHgnLFxyXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzEwMHB4J1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxheW91dHIuc2Nyb2xsYmFyV2lkdGggPSBlbGVtZW50WzBdLm9mZnNldFdpZHRoIC0gZWxlbWVudFswXS5jbGllbnRXaWR0aDtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmRpc2FibGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGxheW91dHIuaHRtbE92ZXJmbG93RW5hYmxlZCkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWxPdmVyZmxvd0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGxheW91dHIuaXNNb2RhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmNoZWNrTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIubW9kYWwuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsVG9wID0gbGF5b3V0ci5zY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdzY3JvbGwtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5ib2R5LnNjcm9sbFRvcChzY3JvbGxUb3ApO1xyXG4gICAgICAgICAgICBsYXlvdXRyLm1haW4uc2Nyb2xsVG9wKHNjcm9sbFRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmVuYWJsZVNjcm9sbCA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIWxheW91dHIuaHRtbE92ZXJmbG93RW5hYmxlZCkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWxPdmVyZmxvd0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobGF5b3V0ci5pc1NpdGVMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGxheW91dHIuc2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwucmVtb3ZlQ2xhc3MoJ3Njcm9sbC1kaXNhYmxlZCBtb2RhbCcpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5tYWluLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmJvZHkuc2Nyb2xsVG9wKHNjcm9sbFRvcCk7IC8vIGVkZ2UsIHNhZmFyaVxyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLnNjcm9sbFRvcChzY3JvbGxUb3ApOyAvLyBjaHJvbWUsIGZpcmVmb3gsIGllXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwucmVtb3ZlQ2xhc3MoJ3Njcm9sbC1kaXNhYmxlZCBtb2RhbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLnNldEh0bWxTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFsYXlvdXRyLmlzTW9kYWwoKSAmJiAhbGF5b3V0ci5pc0xvYWRpbmcoKSAmJiAhbGF5b3V0ci5odG1sT3ZlcmZsb3dFbmFibGVkICYmICghbGF5b3V0ci5pc1NtYWxsQnJlYWtwb2ludCgpIHx8IGxheW91dHIuaXNTbWFsbEJyZWFrcG9pbnQoKSAmJiAhbGF5b3V0ci5pc0FzaWRlTGVmdCgpICYmICFsYXlvdXRyLmlzQXNpZGVSaWdodCgpKSkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmVuYWJsZVNjcm9sbCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ci5pc01vZGFsKCkgfHwgbGF5b3V0ci5pc1NtYWxsQnJlYWtwb2ludCgpICYmIGxheW91dHIuaHRtbE92ZXJmbG93RW5hYmxlZCAmJiAobGF5b3V0ci5pc0FzaWRlTGVmdCgpIHx8IGxheW91dHIuaXNBc2lkZVJpZ2h0KCkpKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuZGlzYWJsZVNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGgoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxheW91dHIuc2V0U2Nyb2xsVG9wID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCBlbnRyeSA9IHtcclxuICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXHJcbiAgICAgICAgICAgIHNjcm9sbFRvcDogbGF5b3V0ci5zY3JvbGxUb3AoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Njcm9sbCcsIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XHJcbiAgICB9O1xyXG5cclxufSIsIntcclxuICAgIGxheW91dHIuc2hvd0xvYWRpbmcgPSAoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5sb2FkaW5nQ291bnQrKztcclxuICAgICAgICBsYXlvdXRyLmRpc2FibGVTY3JvbGwoKTtcclxuICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5oaWRlTG9hZGluZyA9ICgpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmxvYWRpbmdDb3VudC0tO1xyXG4gICAgICAgIGlmIChsYXlvdXRyLmxvYWRpbmdDb3VudCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIubG9hZGluZ0NvdW50ID0gMDtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2V0SHRtbFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0iLCJ7XHJcbiAgICBsZXQgdHJhbnNpdGlvbkxvY2sgPSBmYWxzZTtcclxuXHJcbiAgICBsYXlvdXRyLmFzaWRlQ2hhbmdlZCA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdHJpZ2dlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLnRyaWdnZXIoJ2FzaWRlLWNoYW5nZWQuZGF0YXRhYmxlcycpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwudHJpZ2dlcignYXNpZGUtY2hhbmdlZC5yYicpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwudHJpZ2dlcignYXNpZGUtY2hhbmdlZC5tYXAnKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAobGF5b3V0ci5pc1RyYW5zaXRpb25zKCkpIHtcclxuICAgICAgICAgICAgbGV0IGF3YWl0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zaXRpb25Mb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhd2FpdEludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBsYXlvdXRyLmF3YWl0SW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Mb2NrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sIGxheW91dHIudHJhbnNpdGlvblRpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25Mb2NrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyaWdnZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIudG9nZ2xlQXNpZGUgPSAoYXNpZGUsIHBhZ2VDaGFuZ2VkKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uTG9jaykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uTG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWF1dGhlbnRpY2F0aW9uJywgJycpO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEFzaWRlID0gbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXNpZGUnKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBc2lkZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhc2lkZSA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRBc2lkZSA9PT0gYXNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2Nyb2xsVG9wID0gbGF5b3V0ci5zY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hc2lkZScsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLm1haW4uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmJvZHkuc2Nyb2xsVG9wKHNjcm9sbFRvcCk7IC8vIGVkZ2UsIHNhZmFyaVxyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5zY3JvbGxUb3Aoc2Nyb2xsVG9wKTsgLy8gY2hyb21lLCBmaXJlZm94LCBpZVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hc2lkZScsIGFzaWRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWFzaWRlJywgYXNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhc2lkZSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmxlZnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhc2lkZSA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5yaWdodC5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLmFzaWRlQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLnNldEh0bWxTY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICQoKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIubWFpbi5maW5kKCcuYXNpZGUubGVmdCcpLmNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgnbGVmdCcpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRyLm1haW4uZmluZCgnLmFzaWRlLnJpZ2h0JykuY2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLnRvZ2dsZUFzaWRlKCdyaWdodCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICAkKCgpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmF1dGhlbnRpY2F0aW9uLm9uKCdjbGljaycsICc+IGRpdiA+IGJ1dHRvbicsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZS5jdXJyZW50VGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgIHR5cGUgPSAkdGhpcy5hdHRyKCdkYXRhLXR5cGUnKTtcclxuICAgICAgICAgICAgaWYgKGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWF1dGhlbnRpY2F0aW9uJykgPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWF1dGhlbnRpY2F0aW9uJywgJycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXV0aGVudGljYXRpb24nLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuYXV0aGVudGljYXRpb24uY2hpbGRyZW4oJzpsYXN0LWNoaWxkJykuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRyLmF1dGhlbnRpY2F0ZWRMaW5rcy5vbignY2xpY2snLCAnPiBhJywgKGUpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRyLmFkZFZhbGlkYXRpb24oXHJcbiAgICAgICAgICAgIGxheW91dHIuYXV0aGVudGljYXRpb24uZmluZCgnLnJlZ2lzdGVyID4gZm9ybScpLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZWdpc3Rlcl91c2VybmFtZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmxlbmd0aDogMlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyX3Bhc3N3b3JkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmRfcmVnZXg6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZWdpc3Rlcl9jb25maXJtX3Bhc3N3b3JkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxUbzogXCIjcmVnaXN0ZXJfcGFzc3dvcmRcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyX2VtYWlsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJfdXNlcm5hbWU6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJQbGVhc2UgZW50ZXIgeW91ciB1c2VybmFtZVwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJfcGFzc3dvcmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJQbGVhc2UgZW50ZXIgeW91ciBwYXNzd29yZFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJfY29uZmlybV9wYXNzd29yZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBwcm92aWRlIGEgcGFzc3dvcmRcIixcclxuICAgICAgICAgICAgICAgICAgICBlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSBwYXNzd29yZCBhcyBhYm92ZVwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJfZW1haWw6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBsYXlvdXRyLmFkZFZhbGlkYXRpb24oXHJcbiAgICAgICAgICAgIGxheW91dHIuYXV0aGVudGljYXRpb24uZmluZCgnLmxvZ2luID4gZm9ybScpLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB1c2VybmFtZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB1c2VybmFtZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBlbnRlciB5b3VyIHVzZXJuYW1lXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBlbnRlciB5b3VyIHBhc3N3b3JkXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxufSIsIntcclxuICAgICQoKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuY29va2llLm9uKCdjbGljaycsICcjY29va2llLWFjY2VwdCcsICgpID0+IHtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Nvb2tpZScsICdjb29raWUnKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLnJlbW92ZUNsYXNzKCdjb29raWUnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGNvb2tpZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY29va2llXCIpO1xyXG4gICAgICAgIGlmIChjb29raWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdjb29raWUnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSIsIntcclxuICAgIGxheW91dHIubG9hZFBhZ2UgPSAodXJsLCBwdXNoU3RhdGUsIGluaXRpYWwpID0+IHtcclxuICAgICAgICBsYXlvdXRyLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgbGF5b3V0ci5sb2FkLmh0bWwoYCR7bGF5b3V0ci5ob3N0fSR7bGF5b3V0ci5hamF4fXBhZ2VzJHt1cmwgPT09ICcvJyA/ICcvaG9tZScgOiB1cmx9Lmh0bWxgKS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmNvbnRlbnQuaHRtbChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIGxldCBxID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBxICE9PSAtMSA/IHEgOiB1cmwubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5sZWZ0LmZpbmQoJy50cmVlIGEubGFiZWwuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmxlZnQuZmluZChgYS5sYWJlbFtocmVmPVwiJHt1cmx9XCJdYCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1zdGF0dXMnLCAnJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIudGl0bGUuaHRtbCgnJyk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gbGF5b3V0ci5zaXRlTmFtZTtcclxuICAgICAgICAgICAgaWYgKHVybCA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5ib2R5LmNoaWxkcmVuKCcjc3ZnLWJyb3dzZXInKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmxvYWQuaHRtbChsYXlvdXRyLmhvc3QgKyBsYXlvdXRyLmFqYXggKyAnc3ZnL2Jyb3dzZXIuaHRtbCcpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQocmVzcG9uc2UpLnByZXBlbmRUbyhsYXlvdXRyLmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ0ZhaWxlZCB0byBsb2FkIGJyb3dzZXIgc3ZnIGh0bWwnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5ib2R5LmNoaWxkcmVuKCcjc3ZnLW9zJykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5sb2FkLmh0bWwobGF5b3V0ci5ob3N0ICsgbGF5b3V0ci5hamF4ICsgJ3N2Zy9vcy5odG1sJykudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChyZXNwb25zZSkucHJlcGVuZFRvKGxheW91dHIuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgb3Mgc3ZnIGh0bWwnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBsYXlvdXRyLmNhcGl0YWxpemUodXJsLnJlcGxhY2UoJy8nLCAnJykucmVwbGFjZUFsbCgnLScsICcgJykpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci50aXRsZS5odG1sKHRpdGxlKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gYCR7dGl0bGV9IC0gJHtsYXlvdXRyLnNpdGVOYW1lfWA7XHJcbiAgICAgICAgICAgICAgICBpZiAodXJsID09PSAnL2Zvcm0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5wYWdlRm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC50cmlnZ2VyKCdoZWFkZXItY2hhbmdlZC5yZXNwb25zaXZlSGVhZGVyJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIucHJvbWlzZUNTUy50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucGFnZUxvYWRlZChpbml0aWFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkuY2F0Y2goKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGxheW91dHIubG9hZC5odG1sKGxheW91dHIuaG9zdCArIGxheW91dHIuYWpheCArICdwYWdlcy9lcnJvci5odG1sJykudGhlbigocmVzcG9uc2UyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmNvbnRlbnQuaHRtbChyZXNwb25zZTIpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtc3RhdHVzJywgJ2Vycm9yJyk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9IGAke3Jlc3BvbnNlfS0ke2xheW91dHIuc2l0ZU5hbWV9YDtcclxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IGAke3Jlc3BvbnNlfSAtIGA7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICdQYWdlIG5vdCBmb3VuZCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICdTZXJ2ZXIgZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5jb250ZW50LmZpbmQoJyNlcnJvci10aXRsZScpLmh0bWwodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLnRyaWdnZXIoJ2hlYWRlci1jaGFuZ2VkLnJlc3BvbnNpdmVIZWFkZXInKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ0ZhaWxlZCB0byBsb2FkIGNvbnRlbnQgaHRtbCcsICdkYW5nZXInKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5wcm9taXNlQ1NTLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIucGFnZUxvYWRlZChpbml0aWFsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGhpc3RvcnlVcmwgPSAobGF5b3V0ci5pc0xvY2FsaG9zdCA/ICcnIDogYC8ke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zcGxpdCgnLycpWzFdfWApICsgdXJsO1xyXG4gICAgICAgIGlmIChwdXNoU3RhdGUpIHtcclxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIGhpc3RvcnlVcmwpO1xyXG4gICAgICAgICAgICBsb2FkUGFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmludGVybmFsTGlua0NsaWNrID0gKGhyZWYsIGUpID0+IHtcclxuICAgICAgICBpZiAoIWUuY3RybEtleSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxheW91dHIubG9hZFBhZ2UoaHJlZiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcclxuICAgICAgICBsYXlvdXRyLnVybCA9IHt9O1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdi5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLnVybFthWzBdXSA9IGEuc2xpY2UoMSkuam9pbignPScpLnJlcGxhY2UoL35hbmR+L2csICcmJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGxheW91dHIudXJsLnAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zbGljZSgwLCAtMSkgKyBsYXlvdXRyLnVybC5wICtcclxuICAgICAgICAgICAgICAgIChsYXlvdXRyLnVybC5xID8gYD8ke2xheW91dHIudXJsLnF9YCA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgbG9hZFBhZ2UgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcclxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKGUpID0+IHtcclxuICAgICAgICBpZiAobG9hZFBhZ2UpIHtcclxuICAgICAgICAgICAgbGV0IHVybCA9IGxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICBpZiAoIWxheW91dHIuaXNMb2NhbGhvc3QpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcodXJsLmluZGV4T2YoXCIvXCIsIHVybC5pbmRleE9mKFwiL1wiKSArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXlvdXRyLmxvYWRQYWdlKHVybCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5hcHBseU5hdmlnYXRpb24gPSAoaWQsIHZhbHVlLCBzZXQpID0+IHtcclxuICAgICAgICBpZiAoc2V0KSB7XHJcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHtcclxuICAgICAgICAgICAgICAgIFwiaWRcIjogaWQsXHJcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBleGlzdHMgPSAkLmdyZXAobGF5b3V0ci5uYXZpZ2F0aW9uLCAoZSkgPT4geyByZXR1cm4gZS5uYW1lID09PSBuYW1lOyB9KTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5uYXZpZ2F0aW9uLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvdW5kXHJcbiAgICAgICAgICAgICAgICBleGlzdHNbMF0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbmF2aWdhdGlvbicsIEpTT04uc3RyaW5naWZ5KGxheW91dHIubmF2aWdhdGlvbikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dHIubGVmdC5maW5kKGAjJHtpZH1gKS5wcm9wKCdjaGVja2VkJywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5sb2FkLmh0bWwobGF5b3V0ci5ob3N0ICsgbGF5b3V0ci5hamF4ICsgJ2xheW91dC9uYXZpZ2F0aW9uLmh0bWwnKS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmxlZnQuZmluZCgnPiAuY29udGVudCA+IGRpdicpLmh0bWwocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLm5hdmlnYXRpb25UcmVlID0gbGF5b3V0ci5sZWZ0LmZpbmQoJy50cmVlJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIubmF2aWdhdGlvbiA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJuYXZpZ2F0aW9uXCIpKTtcclxuICAgICAgICAgICAgaWYgKGxheW91dHIubmF2aWdhdGlvbiA9PT0gbnVsbCkgbGF5b3V0ci5uYXZpZ2F0aW9uID0gW107XHJcbiAgICAgICAgICAgICQuZWFjaChsYXlvdXRyLm5hdmlnYXRpb24sIChpLCBlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5hcHBseU5hdmlnYXRpb24oZW50cnkuaWQsIGVudHJ5LnZhbHVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsYXlvdXRyLm5hdmlnYXRpb25UcmVlLm9uKCdjaGFuZ2UnLCAnaW5wdXRbdHlwZT1jaGVja2JveF0nLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoZWNrYm94ID0gJChlLmN1cnJlbnRUYXJnZXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gY2hlY2tib3guYXR0cignaWQnKSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoZWNrYm94LmlzKCc6Y2hlY2tlZCcpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5hcHBseU5hdmlnYXRpb24oaWQsIHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxheW91dHIuaGVhZGVyLmZpbmQoJy5hc2lkZS5sZWZ0JykuYWRkQ2xhc3MoJ2xvYWRlZCcpO1xyXG4gICAgICAgICAgICBpZiAobGF5b3V0ci51cmwgJiYgbGF5b3V0ci51cmwucCkge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5uYXZpZ2F0aW9uVHJlZS5maW5kKGBhLmxhYmVsW2hyZWY9XCIke2xheW91dHIudXJsLnB9XCJdYCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5uYXZpZ2F0aW9uVHJlZS5maW5kKCdhLmxhYmVsW2hyZWY9XCJcIl0nKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLnNob3dQb3B1cEFsZXJ0KCdGYWlsZWQgdG8gbG9hZCBuYXZpZ2F0aW9uIGh0bWwnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChsYXlvdXRyLnVybCAmJiBsYXlvdXRyLnVybC5wKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIubG9hZFBhZ2UobGF5b3V0ci51cmwucCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGwgPSB3aW5kb3cubG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50Q291bnQgPSBsLm9yaWdpbi5lbmRzV2l0aCgnZ2l0aHViLmlvJykgPyAxIDogMCxcclxuICAgICAgICAgICAgICAgIHVybCA9IGAvJHtsLnBhdGhuYW1lLnNsaWNlKDEpLnNwbGl0KCcvJykuc2xpY2Uoc2VnbWVudENvdW50KX1gO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmxvYWRQYWdlKHVybCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxheW91dHIubGVmdC5vbignY2xpY2snLCAnLnRyZWUgYS5sYWJlbDpub3QoLmFjdGl2ZSknLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmludGVybmFsTGlua0NsaWNrKCQoZS5jdXJyZW50VGFyZ2V0KS5hdHRyKCdocmVmJyksIGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRyLmJvZHkub24oJ2NsaWNrJywgJy5pbnRlcm5hbC1saW5rJywgKGUpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci5pbnRlcm5hbExpbmtDbGljaygkKGUuY3VycmVudFRhcmdldCkuYXR0cignaHJlZicpLCBlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGF5b3V0ci5sZWZ0Lm9uKCdjbGljaycsICcjbmF2aWdhdGlvbi1leHBhbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxheW91dHIubmF2aWdhdGlvblRyZWUuZmluZCgnaW5wdXRbdHlwZT1jaGVja2JveF06bm90KDpjaGVja2VkKScpLmNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxheW91dHIubGVmdC5vbignY2xpY2snLCAnI25hdmlnYXRpb24tY29sbGFwc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxheW91dHIubmF2aWdhdGlvblRyZWUuZmluZCgnaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCcpLmNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSIsIntcclxuICAgIGxheW91dHIuYXBwbHlTZXR0aW5ncyA9IChpZCwgbmFtZSwgdHlwZSwgdmFsdWUsIHNldCkgPT4ge1xyXG4gICAgICAgIGlmIChzZXQpIHtcclxuICAgICAgICAgICAgbGV0IGVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgXCJpZFwiOiBpZCxcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBleGlzdHMgPSAkLmdyZXAobGF5b3V0ci5zZXR0aW5ncywgKGUpID0+IHsgcmV0dXJuIGUubmFtZSA9PT0gbmFtZTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChleGlzdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgZm91bmRcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2V0dGluZ3MucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZm91bmRcclxuICAgICAgICAgICAgICAgIGV4aXN0c1swXS5pZCA9IGlkO1xyXG4gICAgICAgICAgICAgICAgZXhpc3RzWzBdLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkobGF5b3V0ci5zZXR0aW5ncykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImNoZWNrYm94XCIgfHwgdHlwZSA9PT0gXCJyYWRpb1wiKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnJpZ2h0LmZpbmQoYCNzZXR0aW5ncy0ke2lkfWApLnByb3AoJ2NoZWNrZWQnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzbGlkZXJcIikge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5yaWdodC5maW5kKGAjc2V0dGluZ3MtJHtpZH1gKS5zbGlkZXIoJ3NldFZhbHVlJywgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09IFwicmFkaW9cIikge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKGxheW91dHIucmlnaHQuZmluZChgaW5wdXRbdHlwZT1yYWRpb11bbmFtZT1cInNldHRpbmdzLSR7bmFtZX1cIl06bm90KCNzZXR0aW5ncy0ke2lkfSlgKSwgKGksIHJhZGlvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLnJlbW92ZUNsYXNzKCQocmFkaW8pLmF0dHIoJ2lkJykucmVwbGFjZSgnc2V0dGluZ3MtJywgJycpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAndGhlbWUnKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmxvYWRUaGVtZShpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdmb2N1cycgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuZW5hYmxlRm9jdXMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndHRzJyAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy9sYXlvdXRyLmVuYWJsZVRUUygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzd2lwZScgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuZW5hYmxlU3dpcGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcyhpZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwucmVtb3ZlQ2xhc3MoaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3R3by1jb2x1bW5zJykge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLnRyaWdnZXIoJ2NvbHVtbnMtY2hhbmdlZC5yYicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3NpZ25lZC1pbicgfHwgaWQgPT09ICdmb2N1cycgfHwgaWQgPT09ICd0dHMnKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwudHJpZ2dlcignaGVhZGVyLWNoYW5nZWQucmVzcG9uc2l2ZUhlYWRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnYXNpZGUtbGVmdCcgfHwgJ2FzaWRlLXJpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5hc2lkZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5sb2FkLmh0bWwobGF5b3V0ci5ob3N0ICsgbGF5b3V0ci5hamF4ICsgJ2xheW91dC9zZXR0aW5ncy5odG1sJykudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgbGV0ICR0aGlzID0gbGF5b3V0ci5yaWdodC5maW5kKCc+IC5jb250ZW50ID4gZGl2Jyk7XHJcbiAgICAgICAgICAgICR0aGlzLmh0bWwocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLnByb21pc2VDU1MudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2gobGF5b3V0ci5zZXR0aW5ncywgKGksIGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5hcHBseVNldHRpbmdzKGVudHJ5LmlkLCBlbnRyeS5uYW1lLCBlbnRyeS50eXBlLCBlbnRyeS52YWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmhlYWRlci5maW5kKCcuYXNpZGUucmlnaHQnKS5hZGRDbGFzcygnbG9hZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5vbignY2hhbmdlJywgJ2lucHV0W3R5cGU9Y2hlY2tib3hdLCBpbnB1dFt0eXBlPXJhZGlvXScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlucHV0ID0gJChlLmN1cnJlbnRUYXJnZXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGlucHV0LmF0dHIoJ2lkJykucmVwbGFjZSgnc2V0dGluZ3MtJywgJycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gaW5wdXQuYXR0cignbmFtZScpLnJlcGxhY2UoJ3NldHRpbmdzLScsICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGlucHV0LmF0dHIoJ3R5cGUnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC5pcygnOmNoZWNrZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmFwcGx5U2V0dGluZ3MoaWQsIG5hbWUsIHR5cGUsIHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09ICdsZWZ0LXNocmluaycgfHwgaWQgPT09ICdyaWdodC1zaHJpbmsnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID09PSAnbGVmdC1wdXNoJyB8fCBpZCA9PT0gJ3JpZ2h0LXB1c2gnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID09PSAnbGVmdC1vdmVybGF5JyB8fCBpZCA9PT0gJ3JpZ2h0LW92ZXJsYXknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc2V0SHRtbFNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXRyLnNob3dQb3B1cEFsZXJ0KCdGYWlsZWQgdG8gbG9hZCBzZXR0aW5ncyBodG1sJywgJ2RhbmdlcicpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRyLnJpZ2h0Lm9uKCdjbGljaycsICcjc2V0dGluZ3MtY2xlYXItbG9jYWxzdG9yYWdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSIsIntcclxuICAgICQoKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuYm9keS5vbihcImtleWRvd25cIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS50YXJnZXQpLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICBpZiAobGF5b3V0ci5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDkgfHwgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gNjUpIHsgLy8gdGFiIHx8ICBjdHJsICsgYVxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAzNyAmJiAhbGF5b3V0ci5pc0ZvY3VzKCkgJiYgIWxheW91dHIuaXNNb2RhbCgpKSB7IC8vIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxheW91dHIuYXJyb3dLZXlMb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dHIuaXNBc2lkZUxlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgpOyAvLyBjbG9zZXMgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbGF5b3V0ci5pc0FzaWRlUmlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgncmlnaHQnKTsgLy8gb3BlbnMgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gMzkgJiYgIWxheW91dHIuaXNGb2N1cygpICYmICFsYXlvdXRyLmlzTW9kYWwoKSkgeyAvLyByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5b3V0ci5hcnJvd0tleUxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5pc0FzaWRlUmlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgpOyAvLyBjbG9zZXMgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFsYXlvdXRyLmlzQXNpZGVMZWZ0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIudG9nZ2xlQXNpZGUoJ2xlZnQnKTsgLy8gb3BlbnMgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSAyNykgeyAvLyBlc2NcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRyLnR0cyAhPT0gdW5kZWZpbmVkICYmIGxheW91dHIudHRzLklzU3BlYWtpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnN0b3BUVFMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dHIuaXNGb2N1cygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuaGlkZUZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXRyLmlzTW9kYWwoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNsb3NlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5pc0FzaWRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIudG9nZ2xlQXNpZGUoKTsgLy8gY2xvc2VzIGFzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcHVwcyA9IGxheW91dHIuYm9keS5jaGlsZHJlbignLnBvcHVwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3B1cHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cHMuZmFkZU91dChsYXlvdXRyLmZhZGVPdXRUaW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRyb3Bkb3ducyA9IGxheW91dHIuY29udGVudC5maW5kKCdkaXYuZHJvcGRvd24ub3BlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcGRvd25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25zLnJlbW92ZUNsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXV0aGVudGljYXRpb24nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7IC8vIGVudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyb3Bkb3duID0gdGFyZ2V0LnBhcmVudHMoJ2Rpdi5kcm9wZG93bicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wZG93bi5sZW5ndGggfHwgcGFyZW50LnBhcmVudCgpLmhhc0NsYXNzKCdhY2NvcmRpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcGRvd24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5jaGlsZHJlbignZGl2JykuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50Lmhhc0NsYXNzKCdjaGVja2JveCcpIHx8IHBhcmVudC5oYXNDbGFzcygncmFkaW8nKSB8fCBwYXJlbnQuaGFzQ2xhc3MoJ3N3aXRjaCcpIHx8IHRhcmdldC5oYXNDbGFzcygndG9nZ2xlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNpYmxpbmdzKCdpbnB1dCcpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGF5b3V0ci5ib2R5Lm9uKCdrZXl1cCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbGF5b3V0ci5pc0xvYWRpbmcoKSAmJiAhbGF5b3V0ci5pc0ZvY3VzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSA5KSB7IC8vIHRhYlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5wYXJlbnRzKCdkaXYuZHJvcGRvd24ub3BlbicpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCdkaXYuZHJvcGRvd24ub3BlbicpLnJlbW92ZUNsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LnBhcmVudHMoJyNhdXRoZW50aWNhdGVkLm9wZW4nKS5sZW5ndGggfHwgdGFyZ2V0LmNsb3Nlc3QoJyNhdXRoZW50aWNhdGVkID4gYnV0dG9uJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNhdXRoZW50aWNhdGVkLm9wZW4nKS5yZW1vdmVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5pc01vZGFsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQucGFyZW50cygnI21vZGFsJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNsb3NlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc2lkZSA9IHRhcmdldC5wYXJlbnRzKCdhc2lkZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNpZGUubGVuZ3RoID09PSAwICYmIHRhcmdldC5pcygnYXNpZGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNpZGUgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzaWRlLmxlbmd0aCAmJiBhc2lkZS5hdHRyKCdpZCcpICE9PSBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hc2lkZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnRvZ2dsZUFzaWRlKGFzaWRlLmF0dHIoJ2lkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFhc2lkZS5sZW5ndGggJiYgbGF5b3V0ci5pc0FzaWRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIudG9nZ2xlQXNpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLnNob3dNb2RhbCA9ICh0eXBlKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtbW9kYWwnLCB0eXBlKTtcclxuICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ21vZGFsJyk7XHJcbiAgICAgICAgbGF5b3V0ci5oaWRlTG9hZGluZygpO1xyXG4gICAgICAgIGxheW91dHIuY2hlY2tNb2RhbCgpO1xyXG4gICAgICAgIGxheW91dHIubW9kYWwuZm9jdXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5jbG9zZU1vZGFsID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChsYXlvdXRyLmZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgbGF5b3V0ci5leGl0RnVsbFNjcmVlbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5yZW1vdmVDbGFzcygnbW9kYWwnKS5hdHRyKCdkYXRhLW1vZGFsJywgJycpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLm1vZGFsLnJlbW92ZUNsYXNzKCdpbmZvLXNob3duJykuZW1wdHkoKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5jaGVja01vZGFsKCk7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2V0SHRtbFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGF5b3V0ci5jaGVja01vZGFsID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChsYXlvdXRyLmlzTW9kYWwoKSkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgbGF5b3V0ci5zY3JvbGxiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChsYXlvdXRyLmh0bWwuYXR0cignZGF0YS1hc2lkZScpID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnJpZ2h0LmNzcygnbWFyZ2luLXJpZ2h0JywgbGF5b3V0ci5zY3JvbGxiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGF5b3V0ci5ib2R5LmNoaWxkcmVuKCcucG9wdXAnKS5jc3MoJ21hcmdpbi1yaWdodCcsIGxheW91dHIuc2Nyb2xsYmFyV2lkdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCAwKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5yaWdodC5jc3MoJ21hcmdpbi1yaWdodCcsIDApO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmJvZHkuY2hpbGRyZW4oJy5wb3B1cCcpLmNzcygnbWFyZ2luLXJpZ2h0JywgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxheW91dHIuaHRtbC50cmlnZ2VyKCdtb2RlbC1jaGVjaycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkKCgpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmJvZHkub24oJ2NsaWNrJywgJy5tb2RhbCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZS5jdXJyZW50VGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgIHR5cGUgPSAkdGhpcy5hdHRyKCdkYXRhLW1vZGFsJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5sZW5ndGggJiYgKHR5cGUgPT09ICdpbWFnZScgfHwgdHlwZSA9PT0gJ2Zvcm0nKSkge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93TG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gJHRoaXMuYXR0cignZGF0YS1tb2RhbC1pZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUaXRsZSA9ICR0aGlzLmF0dHIoJ2RhdGEtbW9kYWwtdGl0bGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhQ29udGVudCA9ICR0aGlzLmF0dHIoJ2RhdGEtbW9kYWwtY29udGVudCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFGdWxsc2NyZWVuID0gJHRoaXMuYXR0cignZGF0YS1tb2RhbC1mdWxsc2NyZWVuJykgPT09ICd0cnVlJztcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbWFnZScgJiYgJHRoaXMuYXR0cignZGF0YS1tb2RhbC1pbWcnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUaXRsZSAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIubW9kYWwuYWRkQ2xhc3MoJ2hhcy1pbmZvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXHJcbmAke2RhdGFUaXRsZSAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDb250ZW50ICE9PSB1bmRlZmluZWQgPyBgXHJcbjxidXR0b24gaWQ9XCJtb2RhbC10b2dnbGVcIiBjbGFzcz1cImJ0blwiIGFyaWEtbGFiZWw9XCJUb2dnbGUgaW5mb1wiPlxyXG4gICAgPHN2ZyBmb2N1c2FibGU9XCJmYWxzZVwiPjx1c2UgeGxpbms6aHJlZj1cIiNzdmctaW5mb1wiPjwvdXNlPjwvc3ZnPlxyXG48L2J1dHRvbj5cclxuJHtkYXRhVGl0bGUgIT09IHVuZGVmaW5lZCA/IGA8ZGl2IGlkPVwibW9kYWwtdGl0bGVcIj4ke2RhdGFUaXRsZX08L2Rpdj5gIDogJyd9XHJcbiR7ZGF0YUNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IGA8ZGl2IGlkPVwibW9kYWwtY29udGVudFwiPiR7ZGF0YUNvbnRlbnR9PC9kaXY+YCA6ICcnfVxyXG5gIDogJyd9XHJcbjxpbWcgaWQ9XCJtb2RhbC1pbWdcIiAvPmA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZm9ybScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXHJcbmA8ZGl2IGNsYXNzPVwiaGVhZGVyXCI+XHJcbiAgICAke2RhdGFUaXRsZSAhPT0gdW5kZWZpbmVkID8gYDxzcGFuIGNsYXNzPVwidGl0bGVcIj4ke2RhdGFUaXRsZX08L3NwYW4+YCA6ICcnfVxyXG4gICAgPGJ1dHRvbiBpZD1cIm1vZGFsLWNsb3NlXCIgY2xhc3M9XCJjbG9zZSBleHBhbmRcIiBhcmlhLWxhYmVsPVwiQ2xvc2UgJHtkYXRhVGl0bGUgIT09IHVuZGVmaW5lZCA/IGRhdGFUaXRsZSA6ICcnfVwiPlxyXG4gICAgICAgIDxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWNsb3NlXCI+PC91c2U+PC9zdmc+XHJcbiAgICA8L2J1dHRvbj5cclxuPC9kaXY+XHJcbjxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbjwvZGl2PmA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBodG1sID0gXHJcbmA8ZGl2PlxyXG4gICAgPGRpdj5cclxuICAgICAgICA8ZGl2IGlkPVwibW9kYWwtY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICR7dGVtcGxhdGUoKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L2Rpdj5gO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5tb2RhbC5odG1sKGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2UgPSBsYXlvdXRyLm1vZGFsLmZpbmQoJyNtb2RhbC1pbWcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvd3Nlci5hbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5jc3MoJ21heC1oZWlnaHQnLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd01vZGFsKHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmF0dHIoJ3NyYycsICR0aGlzLmF0dHIoJ2RhdGEtbW9kYWwtaW1nJykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVNpemUgPSAkdGhpcy5hdHRyKCdkYXRhLW1vZGFsLXNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVNpemUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLm1vZGFsLmNoaWxkcmVuKCdkaXYnKS5hdHRyKCdkYXRhLW1vZGFsLXNpemUnLCBkYXRhU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gbGF5b3V0ci5tb2RhbC5maW5kKCcjbW9kYWwtY29udGFpbmVyID4gLmNvbnRlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZChkYXRhQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5jb250ZW50TG9hZGVkKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd01vZGFsKHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFGdWxsc2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5yZXF1ZXN0RnVsbFNjcmVlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxheW91dHIuYm9keS5vbignY2xpY2snLCAnI21vZGFsLXRvZ2dsZScsICgpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci5tb2RhbC50b2dnbGVDbGFzcygnaW5mby1zaG93bicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLnJlc3BvbnNpdmVIZWFkZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGgxID0gbGF5b3V0ci5oZWFkZXIuZmluZCgnaDEnKSxcclxuICAgICAgICAgICAgbGluayA9IGgxLmNoaWxkcmVuKCdhJyk7XHJcblxyXG4gICAgICAgIGxldCBjaGVjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgaDEuYWRkQ2xhc3MoJ3Nob3ctdGl0bGUnKTtcclxuICAgICAgICAgICAgbGF5b3V0ci51bmF1dGhlbnRpY2F0ZWQuYWRkQ2xhc3MoJ3Nob3ctdGV4dCcpO1xyXG4gICAgICAgICAgICBpZiAoaDEub3V0ZXJXaWR0aCgpIDwgbGluay5vdXRlcldpZHRoKCkpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIudW5hdXRoZW50aWNhdGVkLnJlbW92ZUNsYXNzKCdzaG93LXRleHQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChoMS5vdXRlcldpZHRoKCkgPCBsaW5rLm91dGVyV2lkdGgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGgxLnJlbW92ZUNsYXNzKCdzaG93LXRpdGxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsICgpID0+IHtcclxuICAgICAgICAgICAgY2hlY2soKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2hlY2soKTtcclxuXHJcbiAgICAgICAgbGF5b3V0ci5odG1sLm9uKCdoZWFkZXItY2hhbmdlZC5yZXNwb25zaXZlSGVhZGVyJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjaGVjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufSIsIntcclxuICAgIGxheW91dHIuZW5hYmxlRm9jdXMgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IGxheW91dHIuZm9jdXMuZmluZCgnPiAuY29tcG9uZW50ID4gZGl2Jyk7XHJcblxyXG4gICAgICAgIGlmICghbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdmb2N1cy1sb2FkZWQnKSkge1xyXG4gICAgICAgICAgICBsYXlvdXRyLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIGxheW91dHIucHJvbWlzZUZvY3VzID0gbGF5b3V0ci5sb2FkLmpzKCdkaXN0L2pzL2ZvY3VzLmpzJykuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ2ZvY3VzLWxvYWRlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGF5b3V0ci5wcm9taXNlRm9jdXMudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgLmRyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpczogXCJ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6IFwicGFyZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBcIi5tb3ZlXCJcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAucmVzaXphYmxlKHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG46ICcudWktcmVzaXphYmxlLW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzOiAnLnVpLXJlc2l6YWJsZS1zJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWluSGVpZ2h0OiA1MCxcclxuICAgICAgICAgICAgICAgICAgICBjb250YWlubWVudDogXCJwYXJlbnRcIlxyXG4gICAgICAgICAgICAgICAgfSkub24oJ3Jlc2l6ZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGF5b3V0ci5mb2N1cy5vbignY2xpY2snLCAnLmNsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5oaWRlRm9jdXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLm1haW4uZmluZCgnLmZvY3VzJykuY2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93Rm9jdXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xyXG4gICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGhlaWdodCBpcyB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgICAgaWYgKCQod2luZG93KS5oZWlnaHQoKSA9PT0gaGVpZ2h0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucmVtb3ZlQXR0cignc3R5bGUnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgZm9jdXMnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dHIuc2hvd0ZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWF1dGhlbnRpY2F0aW9uJywgJycpO1xyXG4gICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWZvY3VzJywgdHJ1ZSk7XHJcbiAgICAgICAgbGF5b3V0ci5mb2N1cy5mb2N1cygpO1xyXG4gICAgfTtcclxuICAgIGxheW91dHIuaGlkZUZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBsYXlvdXRyLnNjcm9sbFRvcCgpO1xyXG4gICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLWZvY3VzJywgZmFsc2UpO1xyXG4gICAgICAgIGxheW91dHIubWFpbi5mb2N1cygpO1xyXG4gICAgICAgIGxheW91dHIuYm9keS5zY3JvbGxUb3Aoc2Nyb2xsVG9wKTsgLy8gZWRnZSwgc2FmYXJpXHJcbiAgICAgICAgbGF5b3V0ci5odG1sLnNjcm9sbFRvcChzY3JvbGxUb3ApOyAvLyBjaHJvbWUsIGZpcmVmb3gsIGllXHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5lbmFibGVTd2lwZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoYm93c2VyLmFuZHJvaWQpIHtcclxuICAgICAgICAgICAgbGV0IHhEb3duID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIHlEb3duID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIG9mZnNldEJlZm9yZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoYW5kbGVUb3VjaFN0YXJ0ID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXRyLmlzU3dpcGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhEb3duID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgeURvd24gPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QmVmb3JlID0gJChlLnRhcmdldCkub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoYW5kbGVUb3VjaE1vdmUgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dHIuaXNTd2lwZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldEFmdGVyID0gJChlLnRhcmdldCkub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXhEb3duIHx8ICF5RG93biB8fCBvZmZzZXRCZWZvcmUgIT09IG9mZnNldEFmdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhVcCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVVwID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4RGlmZiA9IHhEb3duIC0geFVwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5RGlmZiA9IHlEb3duIC0geVVwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4RGlmZikgPiBNYXRoLmFicyh5RGlmZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gcGFyc2VJbnQoJCh3aW5kb3cpLndpZHRoKCkgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlEaWZmID4gLTEwMCB8fCB5RGlmZiA8IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRBc2lkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4RGlmZiA+IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVmdCBzd2lwZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGF5b3V0ci5pc01vZGFsKCkgJiYgIWxheW91dHIuaXNMb2FkaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFzaWRlID0gbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXNpZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBc2lkZSA9PT0gJ2xlZnQnICYmIGN1cnJlbnRBc2lkZSAhPT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRBc2lkZSAhPT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgncmlnaHQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeERpZmYgPCAtZGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByaWdodCBzd2lwZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGF5b3V0ci5pc01vZGFsKCkgJiYgIWxheW91dHIuaXNMb2FkaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFzaWRlID0gbGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtYXNpZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBc2lkZSA9PT0gJ3JpZ2h0JyAmJiBjdXJyZW50QXNpZGUgIT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci50b2dnbGVBc2lkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRBc2lkZSAhPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLnRvZ2dsZUFzaWRlKCdsZWZ0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8qIHJlc2V0IHZhbHVlcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHhEb3duID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB5RG93biA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hNb3ZlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSIsIntcclxuICAgIGxheW91dHIuY2xlYXJTZWxlY3Rpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLnN0b3BUVFMgPSAoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5jbGVhclNlbGVjdGlvbigpO1xyXG4gICAgICAgIGlmIChsYXlvdXRyLnR0cyAmJiBsYXlvdXRyLnR0cy5Jc1NwZWFraW5nKCkpIHtcclxuICAgICAgICAgICAgbGF5b3V0ci50dHMuU2h1dFVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmVuYWJsZVRUUyA9ICgpID0+IHtcclxuICAgICAgICBpZiAoYm93c2VyLmRlc2t0b3ApIHtcclxuICAgICAgICAgICAgbGV0IHNuYXBTZWxlY3Rpb25Ub1dvcmQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkIHx8IHJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdCBmdWxsIHN0YXJ0IHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnN0YXJ0T2Zmc2V0ID4gMCAmJiByYW5nZS50b1N0cmluZygpWzBdLm1hdGNoKC9bXlxcc10vKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFzIGZpcnN0IHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmRhdGEuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0T2Zmc2V0KS5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdCBmdWxsIGVuZCB3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS5lbmRPZmZzZXQgPCByYW5nZS5lbmRDb250YWluZXIubGVuZ3RoICYmIHJhbmdlLnRvU3RyaW5nKClbcmFuZ2UudG9TdHJpbmcoKS5sZW5ndGggLSAxXS5tYXRjaCgvW15cXHNdLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzcGFjZSBhcyBsYXN0IHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZS5lbmRDb250YWluZXIuZGF0YS5zdWJzdHJpbmcoMCwgcmFuZ2UuZW5kT2Zmc2V0KS5zbGljZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBsZXQgZ2V0VGV4dCA9IChub2RlLCBzZWxlY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbm9uV2hpdGVzcGFjZU1hdGNoZXIgPSAvXFxTLyxcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXh0Tm9kZXMgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gJChub2RlLnBhcmVudE5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5jb250YWluc05vZGUobm9kZSwgZmFsc2UpICYmIChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykgJiYgbm9uV2hpdGVzcGFjZU1hdGNoZXIudGVzdChub2RlLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3BlY2lhbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmNvbnRhaW5zTm9kZShub2RlLCB0cnVlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uV2hpdGVzcGFjZU1hdGNoZXIudGVzdChub2RlLm5vZGVWYWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pcygnOnZpc2libGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNzcygndXNlci1zZWxlY3QnKSAhPT0gJ25vbmUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50cygpLmNzcygndXNlci1zZWxlY3QnKSAhPT0gJ25vbmUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzZWxlY3Rpb24uZXh0ZW50Tm9kZS5ub2RlVHlwZSAhPT0gMyAmJiAkKHNlbGVjdGlvbi5leHRlbnROb2RlKS5pcyhwYXJlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5ub2RlVmFsdWUubWF0Y2goL1xcLlxccyokLykgJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgPT09IG51bGwgJiYgcGFyZW50LmlzKCdoMSBzcGFuLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwLCB0aCwgdGQsIC5kYXRhVGFibGUgdGggc3BhbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLm5vZGVWYWx1ZSArICcuICcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLm5vZGVWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoc2VsZWN0aW9uLmFuY2hvck5vZGUpLmlzKHNlbGVjdGlvbi5mb2N1c05vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRbMF0gPSB0ZXh0WzBdLnN1YnN0cmluZygwLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpLnN1YnN0cmluZyhzZWxlY3Rpb24uYmFzZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFswXSA9IHRleHRbMF0uc3Vic3RyaW5nKHNlbGVjdGlvbi5iYXNlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRbMF0gPT09ICcuICcgfHwgdGV4dFswXSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRbMF0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFRleHROb2Rlcyhub2RlLmNoaWxkTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZXRUZXh0Tm9kZXMobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggJiYgdGV4dC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID0gdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdLnN1YnN0cmluZygwLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuam9pbignICcpLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCAnICcpLnJlcGxhY2UoLyArXFwuL2csICcuICcpLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKS5yZXBsYWNlKCcsLicsICcuJykudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWxheW91dHIuaHRtbC5oYXNDbGFzcygndHRzLWxvYWRlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLlByb21pc2VUVFMgPSBsYXlvdXRyLmxvYWQuanMoJ2Rpc3QvanMvdHRzLmpzJykuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5oaWRlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ3R0cy1sb2FkZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXlvdXRyLlByb21pc2VUVFMudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXdzQ3JlZGVudGlhbHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKCdBS0lBSTVKTUNWQlo0Q1dTU09PUScsICdGTTdqOUZiUUxrVVU4dTN0SFNjdjBJT0c0SW9heVVrcC9STk5OTm5pJyksXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3c0NyZWRlbnRpYWxzOiBhd3NDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdzUmVnaW9uOiAnZXUtY2VudHJhbC0xJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbHlWb2ljZUlkOiAnUnVzc2VsbCdcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGxheW91dHIudHRzID0gQ2hhdHR5S2F0aHkoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLXR0cycsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbignbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5b3V0ci5pc0xvYWRpbmcoKSAmJiAhbGF5b3V0ci5pc0ZvY3VzKCkgJiYgbGF5b3V0ci5pc1RUUygpICYmIGxheW91dHIuaXNUVFNFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5jbGVhclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbignbW91c2V1cCB0b3VjaGVuZCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKCdpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0LCAuZHJvcGRvd24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxheW91dHIuaXNMb2FkaW5nKCkgJiYgIWxheW91dHIuaXNGb2N1cygpICYmIGxheW91dHIuaXNUVFMoKSAmJiBsYXlvdXRyLmlzVFRTRW5hYmxlZCgpICYmIGUub3JpZ2luYWxFdmVudC5kZXRhaWwgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gc25hcFNlbGVjdGlvblRvV29yZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZ2V0VGV4dChzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lciwgc2VsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIudHRzLlNwZWFrV2l0aFByb21pc2UodGV4dCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNsZWFyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc3RvcFRUUygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5oZWFkZXIuZmluZCgnLnR0cycpLmNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0ci5odG1sLmF0dHIoJ2RhdGEtdHRzJykgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYXR0cignZGF0YS10dHMnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc3RvcFRUUygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hdHRyKCdkYXRhLXR0cycsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgdHRzJywgJ2RhbmdlcicpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSIsIntcclxuICAgICQoKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuaHRtbC5vbignbW9kZWwtY2hlY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50SGVhZGVyID0gbGF5b3V0ci5jb250ZW50LmNoaWxkcmVuKCcuY29udGVudC1oZWFkZXI6bm90KC5mdWxsKScpO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudEhlYWRlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXRyLmlzTW9kYWwoKSAmJiBjb250ZW50SGVhZGVyLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYWxmT3ZlcmZsb3dZID0gbGF5b3V0ci5zY3JvbGxiYXJXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhlYWRlci5jaGlsZHJlbigpLmNzcygnd2lkdGgnLCBgY2FsYygxMDAlIC0gJHtoYWxmT3ZlcmZsb3dZfXB4KWApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGVhZGVyLmNoaWxkcmVuKCkuY3NzKCd3aWR0aCcsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICAvL2xheW91dHIubG9hZFRoZW1lID0gKGlkKSA9PiB7XHJcbiAgICAvLyAgICBsZXQgc3R5bGVzaGVldCA9IGxheW91dHIuYm9keS5jaGlsZHJlbihgbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdW2hyZWZePVwiJHtsYXlvdXRyLmhvc3R9ZGlzdC9jc3MvdGhlbWUvXCJdYCksXHJcbiAgICAvLyAgICAgICAgaHJlZjEgPSBzdHlsZXNoZWV0LmF0dHIoJ2hyZWYnKSxcclxuICAgIC8vICAgICAgICBzcGxpdDEgPSBocmVmMS5zcGxpdCgnLycpLFxyXG4gICAgLy8gICAgICAgIHNwbGl0MiA9IHNwbGl0MVtzcGxpdDEubGVuZ3RoIC0gMV0uc3BsaXQoJy4nKTtcclxuICAgIC8vICAgIGxldCBocmVmMiA9IFtdO1xyXG4gICAgLy8gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdDEubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAvLyAgICAgICAgaHJlZjIucHVzaChzcGxpdDFbaV0gKyAnLycpO1xyXG4gICAgLy8gICAgfVxyXG4gICAgLy8gICAgbGV0IHRoZW1lID0gaWQuc3Vic3RyaW5nKGlkLmluZGV4T2YoXCItXCIpICsgMSk7XHJcbiAgICAvLyAgICBocmVmMi5wdXNoKHRoZW1lKTtcclxuXHJcbiAgICAvLyAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwbGl0Mi5sZW5ndGg7IGkrKykge1xyXG4gICAgLy8gICAgICAgIGhyZWYyLnB1c2goYC4ke3NwbGl0MltpXX1gKTtcclxuICAgIC8vICAgIH1cclxuICAgIC8vICAgIGhyZWYyID0gaHJlZjIuam9pbihcIlwiKTtcclxuICAgIC8vICAgIGlmIChocmVmMSAhPT0gaHJlZjIpIHtcclxuICAgIC8vICAgICAgICBsYXlvdXRyLnNob3dMb2FkaW5nKCk7XHJcbiAgICAvLyAgICAgICAgbGF5b3V0ci5sb2FkLmNzcyhocmVmMikudGhlbigoKSA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgIHN0eWxlc2hlZXQucmVtb3ZlKCk7XHJcbiAgICAvLyAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgIC8vICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgdGhlbWUnLCAnZGFuZ2VyJyk7XHJcbiAgICAvLyAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAvLyAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgIGxheW91dHIuaGlkZUxvYWRpbmcoKTtcclxuICAgIC8vICAgICAgICB9KTtcclxuICAgIC8vICAgIH1cclxuICAgIC8vfTtcclxuXHJcbiAgICAkKCgpID0+IHtcclxuICAgICAgICBsZXQgYm9keSA9ICQoXCJib2R5XCIpLFxyXG4gICAgICAgICAgICBjb2xvcnMgPSBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JsdWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnIzAwNzJFRCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2luZGlnbycsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcjNjYxMGYyJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHVycGxlJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ8K0IzZmNDJjMSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BpbmsnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnI2U4M2U4YydcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcjZGMzNTQ1J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb3JhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJyNCRTVBMDYnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd5ZWxsb3cnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnI2ZmYzEwNydcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dyZWVuJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJyMyMTg4MzgnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZWFsJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJyMyMGM5OTcnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjeWFuJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJyMxMzgyOTQnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgbGV0IHRoZW1lTGlnaHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdsaWdodCcsXHJcbiAgICAgICAgICAgIGhvdmVyOiA3LjUsXHJcbiAgICAgICAgICAgIGJvZHk6ICcjZjFmMWYxJyxcclxuICAgICAgICAgICAgZ3JheXM6IFtcclxuICAgICAgICAgICAgICAgIFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgXCIjZjhmOWZhXCIsXHJcbiAgICAgICAgICAgICAgICBcIiNlOWVjZWZcIixcclxuICAgICAgICAgICAgICAgIFwiI2RlZTJlNlwiLFxyXG4gICAgICAgICAgICAgICAgXCIjY2VkNGRhXCIsXHJcbiAgICAgICAgICAgICAgICBcIiNhZGI1YmRcIixcclxuICAgICAgICAgICAgICAgIFwiIzZGNzc4MFwiLFxyXG4gICAgICAgICAgICAgICAgXCIjNDk1MDU3XCIsXHJcbiAgICAgICAgICAgICAgICBcIiMzNDNhNDBcIixcclxuICAgICAgICAgICAgICAgIFwiIzIxMjUyOVwiLFxyXG4gICAgICAgICAgICAgICAgXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgY29sb3JzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJwcmltYXJ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiBjb2xvcnMuZmluZCh4ID0+IHgubmFtZSA9PT0gJ2JsdWUnKS52YWx1ZSB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2Vjb25kYXJ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiB0aGVtZUxpZ2h0LmdyYXlzWzZdIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiBjb2xvcnMuZmluZCh4ID0+IHgubmFtZSA9PT0gJ2dyZWVuJykudmFsdWUgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImluZm9cIixcclxuICAgICAgICAgICAgICAgICAgICBoZXg6ICgpID0+IHsgcmV0dXJuIGNvbG9ycy5maW5kKHggPT4geC5uYW1lID09PSAnY3lhbicpLnZhbHVlIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ3YXJuaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiBjb2xvcnMuZmluZCh4ID0+IHgubmFtZSA9PT0gJ29yYW5nZScpLnZhbHVlIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJkYW5nZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBoZXg6ICgpID0+IHsgcmV0dXJuIGNvbG9ycy5maW5kKHggPT4geC5uYW1lID09PSAncmVkJykudmFsdWUgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImxpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiB0aGVtZUxpZ2h0LmdyYXlzWzFdIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJkYXJrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4OiAoKSA9PiB7IHJldHVybiB0aGVtZUxpZ2h0LmdyYXlzWzhdIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHRoZW1lcyA9IFtcclxuICAgICAgICAgICAgdGhlbWVMaWdodFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMgaW5zaWRlXHJcbiAgICAgICAgICAgIC8vIHRoZSBhcnJheSwgeW91IHNob3VsZCBzb3J0IGJvdGggYXJyYXlzIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIFBsZWFzZSBub3RlIHRoYXQgY2FsbGluZyBzb3J0IG9uIGFuIGFycmF5IHdpbGwgbW9kaWZ5IHRoYXQgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vIHlvdSBtaWdodCB3YW50IHRvIGNsb25lIHlvdXIgYXJyYXkgZmlyc3QuXHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmdiQWxwaGEgPSAocmdiLCBwZXJjZW50YWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2IubWFwKGQgPT4gKGQgKz0gcGVyY2VudGFnZSkgPCAwID8gMCA6IGQgPiAyNTUgPyAyNTUgOiBkIHwgMCk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIGxldCB5aXEgPSByZ2IgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiWzBdICogMC4yOTkgKyByZ2JbMV0gKiAwLjU4NyArIHJnYlsyXSAqIDAuMTE0ID4gMTQ1ID8gWyAwLCAwLCAwIF0gOiBbIDI1NSwgMjU1LCAyNTUgXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgbGlnaHRlbiA9IChyZ2IsIHBlcmNlbnQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJnYkFscGhhKHJnYiwgcGVyY2VudCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IGRhcmtlbiA9IChyZ2IsIHBlcmNlbnQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJnYkFscGhhKHJnYiwgLXBlcmNlbnQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxldCBib3JkZXIgPSAoY29sb3IsIHlpcSwgcGVyY2VudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlzRXF1YWwoeWlxLCBbMCwgMCwgMF0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGFya2VuKGNvbG9yLCBwZXJjZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaWdodGVuKGNvbG9yLCBwZXJjZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxldCBoZXhUb1JnYiA9IChoZXgpID0+IHtcclxuICAgICAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoJyMnLCAnJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNiksXHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNiksXHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChoZXguc3Vic3RyaW5nKDQsIDYpLCAxNilcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgbGV0IGxvYWRUaGVtZSA9IChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0aGVtZSA9IHRoZW1lcy5maW5kKHggPT4geC5uYW1lID09PSBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaCh0aGVtZS5ncmF5cywgKGksIGdyYXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGJvZHkuY3NzKGAtLWdyYXktJHtpICogMTB9YCwgaGV4VG9SZ2IoZ3JheSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJC5lYWNoKHRoZW1lLmNvbG9ycywgKGksIGNvbG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmdiID0gaGV4VG9SZ2IoY29sb3IuaGV4KCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2YXJpYW50cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJnYlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGVmYXVsdC1ob3ZlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZ2JBbHBoYShyZ2IsIHRoZW1lLmhvdmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhcmlhbnRzLCAoaiwgdmFyaWFudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29sb3IgPSB5aXEodmFyaWFudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5jc3MoYC0tJHtjb2xvci5uYW1lfS0ke3ZhcmlhbnQubmFtZX0tYmFja2dyb3VuZGAsIHZhcmlhbnQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuY3NzKGAtLSR7Y29sb3IubmFtZX0tJHt2YXJpYW50Lm5hbWV9LXRleHRgLCB0ZXh0Q29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuY3NzKGAtLSR7Y29sb3IubmFtZX0tJHt2YXJpYW50Lm5hbWV9LWJvcmRlcmAsIGJvcmRlcih2YXJpYW50LnZhbHVlLCB0ZXh0Q29sb3IsIDIwKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbG9hZFRoZW1lKCdsaWdodCcpO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLnNldE9ubGluZSA9ICgpID0+IHtcclxuICAgICAgICBsZXQgb25saW5lID0gbmF2aWdhdG9yLm9uTGluZTtcclxuXHJcbiAgICAgICAgbGF5b3V0ci5ib2R5LmZpbmQoJy5hbGVydFtkYXRhLXR5cGU9XCJjb25uZWN0ZWRcIl0nKS5yZW1vdmUoKTtcclxuICAgICAgICBpZiAob25saW5lKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ1lvdSBhcmUgb25saW5lJywgJ3N1Y2Nlc3MnLCAnYm90dG9tIHJpZ2h0JywgJ2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ1lvdSBhcmUgb2ZmbGluZScsICdkYW5nZXInLCAnYm90dG9tIHJpZ2h0JywgJ2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGxheW91dHIuc2V0T25saW5lKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGxheW91dHIuc2V0T25saW5lKTtcclxuXHJcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2V0T25saW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrRHJvcGRvd24gPSAoZHJvcGRvd25zKSA9PiB7XHJcbiAgICAgICAgZHJvcGRvd25zLmVhY2goKGksIGUpID0+IHtcclxuICAgICAgICAgICAgbGV0ICR0aGlzID0gJChlKSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gJHRoaXMuY2hpbGRyZW4oJ29wdGlvbjpzZWxlY3RlZCcpLFxyXG4gICAgICAgICAgICAgICAgYXR0ciA9ICR0aGlzLmF0dHIoJ2NsYXNzJyksXHJcbiAgICAgICAgICAgICAgICB0aGVtZSA9ICcnLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggPSAkdGhpcy5hdHRyKCdkYXRhLXdpZHRoJyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gJHRoaXMuY2hpbGRyZW4oKS5maXJzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gdHlwZW9mIHVuZGVmaW5lZCAmJiBhdHRyICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBhdHRyLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gJC5ncmVwKHRlbXAsIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRyaW0oKS5tYXRjaCgvXnRoZW1lLS8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVtcC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGVtZSA9IHRlbXBbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBsaVRlbXBsYXRlID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsaSA9ICQoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGxpLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyZuYnNwOyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5pbmRleE9mKCckJCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGkuYXR0cignZGF0YS1tYXRoJywgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYDxsaSBkYXRhLWlkPVwiJHtsaS52YWwoKX1cIiR7bGkuaXMoJzpzZWxlY3RlZCcpID8gJyBjbGFzcz1cInNlbGVjdGVkXCInIDogJyd9PlxyXG4gICAgPGRpdiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cInRoZW1lLWxpZ2h0XCI+XHJcbiAgICAgICAgPGxhYmVsPiR7dGV4dH08L2xhYmVsPlxyXG4gICAgICAgIDxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWNoZWNrbWFya1wiPjwvdXNlPjwvc3ZnPlxyXG4gICAgPC9kaXY+XHJcbjwvbGk+YDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IGh0bWwgPSBcclxuYDxkaXYgY2xhc3M9XCJkcm9wZG93blxyXG4gICAgJHskdGhpcy5oYXNDbGFzcygnbm90LWZpcnN0JykgPyAnIG5vdC1maXJzdCcgOiAnJ31cclxuICAgICR7JHRoaXMuaGFzQ2xhc3MoJ25vd3JhcCcpID8gJyBub3dyYXAnIDogJyd9XHJcbiAgICAkeyR0aGlzLmhhc0NsYXNzKCdjaGVjaycpID8gJyBjaGVjaycgOiAnJ31cclxuICAgICR7JHRoaXMuaGFzQ2xhc3MoJ2VsbGlwc2lzJykgPyAnIGVsbGlwc2lzJyA6ICcnfVxyXG4gICAgJHskdGhpcy5oYXNDbGFzcygnYWxpZ24tbGVmdCcpID8gJyBhbGlnbi1sZWZ0JyA6ICcnfVxyXG4gICAgJHskdGhpcy5oYXNDbGFzcygnYWxpZ24tcmlnaHQnKSA/ICcgYWxpZ24tcmlnaHQnIDogJyd9XHJcbiAgICAkeyR0aGlzLmhhc0NsYXNzKCdkaXJlY3Rpb24tdXAnKSA/ICcgZGlyZWN0aW9uLXVwJyA6ICcnfVxyXG4gICAgXCJcclxuICAgICR7d2lkdGggIT09IHVuZGVmaW5lZCA/IGAgc3R5bGU9XCJ3aWR0aDogJHt3aWR0aH1weFwiYCA6ICcnfVxyXG4+XHJcbiAgICA8ZGl2IHRhYmluZGV4PVwiMFwiIGNsYXNzPVwiJHt0aGVtZX1cIj5cclxuICAgICAgICA8bGFiZWw+JHtzZWxlY3RlZC50ZXh0KCl9PC9sYWJlbD5cclxuICAgICAgICA8c3ZnIGZvY3VzYWJsZT1cImZhbHNlXCI+PHVzZSB4bGluazpocmVmPVwiI3N2Zy1hcnJvd1wiPjwvdXNlPjwvc3ZnPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8dWwgY2xhc3M9XCIke3RoZW1lfVwiPlxyXG4gICAgICAgICR7JC5tYWtlQXJyYXkoJHRoaXMuY2hpbGRyZW4oKSkubWFwKGxpVGVtcGxhdGUpLmpvaW4oJycpfVxyXG4gICAgPC91bD5cclxuPC9kaXY+YDtcclxuICAgICAgICAgICAgJHRoaXMuYWZ0ZXIoaHRtbCk7XHJcbiAgICAgICAgICAgIGh0bWwgPSAkdGhpcy5uZXh0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoJHRoaXMuaGFzQ2xhc3MoJ25vd3JhcCcpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gaHRtbC5jaGlsZHJlbigpLmVxKDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGh0bWwuY2hpbGRyZW4oKS5lcSgxKSxcclxuICAgICAgICAgICAgICAgICAgICB0b3BXaWR0aCA9IHRvcC53aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbVdpZHRoID0gYm90dG9tLndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tV2lkdGggPiB0b3BXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcC5jc3MoJ21pbi13aWR0aCcsIGJvdHRvbVdpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbC5vbignY2xpY2snLCAnPiBkaXYnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0ICR0aGF0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgJHRoYXQucGFyZW50KCkudG9nZ2xlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGh0bWwub24oJ2NsaWNrJywgJ2xpJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCAkdGhhdCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICghJHRoYXQuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGVzdCBhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoYXQuc2libGluZ3MoJy5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGF0LmFkZENsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSAkdGhpcy5jaGlsZHJlbihgW3ZhbHVlPVwiJHskdGhhdC5hdHRyKCdkYXRhLWlkJyl9XCJdYCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAkdGhhdC50ZXh0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGggPSBvcHRpb24uYXR0cignZGF0YS1tYXRoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbWF0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gaHRtbC5jaGlsZHJlbignZGl2JykuY2hpbGRyZW4oJ2xhYmVsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudGV4dCh0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlck1hdGhJbkVsZW1lbnQobGFiZWxbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGlsZHJlbignOnNlbGVjdGVkJykucmVtb3ZlQXR0cignc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICQod2luZG93KS5jbGljaygoZSkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgICBpZiAodGFyZ2V0LmNsb3Nlc3QoXCJkaXYuZHJvcGRvd25cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICQoJ2Rpdi5kcm9wZG93bicpLm5vdCh0YXJnZXQuY2xvc2VzdChcImRpdi5kcm9wZG93blwiKSkucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGFyZ2V0LmNsb3Nlc3QoXCIuZHJvcGRvd25cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICQoJ2Rpdi5kcm9wZG93bicpLnJlbW92ZUNsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrQWNjb3JkaW9uID0gKGVsZW1lbnRzKSA9PiB7XHJcbiAgICAgICAgZWxlbWVudHMub24oXCJjbGlja1wiLCBcIi5oZWFkbGluZVwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Lmhhc0NsYXNzKCdvcGVuJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ29wZW4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zbGlkZVVwKFwiODAwXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcIm9wZW5cIilcclxuICAgICAgICAgICAgICAgICAgICAuc2xpZGVUb2dnbGUoXCI4MDBcIilcclxuICAgICAgICAgICAgICAgICAgICAucGFyZW50cygnLmFjY29yZGlvbicpLmZpbmQoXCIuY29udGVudC5vcGVuXCIpLm5vdChjb250ZW50KS5yZW1vdmVDbGFzcygnb3BlbicpLnNsaWRlVXAoXCI4MDBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn0iLCJ7XHJcbiAgICBsZXQgY2xvc2VBbGVydCA9ICh0YXJnZXQpID0+IHtcclxuICAgICAgICB0YXJnZXQuZmFkZU91dChsYXlvdXRyLmZhZGVPdXRUaW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0YXJnZXQucGFyZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzQ2xhc3MoJ3BvcHVwJykgJiYgcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJCgoKSA9PiB7XHJcbiAgICAgICAgbGF5b3V0ci5ib2R5Lm9uKCdjbGljaycsICcuYWxlcnQgLmNsb3NlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKTtcclxuICAgICAgICAgICAgY2xvc2VBbGVydCh0YXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrTWFwID0gKG1hcHMpID0+IHtcclxuICAgICAgICBsYXlvdXRyLmhlYWQuZmluZCgnc2NyaXB0W3NyY149XCJodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy1hcGktXCJdJykucmVtb3ZlKCk7XHJcbiAgICAgICAgaWYgKG1hcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdtYXAtbG9hZGVkJykpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucHJvbWlzZU1hcCA9IGxheW91dHIubG9hZC5qcygnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT1BSXphU3lCRWNvbURqUlM0TnUzUlFDa2tTSVEwbnJCaHVRTTBnbmcnKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnbWFwLWxvYWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLnByb21pc2VNYXAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtYXBzLmVhY2goKGksIGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXQgPSBsYXlvdXRyLnRyeVBhcnNlRmxvYXQoJHRoaXMuYXR0cignZGF0YS1sYXQnKSwgMzcuNDAyOTkzNyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxuZyA9IGxheW91dHIudHJ5UGFyc2VGbG9hdCgkdGhpcy5hdHRyKCdkYXRhLWxuZycpLCAtMTIyLjE4MTE3OTMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tID0gbGF5b3V0ci50cnlQYXJzZUludCgkdGhpcy5hdHRyKCdkYXRhLXpvb20nKSwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmRzID0geyBsYXQ6IGxhdCwgbG5nOiBsbmcgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoJHRoaXNbMF0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogem9vbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBjb3Jkc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjb3JkcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBtYXBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS5tYXAnLCAkLnRocm90dGxlKGxheW91dHIudGhyb3R0bGVJbnRlcnZhbCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcigkdGhpc1swXSwgJ3Jlc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLm9uKCdhc2lkZS1jaGFuZ2VkLm1hcCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcigkdGhpc1swXSwgJ3Jlc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnNob3dQb3B1cEFsZXJ0KCdGYWlsZWQgdG8gbG9hZCBtYXBzJywgJ2RhbmdlcicpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCh3aW5kb3cpLnVuYmluZCgncmVzaXplLm1hcCcpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwub2ZmKCdhc2lkZS1jaGFuZ2VkLm1hcCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrTWF0aCA9IChtYXRoKSA9PiB7XHJcbiAgICAgICAgaWYgKG1hdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdtYXRoLWxvYWRlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnByb21pc2VNYXRoID0gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIubG9hZC5jc3MoJ2Rpc3QvY3NzL2thdGV4LmNzcycpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIubG9hZC5qcygnZGlzdC9qcy9rYXRleC5qcycpXHJcbiAgICAgICAgICAgICAgICBdKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnbWF0aC1sb2FkZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGF5b3V0ci5wcm9taXNlTWF0aC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG1hdGguZWFjaCgoaSwgZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWF0aEluRWxlbWVudCgkdGhpc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZUNsYXNzKCdtYXRoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ0ZhaWxlZCB0byBsb2FkIG1hdGgnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5jaGVja01lZGlhID0gKG1lZGlhKSA9PiB7XHJcbiAgICAgICAgaWYgKG1lZGlhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIWxheW91dHIuaHRtbC5oYXNDbGFzcygnbWVkaWEtbG9hZGVkJykpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucHJvbWlzZU1lZGlhID0gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIubG9hZC5jc3MoJ2Rpc3QvY3NzL3BseXIuY3NzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5sb2FkLmpzKCdkaXN0L2pzL3BseXIuanMnKVxyXG4gICAgICAgICAgICAgICAgXSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5oaWRlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ21lZGlhLWxvYWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLnByb21pc2VNZWRpYS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG1lZGlhLmVhY2goKGksIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgUGx5cihpdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgbWVkaWEnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5jaGVja0xhenkgPSAoZWxlbWVudHMpID0+IHtcclxuICAgICAgICBlbGVtZW50cy5sYXp5KHtcclxuICAgICAgICAgICAgYWZ0ZXJMb2FkOiAoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnbGF6eScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59OyIsIntcclxuICAgICQoKCkgPT4ge1xyXG4gICAgICAgIGxheW91dHIuYm9keS5vbignY2xpY2snLCAnLnNob3ctcG9wdXAtYWxlcnQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldCksXHJcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICR0aGlzLmF0dHIoJ2RhdGEtcG9wdXAtdGl0bGUnKSxcclxuICAgICAgICAgICAgICAgIHRoZW1lID0gJHRoaXMuYXR0cignZGF0YS1wb3B1cC10aGVtZScpLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAkdGhpcy5hdHRyKCdkYXRhLXBvcHVwLXBvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQodGl0bGUsIHRoZW1lLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsYXlvdXRyLnNob3dQb3B1cEFsZXJ0ID0gKHRpdGxlLCB0aGVtZSA9ICdsaWdodCcsIHBvc2l0aW9uID0gJ3RvcCBsZWZ0JywgdHlwZSA9ICdkZWZhdWx0JykgPT4ge1xyXG4gICAgICAgIGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCBwb3B1cCA9IGxheW91dHIuYm9keS5jaGlsZHJlbihgLnBvcHVwW2RhdGEtcG9zaXRpb249XCIke3Bvc2l0aW9ufVwiXWApLFxyXG4gICAgICAgICAgICAgICAgaHRtbCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCJhbGVydCB0aGVtZS0ke3RoZW1lfVwiIGRhdGEtdHlwZT1cIiR7dHlwZX1cIj5cclxuPGRpdj48cD4ke3RpdGxlfTwvcD48L2Rpdj5cclxuPGJ1dHRvbiBjbGFzcz1cImNsb3NlXCIgYXJpYS1sYWJlbD1cIkNsb3NlIHBvcHVwXCI+PHN2ZyBmb2N1c2FibGU9XCJmYWxzZVwiPjx1c2UgeGxpbms6aHJlZj1cIiNzdmctY2xvc2VcIj48L3VzZT48L3N2Zz48L2J1dHRvbj5cclxuPC9kaXY+YDtcclxuICAgICAgICAgICAgaWYgKHBvcHVwLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcG9wdXAuYXBwZW5kKGh0bWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbCA9IGA8ZGl2IGNsYXNzPVwicG9wdXAgcG9zaXRpb24gJHtwb3NpdGlvbn1cIiBkYXRhLXBvc2l0aW9uPVwiJHtwb3NpdGlvbn1cIj4ke2h0bWx9YDtcclxuICAgICAgICAgICAgICAgIGh0bWwgPSBgJHtodG1sfTwvZGl2PmA7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmJvZHkucHJlcGVuZChodG1sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrUmVzcG9uc2l2ZUJhY2tncm91bmQgPSAoZWxlbWVudHMpID0+IHtcclxuICAgICAgICBsZXQgc2V0UmIgPSAoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2xvbmUgPSBlbGVtZW50LmNoaWxkcmVuKCcuY2xvbmUnKSxcclxuICAgICAgICAgICAgICAgIGltYWdlID0gZWxlbWVudC5hdHRyKCdkYXRhLXJiLWltYWdlJyksXHJcbiAgICAgICAgICAgICAgICBmaWxldHlwZSA9IGVsZW1lbnQuYXR0cignZGF0YS1yYi1pbWFnZS1maWxldHlwZScpLFxyXG4gICAgICAgICAgICAgICAgc2l6ZXNXaWR0aCA9IGVsZW1lbnQuYXR0cignZGF0YS1yYi1zaXplcycpLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGVsZW1lbnQuYXR0cignZGF0YS1yYi1jdXJyZW50JyksXHJcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbyA9IGVsZW1lbnQuYXR0cignZGF0YS1yYi1hc3BlY3QtcmF0aW8nKTtcclxuICAgICAgICAgICAgaWYgKGltYWdlICE9PSB1bmRlZmluZWQgJiYgaW1hZ2UubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICBmaWxldHlwZSAhPT0gdW5kZWZpbmVkICYmIGZpbGV0eXBlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgc2l6ZXNXaWR0aCAhPT0gdW5kZWZpbmVkICYmIHNpemVzV2lkdGgubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbyAhPT0gdW5kZWZpbmVkICYmIGFzcGVjdFJhdGlvLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChmaWxldHlwZSA9PT0gJ2pwZycgfHwgZmlsZXR5cGUgPT09ICdqcGVnJyB8fCBmaWxldHlwZSA9PT0gJ3BuZycpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGFzcGVjdFJhdGlvID09PSAnMjFieTknIHx8IGFzcGVjdFJhdGlvID09PSAnMTZieTknIHx8IGFzcGVjdFJhdGlvID09PSAnNGJ5MycgfHwgYXNwZWN0UmF0aW8gPT09ICcxYnkxJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplc1dpZHRoID0gc2l6ZXNXaWR0aC5yZXBsYWNlKC9cXHMvZywgJycpLnNwbGl0KCcsJykuc29ydCgoYSwgYikgPT4geyByZXR1cm4gYSAtIGI7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmF0dHIoJ3N0eWxlJywgZWxlbWVudC5hdHRyKCdzdHlsZScpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdvYWxXaWR0aCA9IGVsZW1lbnQud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ29hbEhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0UGVyY2VudGFnZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdldEhlaWdodEluUGVyY2VudGFnZSA9IChudW0sIGFtb3VudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtICogMTAwIC8gYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3BlY3RSYXRpbyA9PT0gJzIxYnk5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRQZXJjZW50YWdlID0gZ2V0SGVpZ2h0SW5QZXJjZW50YWdlKDksIDIxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzcGVjdFJhdGlvID09PSAnMTZieTknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodFBlcmNlbnRhZ2UgPSBnZXRIZWlnaHRJblBlcmNlbnRhZ2UoOSwgMTYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzcGVjdFJhdGlvID09PSAnNGJ5MycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0UGVyY2VudGFnZSA9IGdldEhlaWdodEluUGVyY2VudGFnZSgzLCA0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3BlY3RSYXRpbyA9PT0gJzFieTEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodFBlcmNlbnRhZ2UgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZ2V0SGVpZ2h0SW5QaXhlbHMgPSAobnVtLCBhbW91bnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bSAqIGFtb3VudCAvIDEwMDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2l6ZXNXaWR0aCwgKGksIGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gcGFyc2VJbnQoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBnZXRIZWlnaHRJblBpeGVscyhoZWlnaHRQZXJjZW50YWdlLCB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0V2lkdGggPT09IHVuZGVmaW5lZCB8fCB3aWR0aCA8IGdvYWxXaWR0aCB8fCBjbG9zZXN0V2lkdGggPCBnb2FsV2lkdGggfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RIZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPCBnb2FsSGVpZ2h0IHx8IGNsb3Nlc3RIZWlnaHQgPCBnb2FsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0V2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Lmxlbmd0aCAmJiBwYXJzZUludChjdXJyZW50KSA8IGNsb3Nlc3RXaWR0aCB8fCBjdXJyZW50ID09PSB1bmRlZmluZWQgfHwgY3VycmVudC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNyYyA9IGAke2ltYWdlfS0ke2Nsb3Nlc3RXaWR0aH0uJHtmaWxldHlwZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmxvYWQuaW1nKHNyYykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBgdXJsKCR7c3JjfSlgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgYHVybCgke3NyY30pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogZmluZCByZXBsYWNlbWVudCBmb3IgNTAwIG1zIHRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS1yYi1jdXJyZW50JywgY2xvc2VzdFdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ0ZhaWxlZCB0byBsb2FkIHJlc3BvbnNpdmUgYmFja2dyb3VuZCBpbWFnZScsICdkYW5nZXInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZWxlbWVudHMuZWFjaCgoaSwgZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSAkKGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldFJiKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbigncmVzaXplLnJiJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFJiKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLm9uKCdjb2x1bW5zLWNoYW5nZWQucmInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmIoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwub24oJ2FzaWRlLWNoYW5nZWQucmInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmIoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5yYicpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmh0bWwub2ZmKCdjb2x1bW5zLWNoYW5nZWQucmInKTtcclxuICAgICAgICAgICAgbGF5b3V0ci5odG1sLm9mZignYXNpZGUtY2hhbmdlZC5yYicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5jaGVja1Rvb2x0aXAgPSAodG9vbHRpcHMpID0+IHtcclxuICAgICAgICB0b29sdGlwcy5lYWNoKChpLCBlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZSksXHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZSA9ICR0aGlzLmhhc0NsYXNzKCdpbnRlcmFjdGl2ZScpO1xyXG4gICAgICAgICAgICAkdGhpcy50b29sdGlwc3Rlcih7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlck9wZW46IHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2xvc2U6IHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZWxlYXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5jaGVja0RhdGF0YWJsZSA9ICh0YWJsZXMpID0+IHtcclxuICAgICAgICBpZiAodGFibGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIWxheW91dHIuaHRtbC5oYXNDbGFzcygnZGF0YXRhYmxlcy1sb2FkZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93TG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5wcm9taXNlRGF0YXRhYmxlcyA9IGxheW91dHIubG9hZC5qcygnZGlzdC9qcy9kYXRhdGFibGVzLmpzJykuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5oaWRlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLmh0bWwuYWRkQ2xhc3MoJ2RhdGF0YWJsZXMtbG9hZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGF5b3V0ci5wcm9taXNlRGF0YXRhYmxlcy50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gJ2dhcC0zJztcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZV9oZWFkZXJfaW5wdXQgPSAoaW5zdGFuY2UsIHdyYXBwZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGhzID0gd3JhcHBlci5maW5kKCd0aGVhZCB0aCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGpRdWVyeS5ncmVwKHRocywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSAkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5oYXNDbGFzcygnZHJvcGRvd24nKSB8fCBjb2x1bW4uaGFzQ2xhc3MoJ3RleHQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9ICQodGhzW2ldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBjb2x1bW4uaHRtbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb2x1bW4uYXR0cignZGF0YS1taW4td2lkdGgnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gbWluV2lkdGggPyBgbWluLXdpZHRoOiAke21pbldpZHRofXB4O2AgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA8ZGl2IHN0eWxlPVwiJHtzdHlsZX1cIj5cclxuICAgIDxkaXY+XHJcbiAgICAgICAgPHNwYW4+JHt0ZXh0fTwvc3Bhbj5cclxuICAgIDwvZGl2PlxyXG4gICAgJHtlbGVtZW50cy5sZW5ndGggPyAnPGRpdj48L2Rpdj4nIDogJyd9XHJcbjwvZGl2PmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5lbXB0eSgpLmFwcGVuZChodG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gY29sdW1uLmluZGV4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmhhc0NsYXNzKCdkcm9wZG93bicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ID0gJCgnPHNlbGVjdCBjbGFzcz1cImRyb3Bkb3duIGFsaWduLWxlZnQgbm93cmFwXCI+PG9wdGlvbiB2YWx1ZT1cIlwiPjwvb3B0aW9uPjwvc2VsZWN0PicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbHVtbi5maW5kKCc+IGRpdiA+IGRpdjpsYXN0LWNoaWxkJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb2x1bW4oaW5kZXgpLnNlYXJjaChlLmN1cnJlbnRUYXJnZXQudmFsdWUpLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb2x1bW4oaSkuZGF0YSgpLnVuaXF1ZSgpLnNvcnQobGF5b3V0ci5zb3J0KS5lYWNoKChkLCBqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0LmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cIiR7ZH1cIj4ke2R9PC9vcHRpb24+YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW4uaGFzQ2xhc3MoJ3RleHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhjb2x1bW4uZmluZCgnPiBkaXYgPiBkaXY6bGFzdC1jaGlsZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbigna2V5dXAnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAkdGhpcy52YWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpcy5hdHRyKCdkYXRhLWxhc3QnKSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb2x1bW4oaW5kZXgpLnNlYXJjaCh2YWwpLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdHRyKCdkYXRhLWxhc3QnLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQucGFyZW50KCkuYWRkQ2xhc3MoJ2Zvcm0tZ3JvdXAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RlYnVnZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFibGVfaGVhZGVyX3NvcnQgPSAoaW5zdGFuY2UsIHdyYXBwZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmZpbmQoJ3RoZWFkIHRoJykudW5iaW5kKCdjbGljaycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZCA9IHdyYXBwZXIuZmluZCgndGhlYWQgdGg6bm90KC5zb3J0aW5nLWRpc2FibGVkKScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHdyYXBwZXIuZmluZCgndGhlYWQgdGguc29ydGluZy1kaXNhYmxlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZC5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkLmZpbmQoJz4gZGl2ID4gZGl2OmZpcnN0LWNoaWxkJykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cInNvcnQtYnRuXCI+PC9zcGFuPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQuY2xpY2soKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0ICR0aGlzID0gJChlLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHRoaXMuY2xvc2VzdCgnZGl2LmRyb3Bkb3duJykubGVuZ3RoICYmICEkdGhpcy5jbG9zZXN0KCdpbnB1dCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICR0aGlzLnBhcmVudHMoJ3RoJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJlbnQuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzQ2xhc3MoJ3NvcnRpbmdfYXNjJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb2x1bW4oaW5kZXgpLm9yZGVyKCdkZXNjJykuZHJhdygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29sdW1uKGluZGV4KS5vcmRlcignYXNjJykuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhYmxlX2hlYWRlcl9sZW5ndGggPSAod3JhcHBlciwgaGVhZGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHdyYXBwZXIuZmluZCgnLmRhdGFUYWJsZXNfbGVuZ3RoJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duID0gbGVuZ3RoLmZpbmQoJ3NlbGVjdCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGguYXBwZW5kKGRyb3Bkb3duKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGguY2hpbGRyZW4oJ2xhYmVsJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkQ2xhc3MoJ2Ryb3Bkb3duJykuYXR0cignZGF0YS13aWR0aCcsIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZV9oZWFkZXJfYnV0dG9ucyA9ICh3cmFwcGVyLCBoZWFkZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gd3JhcHBlci5maW5kKCcuZHQtYnV0dG9ucycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKGA8ZGl2IGNsYXNzPVwiZmxleCB3cmFwICR7Z2FwfVwiPjwvZGl2PmApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gY29udGFpbmVyLmNoaWxkcmVuKCdkaXYnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IGNvbnRhaW5lci5jaGlsZHJlbignYnV0dG9uJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQoZGl2KTtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25zLmFkZENsYXNzKCdidG4nKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuYXBwZW5kKGJ1dHRvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlci5hcHBlbmQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFibGVfaGVhZGVyX2ZpbHRlciA9ICh3cmFwcGVyLCBoZWFkZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyID0gd3JhcHBlci5maW5kKCcuZGF0YVRhYmxlc19maWx0ZXInKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmFkZENsYXNzKCdpbnB1dC1ncm91cCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci5maW5kKCdpbnB1dCcpLmFwcGVuZFRvKGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmFwcGVuZCgnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCI+PHN2ZyBmb2N1c2FibGU9XCJmYWxzZVwiPjx1c2UgeGxpbms6aHJlZj1cIiNzdmctc2VhcmNoXCI+PC91c2U+PC9zdmc+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZpbmQoJ2xhYmVsJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZV9jb250ZW50ID0gKHdyYXBwZXIsIGNvbnRlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFibGUgPSB3cmFwcGVyLmZpbmQoJ3RhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5hcHBlbmQodGFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFibGVfZm9vdGVyX2luZm8gPSAod3JhcHBlciwgZm9vdGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm8gPSB3cmFwcGVyLmZpbmQoJy5kYXRhVGFibGVzX2luZm8nKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXIuYXBwZW5kKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCBwYWdpbmF0ZUZpeCA9IChwYWdpbmF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFuID0gcGFnaW5hdGUuY2hpbGRyZW4oJ3NwYW4nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhZ2luYXRlLmZpbmQoJy5wYWdpbmF0ZV9idXR0b24ucHJldmlvdXMnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhZ2luYXRlLmZpbmQoJy5wYWdpbmF0ZV9idXR0b24ubmV4dCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmV2Lmh0bWwoJzxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWFycm93XCI+PC91c2U+PC9zdmc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5odG1sKCc8c3ZnIGZvY3VzYWJsZT1cImZhbHNlXCI+PHVzZSB4bGluazpocmVmPVwiI3N2Zy1hcnJvd1wiPjwvdXNlPjwvc3ZnPicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmV2LnByZXBlbmRUbyhzcGFuKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmFwcGVuZFRvKHNwYW4pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZV9mb290ZXJfcGFnaW5hdGUgPSAod3JhcHBlciwgZm9vdGVyLCBwYWdpbmF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRlLmFkZENsYXNzKCdmbGV4IHdyYXAnKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXIuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19wYWdpbmF0ZV9jb250YWluZXJcIj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gZm9vdGVyLmZpbmQoJy5kYXRhVGFibGVzX3BhZ2luYXRlX2NvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRlRml4KHBhZ2luYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKHBhZ2luYXRlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFibGVfZHJvcGRvd25zID0gKHdyYXBwZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZHJvcGRvd25zID0gd3JhcHBlci5maW5kKCdzZWxlY3QuZHJvcGRvd24nKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNoZWNrRHJvcGRvd24oZHJvcGRvd25zKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdGFibGVzLmVhY2goKGksIGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcjogKHRleHQsIGluZGV4LCB0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aCkuZmluZCgnc3BhbjpmaXJzdCcpLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoJ25vd3JhcCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLkRhdGFUYWJsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9tXCI6ICdsQmZydGlwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiU29ydENlbGxzVG9wXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQ6ICdjb3B5SHRtbDUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0T3B0aW9uczogZXhwb3J0T3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQ6ICdleGNlbEh0bWw1JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb290ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydE9wdGlvbnM6IGV4cG9ydE9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kOiAnY3N2SHRtbDUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0T3B0aW9uczogZXhwb3J0T3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Q29tcGxldGU6IChzZXR0aW5ncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gc2V0dGluZ3Mub0luc3RhbmNlLmFwaSh0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZChgPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfaGVhZGVyIGZsZXggY29sdW1uIGdyb3dcIj48ZGl2IGNsYXNzPVwiZmxleCB3cmFwICR7Z2FwfVwiPjwvZGl2PjwvZGl2PmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9IHdyYXBwZXIuZmluZCgnPiAuZGF0YVRhYmxlc19oZWFkZXIgPiBkaXYnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZCgnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfY29udGVudCB0YWJsZVwiPjwvZGl2PicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB3cmFwcGVyLmZpbmQoJz4gLmRhdGFUYWJsZXNfY29udGVudCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kKGA8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19mb290ZXJcIj48ZGl2IGNsYXNzPVwiZmxleCB3cmFwIHZlcnRpY2FsLWNlbnRlciAke2dhcH1cIj48L2Rpdj48L2Rpdj5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb290ZXIgPSB3cmFwcGVyLmZpbmQoJz4gLmRhdGFUYWJsZXNfZm9vdGVyID4gZGl2Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVfaGVhZGVyX2lucHV0KGluc3RhbmNlLCB3cmFwcGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlX2hlYWRlcl9zb3J0KGluc3RhbmNlLCB3cmFwcGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlX2hlYWRlcl9sZW5ndGgod3JhcHBlciwgaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlX2hlYWRlcl9idXR0b25zKHdyYXBwZXIsIGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZV9oZWFkZXJfZmlsdGVyKHdyYXBwZXIsIGhlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhYmxlID0gdGFibGVfY29udGVudCh3cmFwcGVyLCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZV9mb290ZXJfaW5mbyh3cmFwcGVyLCBmb290ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYWdpbmF0ZSA9IHdyYXBwZXIuZmluZCgnLmRhdGFUYWJsZXNfcGFnaW5hdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlX2Zvb3Rlcl9wYWdpbmF0ZSh3cmFwcGVyLCBmb290ZXIsIHBhZ2luYXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZV9kcm9wZG93bnMod3JhcHBlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdGFibGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZHJhdy5kdCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9IGluc3RhbmNlLmNvbHVtbnMoKS5yZXNwb25zaXZlSGlkZGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcigncmVzcG9uc2l2ZS1yZXNpemUuZHQnLCBbdGFibGVbMF0sIGNvbHVtbnNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5vbignYXNpZGUtY2hhbmdlZC5kYXRhdGFibGVzJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlc3BvbnNpdmUucmVjYWxjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigncmVzcG9uc2l2ZS1yZXNpemUuZHQnLCAoZSwgZGF0YXRhYmxlLCBjb2x1bW5zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gY29sdW1ucy5yZWR1Y2UoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIgPT09IGZhbHNlID8gYSArIDEgOiBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudHMgPSB0YWJsZS5maW5kKCd0Ym9keSB0cjpub3QoLmNoaWxkKSA+ICo6Zmlyc3QtY2hpbGQ6bm90KC5kYXRhVGFibGVzX2VtcHR5KScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmNoaWxkcmVuKCdpJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnByZXBlbmQoJzxpIHRhYmluZGV4PVwiMFwiPjxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLXBsdXNcIj48L3VzZT48L3N2Zz48c3ZnIGZvY3VzYWJsZT1cImZhbHNlXCI+PHVzZSB4bGluazpocmVmPVwiI3N2Zy1taW51c1wiPjwvdXNlPjwvc3ZnPjwvaT4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5zaG93UG9wdXBBbGVydCgnRmFpbGVkIHRvIGxvYWQgZGF0YXRhYmxlcycsICdkYW5nZXInKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dHIuaHRtbC5vZmYoJ2FzaWRlLWNoYW5nZWQuZGF0YXRhYmxlcycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0iLCJ7XHJcbiAgICBsYXlvdXRyLmNoZWNrU3dpcGVyID0gKHN3aXBlcikgPT4ge1xyXG4gICAgICAgIGlmIChzd2lwZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghbGF5b3V0ci5odG1sLmhhc0NsYXNzKCdzd2lwZXItbG9hZGVkJykpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucHJvbWlzZVN3aXBlciA9IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmxvYWQuY3NzKCdkaXN0L2Nzcy9zd2lwZXIuY3NzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5sb2FkLmpzKCdkaXN0L2pzL3N3aXBlci5qcycpXHJcbiAgICAgICAgICAgICAgICBdKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuaHRtbC5hZGRDbGFzcygnc3dpcGVyLWxvYWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLnByb21pc2VTd2lwZXIudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzd2lwZXIuZWFjaCgoaSwgZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdGhpcy5oYXNDbGFzcygnbG9hZGVkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXBwZW5kKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWZvb3RlclwiPjwvZGl2PicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGlsZHJlbignLnN3aXBlci1mb290ZXInKS5hcHBlbmQoJzxkaXY+PC9kaXY+Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9vdGVyID0gJHRoaXMuZmluZCgnPiAuc3dpcGVyLWZvb3RlciA+IGRpdicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbiA9ICR0aGlzLmhhc0NsYXNzKCdwYWdpbmF0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0cyA9ICR0aGlzLmhhc0NsYXNzKCdkeW5hbWljLWJ1bGxldHMnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb24gPSAkdGhpcy5oYXNDbGFzcygnbmF2aWdhdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IGxheW91dHIuaXNUcnVlKCR0aGlzLmF0dHIoJ2RhdGEtbG9vcCcpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbiA9ICR0aGlzLmhhc0NsYXNzKCdzcGFjZS1iZXR3ZWVuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3ID0gbGF5b3V0ci50cnlQYXJzZUludCgkdGhpcy5hdHRyKCdkYXRhLXNsaWRlcy1wZXItdmlldycpLCAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzID0gbGF5b3V0ci50cnlQYXJzZUpTT04oJHRoaXMuYXR0cignZGF0YS1icmVha3BvaW50cycpLCB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb290ZXIuYWRkQ2xhc3MoJ2ZsZXggd3JhcCBnYXAtMyBjZW50ZXInKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdpbmF0aW9uIHx8IGR5bmFtaWNCdWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb290ZXIuYXBwZW5kKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXBhZ2luYXRpb24gZmxleCB3cmFwIGdhcC0xIGNlbnRlciB2ZXJ0aWNhbC1jZW50ZXJcIj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvb3Rlci5hcHBlbmQoJzxidXR0b24gY2xhc3M9XCJidG4gc3F1YXJlIGNpcmNsZSBwcmV2IHRoZW1lLWRhcmtcIj48c3ZnIGZvY3VzYWJsZT1cImZhbHNlXCI+PHVzZSB4bGluazpocmVmPVwiI3N2Zy1hcnJvd1wiPjwvdXNlPjwvc3ZnPjwvYnV0dG9uPicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyLmFwcGVuZCgnPGJ1dHRvbiBjbGFzcz1cImJ0biBzcXVhcmUgY2lyY2xlIG5leHQgdGhlbWUtZGFya1wiPjxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWFycm93XCI+PC91c2U+PC9zdmc+PC9idXR0b24+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZUJldHdlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbiA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3dpcGVyID0gbmV3IFN3aXBlcigkdGhpc1swXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcDogbG9vcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IHNsaWRlc1BlclZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IHNwYWNlQmV0d2VlbixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHBhZ2luYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogJy5zd2lwZXItcGFnaW5hdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0J1bGxldHM6IGR5bmFtaWNCdWxsZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hdmlnYXRpb24gYXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEVsOiAnLnN3aXBlci1mb290ZXIgLm5leHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZFbDogJy5zd2lwZXItZm9vdGVyIC5wcmV2J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgaWYgd2UgbmVlZCBzY3JvbGxiYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiAnLnN3aXBlci1zY3JvbGxiYXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKCdsb2FkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlQ2hhbmdlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dHIuY2hlY2tMYXp5KCR0aGlzLmZpbmQoJy5sYXp5JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRyLnNob3dQb3B1cEFsZXJ0KCdGYWlsZWQgdG8gbG9hZCBzd2lwZXInLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59Iiwie1xyXG4gICAgbGF5b3V0ci5nZXRBc3NpZ25tZW50SXRlbSA9IChpdGVtcywgaWQpID0+IHtcclxuICAgICAgICByZXR1cm4gJCgkLm1hcChpdGVtcywgKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsYXlvdXRyLmNoZWNrQXNzaWdubWVudCA9IChhc3NpZ25tZW50cykgPT4ge1xyXG4gICAgICAgIGlmIChhc3NpZ25tZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFsYXlvdXRyLmh0bWwuaGFzQ2xhc3MoJ2Fzc2lnbm1lbnQtbG9hZGVkJykpIHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxheW91dHIucHJvbWlzZUFzc2lnbm1lbnQgPSBsYXlvdXRyLmxvYWQuanMoJ2Rpc3QvanMvYXNzaWdubWVudC5qcycpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0ci5odG1sLmFkZENsYXNzKCdhc3NpZ25tZW50LWxvYWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXlvdXRyLnByb21pc2VBc3NpZ25tZW50LnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgJChhc3NpZ25tZW50cykuZWFjaCgoaSwgYXNzaWdubWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQgPSAkKGFzc2lnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuY2hlY2tBc3NpZ25tZW50U29ydChhc3NpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRyLmNoZWNrQXNzaWdubWVudERyYWdBbmREcm9wKGFzc2lnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dHIuY2hlY2tBc3NpZ25tZW50Q29sb3IoYXNzaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ci5jaGVja0Fzc2lnbm1lbnRQdXp6bGUoYXNzaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxheW91dHIuc2hvd1BvcHVwQWxlcnQoJ0ZhaWxlZCB0byBsb2FkIGFzc2lnbm1lbnQnLCAnZGFuZ2VyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsYXlvdXRyLmFycm93S2V5TG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZS5hc3NpZ25tZW50U29ydCcpO1xyXG4gICAgICAgICAgICBsYXlvdXRyLmJvZHkub24oJ2tleWRvd24uYXNzaWdubWVudFB1enpsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0iXX0=
