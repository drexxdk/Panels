/*! Sortable 1.7.0 - MIT | git://github.com/rubaxa/Sortable.git */

!function (t) { "use strict"; "function" == typeof define && define.amd ? define(t) : "undefined" != typeof module && void 0 !== module.exports ? module.exports = t() : window.Sortable = t() }(function () { "use strict"; function t(e, n) { if (!e || !e.nodeType || 1 !== e.nodeType) throw "Sortable: `el` must be HTMLElement, and not " + {}.toString.call(e); this.el = e, this.options = n = g({}, n), e[j] = this; var i = { group: null, sort: !0, disabled: !1, store: null, handle: null, scroll: !0, scrollSensitivity: 30, scrollSpeed: 10, draggable: /[uo]l/i.test(e.nodeName) ? "li" : ">*", ghostClass: "sortable-ghost", chosenClass: "sortable-chosen", dragClass: "sortable-drag", ignore: "a, img", filter: null, preventOnFilter: !0, animation: 0, setData: function (t, e) { t.setData("Text", e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: "data-id", delay: 0, forceFallback: !1, fallbackClass: "sortable-fallback", fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: !1 !== t.supportPointer }; for (var r in i) !(r in n) && (n[r] = i[r]); rt(n); for (var a in this) "_" === a.charAt(0) && "function" == typeof this[a] && (this[a] = this[a].bind(this)); this.nativeDraggable = !n.forceFallback && Z, o(e, "mousedown", this._onTapStart), o(e, "touchstart", this._onTapStart), n.supportPointer && o(e, "pointerdown", this._onTapStart), this.nativeDraggable && (o(e, "dragover", this), o(e, "dragenter", this)), nt.push(this._onDragOver), n.store && this.sort(n.store.get(this)) } function e(t, e) { "clone" !== t.lastPullMode && (e = !0), w && w.state !== e && (a(w, "display", e ? "none" : ""), e || w.state && (t.options.group.revertClone ? (T.insertBefore(w, C), t._animate(b, w)) : T.insertBefore(w, b)), w.state = e) } function n(t, e, n) { if (t) { n = n || W; do { if (">*" === e && t.parentNode === n || f(t, e)) return t } while (t = function (t) { var e = t.host; return e && e.nodeType ? e : t.parentNode }(t)) } return null } function o(t, e, n) { t.addEventListener(e, n, Q) } function i(t, e, n) { t.removeEventListener(e, n, Q) } function r(t, e, n) { if (t) if (t.classList) t.classList[n ? "add" : "remove"](e); else { var o = (" " + t.className + " ").replace(F, " ").replace(" " + e + " ", " "); t.className = (o + (n ? " " + e : "")).replace(F, " ") } } function a(t, e, n) { var o = t && t.style; if (o) { if (void 0 === n) return W.defaultView && W.defaultView.getComputedStyle ? n = W.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e]; e in o || (e = "-webkit-" + e), o[e] = n + ("string" == typeof n ? "" : "px") } } function l(t, e, n) { if (t) { var o = t.getElementsByTagName(e), i = 0, r = o.length; if (n) for (; i < r; i++)n(o[i], i); return o } return [] } function s(t, e, n, o, i, r, a, l) { t = t || e[j]; var s = W.createEvent("Event"), c = t.options, d = "on" + n.charAt(0).toUpperCase() + n.substr(1); s.initEvent(n, !0, !0), s.to = i || e, s.from = r || e, s.item = o || e, s.clone = w, s.oldIndex = a, s.newIndex = l, e.dispatchEvent(s), c[d] && c[d].call(t, s) } function c(t, e, n, o, i, r, a, l) { var s, c, d = t[j], h = d.options.onMove; return (s = W.createEvent("Event")).initEvent("move", !0, !0), s.to = e, s.from = t, s.dragged = n, s.draggedRect = o, s.related = i || e, s.relatedRect = r || e.getBoundingClientRect(), s.willInsertAfter = l, t.dispatchEvent(s), h && (c = h.call(d, s, a)), c } function d(t) { t.draggable = !1 } function h() { K = !1 } function u(t, e) { var n = 0; if (!t || !t.parentNode) return -1; for (; t && (t = t.previousElementSibling);)"TEMPLATE" === t.nodeName.toUpperCase() || ">*" !== e && !f(t, e) || n++; return n } function f(t, e) { if (t) { var n = (e = e.split(".")).shift().toUpperCase(), o = new RegExp("\\s(" + e.join("|") + ")(?=\\s)", "g"); return !("" !== n && t.nodeName.toUpperCase() != n || e.length && ((" " + t.className + " ").match(o) || []).length != e.length) } return !1 } function p(t, e) { var n, o; return function () { void 0 === n && (n = arguments, o = this, q(function () { 1 === n.length ? t.call(o, n[0]) : t.apply(o, n), n = void 0 }, e)) } } function g(t, e) { if (t && e) for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } function v(t) { return G && G.dom ? G.dom(t).cloneNode(!0) : z ? z(t).clone(!0)[0] : t.cloneNode(!0) } function m(t) { return q(t, 0) } function _(t) { return clearTimeout(t) } if ("undefined" == typeof window || !window.document) return function () { throw new Error("Sortable.js requires a window with a document") }; var b, D, y, w, T, C, S, E, x, N, k, B, P, Y, X, O, I, R, A, M, L = {}, F = /\s+/g, U = /left|right|inline/, j = "Sortable" + (new Date).getTime(), H = window, W = H.document, V = H.parseInt, q = H.setTimeout, z = H.jQuery || H.Zepto, G = H.Polymer, Q = !1, Z = "draggable" in W.createElement("div"), J = function (t) { return !navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie)/i) && (t = W.createElement("x"), t.style.cssText = "pointer-events:auto", "auto" === t.style.pointerEvents) }(), K = !1, $ = Math.abs, tt = Math.min, et = [], nt = [], ot = function () { return !1 }, it = p(function (t, e, n) { if (n && e.scroll) { var o, i, r, a, l, s, c = n[j], d = e.scrollSensitivity, h = e.scrollSpeed, u = t.clientX, f = t.clientY, p = window.innerWidth, g = window.innerHeight; if (x !== n && (E = e.scroll, x = n, N = e.scrollFn, !0 === E)) { E = n; do { if (E.offsetWidth < E.scrollWidth || E.offsetHeight < E.scrollHeight) break } while (E = E.parentNode) } E && (o = E, i = E.getBoundingClientRect(), r = ($(i.right - u) <= d) - ($(i.left - u) <= d), a = ($(i.bottom - f) <= d) - ($(i.top - f) <= d)), r || a || (a = (g - f <= d) - (f <= d), ((r = (p - u <= d) - (u <= d)) || a) && (o = H)), L.vx === r && L.vy === a && L.el === o || (L.el = o, L.vx = r, L.vy = a, clearInterval(L.pid), o && (L.pid = setInterval(function () { if (s = a ? a * h : 0, l = r ? r * h : 0, "function" == typeof N) return N.call(c, l, s, t); o === H ? H.scrollTo(H.pageXOffset + l, H.pageYOffset + s) : (o.scrollTop += s, o.scrollLeft += l) }, 24))) } }, 30), rt = function (t) { function e(t, e) { return null != t && !0 !== t || null != (t = n.name) ? "function" == typeof t ? t : function (n, o) { var i = o.options.group.name; return e ? t : t && (t.join ? t.indexOf(i) > -1 : i == t) } : ot } var n = {}, o = t.group; o && "object" == typeof o || (o = { name: o }), n.name = o.name, n.checkPull = e(o.pull, !0), n.checkPut = e(o.put), n.revertClone = o.revertClone, t.group = n }; try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function () { Q = { capture: !1, passive: !1 } } })) } catch (t) { } return t.prototype = { constructor: t, _onTapStart: function (t) { var e, o = this, i = this.el, r = this.options, a = r.preventOnFilter, l = t.type, c = t.touches && t.touches[0], d = (c || t).target, h = t.target.shadowRoot && t.path && t.path[0] || d, f = r.filter; if (function (t) { et.length = 0; for (var e = t.getElementsByTagName("input"), n = e.length; n--;) { var o = e[n]; o.checked && et.push(o) } }(i), !b && !(/mousedown|pointerdown/.test(l) && 0 !== t.button || r.disabled) && !h.isContentEditable && (d = n(d, r.draggable, i)) && S !== d) { if (e = u(d, r.draggable), "function" == typeof f) { if (f.call(this, t, d, this)) return s(o, h, "filter", d, i, i, e), void (a && t.preventDefault()) } else if (f && (f = f.split(",").some(function (t) { if (t = n(h, t.trim(), i)) return s(o, t, "filter", d, i, i, e), !0 }))) return void (a && t.preventDefault()); r.handle && !n(h, r.handle, i) || this._prepareDragStart(t, c, d, e) } }, _prepareDragStart: function (t, e, n, i) { var a, c = this, h = c.el, u = c.options, f = h.ownerDocument; n && !b && n.parentNode === h && (R = t, T = h, D = (b = n).parentNode, C = b.nextSibling, S = n, O = u.group, Y = i, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, b.style["will-change"] = "all", a = function () { c._disableDelayedDrag(), b.draggable = c.nativeDraggable, r(b, u.chosenClass, !0), c._triggerDragStart(t, e), s(c, T, "choose", b, T, T, Y) }, u.ignore.split(",").forEach(function (t) { l(b, t.trim(), d) }), o(f, "mouseup", c._onDrop), o(f, "touchend", c._onDrop), o(f, "touchcancel", c._onDrop), o(f, "selectstart", c), u.supportPointer && o(f, "pointercancel", c._onDrop), u.delay ? (o(f, "mouseup", c._disableDelayedDrag), o(f, "touchend", c._disableDelayedDrag), o(f, "touchcancel", c._disableDelayedDrag), o(f, "mousemove", c._disableDelayedDrag), o(f, "touchmove", c._disableDelayedDrag), u.supportPointer && o(f, "pointermove", c._disableDelayedDrag), c._dragStartTimer = q(a, u.delay)) : a()) }, _disableDelayedDrag: function () { var t = this.el.ownerDocument; clearTimeout(this._dragStartTimer), i(t, "mouseup", this._disableDelayedDrag), i(t, "touchend", this._disableDelayedDrag), i(t, "touchcancel", this._disableDelayedDrag), i(t, "mousemove", this._disableDelayedDrag), i(t, "touchmove", this._disableDelayedDrag), i(t, "pointermove", this._disableDelayedDrag) }, _triggerDragStart: function (t, e) { (e = e || ("touch" == t.pointerType ? t : null)) ? (R = { target: b, clientX: e.clientX, clientY: e.clientY }, this._onDragStart(R, "touch")) : this.nativeDraggable ? (o(b, "dragend", this), o(T, "dragstart", this._onDragStart)) : this._onDragStart(R, !0); try { W.selection ? m(function () { W.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) { } }, _dragStarted: function () { if (T && b) { var e = this.options; r(b, e.ghostClass, !0), r(b, e.dragClass, !1), t.active = this, s(this, T, "start", b, T, T, Y) } else this._nulling() }, _emulateDragOver: function () { if (A) { if (this._lastX === A.clientX && this._lastY === A.clientY) return; this._lastX = A.clientX, this._lastY = A.clientY, J || a(y, "display", "none"); var t = W.elementFromPoint(A.clientX, A.clientY), e = t, n = nt.length; if (t && t.shadowRoot && (e = t = t.shadowRoot.elementFromPoint(A.clientX, A.clientY)), e) do { if (e[j]) { for (; n--;)nt[n]({ clientX: A.clientX, clientY: A.clientY, target: t, rootEl: e }); break } t = e } while (e = e.parentNode); J || a(y, "display", "") } }, _onTouchMove: function (e) { if (R) { var n = this.options, o = n.fallbackTolerance, i = n.fallbackOffset, r = e.touches ? e.touches[0] : e, l = r.clientX - R.clientX + i.x, s = r.clientY - R.clientY + i.y, c = e.touches ? "translate3d(" + l + "px," + s + "px,0)" : "translate(" + l + "px," + s + "px)"; if (!t.active) { if (o && tt($(r.clientX - this._lastX), $(r.clientY - this._lastY)) < o) return; this._dragStarted() } this._appendGhost(), M = !0, A = r, a(y, "webkitTransform", c), a(y, "mozTransform", c), a(y, "msTransform", c), a(y, "transform", c), e.preventDefault() } }, _appendGhost: function () { if (!y) { var t, e = b.getBoundingClientRect(), n = a(b), o = this.options; r(y = b.cloneNode(!0), o.ghostClass, !1), r(y, o.fallbackClass, !0), r(y, o.dragClass, !0), a(y, "top", e.top - V(n.marginTop, 10)), a(y, "left", e.left - V(n.marginLeft, 10)), a(y, "width", e.width), a(y, "height", e.height), a(y, "opacity", "0.8"), a(y, "position", "fixed"), a(y, "zIndex", "100000"), a(y, "pointerEvents", "none"), o.fallbackOnBody && W.body.appendChild(y) || T.appendChild(y), t = y.getBoundingClientRect(), a(y, "width", 2 * e.width - t.width), a(y, "height", 2 * e.height - t.height) } }, _onDragStart: function (t, e) { var n = this, i = t.dataTransfer, l = n.options; n._offUpEvents(), O.checkPull(n, n, b, t) && ((w = v(b)).draggable = !1, w.style["will-change"] = "", a(w, "display", "none"), r(w, n.options.chosenClass, !1), n._cloneId = m(function () { T.insertBefore(w, b), s(n, T, "clone", b) })), r(b, l.dragClass, !0), e ? ("touch" === e ? (o(W, "touchmove", n._onTouchMove), o(W, "touchend", n._onDrop), o(W, "touchcancel", n._onDrop), l.supportPointer && (o(W, "pointermove", n._onTouchMove), o(W, "pointerup", n._onDrop))) : (o(W, "mousemove", n._onTouchMove), o(W, "mouseup", n._onDrop)), n._loopId = setInterval(n._emulateDragOver, 50)) : (i && (i.effectAllowed = "move", l.setData && l.setData.call(n, i, b)), o(W, "drop", n), n._dragStartId = m(n._dragStarted)) }, _onDragOver: function (o) { var i, r, l, s, d = this.el, u = this.options, f = u.group, p = t.active, g = O === f, v = !1, m = u.sort; if (void 0 !== o.preventDefault && (o.preventDefault(), !u.dragoverBubble && o.stopPropagation()), !b.animated && (M = !0, p && !u.disabled && (g ? m || (s = !T.contains(b)) : I === this || (p.lastPullMode = O.checkPull(this, p, b, o)) && f.checkPut(this, p, b, o)) && (void 0 === o.rootEl || o.rootEl === this.el))) { if (it(o, u, this.el), K) return; if (i = n(o.target, u.draggable, d), r = b.getBoundingClientRect(), I !== this && (I = this, v = !0), s) return e(p, !0), D = T, void (w || C ? T.insertBefore(b, w || C) : m || T.appendChild(b)); if (0 === d.children.length || d.children[0] === y || d === o.target && function (t, e) { var n = t.lastElementChild.getBoundingClientRect(); return e.clientY - (n.top + n.height) > 5 || e.clientX - (n.left + n.width) > 5 }(d, o)) { if (0 !== d.children.length && d.children[0] !== y && d === o.target && (i = d.lastElementChild), i) { if (i.animated) return; l = i.getBoundingClientRect() } e(p, g), !1 !== c(T, d, b, r, i, l, o) && (b.contains(d) || (d.appendChild(b), D = d), this._animate(r, b), i && this._animate(l, i)) } else if (i && !i.animated && i !== b && void 0 !== i.parentNode[j]) { k !== i && (k = i, B = a(i), P = a(i.parentNode)); var _ = (l = i.getBoundingClientRect()).right - l.left, S = l.bottom - l.top, E = U.test(B.cssFloat + B.display) || "flex" == P.display && 0 === P["flex-direction"].indexOf("row"), x = i.offsetWidth > b.offsetWidth, N = i.offsetHeight > b.offsetHeight, Y = (E ? (o.clientX - l.left) / _ : (o.clientY - l.top) / S) > .5, X = i.nextElementSibling, R = !1; if (E) { var A = b.offsetTop, L = i.offsetTop; R = A === L ? i.previousElementSibling === b && !x || Y && x : i.previousElementSibling === b || b.previousElementSibling === i ? (o.clientY - l.top) / S > .5 : L > A } else v || (R = X !== b && !N || Y && N); var F = c(T, d, b, r, i, l, o, R); !1 !== F && (1 !== F && -1 !== F || (R = 1 === F), K = !0, q(h, 30), e(p, g), b.contains(d) || (R && !X ? d.appendChild(b) : i.parentNode.insertBefore(b, R ? X : i)), D = b.parentNode, this._animate(r, b), this._animate(l, i)) } } }, _animate: function (t, e) { var n = this.options.animation; if (n) { var o = e.getBoundingClientRect(); 1 === t.nodeType && (t = t.getBoundingClientRect()), a(e, "transition", "none"), a(e, "transform", "translate3d(" + (t.left - o.left) + "px," + (t.top - o.top) + "px,0)"), e.offsetWidth, a(e, "transition", "all " + n + "ms"), a(e, "transform", "translate3d(0,0,0)"), clearTimeout(e.animated), e.animated = q(function () { a(e, "transition", ""), a(e, "transform", ""), e.animated = !1 }, n) } }, _offUpEvents: function () { var t = this.el.ownerDocument; i(W, "touchmove", this._onTouchMove), i(W, "pointermove", this._onTouchMove), i(t, "mouseup", this._onDrop), i(t, "touchend", this._onDrop), i(t, "pointerup", this._onDrop), i(t, "touchcancel", this._onDrop), i(t, "pointercancel", this._onDrop), i(t, "selectstart", this) }, _onDrop: function (e) { var n = this.el, o = this.options; clearInterval(this._loopId), clearInterval(L.pid), clearTimeout(this._dragStartTimer), _(this._cloneId), _(this._dragStartId), i(W, "mouseover", this), i(W, "mousemove", this._onTouchMove), this.nativeDraggable && (i(W, "drop", this), i(n, "dragstart", this._onDragStart)), this._offUpEvents(), e && (M && (e.preventDefault(), !o.dropBubble && e.stopPropagation()), y && y.parentNode && y.parentNode.removeChild(y), T !== D && "clone" === t.active.lastPullMode || w && w.parentNode && w.parentNode.removeChild(w), b && (this.nativeDraggable && i(b, "dragend", this), d(b), b.style["will-change"] = "", r(b, this.options.ghostClass, !1), r(b, this.options.chosenClass, !1), s(this, T, "unchoose", b, D, T, Y), T !== D ? (X = u(b, o.draggable)) >= 0 && (s(null, D, "add", b, D, T, Y, X), s(this, T, "remove", b, D, T, Y, X), s(null, D, "sort", b, D, T, Y, X), s(this, T, "sort", b, D, T, Y, X)) : b.nextSibling !== C && (X = u(b, o.draggable)) >= 0 && (s(this, T, "update", b, D, T, Y, X), s(this, T, "sort", b, D, T, Y, X)), t.active && (null != X && -1 !== X || (X = Y), s(this, T, "end", b, D, T, Y, X), this.save()))), this._nulling() }, _nulling: function () { T = b = D = y = C = w = S = E = x = R = A = M = X = k = B = I = O = t.active = null, et.forEach(function (t) { t.checked = !0 }), et.length = 0 }, handleEvent: function (t) { switch (t.type) { case "drop": case "dragend": this._onDrop(t); break; case "dragover": case "dragenter": b && (this._onDragOver(t), function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.preventDefault() }(t)); break; case "mouseover": this._onDrop(t); break; case "selectstart": t.preventDefault() } }, toArray: function () { for (var t, e = [], o = this.el.children, i = 0, r = o.length, a = this.options; i < r; i++)n(t = o[i], a.draggable, this.el) && e.push(t.getAttribute(a.dataIdAttr) || function (t) { for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; n--;)o += e.charCodeAt(n); return o.toString(36) }(t)); return e }, sort: function (t) { var e = {}, o = this.el; this.toArray().forEach(function (t, i) { var r = o.children[i]; n(r, this.options.draggable, o) && (e[t] = r) }, this), t.forEach(function (t) { e[t] && (o.removeChild(e[t]), o.appendChild(e[t])) }) }, save: function () { var t = this.options.store; t && t.set(this) }, closest: function (t, e) { return n(t, e || this.options.draggable, this.el) }, option: function (t, e) { var n = this.options; if (void 0 === e) return n[t]; n[t] = e, "group" === t && rt(n) }, destroy: function () { var t = this.el; t[j] = null, i(t, "mousedown", this._onTapStart), i(t, "touchstart", this._onTapStart), i(t, "pointerdown", this._onTapStart), this.nativeDraggable && (i(t, "dragover", this), i(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function (t) { t.removeAttribute("draggable") }), nt.splice(nt.indexOf(this._onDragOver), 1), this._onDrop(), this.el = t = null } }, o(W, "touchmove", function (e) { t.active && e.preventDefault() }), t.utils = { on: o, off: i, css: a, find: l, is: function (t, e) { return !!n(t, e, t) }, extend: g, throttle: p, closest: n, toggleClass: r, clone: v, index: u, nextTick: m, cancelNextTick: _ }, t.create = function (e, n) { return new t(e, n) }, t.version = "1.7.0", t });
var app = app || {};

app.checkAssignmentColor = (assignment) => {
    if(assignment.hasClass('color')) {
        let assignmentId = assignment.attr('data-id'),
            controls = assignment.find('.controls > button'),
            container = assignment.find('.flex-table'),
            items = container.children(),
            activeId = controls.filter(".active").attr('data-id'),
            correctSvg = '<svg focusable="false"><use xlink:href="#svg-checkmark"></use></svg>',
            wrongSvg = '<svg focusable="false"><use xlink:href="#svg-close"></use></svg>';

        let reset = () => {
            controls.filter('.eraser').addClass('active');
            controls.filter(':not(.eraser)').removeClass('active').empty();
            items.removeAttr('data-id');
            assignment.removeClass('validated');
        };

        let getCorrect = () => {
            // this should be retrieved with api call
            if (assignmentId === '1') {
                return [
                    {
                        id: 'blue',
                        value: 3
                    },
                    {
                        id: 'green',
                        value: 2
                    },
                    {
                        id: 'red',
                        value: 4
                    }
                ];
            } else if (assignmentId === '2') {
                return [
                    {
                        id: 'orange',
                        value: 4
                    },
                    {
                        id: 'teal',
                        value: 2
                    }
                ];
            }
        };

        let getItems = (id) => {
            let result = 0;
            items.each((i, data) => {
                let $this = $(data),
                    itemId = $this.attr('data-id');
                if (itemId !== undefined && id === itemId) {
                    result++;
                }
            });
            return result;
        };

        assignment.on('click', 'button[type="submit"]', () => {
            if (!assignment.hasClass('validated')) {
                assignment.addClass('validated');
                let correct = getCorrect();
                $(correct).each((i, data) => {
                    let selected = getItems(data.id),
                        append = (data.value === selected) ? correctSvg : wrongSvg;
                    controls.filter('[data-id="' + data.id + '"]').append(append);
                });
            }
        });

        assignment.on('click', 'button[type="reset"]', () => {
            reset();
        });

        assignment.on('click', 'button.correct', () => {
            reset();
            assignment.addClass('validated');
            let correct = getCorrect();
            $(correct).each((i, data) => {
                for (i = 0; i < data.value; i++) {
                    $(items.filter(':not([data-id])')[0]).attr('data-id', data.id);
                }
                controls.filter('[data-id="' + data.id + '"]').append(correctSvg);
            });
        });

        controls.on('click', (e) => {
            let $this = $(e.currentTarget);
            $this.addClass('active').siblings('.active').removeClass('active');
            activeId = $this.attr('data-id');
        });

        items.on('click', (e) => {
            let $this = $(e.currentTarget);
            $this.attr('data-id', activeId);
        });
    };
};
var app = app || {};

app.checkAssignmentDragAndDrop = (assignment) => {
    if (assignment.hasClass('drag-and-drop')) {
        assignment.attr('data-moving', 0);
        let id = assignment.attr('data-id'),
            from = assignment.find('.from .container'),
            items = assignment.find('.item'),
            checkboxes = items.find('input[type=checkbox]');

        let getChecked = () => {
            return $($.map(checkboxes, (item) => {
                if (item.checked) {
                    return item;
                }
            }));
        };
    
        let reset = () => {
            items.removeClass('valid invalid');
            let checked = getChecked();
            if (checked.length) {
                checked.prop('checked', false);
            }
            from.append(items);
            assignment.removeClass('validated moving');
            items = items.shuffle();
        };

        let getCorrect = () => {
            // this should be retrieved with api call
            if (id === '1') {
                return [
                    {
                        id: '1', // TV
                        items: ['5', '7']
                    },
                    {
                        id: '2', // Games
                        items: ['6', '8']
                    },
                    {
                        id: '3', // Music
                        items: ['2', '4']
                    },
                    {
                        id: '4', // Sport
                        items: ['1', '3']
                    }
                ];
            }
        };
        if (bowser.desktop) {
            assignment.find('.container').each((i, e) => {
                Sortable.create(e, {
                    group: 'container', draggable: ".item",
                    animation: 0,
                    scroll: false,
                    forceFallback: true,
                    fallbackOnBody: true,
                    chosenClass: 'drag-and-drop-sortable-chosen',
                    onAdd: () => {
                        setTimeout(() => {
                            let checked = getChecked();
                            if (checked.length) {
                                checked.prop('checked', false);
                                assignment.removeClass('moving');
                            }
                        });
                    }
                });
            });
        }

        checkboxes.on('click', (e) => {
            let $this = $(e.currentTarget),
                item = $this.parents('.item'),
                moving = parseInt(assignment.attr('data-moving'));
            if ($this.is(':checked')) {
                moving++;
                assignment.attr('data-moving', moving);
                assignment.addClass('moving');
            } else {
                moving--;
                assignment.attr('data-moving', moving);
                if (moving === 0) {
                    assignment.removeClass('moving');
                }
            }
        });

        assignment.on('click', '.place', (e) => {
            let $this = $(e.currentTarget)
            assignment.removeClass('moving');
            let checked = getChecked();
            if (checked.length) {
                checked.prop('checked', false);
                $this.parent('.header').next().children('.container').append(checked.parent());
            }
        });

        assignment.on('click', 'button[type="submit"]', () => {
            if (!assignment.hasClass('validated')) {
                let checked = getChecked();
                if (checked.length) {
                    checked.prop('checked', false);
                }
                assignment.addClass('validated');
                let correct = getCorrect();
                $(correct).each((i, data) => {
                    let container = assignment.find('.to .container[data-id="' + data.id + '"]');
                    container.children().each((i, child) => {
                        let item = $(child);
                        if ($.inArray(item.attr('data-id'), data.items) !== -1) {
                            item.addClass('valid');
                        } else {
                            item.addClass('invalid');
                        }
                    });
                });
            }
        });

        assignment.on('click', 'button[type="reset"]', () => {
            reset();
        });

        assignment.on('click', 'button.correct', () => {
            reset();
            assignment.addClass('validated');
            let correct = getCorrect();
            $(correct).each((i, data) => {
                let container = assignment.find('.to .container[data-id="' + data.id + '"]');
                $(data.items).each((j, id) => {
                    let item = app.getAssignmentItem(items, id);
                    item.addClass('valid');
                    item.appendTo(container);
                });
            });
        });
    }
};
var app = app || {};

app.checkAssignmentSort = (assignment) => {
    if (assignment.hasClass('sort')) {
        let id = assignment.attr('data-id'),
            container = assignment.find('.container'),
            items = assignment.find('.item');
        Sortable.create(container[0], {
            draggable: ".item",
            animation: 0,
            scroll: false,
            forceFallback: true,
            fallbackOnBody: true,
            chosenClass: 'sort-sortable-chosen'
        });

        if (!container.hasClass('wrap')) {
            let checkWidth = () => {
                container.css('height', container.height()).removeClass('row').addClass('column');
                let containerLeft = container[0].getBoundingClientRect().left,
                    firstItem = container.find('> .item:first-child'),
                    firstItemLeft = firstItem[0].getBoundingClientRect().left - parseInt(firstItem.css('margin-left'));
                if (firstItemLeft < containerLeft) {
                    container.removeClass('column').addClass('row');
                }
                container.css('height', '').addClass('checked');
            };

            checkWidth();
            
            $(window).bind('resize.assignmentSort', $.throttle(app.throttleInterval, false, () => {
                checkWidth();
            }));
        }

        let reset = () => {
            items.removeClass('valid invalid');
            assignment.removeClass('validated');
            items = items.shuffle();
        };

        let getCorrect = () => {
            // this should be retrieved with api call
            if (id === '1') {
                return ['3', '1', '2', '5', '4', '7', '6', '8', '9'];
            } else if (id === '2') {
                return ['4', '2', '1', '3'];
            }
        };

        assignment.on('click', 'button[type="submit"]', () => {
            if (!assignment.hasClass('validated')) {
                assignment.addClass('validated');
                let correct = getCorrect();
                $(correct).each((i, id) => {
                    let item = app.getAssignmentItem(items, id);
                    if (item.index() === i) {
                        item.addClass('valid');
                    } else {
                        item.addClass('invalid');
                    }
                });
            }
        });

        assignment.on('click', 'button[type="reset"]', () => {
            reset();
        });

        function insertAtIndex(i, item) {
            if (i === 0) {
                container.prepend(item);
            } else {
                container.find('> .item:nth-child(' + i + ')').after(item);
            }
        };

        assignment.on('click', 'button.correct', () => {
            reset();
            assignment.addClass('validated');
            let correct = getCorrect();
            $(correct).each((i, id) => {
                let item = app.getAssignmentItem(items, id);
                item.addClass('valid');
                insertAtIndex(i, item);
            });
        });
    } else {
        $(window).unbind('resize.assignmentSort');
    }
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvcnRhYmxlLm1pbi5qcyIsImNvbG9yLmpzIiwiZHJhZ0FuZERyb3AuanMiLCJzb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhc3NpZ25tZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBTb3J0YWJsZSAxLjcuMCAtIE1JVCB8IGdpdDovL2dpdGh1Yi5jb20vcnViYXhhL1NvcnRhYmxlLmdpdCAqL1xyXG5cclxuIWZ1bmN0aW9uICh0KSB7IFwidXNlIHN0cmljdFwiOyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKHQpIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlICYmIHZvaWQgMCAhPT0gbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA9IHQoKSA6IHdpbmRvdy5Tb3J0YWJsZSA9IHQoKSB9KGZ1bmN0aW9uICgpIHsgXCJ1c2Ugc3RyaWN0XCI7IGZ1bmN0aW9uIHQoZSwgbikgeyBpZiAoIWUgfHwgIWUubm9kZVR5cGUgfHwgMSAhPT0gZS5ub2RlVHlwZSkgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIEhUTUxFbGVtZW50LCBhbmQgbm90IFwiICsge30udG9TdHJpbmcuY2FsbChlKTsgdGhpcy5lbCA9IGUsIHRoaXMub3B0aW9ucyA9IG4gPSBnKHt9LCBuKSwgZVtqXSA9IHRoaXM7IHZhciBpID0geyBncm91cDogbnVsbCwgc29ydDogITAsIGRpc2FibGVkOiAhMSwgc3RvcmU6IG51bGwsIGhhbmRsZTogbnVsbCwgc2Nyb2xsOiAhMCwgc2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLCBzY3JvbGxTcGVlZDogMTAsIGRyYWdnYWJsZTogL1t1b11sL2kudGVzdChlLm5vZGVOYW1lKSA/IFwibGlcIiA6IFwiPipcIiwgZ2hvc3RDbGFzczogXCJzb3J0YWJsZS1naG9zdFwiLCBjaG9zZW5DbGFzczogXCJzb3J0YWJsZS1jaG9zZW5cIiwgZHJhZ0NsYXNzOiBcInNvcnRhYmxlLWRyYWdcIiwgaWdub3JlOiBcImEsIGltZ1wiLCBmaWx0ZXI6IG51bGwsIHByZXZlbnRPbkZpbHRlcjogITAsIGFuaW1hdGlvbjogMCwgc2V0RGF0YTogZnVuY3Rpb24gKHQsIGUpIHsgdC5zZXREYXRhKFwiVGV4dFwiLCBlLnRleHRDb250ZW50KSB9LCBkcm9wQnViYmxlOiAhMSwgZHJhZ292ZXJCdWJibGU6ICExLCBkYXRhSWRBdHRyOiBcImRhdGEtaWRcIiwgZGVsYXk6IDAsIGZvcmNlRmFsbGJhY2s6ICExLCBmYWxsYmFja0NsYXNzOiBcInNvcnRhYmxlLWZhbGxiYWNrXCIsIGZhbGxiYWNrT25Cb2R5OiAhMSwgZmFsbGJhY2tUb2xlcmFuY2U6IDAsIGZhbGxiYWNrT2Zmc2V0OiB7IHg6IDAsIHk6IDAgfSwgc3VwcG9ydFBvaW50ZXI6ICExICE9PSB0LnN1cHBvcnRQb2ludGVyIH07IGZvciAodmFyIHIgaW4gaSkgIShyIGluIG4pICYmIChuW3JdID0gaVtyXSk7IHJ0KG4pOyBmb3IgKHZhciBhIGluIHRoaXMpIFwiX1wiID09PSBhLmNoYXJBdCgwKSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXNbYV0gJiYgKHRoaXNbYV0gPSB0aGlzW2FdLmJpbmQodGhpcykpOyB0aGlzLm5hdGl2ZURyYWdnYWJsZSA9ICFuLmZvcmNlRmFsbGJhY2sgJiYgWiwgbyhlLCBcIm1vdXNlZG93blwiLCB0aGlzLl9vblRhcFN0YXJ0KSwgbyhlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25UYXBTdGFydCksIG4uc3VwcG9ydFBvaW50ZXIgJiYgbyhlLCBcInBvaW50ZXJkb3duXCIsIHRoaXMuX29uVGFwU3RhcnQpLCB0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiAobyhlLCBcImRyYWdvdmVyXCIsIHRoaXMpLCBvKGUsIFwiZHJhZ2VudGVyXCIsIHRoaXMpKSwgbnQucHVzaCh0aGlzLl9vbkRyYWdPdmVyKSwgbi5zdG9yZSAmJiB0aGlzLnNvcnQobi5zdG9yZS5nZXQodGhpcykpIH0gZnVuY3Rpb24gZSh0LCBlKSB7IFwiY2xvbmVcIiAhPT0gdC5sYXN0UHVsbE1vZGUgJiYgKGUgPSAhMCksIHcgJiYgdy5zdGF0ZSAhPT0gZSAmJiAoYSh3LCBcImRpc3BsYXlcIiwgZSA/IFwibm9uZVwiIDogXCJcIiksIGUgfHwgdy5zdGF0ZSAmJiAodC5vcHRpb25zLmdyb3VwLnJldmVydENsb25lID8gKFQuaW5zZXJ0QmVmb3JlKHcsIEMpLCB0Ll9hbmltYXRlKGIsIHcpKSA6IFQuaW5zZXJ0QmVmb3JlKHcsIGIpKSwgdy5zdGF0ZSA9IGUpIH0gZnVuY3Rpb24gbih0LCBlLCBuKSB7IGlmICh0KSB7IG4gPSBuIHx8IFc7IGRvIHsgaWYgKFwiPipcIiA9PT0gZSAmJiB0LnBhcmVudE5vZGUgPT09IG4gfHwgZih0LCBlKSkgcmV0dXJuIHQgfSB3aGlsZSAodCA9IGZ1bmN0aW9uICh0KSB7IHZhciBlID0gdC5ob3N0OyByZXR1cm4gZSAmJiBlLm5vZGVUeXBlID8gZSA6IHQucGFyZW50Tm9kZSB9KHQpKSB9IHJldHVybiBudWxsIH0gZnVuY3Rpb24gbyh0LCBlLCBuKSB7IHQuYWRkRXZlbnRMaXN0ZW5lcihlLCBuLCBRKSB9IGZ1bmN0aW9uIGkodCwgZSwgbikgeyB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbiwgUSkgfSBmdW5jdGlvbiByKHQsIGUsIG4pIHsgaWYgKHQpIGlmICh0LmNsYXNzTGlzdCkgdC5jbGFzc0xpc3RbbiA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShlKTsgZWxzZSB7IHZhciBvID0gKFwiIFwiICsgdC5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShGLCBcIiBcIikucmVwbGFjZShcIiBcIiArIGUgKyBcIiBcIiwgXCIgXCIpOyB0LmNsYXNzTmFtZSA9IChvICsgKG4gPyBcIiBcIiArIGUgOiBcIlwiKSkucmVwbGFjZShGLCBcIiBcIikgfSB9IGZ1bmN0aW9uIGEodCwgZSwgbikgeyB2YXIgbyA9IHQgJiYgdC5zdHlsZTsgaWYgKG8pIHsgaWYgKHZvaWQgMCA9PT0gbikgcmV0dXJuIFcuZGVmYXVsdFZpZXcgJiYgVy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlID8gbiA9IFcuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0LCBcIlwiKSA6IHQuY3VycmVudFN0eWxlICYmIChuID0gdC5jdXJyZW50U3R5bGUpLCB2b2lkIDAgPT09IGUgPyBuIDogbltlXTsgZSBpbiBvIHx8IChlID0gXCItd2Via2l0LVwiICsgZSksIG9bZV0gPSBuICsgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyBcIlwiIDogXCJweFwiKSB9IH0gZnVuY3Rpb24gbCh0LCBlLCBuKSB7IGlmICh0KSB7IHZhciBvID0gdC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKSwgaSA9IDAsIHIgPSBvLmxlbmd0aDsgaWYgKG4pIGZvciAoOyBpIDwgcjsgaSsrKW4ob1tpXSwgaSk7IHJldHVybiBvIH0gcmV0dXJuIFtdIH0gZnVuY3Rpb24gcyh0LCBlLCBuLCBvLCBpLCByLCBhLCBsKSB7IHQgPSB0IHx8IGVbal07IHZhciBzID0gVy5jcmVhdGVFdmVudChcIkV2ZW50XCIpLCBjID0gdC5vcHRpb25zLCBkID0gXCJvblwiICsgbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG4uc3Vic3RyKDEpOyBzLmluaXRFdmVudChuLCAhMCwgITApLCBzLnRvID0gaSB8fCBlLCBzLmZyb20gPSByIHx8IGUsIHMuaXRlbSA9IG8gfHwgZSwgcy5jbG9uZSA9IHcsIHMub2xkSW5kZXggPSBhLCBzLm5ld0luZGV4ID0gbCwgZS5kaXNwYXRjaEV2ZW50KHMpLCBjW2RdICYmIGNbZF0uY2FsbCh0LCBzKSB9IGZ1bmN0aW9uIGModCwgZSwgbiwgbywgaSwgciwgYSwgbCkgeyB2YXIgcywgYywgZCA9IHRbal0sIGggPSBkLm9wdGlvbnMub25Nb3ZlOyByZXR1cm4gKHMgPSBXLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpLmluaXRFdmVudChcIm1vdmVcIiwgITAsICEwKSwgcy50byA9IGUsIHMuZnJvbSA9IHQsIHMuZHJhZ2dlZCA9IG4sIHMuZHJhZ2dlZFJlY3QgPSBvLCBzLnJlbGF0ZWQgPSBpIHx8IGUsIHMucmVsYXRlZFJlY3QgPSByIHx8IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHMud2lsbEluc2VydEFmdGVyID0gbCwgdC5kaXNwYXRjaEV2ZW50KHMpLCBoICYmIChjID0gaC5jYWxsKGQsIHMsIGEpKSwgYyB9IGZ1bmN0aW9uIGQodCkgeyB0LmRyYWdnYWJsZSA9ICExIH0gZnVuY3Rpb24gaCgpIHsgSyA9ICExIH0gZnVuY3Rpb24gdSh0LCBlKSB7IHZhciBuID0gMDsgaWYgKCF0IHx8ICF0LnBhcmVudE5vZGUpIHJldHVybiAtMTsgZm9yICg7IHQgJiYgKHQgPSB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpOylcIlRFTVBMQVRFXCIgPT09IHQubm9kZU5hbWUudG9VcHBlckNhc2UoKSB8fCBcIj4qXCIgIT09IGUgJiYgIWYodCwgZSkgfHwgbisrOyByZXR1cm4gbiB9IGZ1bmN0aW9uIGYodCwgZSkgeyBpZiAodCkgeyB2YXIgbiA9IChlID0gZS5zcGxpdChcIi5cIikpLnNoaWZ0KCkudG9VcHBlckNhc2UoKSwgbyA9IG5ldyBSZWdFeHAoXCJcXFxccyhcIiArIGUuam9pbihcInxcIikgKyBcIikoPz1cXFxccylcIiwgXCJnXCIpOyByZXR1cm4gIShcIlwiICE9PSBuICYmIHQubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPSBuIHx8IGUubGVuZ3RoICYmICgoXCIgXCIgKyB0LmNsYXNzTmFtZSArIFwiIFwiKS5tYXRjaChvKSB8fCBbXSkubGVuZ3RoICE9IGUubGVuZ3RoKSB9IHJldHVybiAhMSB9IGZ1bmN0aW9uIHAodCwgZSkgeyB2YXIgbiwgbzsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdm9pZCAwID09PSBuICYmIChuID0gYXJndW1lbnRzLCBvID0gdGhpcywgcShmdW5jdGlvbiAoKSB7IDEgPT09IG4ubGVuZ3RoID8gdC5jYWxsKG8sIG5bMF0pIDogdC5hcHBseShvLCBuKSwgbiA9IHZvaWQgMCB9LCBlKSkgfSB9IGZ1bmN0aW9uIGcodCwgZSkgeyBpZiAodCAmJiBlKSBmb3IgKHZhciBuIGluIGUpIGUuaGFzT3duUHJvcGVydHkobikgJiYgKHRbbl0gPSBlW25dKTsgcmV0dXJuIHQgfSBmdW5jdGlvbiB2KHQpIHsgcmV0dXJuIEcgJiYgRy5kb20gPyBHLmRvbSh0KS5jbG9uZU5vZGUoITApIDogeiA/IHoodCkuY2xvbmUoITApWzBdIDogdC5jbG9uZU5vZGUoITApIH0gZnVuY3Rpb24gbSh0KSB7IHJldHVybiBxKHQsIDApIH0gZnVuY3Rpb24gXyh0KSB7IHJldHVybiBjbGVhclRpbWVvdXQodCkgfSBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQpIHJldHVybiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIlNvcnRhYmxlLmpzIHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKSB9OyB2YXIgYiwgRCwgeSwgdywgVCwgQywgUywgRSwgeCwgTiwgaywgQiwgUCwgWSwgWCwgTywgSSwgUiwgQSwgTSwgTCA9IHt9LCBGID0gL1xccysvZywgVSA9IC9sZWZ0fHJpZ2h0fGlubGluZS8sIGogPSBcIlNvcnRhYmxlXCIgKyAobmV3IERhdGUpLmdldFRpbWUoKSwgSCA9IHdpbmRvdywgVyA9IEguZG9jdW1lbnQsIFYgPSBILnBhcnNlSW50LCBxID0gSC5zZXRUaW1lb3V0LCB6ID0gSC5qUXVlcnkgfHwgSC5aZXB0bywgRyA9IEguUG9seW1lciwgUSA9ICExLCBaID0gXCJkcmFnZ2FibGVcIiBpbiBXLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIEogPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llKS9pKSAmJiAodCA9IFcuY3JlYXRlRWxlbWVudChcInhcIiksIHQuc3R5bGUuY3NzVGV4dCA9IFwicG9pbnRlci1ldmVudHM6YXV0b1wiLCBcImF1dG9cIiA9PT0gdC5zdHlsZS5wb2ludGVyRXZlbnRzKSB9KCksIEsgPSAhMSwgJCA9IE1hdGguYWJzLCB0dCA9IE1hdGgubWluLCBldCA9IFtdLCBudCA9IFtdLCBvdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICExIH0sIGl0ID0gcChmdW5jdGlvbiAodCwgZSwgbikgeyBpZiAobiAmJiBlLnNjcm9sbCkgeyB2YXIgbywgaSwgciwgYSwgbCwgcywgYyA9IG5bal0sIGQgPSBlLnNjcm9sbFNlbnNpdGl2aXR5LCBoID0gZS5zY3JvbGxTcGVlZCwgdSA9IHQuY2xpZW50WCwgZiA9IHQuY2xpZW50WSwgcCA9IHdpbmRvdy5pbm5lcldpZHRoLCBnID0gd2luZG93LmlubmVySGVpZ2h0OyBpZiAoeCAhPT0gbiAmJiAoRSA9IGUuc2Nyb2xsLCB4ID0gbiwgTiA9IGUuc2Nyb2xsRm4sICEwID09PSBFKSkgeyBFID0gbjsgZG8geyBpZiAoRS5vZmZzZXRXaWR0aCA8IEUuc2Nyb2xsV2lkdGggfHwgRS5vZmZzZXRIZWlnaHQgPCBFLnNjcm9sbEhlaWdodCkgYnJlYWsgfSB3aGlsZSAoRSA9IEUucGFyZW50Tm9kZSkgfSBFICYmIChvID0gRSwgaSA9IEUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSAoJChpLnJpZ2h0IC0gdSkgPD0gZCkgLSAoJChpLmxlZnQgLSB1KSA8PSBkKSwgYSA9ICgkKGkuYm90dG9tIC0gZikgPD0gZCkgLSAoJChpLnRvcCAtIGYpIDw9IGQpKSwgciB8fCBhIHx8IChhID0gKGcgLSBmIDw9IGQpIC0gKGYgPD0gZCksICgociA9IChwIC0gdSA8PSBkKSAtICh1IDw9IGQpKSB8fCBhKSAmJiAobyA9IEgpKSwgTC52eCA9PT0gciAmJiBMLnZ5ID09PSBhICYmIEwuZWwgPT09IG8gfHwgKEwuZWwgPSBvLCBMLnZ4ID0gciwgTC52eSA9IGEsIGNsZWFySW50ZXJ2YWwoTC5waWQpLCBvICYmIChMLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgaWYgKHMgPSBhID8gYSAqIGggOiAwLCBsID0gciA/IHIgKiBoIDogMCwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBOKSByZXR1cm4gTi5jYWxsKGMsIGwsIHMsIHQpOyBvID09PSBIID8gSC5zY3JvbGxUbyhILnBhZ2VYT2Zmc2V0ICsgbCwgSC5wYWdlWU9mZnNldCArIHMpIDogKG8uc2Nyb2xsVG9wICs9IHMsIG8uc2Nyb2xsTGVmdCArPSBsKSB9LCAyNCkpKSB9IH0sIDMwKSwgcnQgPSBmdW5jdGlvbiAodCkgeyBmdW5jdGlvbiBlKHQsIGUpIHsgcmV0dXJuIG51bGwgIT0gdCAmJiAhMCAhPT0gdCB8fCBudWxsICE9ICh0ID0gbi5uYW1lKSA/IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBmdW5jdGlvbiAobiwgbykgeyB2YXIgaSA9IG8ub3B0aW9ucy5ncm91cC5uYW1lOyByZXR1cm4gZSA/IHQgOiB0ICYmICh0LmpvaW4gPyB0LmluZGV4T2YoaSkgPiAtMSA6IGkgPT0gdCkgfSA6IG90IH0gdmFyIG4gPSB7fSwgbyA9IHQuZ3JvdXA7IG8gJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbyB8fCAobyA9IHsgbmFtZTogbyB9KSwgbi5uYW1lID0gby5uYW1lLCBuLmNoZWNrUHVsbCA9IGUoby5wdWxsLCAhMCksIG4uY2hlY2tQdXQgPSBlKG8ucHV0KSwgbi5yZXZlcnRDbG9uZSA9IG8ucmV2ZXJ0Q2xvbmUsIHQuZ3JvdXAgPSBuIH07IHRyeSB7IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7IGdldDogZnVuY3Rpb24gKCkgeyBRID0geyBjYXB0dXJlOiAhMSwgcGFzc2l2ZTogITEgfSB9IH0pKSB9IGNhdGNoICh0KSB7IH0gcmV0dXJuIHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogdCwgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uICh0KSB7IHZhciBlLCBvID0gdGhpcywgaSA9IHRoaXMuZWwsIHIgPSB0aGlzLm9wdGlvbnMsIGEgPSByLnByZXZlbnRPbkZpbHRlciwgbCA9IHQudHlwZSwgYyA9IHQudG91Y2hlcyAmJiB0LnRvdWNoZXNbMF0sIGQgPSAoYyB8fCB0KS50YXJnZXQsIGggPSB0LnRhcmdldC5zaGFkb3dSb290ICYmIHQucGF0aCAmJiB0LnBhdGhbMF0gfHwgZCwgZiA9IHIuZmlsdGVyOyBpZiAoZnVuY3Rpb24gKHQpIHsgZXQubGVuZ3RoID0gMDsgZm9yICh2YXIgZSA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSwgbiA9IGUubGVuZ3RoOyBuLS07KSB7IHZhciBvID0gZVtuXTsgby5jaGVja2VkICYmIGV0LnB1c2gobykgfSB9KGkpLCAhYiAmJiAhKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QobCkgJiYgMCAhPT0gdC5idXR0b24gfHwgci5kaXNhYmxlZCkgJiYgIWguaXNDb250ZW50RWRpdGFibGUgJiYgKGQgPSBuKGQsIHIuZHJhZ2dhYmxlLCBpKSkgJiYgUyAhPT0gZCkgeyBpZiAoZSA9IHUoZCwgci5kcmFnZ2FibGUpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGYpIHsgaWYgKGYuY2FsbCh0aGlzLCB0LCBkLCB0aGlzKSkgcmV0dXJuIHMobywgaCwgXCJmaWx0ZXJcIiwgZCwgaSwgaSwgZSksIHZvaWQgKGEgJiYgdC5wcmV2ZW50RGVmYXVsdCgpKSB9IGVsc2UgaWYgKGYgJiYgKGYgPSBmLnNwbGl0KFwiLFwiKS5zb21lKGZ1bmN0aW9uICh0KSB7IGlmICh0ID0gbihoLCB0LnRyaW0oKSwgaSkpIHJldHVybiBzKG8sIHQsIFwiZmlsdGVyXCIsIGQsIGksIGksIGUpLCAhMCB9KSkpIHJldHVybiB2b2lkIChhICYmIHQucHJldmVudERlZmF1bHQoKSk7IHIuaGFuZGxlICYmICFuKGgsIHIuaGFuZGxlLCBpKSB8fCB0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KHQsIGMsIGQsIGUpIH0gfSwgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uICh0LCBlLCBuLCBpKSB7IHZhciBhLCBjID0gdGhpcywgaCA9IGMuZWwsIHUgPSBjLm9wdGlvbnMsIGYgPSBoLm93bmVyRG9jdW1lbnQ7IG4gJiYgIWIgJiYgbi5wYXJlbnROb2RlID09PSBoICYmIChSID0gdCwgVCA9IGgsIEQgPSAoYiA9IG4pLnBhcmVudE5vZGUsIEMgPSBiLm5leHRTaWJsaW5nLCBTID0gbiwgTyA9IHUuZ3JvdXAsIFkgPSBpLCB0aGlzLl9sYXN0WCA9IChlIHx8IHQpLmNsaWVudFgsIHRoaXMuX2xhc3RZID0gKGUgfHwgdCkuY2xpZW50WSwgYi5zdHlsZVtcIndpbGwtY2hhbmdlXCJdID0gXCJhbGxcIiwgYSA9IGZ1bmN0aW9uICgpIHsgYy5fZGlzYWJsZURlbGF5ZWREcmFnKCksIGIuZHJhZ2dhYmxlID0gYy5uYXRpdmVEcmFnZ2FibGUsIHIoYiwgdS5jaG9zZW5DbGFzcywgITApLCBjLl90cmlnZ2VyRHJhZ1N0YXJ0KHQsIGUpLCBzKGMsIFQsIFwiY2hvb3NlXCIsIGIsIFQsIFQsIFkpIH0sIHUuaWdub3JlLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IGwoYiwgdC50cmltKCksIGQpIH0pLCBvKGYsIFwibW91c2V1cFwiLCBjLl9vbkRyb3ApLCBvKGYsIFwidG91Y2hlbmRcIiwgYy5fb25Ecm9wKSwgbyhmLCBcInRvdWNoY2FuY2VsXCIsIGMuX29uRHJvcCksIG8oZiwgXCJzZWxlY3RzdGFydFwiLCBjKSwgdS5zdXBwb3J0UG9pbnRlciAmJiBvKGYsIFwicG9pbnRlcmNhbmNlbFwiLCBjLl9vbkRyb3ApLCB1LmRlbGF5ID8gKG8oZiwgXCJtb3VzZXVwXCIsIGMuX2Rpc2FibGVEZWxheWVkRHJhZyksIG8oZiwgXCJ0b3VjaGVuZFwiLCBjLl9kaXNhYmxlRGVsYXllZERyYWcpLCBvKGYsIFwidG91Y2hjYW5jZWxcIiwgYy5fZGlzYWJsZURlbGF5ZWREcmFnKSwgbyhmLCBcIm1vdXNlbW92ZVwiLCBjLl9kaXNhYmxlRGVsYXllZERyYWcpLCBvKGYsIFwidG91Y2htb3ZlXCIsIGMuX2Rpc2FibGVEZWxheWVkRHJhZyksIHUuc3VwcG9ydFBvaW50ZXIgJiYgbyhmLCBcInBvaW50ZXJtb3ZlXCIsIGMuX2Rpc2FibGVEZWxheWVkRHJhZyksIGMuX2RyYWdTdGFydFRpbWVyID0gcShhLCB1LmRlbGF5KSkgOiBhKCkpIH0sIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7IGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lciksIGkodCwgXCJtb3VzZXVwXCIsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyksIGkodCwgXCJ0b3VjaGVuZFwiLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpLCBpKHQsIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKSwgaSh0LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpLCBpKHQsIFwidG91Y2htb3ZlXCIsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyksIGkodCwgXCJwb2ludGVybW92ZVwiLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpIH0sIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAodCwgZSkgeyAoZSA9IGUgfHwgKFwidG91Y2hcIiA9PSB0LnBvaW50ZXJUeXBlID8gdCA6IG51bGwpKSA/IChSID0geyB0YXJnZXQ6IGIsIGNsaWVudFg6IGUuY2xpZW50WCwgY2xpZW50WTogZS5jbGllbnRZIH0sIHRoaXMuX29uRHJhZ1N0YXJ0KFIsIFwidG91Y2hcIikpIDogdGhpcy5uYXRpdmVEcmFnZ2FibGUgPyAobyhiLCBcImRyYWdlbmRcIiwgdGhpcyksIG8oVCwgXCJkcmFnc3RhcnRcIiwgdGhpcy5fb25EcmFnU3RhcnQpKSA6IHRoaXMuX29uRHJhZ1N0YXJ0KFIsICEwKTsgdHJ5IHsgVy5zZWxlY3Rpb24gPyBtKGZ1bmN0aW9uICgpIHsgVy5zZWxlY3Rpb24uZW1wdHkoKSB9KSA6IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKSB9IGNhdGNoICh0KSB7IH0gfSwgX2RyYWdTdGFydGVkOiBmdW5jdGlvbiAoKSB7IGlmIChUICYmIGIpIHsgdmFyIGUgPSB0aGlzLm9wdGlvbnM7IHIoYiwgZS5naG9zdENsYXNzLCAhMCksIHIoYiwgZS5kcmFnQ2xhc3MsICExKSwgdC5hY3RpdmUgPSB0aGlzLCBzKHRoaXMsIFQsIFwic3RhcnRcIiwgYiwgVCwgVCwgWSkgfSBlbHNlIHRoaXMuX251bGxpbmcoKSB9LCBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiAoKSB7IGlmIChBKSB7IGlmICh0aGlzLl9sYXN0WCA9PT0gQS5jbGllbnRYICYmIHRoaXMuX2xhc3RZID09PSBBLmNsaWVudFkpIHJldHVybjsgdGhpcy5fbGFzdFggPSBBLmNsaWVudFgsIHRoaXMuX2xhc3RZID0gQS5jbGllbnRZLCBKIHx8IGEoeSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTsgdmFyIHQgPSBXLmVsZW1lbnRGcm9tUG9pbnQoQS5jbGllbnRYLCBBLmNsaWVudFkpLCBlID0gdCwgbiA9IG50Lmxlbmd0aDsgaWYgKHQgJiYgdC5zaGFkb3dSb290ICYmIChlID0gdCA9IHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KEEuY2xpZW50WCwgQS5jbGllbnRZKSksIGUpIGRvIHsgaWYgKGVbal0pIHsgZm9yICg7IG4tLTspbnRbbl0oeyBjbGllbnRYOiBBLmNsaWVudFgsIGNsaWVudFk6IEEuY2xpZW50WSwgdGFyZ2V0OiB0LCByb290RWw6IGUgfSk7IGJyZWFrIH0gdCA9IGUgfSB3aGlsZSAoZSA9IGUucGFyZW50Tm9kZSk7IEogfHwgYSh5LCBcImRpc3BsYXlcIiwgXCJcIikgfSB9LCBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7IGlmIChSKSB7IHZhciBuID0gdGhpcy5vcHRpb25zLCBvID0gbi5mYWxsYmFja1RvbGVyYW5jZSwgaSA9IG4uZmFsbGJhY2tPZmZzZXQsIHIgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLCBsID0gci5jbGllbnRYIC0gUi5jbGllbnRYICsgaS54LCBzID0gci5jbGllbnRZIC0gUi5jbGllbnRZICsgaS55LCBjID0gZS50b3VjaGVzID8gXCJ0cmFuc2xhdGUzZChcIiArIGwgKyBcInB4LFwiICsgcyArIFwicHgsMClcIiA6IFwidHJhbnNsYXRlKFwiICsgbCArIFwicHgsXCIgKyBzICsgXCJweClcIjsgaWYgKCF0LmFjdGl2ZSkgeyBpZiAobyAmJiB0dCgkKHIuY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgJChyLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgbykgcmV0dXJuOyB0aGlzLl9kcmFnU3RhcnRlZCgpIH0gdGhpcy5fYXBwZW5kR2hvc3QoKSwgTSA9ICEwLCBBID0gciwgYSh5LCBcIndlYmtpdFRyYW5zZm9ybVwiLCBjKSwgYSh5LCBcIm1velRyYW5zZm9ybVwiLCBjKSwgYSh5LCBcIm1zVHJhbnNmb3JtXCIsIGMpLCBhKHksIFwidHJhbnNmb3JtXCIsIGMpLCBlLnByZXZlbnREZWZhdWx0KCkgfSB9LCBfYXBwZW5kR2hvc3Q6IGZ1bmN0aW9uICgpIHsgaWYgKCF5KSB7IHZhciB0LCBlID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IGEoYiksIG8gPSB0aGlzLm9wdGlvbnM7IHIoeSA9IGIuY2xvbmVOb2RlKCEwKSwgby5naG9zdENsYXNzLCAhMSksIHIoeSwgby5mYWxsYmFja0NsYXNzLCAhMCksIHIoeSwgby5kcmFnQ2xhc3MsICEwKSwgYSh5LCBcInRvcFwiLCBlLnRvcCAtIFYobi5tYXJnaW5Ub3AsIDEwKSksIGEoeSwgXCJsZWZ0XCIsIGUubGVmdCAtIFYobi5tYXJnaW5MZWZ0LCAxMCkpLCBhKHksIFwid2lkdGhcIiwgZS53aWR0aCksIGEoeSwgXCJoZWlnaHRcIiwgZS5oZWlnaHQpLCBhKHksIFwib3BhY2l0eVwiLCBcIjAuOFwiKSwgYSh5LCBcInBvc2l0aW9uXCIsIFwiZml4ZWRcIiksIGEoeSwgXCJ6SW5kZXhcIiwgXCIxMDAwMDBcIiksIGEoeSwgXCJwb2ludGVyRXZlbnRzXCIsIFwibm9uZVwiKSwgby5mYWxsYmFja09uQm9keSAmJiBXLmJvZHkuYXBwZW5kQ2hpbGQoeSkgfHwgVC5hcHBlbmRDaGlsZCh5KSwgdCA9IHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGEoeSwgXCJ3aWR0aFwiLCAyICogZS53aWR0aCAtIHQud2lkdGgpLCBhKHksIFwiaGVpZ2h0XCIsIDIgKiBlLmhlaWdodCAtIHQuaGVpZ2h0KSB9IH0sIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIG4gPSB0aGlzLCBpID0gdC5kYXRhVHJhbnNmZXIsIGwgPSBuLm9wdGlvbnM7IG4uX29mZlVwRXZlbnRzKCksIE8uY2hlY2tQdWxsKG4sIG4sIGIsIHQpICYmICgodyA9IHYoYikpLmRyYWdnYWJsZSA9ICExLCB3LnN0eWxlW1wid2lsbC1jaGFuZ2VcIl0gPSBcIlwiLCBhKHcsIFwiZGlzcGxheVwiLCBcIm5vbmVcIiksIHIodywgbi5vcHRpb25zLmNob3NlbkNsYXNzLCAhMSksIG4uX2Nsb25lSWQgPSBtKGZ1bmN0aW9uICgpIHsgVC5pbnNlcnRCZWZvcmUodywgYiksIHMobiwgVCwgXCJjbG9uZVwiLCBiKSB9KSksIHIoYiwgbC5kcmFnQ2xhc3MsICEwKSwgZSA/IChcInRvdWNoXCIgPT09IGUgPyAobyhXLCBcInRvdWNobW92ZVwiLCBuLl9vblRvdWNoTW92ZSksIG8oVywgXCJ0b3VjaGVuZFwiLCBuLl9vbkRyb3ApLCBvKFcsIFwidG91Y2hjYW5jZWxcIiwgbi5fb25Ecm9wKSwgbC5zdXBwb3J0UG9pbnRlciAmJiAobyhXLCBcInBvaW50ZXJtb3ZlXCIsIG4uX29uVG91Y2hNb3ZlKSwgbyhXLCBcInBvaW50ZXJ1cFwiLCBuLl9vbkRyb3ApKSkgOiAobyhXLCBcIm1vdXNlbW92ZVwiLCBuLl9vblRvdWNoTW92ZSksIG8oVywgXCJtb3VzZXVwXCIsIG4uX29uRHJvcCkpLCBuLl9sb29wSWQgPSBzZXRJbnRlcnZhbChuLl9lbXVsYXRlRHJhZ092ZXIsIDUwKSkgOiAoaSAmJiAoaS5lZmZlY3RBbGxvd2VkID0gXCJtb3ZlXCIsIGwuc2V0RGF0YSAmJiBsLnNldERhdGEuY2FsbChuLCBpLCBiKSksIG8oVywgXCJkcm9wXCIsIG4pLCBuLl9kcmFnU3RhcnRJZCA9IG0obi5fZHJhZ1N0YXJ0ZWQpKSB9LCBfb25EcmFnT3ZlcjogZnVuY3Rpb24gKG8pIHsgdmFyIGksIHIsIGwsIHMsIGQgPSB0aGlzLmVsLCB1ID0gdGhpcy5vcHRpb25zLCBmID0gdS5ncm91cCwgcCA9IHQuYWN0aXZlLCBnID0gTyA9PT0gZiwgdiA9ICExLCBtID0gdS5zb3J0OyBpZiAodm9pZCAwICE9PSBvLnByZXZlbnREZWZhdWx0ICYmIChvLnByZXZlbnREZWZhdWx0KCksICF1LmRyYWdvdmVyQnViYmxlICYmIG8uc3RvcFByb3BhZ2F0aW9uKCkpLCAhYi5hbmltYXRlZCAmJiAoTSA9ICEwLCBwICYmICF1LmRpc2FibGVkICYmIChnID8gbSB8fCAocyA9ICFULmNvbnRhaW5zKGIpKSA6IEkgPT09IHRoaXMgfHwgKHAubGFzdFB1bGxNb2RlID0gTy5jaGVja1B1bGwodGhpcywgcCwgYiwgbykpICYmIGYuY2hlY2tQdXQodGhpcywgcCwgYiwgbykpICYmICh2b2lkIDAgPT09IG8ucm9vdEVsIHx8IG8ucm9vdEVsID09PSB0aGlzLmVsKSkpIHsgaWYgKGl0KG8sIHUsIHRoaXMuZWwpLCBLKSByZXR1cm47IGlmIChpID0gbihvLnRhcmdldCwgdS5kcmFnZ2FibGUsIGQpLCByID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgSSAhPT0gdGhpcyAmJiAoSSA9IHRoaXMsIHYgPSAhMCksIHMpIHJldHVybiBlKHAsICEwKSwgRCA9IFQsIHZvaWQgKHcgfHwgQyA/IFQuaW5zZXJ0QmVmb3JlKGIsIHcgfHwgQykgOiBtIHx8IFQuYXBwZW5kQ2hpbGQoYikpOyBpZiAoMCA9PT0gZC5jaGlsZHJlbi5sZW5ndGggfHwgZC5jaGlsZHJlblswXSA9PT0geSB8fCBkID09PSBvLnRhcmdldCAmJiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgbiA9IHQubGFzdEVsZW1lbnRDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgcmV0dXJuIGUuY2xpZW50WSAtIChuLnRvcCArIG4uaGVpZ2h0KSA+IDUgfHwgZS5jbGllbnRYIC0gKG4ubGVmdCArIG4ud2lkdGgpID4gNSB9KGQsIG8pKSB7IGlmICgwICE9PSBkLmNoaWxkcmVuLmxlbmd0aCAmJiBkLmNoaWxkcmVuWzBdICE9PSB5ICYmIGQgPT09IG8udGFyZ2V0ICYmIChpID0gZC5sYXN0RWxlbWVudENoaWxkKSwgaSkgeyBpZiAoaS5hbmltYXRlZCkgcmV0dXJuOyBsID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9IGUocCwgZyksICExICE9PSBjKFQsIGQsIGIsIHIsIGksIGwsIG8pICYmIChiLmNvbnRhaW5zKGQpIHx8IChkLmFwcGVuZENoaWxkKGIpLCBEID0gZCksIHRoaXMuX2FuaW1hdGUociwgYiksIGkgJiYgdGhpcy5fYW5pbWF0ZShsLCBpKSkgfSBlbHNlIGlmIChpICYmICFpLmFuaW1hdGVkICYmIGkgIT09IGIgJiYgdm9pZCAwICE9PSBpLnBhcmVudE5vZGVbal0pIHsgayAhPT0gaSAmJiAoayA9IGksIEIgPSBhKGkpLCBQID0gYShpLnBhcmVudE5vZGUpKTsgdmFyIF8gPSAobCA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLnJpZ2h0IC0gbC5sZWZ0LCBTID0gbC5ib3R0b20gLSBsLnRvcCwgRSA9IFUudGVzdChCLmNzc0Zsb2F0ICsgQi5kaXNwbGF5KSB8fCBcImZsZXhcIiA9PSBQLmRpc3BsYXkgJiYgMCA9PT0gUFtcImZsZXgtZGlyZWN0aW9uXCJdLmluZGV4T2YoXCJyb3dcIiksIHggPSBpLm9mZnNldFdpZHRoID4gYi5vZmZzZXRXaWR0aCwgTiA9IGkub2Zmc2V0SGVpZ2h0ID4gYi5vZmZzZXRIZWlnaHQsIFkgPSAoRSA/IChvLmNsaWVudFggLSBsLmxlZnQpIC8gXyA6IChvLmNsaWVudFkgLSBsLnRvcCkgLyBTKSA+IC41LCBYID0gaS5uZXh0RWxlbWVudFNpYmxpbmcsIFIgPSAhMTsgaWYgKEUpIHsgdmFyIEEgPSBiLm9mZnNldFRvcCwgTCA9IGkub2Zmc2V0VG9wOyBSID0gQSA9PT0gTCA/IGkucHJldmlvdXNFbGVtZW50U2libGluZyA9PT0gYiAmJiAheCB8fCBZICYmIHggOiBpLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IGIgfHwgYi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBpID8gKG8uY2xpZW50WSAtIGwudG9wKSAvIFMgPiAuNSA6IEwgPiBBIH0gZWxzZSB2IHx8IChSID0gWCAhPT0gYiAmJiAhTiB8fCBZICYmIE4pOyB2YXIgRiA9IGMoVCwgZCwgYiwgciwgaSwgbCwgbywgUik7ICExICE9PSBGICYmICgxICE9PSBGICYmIC0xICE9PSBGIHx8IChSID0gMSA9PT0gRiksIEsgPSAhMCwgcShoLCAzMCksIGUocCwgZyksIGIuY29udGFpbnMoZCkgfHwgKFIgJiYgIVggPyBkLmFwcGVuZENoaWxkKGIpIDogaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLCBSID8gWCA6IGkpKSwgRCA9IGIucGFyZW50Tm9kZSwgdGhpcy5fYW5pbWF0ZShyLCBiKSwgdGhpcy5fYW5pbWF0ZShsLCBpKSkgfSB9IH0sIF9hbmltYXRlOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgbiA9IHRoaXMub3B0aW9ucy5hbmltYXRpb247IGlmIChuKSB7IHZhciBvID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgMSA9PT0gdC5ub2RlVHlwZSAmJiAodCA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCBhKGUsIFwidHJhbnNpdGlvblwiLCBcIm5vbmVcIiksIGEoZSwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUzZChcIiArICh0LmxlZnQgLSBvLmxlZnQpICsgXCJweCxcIiArICh0LnRvcCAtIG8udG9wKSArIFwicHgsMClcIiksIGUub2Zmc2V0V2lkdGgsIGEoZSwgXCJ0cmFuc2l0aW9uXCIsIFwiYWxsIFwiICsgbiArIFwibXNcIiksIGEoZSwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiksIGNsZWFyVGltZW91dChlLmFuaW1hdGVkKSwgZS5hbmltYXRlZCA9IHEoZnVuY3Rpb24gKCkgeyBhKGUsIFwidHJhbnNpdGlvblwiLCBcIlwiKSwgYShlLCBcInRyYW5zZm9ybVwiLCBcIlwiKSwgZS5hbmltYXRlZCA9ICExIH0sIG4pIH0gfSwgX29mZlVwRXZlbnRzOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcy5lbC5vd25lckRvY3VtZW50OyBpKFcsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uVG91Y2hNb3ZlKSwgaShXLCBcInBvaW50ZXJtb3ZlXCIsIHRoaXMuX29uVG91Y2hNb3ZlKSwgaSh0LCBcIm1vdXNldXBcIiwgdGhpcy5fb25Ecm9wKSwgaSh0LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uRHJvcCksIGkodCwgXCJwb2ludGVydXBcIiwgdGhpcy5fb25Ecm9wKSwgaSh0LCBcInRvdWNoY2FuY2VsXCIsIHRoaXMuX29uRHJvcCksIGkodCwgXCJwb2ludGVyY2FuY2VsXCIsIHRoaXMuX29uRHJvcCksIGkodCwgXCJzZWxlY3RzdGFydFwiLCB0aGlzKSB9LCBfb25Ecm9wOiBmdW5jdGlvbiAoZSkgeyB2YXIgbiA9IHRoaXMuZWwsIG8gPSB0aGlzLm9wdGlvbnM7IGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKSwgY2xlYXJJbnRlcnZhbChMLnBpZCksIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lciksIF8odGhpcy5fY2xvbmVJZCksIF8odGhpcy5fZHJhZ1N0YXJ0SWQpLCBpKFcsIFwibW91c2VvdmVyXCIsIHRoaXMpLCBpKFcsIFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uVG91Y2hNb3ZlKSwgdGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgKGkoVywgXCJkcm9wXCIsIHRoaXMpLCBpKG4sIFwiZHJhZ3N0YXJ0XCIsIHRoaXMuX29uRHJhZ1N0YXJ0KSksIHRoaXMuX29mZlVwRXZlbnRzKCksIGUgJiYgKE0gJiYgKGUucHJldmVudERlZmF1bHQoKSwgIW8uZHJvcEJ1YmJsZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpKSwgeSAmJiB5LnBhcmVudE5vZGUgJiYgeS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHkpLCBUICE9PSBEICYmIFwiY2xvbmVcIiA9PT0gdC5hY3RpdmUubGFzdFB1bGxNb2RlIHx8IHcgJiYgdy5wYXJlbnROb2RlICYmIHcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3KSwgYiAmJiAodGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgaShiLCBcImRyYWdlbmRcIiwgdGhpcyksIGQoYiksIGIuc3R5bGVbXCJ3aWxsLWNoYW5nZVwiXSA9IFwiXCIsIHIoYiwgdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsICExKSwgcihiLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsICExKSwgcyh0aGlzLCBULCBcInVuY2hvb3NlXCIsIGIsIEQsIFQsIFkpLCBUICE9PSBEID8gKFggPSB1KGIsIG8uZHJhZ2dhYmxlKSkgPj0gMCAmJiAocyhudWxsLCBELCBcImFkZFwiLCBiLCBELCBULCBZLCBYKSwgcyh0aGlzLCBULCBcInJlbW92ZVwiLCBiLCBELCBULCBZLCBYKSwgcyhudWxsLCBELCBcInNvcnRcIiwgYiwgRCwgVCwgWSwgWCksIHModGhpcywgVCwgXCJzb3J0XCIsIGIsIEQsIFQsIFksIFgpKSA6IGIubmV4dFNpYmxpbmcgIT09IEMgJiYgKFggPSB1KGIsIG8uZHJhZ2dhYmxlKSkgPj0gMCAmJiAocyh0aGlzLCBULCBcInVwZGF0ZVwiLCBiLCBELCBULCBZLCBYKSwgcyh0aGlzLCBULCBcInNvcnRcIiwgYiwgRCwgVCwgWSwgWCkpLCB0LmFjdGl2ZSAmJiAobnVsbCAhPSBYICYmIC0xICE9PSBYIHx8IChYID0gWSksIHModGhpcywgVCwgXCJlbmRcIiwgYiwgRCwgVCwgWSwgWCksIHRoaXMuc2F2ZSgpKSkpLCB0aGlzLl9udWxsaW5nKCkgfSwgX251bGxpbmc6IGZ1bmN0aW9uICgpIHsgVCA9IGIgPSBEID0geSA9IEMgPSB3ID0gUyA9IEUgPSB4ID0gUiA9IEEgPSBNID0gWCA9IGsgPSBCID0gSSA9IE8gPSB0LmFjdGl2ZSA9IG51bGwsIGV0LmZvckVhY2goZnVuY3Rpb24gKHQpIHsgdC5jaGVja2VkID0gITAgfSksIGV0Lmxlbmd0aCA9IDAgfSwgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uICh0KSB7IHN3aXRjaCAodC50eXBlKSB7IGNhc2UgXCJkcm9wXCI6IGNhc2UgXCJkcmFnZW5kXCI6IHRoaXMuX29uRHJvcCh0KTsgYnJlYWs7IGNhc2UgXCJkcmFnb3ZlclwiOiBjYXNlIFwiZHJhZ2VudGVyXCI6IGIgJiYgKHRoaXMuX29uRHJhZ092ZXIodCksIGZ1bmN0aW9uICh0KSB7IHQuZGF0YVRyYW5zZmVyICYmICh0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCIpLCB0LnByZXZlbnREZWZhdWx0KCkgfSh0KSk7IGJyZWFrOyBjYXNlIFwibW91c2VvdmVyXCI6IHRoaXMuX29uRHJvcCh0KTsgYnJlYWs7IGNhc2UgXCJzZWxlY3RzdGFydFwiOiB0LnByZXZlbnREZWZhdWx0KCkgfSB9LCB0b0FycmF5OiBmdW5jdGlvbiAoKSB7IGZvciAodmFyIHQsIGUgPSBbXSwgbyA9IHRoaXMuZWwuY2hpbGRyZW4sIGkgPSAwLCByID0gby5sZW5ndGgsIGEgPSB0aGlzLm9wdGlvbnM7IGkgPCByOyBpKyspbih0ID0gb1tpXSwgYS5kcmFnZ2FibGUsIHRoaXMuZWwpICYmIGUucHVzaCh0LmdldEF0dHJpYnV0ZShhLmRhdGFJZEF0dHIpIHx8IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIGUgPSB0LnRhZ05hbWUgKyB0LmNsYXNzTmFtZSArIHQuc3JjICsgdC5ocmVmICsgdC50ZXh0Q29udGVudCwgbiA9IGUubGVuZ3RoLCBvID0gMDsgbi0tOylvICs9IGUuY2hhckNvZGVBdChuKTsgcmV0dXJuIG8udG9TdHJpbmcoMzYpIH0odCkpOyByZXR1cm4gZSB9LCBzb3J0OiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHt9LCBvID0gdGhpcy5lbDsgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkgeyB2YXIgciA9IG8uY2hpbGRyZW5baV07IG4ociwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgbykgJiYgKGVbdF0gPSByKSB9LCB0aGlzKSwgdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IGVbdF0gJiYgKG8ucmVtb3ZlQ2hpbGQoZVt0XSksIG8uYXBwZW5kQ2hpbGQoZVt0XSkpIH0pIH0sIHNhdmU6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLm9wdGlvbnMuc3RvcmU7IHQgJiYgdC5zZXQodGhpcykgfSwgY2xvc2VzdDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIG4odCwgZSB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsKSB9LCBvcHRpb246IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBuID0gdGhpcy5vcHRpb25zOyBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gblt0XTsgblt0XSA9IGUsIFwiZ3JvdXBcIiA9PT0gdCAmJiBydChuKSB9LCBkZXN0cm95OiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcy5lbDsgdFtqXSA9IG51bGwsIGkodCwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25UYXBTdGFydCksIGkodCwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uVGFwU3RhcnQpLCBpKHQsIFwicG9pbnRlcmRvd25cIiwgdGhpcy5fb25UYXBTdGFydCksIHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIChpKHQsIFwiZHJhZ292ZXJcIiwgdGhpcyksIGkodCwgXCJkcmFnZW50ZXJcIiwgdGhpcykpLCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQucXVlcnlTZWxlY3RvckFsbChcIltkcmFnZ2FibGVdXCIpLCBmdW5jdGlvbiAodCkgeyB0LnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKSB9KSwgbnQuc3BsaWNlKG50LmluZGV4T2YodGhpcy5fb25EcmFnT3ZlciksIDEpLCB0aGlzLl9vbkRyb3AoKSwgdGhpcy5lbCA9IHQgPSBudWxsIH0gfSwgbyhXLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoZSkgeyB0LmFjdGl2ZSAmJiBlLnByZXZlbnREZWZhdWx0KCkgfSksIHQudXRpbHMgPSB7IG9uOiBvLCBvZmY6IGksIGNzczogYSwgZmluZDogbCwgaXM6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiAhIW4odCwgZSwgdCkgfSwgZXh0ZW5kOiBnLCB0aHJvdHRsZTogcCwgY2xvc2VzdDogbiwgdG9nZ2xlQ2xhc3M6IHIsIGNsb25lOiB2LCBpbmRleDogdSwgbmV4dFRpY2s6IG0sIGNhbmNlbE5leHRUaWNrOiBfIH0sIHQuY3JlYXRlID0gZnVuY3Rpb24gKGUsIG4pIHsgcmV0dXJuIG5ldyB0KGUsIG4pIH0sIHQudmVyc2lvbiA9IFwiMS43LjBcIiwgdCB9KTsiLCJ2YXIgYXBwID0gYXBwIHx8IHt9O1xyXG5cclxuYXBwLmNoZWNrQXNzaWdubWVudENvbG9yID0gKGFzc2lnbm1lbnQpID0+IHtcclxuICAgIGlmKGFzc2lnbm1lbnQuaGFzQ2xhc3MoJ2NvbG9yJykpIHtcclxuICAgICAgICBsZXQgYXNzaWdubWVudElkID0gYXNzaWdubWVudC5hdHRyKCdkYXRhLWlkJyksXHJcbiAgICAgICAgICAgIGNvbnRyb2xzID0gYXNzaWdubWVudC5maW5kKCcuY29udHJvbHMgPiBidXR0b24nKSxcclxuICAgICAgICAgICAgY29udGFpbmVyID0gYXNzaWdubWVudC5maW5kKCcuZmxleC10YWJsZScpLFxyXG4gICAgICAgICAgICBpdGVtcyA9IGNvbnRhaW5lci5jaGlsZHJlbigpLFxyXG4gICAgICAgICAgICBhY3RpdmVJZCA9IGNvbnRyb2xzLmZpbHRlcihcIi5hY3RpdmVcIikuYXR0cignZGF0YS1pZCcpLFxyXG4gICAgICAgICAgICBjb3JyZWN0U3ZnID0gJzxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWNoZWNrbWFya1wiPjwvdXNlPjwvc3ZnPicsXHJcbiAgICAgICAgICAgIHdyb25nU3ZnID0gJzxzdmcgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIHhsaW5rOmhyZWY9XCIjc3ZnLWNsb3NlXCI+PC91c2U+PC9zdmc+JztcclxuXHJcbiAgICAgICAgbGV0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250cm9scy5maWx0ZXIoJy5lcmFzZXInKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzLmZpbHRlcignOm5vdCguZXJhc2VyKScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5lbXB0eSgpO1xyXG4gICAgICAgICAgICBpdGVtcy5yZW1vdmVBdHRyKCdkYXRhLWlkJyk7XHJcbiAgICAgICAgICAgIGFzc2lnbm1lbnQucmVtb3ZlQ2xhc3MoJ3ZhbGlkYXRlZCcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxldCBnZXRDb3JyZWN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSByZXRyaWV2ZWQgd2l0aCBhcGkgY2FsbFxyXG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudElkID09PSAnMScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2JsdWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogM1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2dyZWVuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDJcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogNFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXNzaWdubWVudElkID09PSAnMicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ29yYW5nZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiA0XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAndGVhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAyXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxldCBnZXRJdGVtcyA9IChpZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgICAgICAgICAgaXRlbXMuZWFjaCgoaSwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0ICR0aGlzID0gJChkYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSAkdGhpcy5hdHRyKCdkYXRhLWlkJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUlkICE9PSB1bmRlZmluZWQgJiYgaWQgPT09IGl0ZW1JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBhc3NpZ25tZW50Lm9uKCdjbGljaycsICdidXR0b25bdHlwZT1cInN1Ym1pdFwiXScsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFhc3NpZ25tZW50Lmhhc0NsYXNzKCd2YWxpZGF0ZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzaWdubWVudC5hZGRDbGFzcygndmFsaWRhdGVkJyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29ycmVjdCA9IGdldENvcnJlY3QoKTtcclxuICAgICAgICAgICAgICAgICQoY29ycmVjdCkuZWFjaCgoaSwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IGdldEl0ZW1zKGRhdGEuaWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmQgPSAoZGF0YS52YWx1ZSA9PT0gc2VsZWN0ZWQpID8gY29ycmVjdFN2ZyA6IHdyb25nU3ZnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzLmZpbHRlcignW2RhdGEtaWQ9XCInICsgZGF0YS5pZCArICdcIl0nKS5hcHBlbmQoYXBwZW5kKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFzc2lnbm1lbnQub24oJ2NsaWNrJywgJ2J1dHRvblt0eXBlPVwicmVzZXRcIl0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFzc2lnbm1lbnQub24oJ2NsaWNrJywgJ2J1dHRvbi5jb3JyZWN0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICBhc3NpZ25tZW50LmFkZENsYXNzKCd2YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgbGV0IGNvcnJlY3QgPSBnZXRDb3JyZWN0KCk7XHJcbiAgICAgICAgICAgICQoY29ycmVjdCkuZWFjaCgoaSwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEudmFsdWU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICQoaXRlbXMuZmlsdGVyKCc6bm90KFtkYXRhLWlkXSknKVswXSkuYXR0cignZGF0YS1pZCcsIGRhdGEuaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udHJvbHMuZmlsdGVyKCdbZGF0YS1pZD1cIicgKyBkYXRhLmlkICsgJ1wiXScpLmFwcGVuZChjb3JyZWN0U3ZnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnRyb2xzLm9uKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCAkdGhpcyA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBhY3RpdmVJZCA9ICR0aGlzLmF0dHIoJ2RhdGEtaWQnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXRlbXMub24oJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0ICR0aGlzID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICAkdGhpcy5hdHRyKCdkYXRhLWlkJywgYWN0aXZlSWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufTsiLCJ2YXIgYXBwID0gYXBwIHx8IHt9O1xyXG5cclxuYXBwLmNoZWNrQXNzaWdubWVudERyYWdBbmREcm9wID0gKGFzc2lnbm1lbnQpID0+IHtcclxuICAgIGlmIChhc3NpZ25tZW50Lmhhc0NsYXNzKCdkcmFnLWFuZC1kcm9wJykpIHtcclxuICAgICAgICBhc3NpZ25tZW50LmF0dHIoJ2RhdGEtbW92aW5nJywgMCk7XHJcbiAgICAgICAgbGV0IGlkID0gYXNzaWdubWVudC5hdHRyKCdkYXRhLWlkJyksXHJcbiAgICAgICAgICAgIGZyb20gPSBhc3NpZ25tZW50LmZpbmQoJy5mcm9tIC5jb250YWluZXInKSxcclxuICAgICAgICAgICAgaXRlbXMgPSBhc3NpZ25tZW50LmZpbmQoJy5pdGVtJyksXHJcbiAgICAgICAgICAgIGNoZWNrYm94ZXMgPSBpdGVtcy5maW5kKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpO1xyXG5cclxuICAgICAgICBsZXQgZ2V0Q2hlY2tlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICQoJC5tYXAoY2hlY2tib3hlcywgKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICBsZXQgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnJlbW92ZUNsYXNzKCd2YWxpZCBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIGxldCBjaGVja2VkID0gZ2V0Q2hlY2tlZCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcm9tLmFwcGVuZChpdGVtcyk7XHJcbiAgICAgICAgICAgIGFzc2lnbm1lbnQucmVtb3ZlQ2xhc3MoJ3ZhbGlkYXRlZCBtb3ZpbmcnKTtcclxuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5zaHVmZmxlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IGdldENvcnJlY3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHJldHJpZXZlZCB3aXRoIGFwaSBjYWxsXHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJzEnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcxJywgLy8gVFZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFsnNScsICc3J11cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcyJywgLy8gR2FtZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFsnNicsICc4J11cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICczJywgLy8gTXVzaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFsnMicsICc0J11cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc0JywgLy8gU3BvcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFsnMScsICczJ11cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYm93c2VyLmRlc2t0b3ApIHtcclxuICAgICAgICAgICAgYXNzaWdubWVudC5maW5kKCcuY29udGFpbmVyJykuZWFjaCgoaSwgZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgU29ydGFibGUuY3JlYXRlKGUsIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cDogJ2NvbnRhaW5lcicsIGRyYWdnYWJsZTogXCIuaXRlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlRmFsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tPbkJvZHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hvc2VuQ2xhc3M6ICdkcmFnLWFuZC1kcm9wLXNvcnRhYmxlLWNob3NlbicsXHJcbiAgICAgICAgICAgICAgICAgICAgb25BZGQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tlZCA9IGdldENoZWNrZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50LnJlbW92ZUNsYXNzKCdtb3ZpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hlY2tib3hlcy5vbignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldCksXHJcbiAgICAgICAgICAgICAgICBpdGVtID0gJHRoaXMucGFyZW50cygnLml0ZW0nKSxcclxuICAgICAgICAgICAgICAgIG1vdmluZyA9IHBhcnNlSW50KGFzc2lnbm1lbnQuYXR0cignZGF0YS1tb3ZpbmcnKSk7XHJcbiAgICAgICAgICAgIGlmICgkdGhpcy5pcygnOmNoZWNrZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgbW92aW5nKys7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LmF0dHIoJ2RhdGEtbW92aW5nJywgbW92aW5nKTtcclxuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQuYWRkQ2xhc3MoJ21vdmluZycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW92aW5nLS07XHJcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LmF0dHIoJ2RhdGEtbW92aW5nJywgbW92aW5nKTtcclxuICAgICAgICAgICAgICAgIGlmIChtb3ZpbmcgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50LnJlbW92ZUNsYXNzKCdtb3ZpbmcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhc3NpZ25tZW50Lm9uKCdjbGljaycsICcucGxhY2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldClcclxuICAgICAgICAgICAgYXNzaWdubWVudC5yZW1vdmVDbGFzcygnbW92aW5nJyk7XHJcbiAgICAgICAgICAgIGxldCBjaGVja2VkID0gZ2V0Q2hlY2tlZCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudCgnLmhlYWRlcicpLm5leHQoKS5jaGlsZHJlbignLmNvbnRhaW5lcicpLmFwcGVuZChjaGVja2VkLnBhcmVudCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhc3NpZ25tZW50Lm9uKCdjbGljaycsICdidXR0b25bdHlwZT1cInN1Ym1pdFwiXScsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFhc3NpZ25tZW50Lmhhc0NsYXNzKCd2YWxpZGF0ZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoZWNrZWQgPSBnZXRDaGVja2VkKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LmFkZENsYXNzKCd2YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb3JyZWN0ID0gZ2V0Q29ycmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgJChjb3JyZWN0KS5lYWNoKChpLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGFzc2lnbm1lbnQuZmluZCgnLnRvIC5jb250YWluZXJbZGF0YS1pZD1cIicgKyBkYXRhLmlkICsgJ1wiXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbigpLmVhY2goKGksIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gJChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoaXRlbS5hdHRyKCdkYXRhLWlkJyksIGRhdGEuaXRlbXMpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hZGRDbGFzcygndmFsaWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ2ludmFsaWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXNzaWdubWVudC5vbignY2xpY2snLCAnYnV0dG9uW3R5cGU9XCJyZXNldFwiXScsICgpID0+IHtcclxuICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXNzaWdubWVudC5vbignY2xpY2snLCAnYnV0dG9uLmNvcnJlY3QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgIGFzc2lnbm1lbnQuYWRkQ2xhc3MoJ3ZhbGlkYXRlZCcpO1xyXG4gICAgICAgICAgICBsZXQgY29ycmVjdCA9IGdldENvcnJlY3QoKTtcclxuICAgICAgICAgICAgJChjb3JyZWN0KS5lYWNoKChpLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gYXNzaWdubWVudC5maW5kKCcudG8gLmNvbnRhaW5lcltkYXRhLWlkPVwiJyArIGRhdGEuaWQgKyAnXCJdJyk7XHJcbiAgICAgICAgICAgICAgICAkKGRhdGEuaXRlbXMpLmVhY2goKGosIGlkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBhcHAuZ2V0QXNzaWdubWVudEl0ZW0oaXRlbXMsIGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFkZENsYXNzKCd2YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXBwZW5kVG8oY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTsiLCJ2YXIgYXBwID0gYXBwIHx8IHt9O1xyXG5cclxuYXBwLmNoZWNrQXNzaWdubWVudFNvcnQgPSAoYXNzaWdubWVudCkgPT4ge1xyXG4gICAgaWYgKGFzc2lnbm1lbnQuaGFzQ2xhc3MoJ3NvcnQnKSkge1xyXG4gICAgICAgIGxldCBpZCA9IGFzc2lnbm1lbnQuYXR0cignZGF0YS1pZCcpLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBhc3NpZ25tZW50LmZpbmQoJy5jb250YWluZXInKSxcclxuICAgICAgICAgICAgaXRlbXMgPSBhc3NpZ25tZW50LmZpbmQoJy5pdGVtJyk7XHJcbiAgICAgICAgU29ydGFibGUuY3JlYXRlKGNvbnRhaW5lclswXSwge1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IFwiLml0ZW1cIixcclxuICAgICAgICAgICAgYW5pbWF0aW9uOiAwLFxyXG4gICAgICAgICAgICBzY3JvbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb3JjZUZhbGxiYWNrOiB0cnVlLFxyXG4gICAgICAgICAgICBmYWxsYmFja09uQm9keTogdHJ1ZSxcclxuICAgICAgICAgICAgY2hvc2VuQ2xhc3M6ICdzb3J0LXNvcnRhYmxlLWNob3NlbidcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2xhc3MoJ3dyYXAnKSkge1xyXG4gICAgICAgICAgICBsZXQgY2hlY2tXaWR0aCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jc3MoJ2hlaWdodCcsIGNvbnRhaW5lci5oZWlnaHQoKSkucmVtb3ZlQ2xhc3MoJ3JvdycpLmFkZENsYXNzKCdjb2x1bW4nKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXJMZWZ0ID0gY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RJdGVtID0gY29udGFpbmVyLmZpbmQoJz4gLml0ZW06Zmlyc3QtY2hpbGQnKSxcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEl0ZW1MZWZ0ID0gZmlyc3RJdGVtWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBwYXJzZUludChmaXJzdEl0ZW0uY3NzKCdtYXJnaW4tbGVmdCcpKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1MZWZ0IDwgY29udGFpbmVyTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDbGFzcygnY29sdW1uJykuYWRkQ2xhc3MoJ3JvdycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNzcygnaGVpZ2h0JywgJycpLmFkZENsYXNzKCdjaGVja2VkJyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjaGVja1dpZHRoKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAkKHdpbmRvdykuYmluZCgncmVzaXplLmFzc2lnbm1lbnRTb3J0JywgJC50aHJvdHRsZShhcHAudGhyb3R0bGVJbnRlcnZhbCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoZWNrV2lkdGgoKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpdGVtcy5yZW1vdmVDbGFzcygndmFsaWQgaW52YWxpZCcpO1xyXG4gICAgICAgICAgICBhc3NpZ25tZW50LnJlbW92ZUNsYXNzKCd2YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5zaHVmZmxlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IGdldENvcnJlY3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHJldHJpZXZlZCB3aXRoIGFwaSBjYWxsXHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJzEnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyczJywgJzEnLCAnMicsICc1JywgJzQnLCAnNycsICc2JywgJzgnLCAnOSddO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnMicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJzQnLCAnMicsICcxJywgJzMnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGFzc2lnbm1lbnQub24oJ2NsaWNrJywgJ2J1dHRvblt0eXBlPVwic3VibWl0XCJdJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWFzc2lnbm1lbnQuaGFzQ2xhc3MoJ3ZhbGlkYXRlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LmFkZENsYXNzKCd2YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb3JyZWN0ID0gZ2V0Q29ycmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgJChjb3JyZWN0KS5lYWNoKChpLCBpZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gYXBwLmdldEFzc2lnbm1lbnRJdGVtKGl0ZW1zLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaW5kZXgoKSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFkZENsYXNzKCd2YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ2ludmFsaWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhc3NpZ25tZW50Lm9uKCdjbGljaycsICdidXR0b25bdHlwZT1cInJlc2V0XCJdJywgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBdEluZGV4KGksIGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wcmVwZW5kKGl0ZW0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmZpbmQoJz4gLml0ZW06bnRoLWNoaWxkKCcgKyBpICsgJyknKS5hZnRlcihpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGFzc2lnbm1lbnQub24oJ2NsaWNrJywgJ2J1dHRvbi5jb3JyZWN0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICBhc3NpZ25tZW50LmFkZENsYXNzKCd2YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgbGV0IGNvcnJlY3QgPSBnZXRDb3JyZWN0KCk7XHJcbiAgICAgICAgICAgICQoY29ycmVjdCkuZWFjaCgoaSwgaWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gYXBwLmdldEFzc2lnbm1lbnRJdGVtKGl0ZW1zLCBpZCk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmFkZENsYXNzKCd2YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0QXRJbmRleChpLCBpdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZS5hc3NpZ25tZW50U29ydCcpO1xyXG4gICAgfVxyXG59OyJdfQ==
