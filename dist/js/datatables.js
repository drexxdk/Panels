/*! DataTables 1.10.16
 * Â©2008-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.16
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function (factory) {
    "use strict";

    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                // CommonJS environments without a window global must pass a
                // root. This will give an error otherwise
                root = window;
            }

            if (!$) {
                $ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
                    require('jquery') :
                    require('jquery')(root);
            }

            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}
    (function ($, window, document, undefined) {
        "use strict";

        /**
         * DataTables is a plug-in for the jQuery Javascript library. It is a highly
         * flexible tool, based upon the foundations of progressive enhancement,
         * which will add advanced interaction controls to any HTML table. For a
         * full list of features please refer to
         * [DataTables.net](href="http://datatables.net).
         *
         * Note that the `DataTable` object is not a global variable but is aliased
         * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
         * be  accessed.
         *
         *  @class
         *  @param {object} [init={}] Configuration object for DataTables. Options
         *    are defined by {@link DataTable.defaults}
         *  @requires jQuery 1.7+
         *
         *  @example
         *    // Basic initialisation
         *    $(document).ready( function {
         *      $('#example').dataTable();
         *    } );
         *
         *  @example
         *    // Initialisation with configuration options - in this case, disable
         *    // pagination and sorting.
         *    $(document).ready( function {
         *      $('#example').dataTable( {
         *        "paginate": false,
         *        "sort": false
         *      } );
         *    } );
         */
        var DataTable = function (options) {
            /**
             * Perform a jQuery selector action on the table's TR elements (from the tbody) and
             * return the resulting jQuery object.
             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
             *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
             *    criterion ("applied") or all TR elements (i.e. no filter).
             *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
             *    Can be either 'current', whereby the current sorting of the table is used, or
             *    'original' whereby the original order the data was read into the table is used.
             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
             *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
             *    'current' and filter is 'applied', regardless of what they might be given as.
             *  @returns {object} jQuery object, filtered by the given selector.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Highlight every second row
             *      oTable.$('tr:odd').css('backgroundColor', 'blue');
             *    } );
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Filter to rows with 'Webkit' in them, add a background colour and then
             *      // remove the filter, thus highlighting the 'Webkit' rows only.
             *      oTable.fnFilter('Webkit');
             *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
             *      oTable.fnFilter('');
             *    } );
             */
            this.$ = function (sSelector, oOpts) {
                return this.api(true).$(sSelector, oOpts);
            };


            /**
             * Almost identical to $ in operation, but in this case returns the data for the matched
             * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
             * rather than any descendants, so the data can be obtained for the row/cell. If matching
             * rows are found, the data returned is the original data array/object that was used to
             * create the row (or a generated array if from a DOM source).
             *
             * This method is often useful in-combination with $ where both functions are given the
             * same parameters and the array indexes will match identically.
             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
             *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
             *    criterion ("applied") or all elements (i.e. no filter).
             *  @param {string} [oOpts.order=current] Order of the data in the processed array.
             *    Can be either 'current', whereby the current sorting of the table is used, or
             *    'original' whereby the original order the data was read into the table is used.
             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
             *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
             *    'current' and filter is 'applied', regardless of what they might be given as.
             *  @returns {array} Data for the matched elements. If any elements, as a result of the
             *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
             *    entry in the array.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Get the data from the first row in the table
             *      var data = oTable._('tr:first');
             *
             *      // Do something useful with the data
             *      alert( "First cell is: "+data[0] );
             *    } );
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Filter to 'Webkit' and get all data for
             *      oTable.fnFilter('Webkit');
             *      var data = oTable._('tr', {"search": "applied"});
             *
             *      // Do something with the data
             *      alert( data.length+" rows matched the search" );
             *    } );
             */
            this._ = function (sSelector, oOpts) {
                return this.api(true).rows(sSelector, oOpts).data();
            };


            /**
             * Create a DataTables Api instance, with the currently selected tables for
             * the Api's context.
             * @param {boolean} [traditional=false] Set the API instance's context to be
             *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
             *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
             *   or if all tables captured in the jQuery object should be used.
             * @return {DataTables.Api}
             */
            this.api = function (traditional) {
                return traditional ?
                    new _Api(
                        _fnSettingsFromNode(this[_ext.iApiIndex])
                    ) :
                    new _Api(this);
            };


            /**
             * Add a single new row or multiple rows of data to the table. Please note
             * that this is suitable for client-side processing only - if you are using
             * server-side processing (i.e. "bServerSide": true), then to add data, you
             * must add it to the data source, i.e. the server-side, through an Ajax call.
             *  @param {array|object} data The data to be added to the table. This can be:
             *    <ul>
             *      <li>1D array of data - add a single row with the data provided</li>
             *      <li>2D array of arrays - add multiple rows in a single call</li>
             *      <li>object - data object when using <i>mData</i></li>
             *      <li>array of objects - multiple data objects when using <i>mData</i></li>
             *    </ul>
             *  @param {bool} [redraw=true] redraw the table or not
             *  @returns {array} An array of integers, representing the list of indexes in
             *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
             *    the table.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    // Global var for counter
             *    var giCount = 2;
             *
             *    $(document).ready(function() {
             *      $('#example').dataTable();
             *    } );
             *
             *    function fnClickAddRow() {
             *      $('#example').dataTable().fnAddData( [
             *        giCount+".1",
             *        giCount+".2",
             *        giCount+".3",
             *        giCount+".4" ]
             *      );
             *
             *      giCount++;
             *    }
             */
            this.fnAddData = function (data, redraw) {
                var api = this.api(true);

                /* Check if we want to add multiple rows or not */
                var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ?
                    api.rows.add(data) :
                    api.row.add(data);

                if (redraw === undefined || redraw) {
                    api.draw();
                }

                return rows.flatten().toArray();
            };


            /**
             * This function will make DataTables recalculate the column sizes, based on the data
             * contained in the table and the sizes applied to the columns (in the DOM, CSS or
             * through the sWidth parameter). This can be useful when the width of the table's
             * parent element changes (for example a window resize).
             *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable( {
             *        "sScrollY": "200px",
             *        "bPaginate": false
             *      } );
             *
             *      $(window).on('resize', function () {
             *        oTable.fnAdjustColumnSizing();
             *      } );
             *    } );
             */
            this.fnAdjustColumnSizing = function (bRedraw) {
                var api = this.api(true).columns.adjust();
                var settings = api.settings()[0];
                var scroll = settings.oScroll;

                if (bRedraw === undefined || bRedraw) {
                    api.draw(false);
                }
                else if (scroll.sX !== "" || scroll.sY !== "") {
                    /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
                    _fnScrollDraw(settings);
                }
            };


            /**
             * Quickly and simply clear a table
             *  @param {bool} [bRedraw=true] redraw the table or not
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
             *      oTable.fnClearTable();
             *    } );
             */
            this.fnClearTable = function (bRedraw) {
                var api = this.api(true).clear();

                if (bRedraw === undefined || bRedraw) {
                    api.draw();
                }
            };


            /**
             * The exact opposite of 'opening' a row, this function will close any rows which
             * are currently 'open'.
             *  @param {node} nTr the table row to 'close'
             *  @returns {int} 0 on success, or 1 if failed (can't find the row)
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable;
             *
             *      // 'open' an information row when a row is clicked on
             *      $('#example tbody tr').click( function () {
             *        if ( oTable.fnIsOpen(this) ) {
             *          oTable.fnClose( this );
             *        } else {
             *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
             *        }
             *      } );
             *
             *      oTable = $('#example').dataTable();
             *    } );
             */
            this.fnClose = function (nTr) {
                this.api(true).row(nTr).child.hide();
            };


            /**
             * Remove a row for the table
             *  @param {mixed} target The index of the row from aoData to be deleted, or
             *    the TR element you want to delete
             *  @param {function|null} [callBack] Callback function
             *  @param {bool} [redraw=true] Redraw the table or not
             *  @returns {array} The row that was deleted
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Immediately remove the first row
             *      oTable.fnDeleteRow( 0 );
             *    } );
             */
            this.fnDeleteRow = function (target, callback, redraw) {
                var api = this.api(true);
                var rows = api.rows(target);
                var settings = rows.settings()[0];
                var data = settings.aoData[rows[0][0]];

                rows.remove();

                if (callback) {
                    callback.call(this, settings, data);
                }

                if (redraw === undefined || redraw) {
                    api.draw();
                }

                return data;
            };


            /**
             * Restore the table to it's original state in the DOM by removing all of DataTables
             * enhancements, alterations to the DOM structure of the table and event listeners.
             *  @param {boolean} [remove=false] Completely remove the table from the DOM
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
             *      var oTable = $('#example').dataTable();
             *      oTable.fnDestroy();
             *    } );
             */
            this.fnDestroy = function (remove) {
                this.api(true).destroy(remove);
            };


            /**
             * Redraw the table
             *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
             *      oTable.fnDraw();
             *    } );
             */
            this.fnDraw = function (complete) {
                // Note that this isn't an exact match to the old call to _fnDraw - it takes
                // into account the new data, but can hold position.
                this.api(true).draw(complete);
            };


            /**
             * Filter the input based on data
             *  @param {string} sInput String to filter the table on
             *  @param {int|null} [iColumn] Column to limit filtering to
             *  @param {bool} [bRegex=false] Treat as regular expression or not
             *  @param {bool} [bSmart=true] Perform smart filtering or not
             *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
             *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Sometime later - filter...
             *      oTable.fnFilter( 'test string' );
             *    } );
             */
            this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
                var api = this.api(true);

                if (iColumn === null || iColumn === undefined) {
                    api.search(sInput, bRegex, bSmart, bCaseInsensitive);
                }
                else {
                    api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
                }

                api.draw();
            };


            /**
             * Get the data for the whole table, an individual row or an individual cell based on the
             * provided parameters.
             *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
             *    a TR node then the data source for the whole row will be returned. If given as a
             *    TD/TH cell node then iCol will be automatically calculated and the data for the
             *    cell returned. If given as an integer, then this is treated as the aoData internal
             *    data index for the row (see fnGetPosition) and the data for that row used.
             *  @param {int} [col] Optional column index that you want the data of.
             *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
             *    returned. If mRow is defined, just data for that row, and is iCol is
             *    defined, only data for the designated cell is returned.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    // Row data
             *    $(document).ready(function() {
             *      oTable = $('#example').dataTable();
             *
             *      oTable.$('tr').click( function () {
             *        var data = oTable.fnGetData( this );
             *        // ... do something with the array / object of data for the row
             *      } );
             *    } );
             *
             *  @example
             *    // Individual cell data
             *    $(document).ready(function() {
             *      oTable = $('#example').dataTable();
             *
             *      oTable.$('td').click( function () {
             *        var sData = oTable.fnGetData( this );
             *        alert( 'The cell clicked on had the value of '+sData );
             *      } );
             *    } );
             */
            this.fnGetData = function (src, col) {
                var api = this.api(true);

                if (src !== undefined) {
                    var type = src.nodeName ? src.nodeName.toLowerCase() : '';

                    return col !== undefined || type == 'td' || type == 'th' ?
                        api.cell(src, col).data() :
                        api.row(src).data() || null;
                }

                return api.data().toArray();
            };


            /**
             * Get an array of the TR nodes that are used in the table's body. Note that you will
             * typically want to use the '$' API method in preference to this as it is more
             * flexible.
             *  @param {int} [iRow] Optional row index for the TR element you want
             *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
             *    in the table's body, or iRow is defined, just the TR element requested.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Get the nodes from the table
             *      var nNodes = oTable.fnGetNodes( );
             *    } );
             */
            this.fnGetNodes = function (iRow) {
                var api = this.api(true);

                return iRow !== undefined ?
                    api.row(iRow).node() :
                    api.rows().nodes().flatten().toArray();
            };


            /**
             * Get the array indexes of a particular cell from it's DOM element
             * and column index including hidden columns
             *  @param {node} node this can either be a TR, TD or TH in the table's body
             *  @returns {int} If nNode is given as a TR, then a single index is returned, or
             *    if given as a cell, an array of [row index, column index (visible),
             *    column index (all)] is given.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      $('#example tbody td').click( function () {
             *        // Get the position of the current data from the node
             *        var aPos = oTable.fnGetPosition( this );
             *
             *        // Get the data array for this row
             *        var aData = oTable.fnGetData( aPos[0] );
             *
             *        // Update the data array and return the value
             *        aData[ aPos[1] ] = 'clicked';
             *        this.innerHTML = 'clicked';
             *      } );
             *
             *      // Init DataTables
             *      oTable = $('#example').dataTable();
             *    } );
             */
            this.fnGetPosition = function (node) {
                var api = this.api(true);
                var nodeName = node.nodeName.toUpperCase();

                if (nodeName == 'TR') {
                    return api.row(node).index();
                }
                else if (nodeName == 'TD' || nodeName == 'TH') {
                    var cell = api.cell(node).index();

                    return [
                        cell.row,
                        cell.columnVisible,
                        cell.column
                    ];
                }
                return null;
            };


            /**
             * Check to see if a row is 'open' or not.
             *  @param {node} nTr the table row to check
             *  @returns {boolean} true if the row is currently open, false otherwise
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable;
             *
             *      // 'open' an information row when a row is clicked on
             *      $('#example tbody tr').click( function () {
             *        if ( oTable.fnIsOpen(this) ) {
             *          oTable.fnClose( this );
             *        } else {
             *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
             *        }
             *      } );
             *
             *      oTable = $('#example').dataTable();
             *    } );
             */
            this.fnIsOpen = function (nTr) {
                return this.api(true).row(nTr).child.isShown();
            };


            /**
             * This function will place a new row directly after a row which is currently
             * on display on the page, with the HTML contents that is passed into the
             * function. This can be used, for example, to ask for confirmation that a
             * particular record should be deleted.
             *  @param {node} nTr The table row to 'open'
             *  @param {string|node|jQuery} mHtml The HTML to put into the row
             *  @param {string} sClass Class to give the new TD cell
             *  @returns {node} The row opened. Note that if the table row passed in as the
             *    first parameter, is not found in the table, this method will silently
             *    return.
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable;
             *
             *      // 'open' an information row when a row is clicked on
             *      $('#example tbody tr').click( function () {
             *        if ( oTable.fnIsOpen(this) ) {
             *          oTable.fnClose( this );
             *        } else {
             *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
             *        }
             *      } );
             *
             *      oTable = $('#example').dataTable();
             *    } );
             */
            this.fnOpen = function (nTr, mHtml, sClass) {
                return this.api(true)
                    .row(nTr)
                    .child(mHtml, sClass)
                    .show()
                    .child()[0];
            };


            /**
             * Change the pagination - provides the internal logic for pagination in a simple API
             * function. With this function you can have a DataTables table go to the next,
             * previous, first or last pages.
             *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
             *    or page number to jump to (integer), note that page 0 is the first page.
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *      oTable.fnPageChange( 'next' );
             *    } );
             */
            this.fnPageChange = function (mAction, bRedraw) {
                var api = this.api(true).page(mAction);

                if (bRedraw === undefined || bRedraw) {
                    api.draw(false);
                }
            };


            /**
             * Show a particular column
             *  @param {int} iCol The column whose display should be changed
             *  @param {bool} bShow Show (true) or hide (false) the column
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Hide the second column after initialisation
             *      oTable.fnSetColumnVis( 1, false );
             *    } );
             */
            this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
                var api = this.api(true).column(iCol).visible(bShow);

                if (bRedraw === undefined || bRedraw) {
                    api.columns.adjust().draw();
                }
            };


            /**
             * Get the settings for a particular table for external manipulation
             *  @returns {object} DataTables settings object. See
             *    {@link DataTable.models.oSettings}
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *      var oSettings = oTable.fnSettings();
             *
             *      // Show an example parameter from the settings
             *      alert( oSettings._iDisplayStart );
             *    } );
             */
            this.fnSettings = function () {
                return _fnSettingsFromNode(this[_ext.iApiIndex]);
            };


            /**
             * Sort the table by a particular column
             *  @param {int} iCol the data index to sort on. Note that this will not match the
             *    'display index' if you have hidden data entries
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Sort immediately with columns 0 and 1
             *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
             *    } );
             */
            this.fnSort = function (aaSort) {
                this.api(true).order(aaSort).draw();
            };


            /**
             * Attach a sort listener to an element for a given column
             *  @param {node} nNode the element to attach the sort listener to
             *  @param {int} iColumn the column that a click on this node will sort on
             *  @param {function} [fnCallback] callback function when sort is run
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *
             *      // Sort on column 1, when 'sorter' is clicked on
             *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
             *    } );
             */
            this.fnSortListener = function (nNode, iColumn, fnCallback) {
                this.api(true).order.listener(nNode, iColumn, fnCallback);
            };


            /**
             * Update a table cell or row - this method will accept either a single value to
             * update the cell with, an array of values with one element for each column or
             * an object in the same format as the original data source. The function is
             * self-referencing in order to make the multi column updates easier.
             *  @param {object|array|string} mData Data to update the cell/row with
             *  @param {node|int} mRow TR element you want to update or the aoData index
             *  @param {int} [iColumn] The column to update, give as null or undefined to
             *    update a whole row.
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @param {bool} [bAction=true] Perform pre-draw actions or not
             *  @returns {int} 0 on success, 1 on error
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
             *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
             *    } );
             */
            this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
                var api = this.api(true);

                if (iColumn === undefined || iColumn === null) {
                    api.row(mRow).data(mData);
                }
                else {
                    api.cell(mRow, iColumn).data(mData);
                }

                if (bAction === undefined || bAction) {
                    api.columns.adjust();
                }

                if (bRedraw === undefined || bRedraw) {
                    api.draw();
                }
                return 0;
            };


            /**
             * Provide a common method for plug-ins to check the version of DataTables being used, in order
             * to ensure compatibility.
             *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
             *    formats "X" and "X.Y" are also acceptable.
             *  @returns {boolean} true if this version of DataTables is greater or equal to the required
             *    version, or false if this version of DataTales is not suitable
             *  @method
             *  @dtopt API
             *  @deprecated Since v1.10
             *
             *  @example
             *    $(document).ready(function() {
             *      var oTable = $('#example').dataTable();
             *      alert( oTable.fnVersionCheck( '1.9.0' ) );
             *    } );
             */
            this.fnVersionCheck = _ext.fnVersionCheck;


            var _that = this;
            var emptyInit = options === undefined;
            var len = this.length;

            if (emptyInit) {
                options = {};
            }

            this.oApi = this.internal = _ext.internal;

            // Extend with old style plug-in API methods
            for (var fn in DataTable.ext.internal) {
                if (fn) {
                    this[fn] = _fnExternApiFunc(fn);
                }
            }

            this.each(function () {
                // For each initialisation we want to give it a clean initialisation
                // object that can be bashed around
                var o = {};
                var oInit = len > 1 ? // optimisation for single table case
                    _fnExtend(o, options, true) :
                    options;

                /*global oInit,_that,emptyInit*/
                var i = 0, iLen, j, jLen, k, kLen;
                var sId = this.getAttribute('id');
                var bInitHandedOff = false;
                var defaults = DataTable.defaults;
                var $this = $(this);


                /* Sanity check */
                if (this.nodeName.toLowerCase() != 'table') {
                    _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
                    return;
                }

                /* Backwards compatibility for the defaults */
                _fnCompatOpts(defaults);
                _fnCompatCols(defaults.column);

                /* Convert the camel-case defaults to Hungarian */
                _fnCamelToHungarian(defaults, defaults, true);
                _fnCamelToHungarian(defaults.column, defaults.column, true);

                /* Setting up the initialisation object */
                _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));



                /* Check to see if we are re-initialising a table */
                var allSettings = DataTable.settings;
                for (i = 0, iLen = allSettings.length; i < iLen; i++) {
                    var s = allSettings[i];

                    /* Base check on table node */
                    if (s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this)) {
                        var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
                        var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

                        if (emptyInit || bRetrieve) {
                            return s.oInstance;
                        }
                        else if (bDestroy) {
                            s.oInstance.fnDestroy();
                            break;
                        }
                        else {
                            _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
                            return;
                        }
                    }

                    /* If the element we are initialising has the same ID as a table which was previously
                     * initialised, but the table nodes don't match (from before) then we destroy the old
                     * instance by simply deleting it. This is under the assumption that the table has been
                     * destroyed by other methods. Anyone using non-id selectors will need to do this manually
                     */
                    if (s.sTableId == this.id) {
                        allSettings.splice(i, 1);
                        break;
                    }
                }

                /* Ensure the table has an ID - required for accessibility */
                if (sId === null || sId === "") {
                    sId = "DataTables_Table_" + (DataTable.ext._unique++);
                    this.id = sId;
                }

                /* Create the settings object for this table and set some of the default parameters */
                var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
                    "sDestroyWidth": $this[0].style.width,
                    "sInstance": sId,
                    "sTableId": sId
                });
                oSettings.nTable = this;
                oSettings.oApi = _that.internal;
                oSettings.oInit = oInit;

                allSettings.push(oSettings);

                // Need to add the instance after the instance after the settings object has been added
                // to the settings array, so we can self reference the table instance if more than one
                oSettings.oInstance = (_that.length === 1) ? _that : $this.dataTable();

                // Backwards compatibility, before we apply all the defaults
                _fnCompatOpts(oInit);

                if (oInit.oLanguage) {
                    _fnLanguageCompat(oInit.oLanguage);
                }

                // If the length menu is given, but the init display length is not, use the length menu
                if (oInit.aLengthMenu && !oInit.iDisplayLength) {
                    oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ?
                        oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
                }

                // Apply the defaults and init options to make a single init object will all
                // options defined from defaults and instance options.
                oInit = _fnExtend($.extend(true, {}, defaults), oInit);


                // Map the initialisation options onto the settings object
                _fnMap(oSettings.oFeatures, oInit, [
                    "bPaginate",
                    "bLengthChange",
                    "bFilter",
                    "bSort",
                    "bSortMulti",
                    "bInfo",
                    "bProcessing",
                    "bAutoWidth",
                    "bSortClasses",
                    "bServerSide",
                    "bDeferRender"
                ]);
                _fnMap(oSettings, oInit, [
                    "asStripeClasses",
                    "ajax",
                    "fnServerData",
                    "fnFormatNumber",
                    "sServerMethod",
                    "aaSorting",
                    "aaSortingFixed",
                    "aLengthMenu",
                    "sPaginationType",
                    "sAjaxSource",
                    "sAjaxDataProp",
                    "iStateDuration",
                    "sDom",
                    "bSortCellsTop",
                    "iTabIndex",
                    "fnStateLoadCallback",
                    "fnStateSaveCallback",
                    "renderer",
                    "searchDelay",
                    "rowId",
                    ["iCookieDuration", "iStateDuration"], // backwards compat
                    ["oSearch", "oPreviousSearch"],
                    ["aoSearchCols", "aoPreSearchCols"],
                    ["iDisplayLength", "_iDisplayLength"]
                ]);
                _fnMap(oSettings.oScroll, oInit, [
                    ["sScrollX", "sX"],
                    ["sScrollXInner", "sXInner"],
                    ["sScrollY", "sY"],
                    ["bScrollCollapse", "bCollapse"]
                ]);
                _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

                /* Callback functions which are array driven */
                _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
                _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
                _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
                _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
                _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
                _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
                _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
                _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

                oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);

                /* Browser support detection */
                _fnBrowserDetect(oSettings);

                var oClasses = oSettings.oClasses;

                $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
                $this.addClass(oClasses.sTable);


                if (oSettings.iInitDisplayStart === undefined) {
                    /* Display start point, taking into account the save saving */
                    oSettings.iInitDisplayStart = oInit.iDisplayStart;
                    oSettings._iDisplayStart = oInit.iDisplayStart;
                }

                if (oInit.iDeferLoading !== null) {
                    oSettings.bDeferLoading = true;
                    var tmp = $.isArray(oInit.iDeferLoading);
                    oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
                    oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
                }

                /* Language definitions */
                var oLanguage = oSettings.oLanguage;
                $.extend(true, oLanguage, oInit.oLanguage);

                if (oLanguage.sUrl) {
                    /* Get the language definitions from a file - because this Ajax call makes the language
                     * get async to the remainder of this function we use bInitHandedOff to indicate that
                     * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
                     */
                    $.ajax({
                        dataType: 'json',
                        url: oLanguage.sUrl,
                        success: function (json) {
                            _fnLanguageCompat(json);
                            _fnCamelToHungarian(defaults.oLanguage, json);
                            $.extend(true, oLanguage, json);
                            _fnInitialise(oSettings);
                        },
                        error: function () {
                            // Error occurred loading language file, continue on as best we can
                            _fnInitialise(oSettings);
                        }
                    });
                    bInitHandedOff = true;
                }

                /*
                 * Stripes
                 */
                if (oInit.asStripeClasses === null) {
                    oSettings.asStripeClasses = [
                        oClasses.sStripeOdd,
                        oClasses.sStripeEven
                    ];
                }

                /* Remove row stripe classes if they are already on the table row */
                var stripeClasses = oSettings.asStripeClasses;
                var rowOne = $this.children('tbody').find('tr').eq(0);
                if ($.inArray(true, $.map(stripeClasses, function (el, i) {
                    return rowOne.hasClass(el);
                })) !== -1) {
                    $('tbody tr', this).removeClass(stripeClasses.join(' '));
                    oSettings.asDestroyStripes = stripeClasses.slice();
                }

                /*
                 * Columns
                 * See if we should load columns automatically or use defined ones
                 */
                var anThs = [];
                var aoColumnsInit;
                var nThead = this.getElementsByTagName('thead');
                if (nThead.length !== 0) {
                    _fnDetectHeader(oSettings.aoHeader, nThead[0]);
                    anThs = _fnGetUniqueThs(oSettings);
                }

                /* If not given a column array, generate one with nulls */
                if (oInit.aoColumns === null) {
                    aoColumnsInit = [];
                    for (i = 0, iLen = anThs.length; i < iLen; i++) {
                        aoColumnsInit.push(null);
                    }
                }
                else {
                    aoColumnsInit = oInit.aoColumns;
                }

                /* Add the columns */
                for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
                    _fnAddColumn(oSettings, anThs ? anThs[i] : null);
                }

                /* Apply the column definitions */
                _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
                    _fnColumnOptions(oSettings, iCol, oDef);
                });

                /* HTML5 attribute detection - build an mData object automatically if the
                 * attributes are found
                 */
                if (rowOne.length) {
                    var a = function (cell, name) {
                        return cell.getAttribute('data-' + name) !== null ? name : null;
                    };

                    $(rowOne[0]).children('th, td').each(function (i, cell) {
                        var col = oSettings.aoColumns[i];

                        if (col.mData === i) {
                            var sort = a(cell, 'sort') || a(cell, 'order');
                            var filter = a(cell, 'filter') || a(cell, 'search');

                            if (sort !== null || filter !== null) {
                                col.mData = {
                                    _: i + '.display',
                                    sort: sort !== null ? i + '.@data-' + sort : undefined,
                                    type: sort !== null ? i + '.@data-' + sort : undefined,
                                    filter: filter !== null ? i + '.@data-' + filter : undefined
                                };

                                _fnColumnOptions(oSettings, i);
                            }
                        }
                    });
                }

                var features = oSettings.oFeatures;
                var loadedInit = function () {
                    /*
                     * Sorting
                     * @todo For modularisation (1.11) this needs to do into a sort start up handler
                     */

                    // If aaSorting is not defined, then we use the first indicator in asSorting
                    // in case that has been altered, so the default sort reflects that option
                    if (oInit.aaSorting === undefined) {
                        var sorting = oSettings.aaSorting;
                        for (i = 0, iLen = sorting.length; i < iLen; i++) {
                            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
                        }
                    }

                    /* Do a first pass on the sorting classes (allows any size changes to be taken into
                     * account, and also will apply sorting disabled classes if disabled
                     */
                    _fnSortingClasses(oSettings);

                    if (features.bSort) {
                        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
                            if (oSettings.bSorted) {
                                var aSort = _fnSortFlatten(oSettings);
                                var sortedColumns = {};

                                $.each(aSort, function (i, val) {
                                    sortedColumns[val.src] = val.dir;
                                });

                                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);
                                _fnSortAria(oSettings);
                            }
                        });
                    }

                    _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
                        if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
                            _fnSortingClasses(oSettings);
                        }
                    }, 'sc');


                    /*
                     * Final init
                     * Cache the header, body and footer as required, creating them if needed
                     */

                    // Work around for Webkit bug 83867 - store the caption-side before removing from doc
                    var captions = $this.children('caption').each(function () {
                        this._captionSide = $(this).css('caption-side');
                    });

                    var thead = $this.children('thead');
                    if (thead.length === 0) {
                        thead = $('<thead/>').appendTo($this);
                    }
                    oSettings.nTHead = thead[0];

                    var tbody = $this.children('tbody');
                    if (tbody.length === 0) {
                        tbody = $('<tbody/>').appendTo($this);
                    }
                    oSettings.nTBody = tbody[0];

                    var tfoot = $this.children('tfoot');
                    if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
                        // If we are a scrolling table, and no footer has been given, then we need to create
                        // a tfoot element for the caption element to be appended to
                        tfoot = $('<tfoot/>').appendTo($this);
                    }

                    if (tfoot.length === 0 || tfoot.children().length === 0) {
                        $this.addClass(oClasses.sNoFooter);
                    }
                    else if (tfoot.length > 0) {
                        oSettings.nTFoot = tfoot[0];
                        _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
                    }

                    /* Check if there is data passing into the constructor */
                    if (oInit.aaData) {
                        for (i = 0; i < oInit.aaData.length; i++) {
                            _fnAddData(oSettings, oInit.aaData[i]);
                        }
                    }
                    else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
                        /* Grab the data from the page - only do this when deferred loading or no Ajax
                         * source since there is no point in reading the DOM data if we are then going
                         * to replace it with Ajax data
                         */
                        _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
                    }

                    /* Copy the data index array */
                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

                    /* Initialisation complete - table can be drawn */
                    oSettings.bInitialised = true;

                    /* Check if we need to initialise the table (it might not have been handed off to the
                     * language processor)
                     */
                    if (bInitHandedOff === false) {
                        _fnInitialise(oSettings);
                    }
                };

                /* Must be done after everything which can be overridden by the state saving! */
                if (oInit.bStateSave) {
                    features.bStateSave = true;
                    _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
                    _fnLoadState(oSettings, oInit, loadedInit);
                }
                else {
                    loadedInit();
                }

            });
            _that = null;
            return this;
        };


        /*
         * It is useful to have variables which are scoped locally so only the
         * DataTables functions can access them and they don't leak into global space.
         * At the same time these functions are often useful over multiple files in the
         * core and API, so we list, or at least document, all variables which are used
         * by DataTables as private variables here. This also ensures that there is no
         * clashing of variable names and that they can easily referenced for reuse.
         */


        // Defined else where
        //  _selector_run
        //  _selector_opts
        //  _selector_first
        //  _selector_row_indexes

        var _ext; // DataTable.ext
        var _Api; // DataTable.Api
        var _api_register; // DataTable.Api.register
        var _api_registerPlural; // DataTable.Api.registerPlural

        var _re_dic = {};
        var _re_new_lines = /[\r\n]/g;
        var _re_html = /<.*?>/g;

        // This is not strict ISO8601 - Date.parse() is quite lax, although
        // implementations differ between browsers.
        var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;

        // Escape regular expression special characters
        var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g');

        // http://en.wikipedia.org/wiki/Foreign_exchange_market
        // - \u20BD - Russian ruble.
        // - \u20a9 - South Korean Won
        // - \u20BA - Turkish Lira
        // - \u20B9 - Indian Rupee
        // - R - Brazil (R$) and South Africa
        // - fr - Swiss Franc
        // - kr - Swedish krona, Norwegian krone and Danish krone
        // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
        //   standards as thousands separators.
        var _re_formatted_numeric = /[',$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;


        var _empty = function (d) {
            return !d || d === true || d === '-' ? true : false;
        };


        var _intVal = function (s) {
            var integer = parseInt(s, 10);
            return !isNaN(integer) && isFinite(s) ? integer : null;
        };

        // Convert from a formatted number with characters other than `.` as the
        // decimal place, to a Javascript number
        var _numToDecimal = function (num, decimalPoint) {
            // Cache created regular expressions for speed as this function is called often
            if (!_re_dic[decimalPoint]) {
                _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
            }
            return typeof num === 'string' && decimalPoint !== '.' ?
                num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') :
                num;
        };


        var _isNumber = function (d, decimalPoint, formatted) {
            var strType = typeof d === 'string';

            // If empty return immediately so there must be a number if it is a
            // formatted string (this stops the string "k", or "kr", etc being detected
            // as a formatted number for currency
            if (_empty(d)) {
                return true;
            }

            if (decimalPoint && strType) {
                d = _numToDecimal(d, decimalPoint);
            }

            if (formatted && strType) {
                d = d.replace(_re_formatted_numeric, '');
            }

            return !isNaN(parseFloat(d)) && isFinite(d);
        };


        // A string without HTML in it can be considered to be HTML still
        var _isHtml = function (d) {
            return _empty(d) || typeof d === 'string';
        };


        var _htmlNumeric = function (d, decimalPoint, formatted) {
            if (_empty(d)) {
                return true;
            }

            var html = _isHtml(d);
            return !html ?
                null :
                _isNumber(_stripHtml(d), decimalPoint, formatted) ?
                    true :
                    null;
        };


        var _pluck = function (a, prop, prop2) {
            var out = [];
            var i = 0, ien = a.length;

            // Could have the test in the loop for slightly smaller code, but speed
            // is essential here
            if (prop2 !== undefined) {
                for (; i < ien; i++) {
                    if (a[i] && a[i][prop]) {
                        out.push(a[i][prop][prop2]);
                    }
                }
            }
            else {
                for (; i < ien; i++) {
                    if (a[i]) {
                        out.push(a[i][prop]);
                    }
                }
            }

            return out;
        };


        // Basically the same as _pluck, but rather than looping over `a` we use `order`
        // as the indexes to pick from `a`
        var _pluck_order = function (a, order, prop, prop2) {
            var out = [];
            var i = 0, ien = order.length;

            // Could have the test in the loop for slightly smaller code, but speed
            // is essential here
            if (prop2 !== undefined) {
                for (; i < ien; i++) {
                    if (a[order[i]][prop]) {
                        out.push(a[order[i]][prop][prop2]);
                    }
                }
            }
            else {
                for (; i < ien; i++) {
                    out.push(a[order[i]][prop]);
                }
            }

            return out;
        };


        var _range = function (len, start) {
            var out = [];
            var end;

            if (start === undefined) {
                start = 0;
                end = len;
            }
            else {
                end = start;
                start = len;
            }

            for (var i = start; i < end; i++) {
                out.push(i);
            }

            return out;
        };


        var _removeEmpty = function (a) {
            var out = [];

            for (var i = 0, ien = a.length; i < ien; i++) {
                if (a[i]) { // careful - will remove all falsy values!
                    out.push(a[i]);
                }
            }

            return out;
        };


        var _stripHtml = function (d) {
            return d.replace(_re_html, '');
        };


        /**
         * Determine if all values in the array are unique. This means we can short
         * cut the _unique method at the cost of a single loop. A sorted array is used
         * to easily check the values.
         *
         * @param  {array} src Source array
         * @return {boolean} true if all unique, false otherwise
         * @ignore
         */
        var _areAllUnique = function (src) {
            if (src.length < 2) {
                return true;
            }

            var sorted = src.slice().sort();
            var last = sorted[0];

            for (var i = 1, ien = sorted.length; i < ien; i++) {
                if (sorted[i] === last) {
                    return false;
                }

                last = sorted[i];
            }

            return true;
        };


        /**
         * Find the unique elements in a source array.
         *
         * @param  {array} src Source array
         * @return {array} Array of unique items
         * @ignore
         */
        var _unique = function (src) {
            if (_areAllUnique(src)) {
                return src.slice();
            }

            // A faster unique method is to use object keys to identify used values,
            // but this doesn't work with arrays or objects, which we must also
            // consider. See jsperf.com/compare-array-unique-versions/4 for more
            // information.
            var
                out = [],
                val,
                i, ien = src.length,
                j, k = 0;

            again: for (i = 0; i < ien; i++) {
                val = src[i];

                for (j = 0; j < k; j++) {
                    if (out[j] === val) {
                        continue again;
                    }
                }

                out.push(val);
                k++;
            }

            return out;
        };


        /**
         * DataTables utility methods
         * 
         * This namespace provides helper methods that DataTables uses internally to
         * create a DataTable, but which are not exclusively used only for DataTables.
         * These methods can be used by extension authors to save the duplication of
         * code.
         *
         *  @namespace
         */
        DataTable.util = {
            /**
             * Throttle the calls to a function. Arguments and context are maintained
             * for the throttled function.
             *
             * @param {function} fn Function to be called
             * @param {integer} freq Call frequency in mS
             * @return {function} Wrapped function
             */
            throttle: function (fn, freq) {
                var
                    frequency = freq !== undefined ? freq : 200,
                    last,
                    timer;

                return function () {
                    var
                        that = this,
                        now = +new Date(),
                        args = arguments;

                    if (last && now < last + frequency) {
                        clearTimeout(timer);

                        timer = setTimeout(function () {
                            last = undefined;
                            fn.apply(that, args);
                        }, frequency);
                    }
                    else {
                        last = now;
                        fn.apply(that, args);
                    }
                };
            },


            /**
             * Escape a string such that it can be used in a regular expression
             *
             *  @param {string} val string to escape
             *  @returns {string} escaped string
             */
            escapeRegex: function (val) {
                return val.replace(_re_escape_regex, '\\$1');
            }
        };



        /**
         * Create a mapping object that allows camel case parameters to be looked up
         * for their Hungarian counterparts. The mapping is stored in a private
         * parameter called `_hungarianMap` which can be accessed on the source object.
         *  @param {object} o
         *  @memberof DataTable#oApi
         */
        function _fnHungarianMap(o) {
            var
                hungarian = 'a aa ai ao as b fn i m o s ',
                match,
                newKey,
                map = {};

            $.each(o, function (key, val) {
                match = key.match(/^([^A-Z]+?)([A-Z])/);

                if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
                    newKey = key.replace(match[0], match[2].toLowerCase());
                    map[newKey] = key;

                    if (match[1] === 'o') {
                        _fnHungarianMap(o[key]);
                    }
                }
            });

            o._hungarianMap = map;
        }


        /**
         * Convert from camel case parameters to Hungarian, based on a Hungarian map
         * created by _fnHungarianMap.
         *  @param {object} src The model object which holds all parameters that can be
         *    mapped.
         *  @param {object} user The object to convert from camel case to Hungarian.
         *  @param {boolean} force When set to `true`, properties which already have a
         *    Hungarian value in the `user` object will be overwritten. Otherwise they
         *    won't be.
         *  @memberof DataTable#oApi
         */
        function _fnCamelToHungarian(src, user, force) {
            if (!src._hungarianMap) {
                _fnHungarianMap(src);
            }

            var hungarianKey;

            $.each(user, function (key, val) {
                hungarianKey = src._hungarianMap[key];

                if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
                    // For objects, we need to buzz down into the object to copy parameters
                    if (hungarianKey.charAt(0) === 'o') {
                        // Copy the camelCase options over to the hungarian
                        if (!user[hungarianKey]) {
                            user[hungarianKey] = {};
                        }
                        $.extend(true, user[hungarianKey], user[key]);

                        _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
                    }
                    else {
                        user[hungarianKey] = user[key];
                    }
                }
            });
        }


        /**
         * Language compatibility - when certain options are given, and others aren't, we
         * need to duplicate the values over, in order to provide backwards compatibility
         * with older language files.
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnLanguageCompat(lang) {
            var defaults = DataTable.defaults.oLanguage;
            var zeroRecords = lang.sZeroRecords;

            /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
             * sZeroRecords - assuming that is given.
             */
            if (!lang.sEmptyTable && zeroRecords &&
                defaults.sEmptyTable === "No data available in table") {
                _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
            }

            /* Likewise with loading records */
            if (!lang.sLoadingRecords && zeroRecords &&
                defaults.sLoadingRecords === "Loading...") {
                _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
            }

            // Old parameter name of the thousands separator mapped onto the new
            if (lang.sInfoThousands) {
                lang.sThousands = lang.sInfoThousands;
            }

            var decimal = lang.sDecimal;
            if (decimal) {
                _addNumericSort(decimal);
            }
        }


        /**
         * Map one parameter onto another
         *  @param {object} o Object to map
         *  @param {*} knew The new parameter name
         *  @param {*} old The old parameter name
         */
        var _fnCompatMap = function (o, knew, old) {
            if (o[knew] !== undefined) {
                o[old] = o[knew];
            }
        };


        /**
         * Provide backwards compatibility for the main DT options. Note that the new
         * options are mapped onto the old parameters, so this is an external interface
         * change only.
         *  @param {object} init Object to map
         */
        function _fnCompatOpts(init) {
            _fnCompatMap(init, 'ordering', 'bSort');
            _fnCompatMap(init, 'orderMulti', 'bSortMulti');
            _fnCompatMap(init, 'orderClasses', 'bSortClasses');
            _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
            _fnCompatMap(init, 'order', 'aaSorting');
            _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
            _fnCompatMap(init, 'paging', 'bPaginate');
            _fnCompatMap(init, 'pagingType', 'sPaginationType');
            _fnCompatMap(init, 'pageLength', 'iDisplayLength');
            _fnCompatMap(init, 'searching', 'bFilter');

            // Boolean initialisation of x-scrolling
            if (typeof init.sScrollX === 'boolean') {
                init.sScrollX = init.sScrollX ? '100%' : '';
            }
            if (typeof init.scrollX === 'boolean') {
                init.scrollX = init.scrollX ? '100%' : '';
            }

            // Column search objects are in an array, so it needs to be converted
            // element by element
            var searchCols = init.aoSearchCols;

            if (searchCols) {
                for (var i = 0, ien = searchCols.length; i < ien; i++) {
                    if (searchCols[i]) {
                        _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
                    }
                }
            }
        }


        /**
         * Provide backwards compatibility for column options. Note that the new options
         * are mapped onto the old parameters, so this is an external interface change
         * only.
         *  @param {object} init Object to map
         */
        function _fnCompatCols(init) {
            _fnCompatMap(init, 'orderable', 'bSortable');
            _fnCompatMap(init, 'orderData', 'aDataSort');
            _fnCompatMap(init, 'orderSequence', 'asSorting');
            _fnCompatMap(init, 'orderDataType', 'sortDataType');

            // orderData can be given as an integer
            var dataSort = init.aDataSort;
            if (typeof dataSort === 'number' && !$.isArray(dataSort)) {
                init.aDataSort = [dataSort];
            }
        }


        /**
         * Browser feature detection for capabilities, quirks
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnBrowserDetect(settings) {
            // We don't need to do this every time DataTables is constructed, the values
            // calculated are specific to the browser and OS configuration which we
            // don't expect to change between initialisations
            if (!DataTable.__browser) {
                var browser = {};
                DataTable.__browser = browser;

                // Scrolling feature / quirks detection
                var n = $('<div/>')
                    .css({
                        position: 'fixed',
                        top: 0,
                        left: $(window).scrollLeft() * -1, // allow for scrolling
                        height: 1,
                        width: 1,
                        overflow: 'hidden'
                    })
                    .append(
                        $('<div/>')
                            .css({
                                position: 'absolute',
                                top: 1,
                                left: 1,
                                width: 100,
                                overflow: 'scroll'
                            })
                            .append(
                                $('<div/>')
                                    .css({
                                        width: '100%',
                                        height: 10
                                    })
                            )
                    )
                    .appendTo('body');

                var outer = n.children();
                var inner = outer.children();

                // Numbers below, in order, are:
                // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
                //
                // IE6 XP:                           100 100 100  83
                // IE7 Vista:                        100 100 100  83
                // IE 8+ Windows:                     83  83 100  83
                // Evergreen Windows:                 83  83 100  83
                // Evergreen Mac with scrollbars:     85  85 100  85
                // Evergreen Mac without scrollbars: 100 100 100 100

                // Get scrollbar width
                browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

                // IE6/7 will oversize a width 100% element inside a scrolling element, to
                // include the width of the scrollbar, while other browsers ensure the inner
                // element is contained without forcing scrolling
                browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;

                // In rtl text layout, some browsers (most, but not all) will place the
                // scrollbar on the left, rather than the right.
                browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;

                // IE8- don't provide height and width for getBoundingClientRect
                browser.bBounding = n[0].getBoundingClientRect().width ? true : false;

                n.remove();
            }

            $.extend(settings.oBrowser, DataTable.__browser);
            settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
        }


        /**
         * Array.prototype reduce[Right] method, used for browsers which don't support
         * JS 1.6. Done this way to reduce code size, since we iterate either way
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnReduce(that, fn, init, start, end, inc) {
            var
                i = start,
                value,
                isSet = false;

            if (init !== undefined) {
                value = init;
                isSet = true;
            }

            while (i !== end) {
                if (!that.hasOwnProperty(i)) {
                    continue;
                }

                value = isSet ?
                    fn(value, that[i], i, that) :
                    that[i];

                isSet = true;
                i += inc;
            }

            return value;
        }

        /**
         * Add a column to the list used for the table with default values
         *  @param {object} oSettings dataTables settings object
         *  @param {node} nTh The th element for this column
         *  @memberof DataTable#oApi
         */
        function _fnAddColumn(oSettings, nTh) {
            // Add column to aoColumns array
            var oDefaults = DataTable.defaults.column;
            var iCol = oSettings.aoColumns.length;
            var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
                "nTh": nTh ? nTh : document.createElement('th'),
                "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
                "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
                "mData": oDefaults.mData ? oDefaults.mData : iCol,
                idx: iCol
            });
            oSettings.aoColumns.push(oCol);

            // Add search object for column specific search. Note that the `searchCols[ iCol ]`
            // passed into extend can be undefined. This allows the user to give a default
            // with only some of the parameters defined, and also not give a default
            var searchCols = oSettings.aoPreSearchCols;
            searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);

            // Use the default column options function to initialise classes etc
            _fnColumnOptions(oSettings, iCol, $(nTh).data());
        }


        /**
         * Apply options for a column
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iCol column index to consider
         *  @param {object} oOptions object with sType, bVisible and bSearchable etc
         *  @memberof DataTable#oApi
         */
        function _fnColumnOptions(oSettings, iCol, oOptions) {
            var oCol = oSettings.aoColumns[iCol];
            var oClasses = oSettings.oClasses;
            var th = $(oCol.nTh);

            // Try to get width information from the DOM. We can't get it from CSS
            // as we'd need to parse the CSS stylesheet. `width` option can override
            if (!oCol.sWidthOrig) {
                // Width attribute
                oCol.sWidthOrig = th.attr('width') || null;

                // Style attribute
                var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
                if (t) {
                    oCol.sWidthOrig = t[1];
                }
            }

            /* User specified column options */
            if (oOptions !== undefined && oOptions !== null) {
                // Backwards compatibility
                _fnCompatCols(oOptions);

                // Map camel case parameters to their Hungarian counterparts
                _fnCamelToHungarian(DataTable.defaults.column, oOptions);

                /* Backwards compatibility for mDataProp */
                if (oOptions.mDataProp !== undefined && !oOptions.mData) {
                    oOptions.mData = oOptions.mDataProp;
                }

                if (oOptions.sType) {
                    oCol._sManualType = oOptions.sType;
                }

                // `class` is a reserved word in Javascript, so we need to provide
                // the ability to use a valid name for the camel case input
                if (oOptions.className && !oOptions.sClass) {
                    oOptions.sClass = oOptions.className;
                }
                if (oOptions.sClass) {
                    th.addClass(oOptions.sClass);
                }

                $.extend(oCol, oOptions);
                _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

                /* iDataSort to be applied (backwards compatibility), but aDataSort will take
                 * priority if defined
                 */
                if (oOptions.iDataSort !== undefined) {
                    oCol.aDataSort = [oOptions.iDataSort];
                }
                _fnMap(oCol, oOptions, "aDataSort");
            }

            /* Cache the data get and set functions for speed */
            var mDataSrc = oCol.mData;
            var mData = _fnGetObjectDataFn(mDataSrc);
            var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

            var attrTest = function (src) {
                return typeof src === 'string' && src.indexOf('@') !== -1;
            };
            oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (
                attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
            );
            oCol._setter = null;

            oCol.fnGetData = function (rowData, type, meta) {
                var innerData = mData(rowData, type, undefined, meta);

                return mRender && type ?
                    mRender(innerData, type, rowData, meta) :
                    innerData;
            };
            oCol.fnSetData = function (rowData, val, meta) {
                return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
            };

            // Indicate if DataTables should read DOM data as an object or array
            // Used in _fnGetRowElements
            if (typeof mDataSrc !== 'number') {
                oSettings._rowReadObject = true;
            }

            /* Feature sorting overrides column specific when off */
            if (!oSettings.oFeatures.bSort) {
                oCol.bSortable = false;
                th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
            }

            /* Check that the class assignment is correct for sorting */
            var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
            var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
            if (!oCol.bSortable || (!bAsc && !bDesc)) {
                oCol.sSortingClass = oClasses.sSortableNone;
                oCol.sSortingClassJUI = "";
            }
            else if (bAsc && !bDesc) {
                oCol.sSortingClass = oClasses.sSortableAsc;
                oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
            }
            else if (!bAsc && bDesc) {
                oCol.sSortingClass = oClasses.sSortableDesc;
                oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
            }
            else {
                oCol.sSortingClass = oClasses.sSortable;
                oCol.sSortingClassJUI = oClasses.sSortJUI;
            }
        }


        /**
         * Adjust the table column widths for new data. Note: you would probably want to
         * do a redraw after calling this function!
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnAdjustColumnSizing(settings) {
            /* Not interested in doing column width calculation if auto-width is disabled */
            if (settings.oFeatures.bAutoWidth !== false) {
                var columns = settings.aoColumns;

                _fnCalculateColumnWidths(settings);
                for (var i = 0, iLen = columns.length; i < iLen; i++) {
                    columns[i].nTh.style.width = columns[i].sWidth;
                }
            }

            var scroll = settings.oScroll;
            if (scroll.sY !== '' || scroll.sX !== '') {
                _fnScrollDraw(settings);
            }

            _fnCallbackFire(settings, null, 'column-sizing', [settings]);
        }


        /**
         * Covert the index of a visible column to the index in the data array (take account
         * of hidden columns)
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iMatch Visible column index to lookup
         *  @returns {int} i the data index
         *  @memberof DataTable#oApi
         */
        function _fnVisibleToColumnIndex(oSettings, iMatch) {
            var aiVis = _fnGetColumns(oSettings, 'bVisible');

            return typeof aiVis[iMatch] === 'number' ?
                aiVis[iMatch] :
                null;
        }


        /**
         * Covert the index of an index in the data array and convert it to the visible
         *   column index (take account of hidden columns)
         *  @param {int} iMatch Column index to lookup
         *  @param {object} oSettings dataTables settings object
         *  @returns {int} i the data index
         *  @memberof DataTable#oApi
         */
        function _fnColumnIndexToVisible(oSettings, iMatch) {
            var aiVis = _fnGetColumns(oSettings, 'bVisible');
            var iPos = $.inArray(iMatch, aiVis);

            return iPos !== -1 ? iPos : null;
        }


        /**
         * Get the number of visible columns
         *  @param {object} oSettings dataTables settings object
         *  @returns {int} i the number of visible columns
         *  @memberof DataTable#oApi
         */
        function _fnVisbleColumns(oSettings) {
            var vis = 0;

            // No reduce in IE8, use a loop for now
            $.each(oSettings.aoColumns, function (i, col) {
                if (col.bVisible && $(col.nTh).css('display') !== 'none') {
                    vis++;
                }
            });

            return vis;
        }


        /**
         * Get an array of column indexes that match a given property
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sParam Parameter in aoColumns to look for - typically
         *    bVisible or bSearchable
         *  @returns {array} Array of indexes with matched properties
         *  @memberof DataTable#oApi
         */
        function _fnGetColumns(oSettings, sParam) {
            var a = [];

            $.map(oSettings.aoColumns, function (val, i) {
                if (val[sParam]) {
                    a.push(i);
                }
            });

            return a;
        }


        /**
         * Calculate the 'type' of a column
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnColumnTypes(settings) {
            var columns = settings.aoColumns;
            var data = settings.aoData;
            var types = DataTable.ext.type.detect;
            var i, ien, j, jen, k, ken;
            var col, cell, detectedType, cache;

            // For each column, spin over the 
            for (i = 0, ien = columns.length; i < ien; i++) {
                col = columns[i];
                cache = [];

                if (!col.sType && col._sManualType) {
                    col.sType = col._sManualType;
                }
                else if (!col.sType) {
                    for (j = 0, jen = types.length; j < jen; j++) {
                        for (k = 0, ken = data.length; k < ken; k++) {
                            // Use a cache array so we only need to get the type data
                            // from the formatter once (when using multiple detectors)
                            if (cache[k] === undefined) {
                                cache[k] = _fnGetCellData(settings, k, i, 'type');
                            }

                            detectedType = types[j](cache[k], settings);

                            // If null, then this type can't apply to this column, so
                            // rather than testing all cells, break out. There is an
                            // exception for the last type which is `html`. We need to
                            // scan all rows since it is possible to mix string and HTML
                            // types
                            if (!detectedType && j !== types.length - 1) {
                                break;
                            }

                            // Only a single match is needed for html type since it is
                            // bottom of the pile and very similar to string
                            if (detectedType === 'html') {
                                break;
                            }
                        }

                        // Type is valid for all data points in the column - use this
                        // type
                        if (detectedType) {
                            col.sType = detectedType;
                            break;
                        }
                    }

                    // Fall back - if no type was detected, always use string
                    if (!col.sType) {
                        col.sType = 'string';
                    }
                }
            }
        }


        /**
         * Take the column definitions and static columns arrays and calculate how
         * they relate to column indexes. The callback function will then apply the
         * definition found for a column to a suitable configuration object.
         *  @param {object} oSettings dataTables settings object
         *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
         *  @param {array} aoCols The aoColumns array that defines columns individually
         *  @param {function} fn Callback function - takes two parameters, the calculated
         *    column index and the definition for that column.
         *  @memberof DataTable#oApi
         */
        function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
            var i, iLen, j, jLen, k, kLen, def;
            var columns = oSettings.aoColumns;

            // Column definitions with aTargets
            if (aoColDefs) {
                /* Loop over the definitions array - loop in reverse so first instance has priority */
                for (i = aoColDefs.length - 1; i >= 0; i--) {
                    def = aoColDefs[i];

                    /* Each definition can target multiple columns, as it is an array */
                    var aTargets = def.targets !== undefined ?
                        def.targets :
                        def.aTargets;

                    if (!$.isArray(aTargets)) {
                        aTargets = [aTargets];
                    }

                    for (j = 0, jLen = aTargets.length; j < jLen; j++) {
                        if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
                            /* Add columns that we don't yet know about */
                            while (columns.length <= aTargets[j]) {
                                _fnAddColumn(oSettings);
                            }

                            /* Integer, basic index */
                            fn(aTargets[j], def);
                        }
                        else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
                            /* Negative integer, right to left column counting */
                            fn(columns.length + aTargets[j], def);
                        }
                        else if (typeof aTargets[j] === 'string') {
                            /* Class name matching on TH element */
                            for (k = 0, kLen = columns.length; k < kLen; k++) {
                                if (aTargets[j] == "_all" ||
                                    $(columns[k].nTh).hasClass(aTargets[j])) {
                                    fn(k, def);
                                }
                            }
                        }
                    }
                }
            }

            // Statically defined columns array
            if (aoCols) {
                for (i = 0, iLen = aoCols.length; i < iLen; i++) {
                    fn(i, aoCols[i]);
                }
            }
        }

        /**
         * Add a data array to the table, creating DOM node etc. This is the parallel to
         * _fnGatherData, but for adding rows from a Javascript source, rather than a
         * DOM source.
         *  @param {object} oSettings dataTables settings object
         *  @param {array} aData data array to be added
         *  @param {node} [nTr] TR element to add to the table - optional. If not given,
         *    DataTables will create a row automatically
         *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
         *    if nTr is.
         *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
         *  @memberof DataTable#oApi
         */
        function _fnAddData(oSettings, aDataIn, nTr, anTds) {
            /* Create the object for storing information about this new row */
            var iRow = oSettings.aoData.length;
            var oData = $.extend(true, {}, DataTable.models.oRow, {
                src: nTr ? 'dom' : 'data',
                idx: iRow
            });

            oData._aData = aDataIn;
            oSettings.aoData.push(oData);

            /* Create the cells */
            var nTd, sThisType;
            var columns = oSettings.aoColumns;

            // Invalidate the column types as the new data needs to be revalidated
            for (var i = 0, iLen = columns.length; i < iLen; i++) {
                columns[i].sType = null;
            }

            /* Add to the display array */
            oSettings.aiDisplayMaster.push(iRow);

            var id = oSettings.rowIdFn(aDataIn);
            if (id !== undefined) {
                oSettings.aIds[id] = oData;
            }

            /* Create the DOM information, or register it if already present */
            if (nTr || !oSettings.oFeatures.bDeferRender) {
                _fnCreateTr(oSettings, iRow, nTr, anTds);
            }

            return iRow;
        }


        /**
         * Add one or more TR elements to the table. Generally we'd expect to
         * use this for reading data from a DOM sourced table, but it could be
         * used for an TR element. Note that if a TR is given, it is used (i.e.
         * it is not cloned).
         *  @param {object} settings dataTables settings object
         *  @param {array|node|jQuery} trs The TR element(s) to add to the table
         *  @returns {array} Array of indexes for the added rows
         *  @memberof DataTable#oApi
         */
        function _fnAddTr(settings, trs) {
            var row;

            // Allow an individual node to be passed in
            if (!(trs instanceof $)) {
                trs = $(trs);
            }

            return trs.map(function (i, el) {
                row = _fnGetRowElements(settings, el);
                return _fnAddData(settings, row.data, el, row.cells);
            });
        }


        /**
         * Take a TR element and convert it to an index in aoData
         *  @param {object} oSettings dataTables settings object
         *  @param {node} n the TR element to find
         *  @returns {int} index if the node is found, null if not
         *  @memberof DataTable#oApi
         */
        function _fnNodeToDataIndex(oSettings, n) {
            return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
        }


        /**
         * Take a TD element and convert it into a column data index (not the visible index)
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow The row number the TD/TH can be found in
         *  @param {node} n The TD/TH element to find
         *  @returns {int} index if the node is found, -1 if not
         *  @memberof DataTable#oApi
         */
        function _fnNodeToColumnIndex(oSettings, iRow, n) {
            return $.inArray(n, oSettings.aoData[iRow].anCells);
        }


        /**
         * Get the data for a given cell from the internal cache, taking into account data mapping
         *  @param {object} settings dataTables settings object
         *  @param {int} rowIdx aoData row id
         *  @param {int} colIdx Column index
         *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
         *  @returns {*} Cell data
         *  @memberof DataTable#oApi
         */
        function _fnGetCellData(settings, rowIdx, colIdx, type) {
            var draw = settings.iDraw;
            var col = settings.aoColumns[colIdx];
            var rowData = settings.aoData[rowIdx]._aData;
            var defaultContent = col.sDefaultContent;
            var cellData = col.fnGetData(rowData, type, {
                settings: settings,
                row: rowIdx,
                col: colIdx
            });

            if (cellData === undefined) {
                if (settings.iDrawError != draw && defaultContent === null) {
                    _fnLog(settings, 0, "Requested unknown parameter " +
                        (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") +
                        " for row " + rowIdx + ", column " + colIdx, 4);
                    settings.iDrawError = draw;
                }
                return defaultContent;
            }

            // When the data source is null and a specific data type is requested (i.e.
            // not the original data), we can use default column data
            if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
                cellData = defaultContent;
            }
            else if (typeof cellData === 'function') {
                // If the data source is a function, then we run it and use the return,
                // executing in the scope of the data object (for instances)
                return cellData.call(rowData);
            }

            if (cellData === null && type == 'display') {
                return '';
            }
            return cellData;
        }


        /**
         * Set the value for a specific cell, into the internal data cache
         *  @param {object} settings dataTables settings object
         *  @param {int} rowIdx aoData row id
         *  @param {int} colIdx Column index
         *  @param {*} val Value to set
         *  @memberof DataTable#oApi
         */
        function _fnSetCellData(settings, rowIdx, colIdx, val) {
            var col = settings.aoColumns[colIdx];
            var rowData = settings.aoData[rowIdx]._aData;

            col.fnSetData(rowData, val, {
                settings: settings,
                row: rowIdx,
                col: colIdx
            });
        }


        // Private variable that is used to match action syntax in the data property object
        var __reArray = /\[.*?\]$/;
        var __reFn = /\(\)$/;

        /**
         * Split string on periods, taking into account escaped periods
         * @param  {string} str String to split
         * @return {array} Split string
         */
        function _fnSplitObjNotation(str) {
            return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
                return s.replace(/\\\./g, '.');
            });
        }


        /**
         * Return a function that can be used to get data from a source object, taking
         * into account the ability to use nested objects as a source
         *  @param {string|int|function} mSource The data source for the object
         *  @returns {function} Data get function
         *  @memberof DataTable#oApi
         */
        function _fnGetObjectDataFn(mSource) {
            if ($.isPlainObject(mSource)) {
                /* Build an object of get functions, and wrap them in a single call */
                var o = {};
                $.each(mSource, function (key, val) {
                    if (val) {
                        o[key] = _fnGetObjectDataFn(val);
                    }
                });

                return function (data, type, row, meta) {
                    var t = o[type] || o._;
                    return t !== undefined ?
                        t(data, type, row, meta) :
                        data;
                };
            }
            else if (mSource === null) {
                /* Give an empty string for rendering / sorting etc */
                return function (data) { // type, row and meta also passed, but not used
                    return data;
                };
            }
            else if (typeof mSource === 'function') {
                return function (data, type, row, meta) {
                    return mSource(data, type, row, meta);
                };
            }
            else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
                mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
                /* If there is a . in the source string then the data source is in a
                 * nested object so we loop over the data for each level to get the next
                 * level down. On each loop we test for undefined, and if found immediately
                 * return. This allows entire objects to be missing and sDefaultContent to
                 * be used if defined, rather than throwing an error
                 */
                var fetchData = function (data, type, src) {
                    var arrayNotation, funcNotation, out, innerSrc;

                    if (src !== "") {
                        var a = _fnSplitObjNotation(src);

                        for (var i = 0, iLen = a.length; i < iLen; i++) {
                            // Check if we are dealing with special notation
                            arrayNotation = a[i].match(__reArray);
                            funcNotation = a[i].match(__reFn);

                            if (arrayNotation) {
                                // Array notation
                                a[i] = a[i].replace(__reArray, '');

                                // Condition allows simply [] to be passed in
                                if (a[i] !== "") {
                                    data = data[a[i]];
                                }
                                out = [];

                                // Get the remainder of the nested object to get
                                a.splice(0, i + 1);
                                innerSrc = a.join('.');

                                // Traverse each entry in the array getting the properties requested
                                if ($.isArray(data)) {
                                    for (var j = 0, jLen = data.length; j < jLen; j++) {
                                        out.push(fetchData(data[j], type, innerSrc));
                                    }
                                }

                                // If a string is given in between the array notation indicators, that
                                // is used to join the strings together, otherwise an array is returned
                                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                                data = (join === "") ? out : out.join(join);

                                // The inner call to fetchData has already traversed through the remainder
                                // of the source requested, so we exit from the loop
                                break;
                            }
                            else if (funcNotation) {
                                // Function call
                                a[i] = a[i].replace(__reFn, '');
                                data = data[a[i]]();
                                continue;
                            }

                            if (data === null || data[a[i]] === undefined) {
                                return undefined;
                            }
                            data = data[a[i]];
                        }
                    }

                    return data;
                };

                return function (data, type) { // row and meta also passed, but not used
                    return fetchData(data, type, mSource);
                };
            }
            else {
                /* Array or flat object mapping */
                return function (data, type) { // row and meta also passed, but not used
                    return data[mSource];
                };
            }
        }


        /**
         * Return a function that can be used to set data from a source object, taking
         * into account the ability to use nested objects as a source
         *  @param {string|int|function} mSource The data source for the object
         *  @returns {function} Data set function
         *  @memberof DataTable#oApi
         */
        function _fnSetObjectDataFn(mSource) {
            if ($.isPlainObject(mSource)) {
                /* Unlike get, only the underscore (global) option is used for for
                 * setting data since we don't know the type here. This is why an object
                 * option is not documented for `mData` (which is read/write), but it is
                 * for `mRender` which is read only.
                 */
                return _fnSetObjectDataFn(mSource._);
            }
            else if (mSource === null) {
                /* Nothing to do when the data source is null */
                return function () { };
            }
            else if (typeof mSource === 'function') {
                return function (data, val, meta) {
                    mSource(data, 'set', val, meta);
                };
            }
            else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
                mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
                /* Like the get, we need to get data from a nested object */
                var setData = function (data, val, src) {
                    var a = _fnSplitObjNotation(src), b;
                    var aLast = a[a.length - 1];
                    var arrayNotation, funcNotation, o, innerSrc;

                    for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
                        // Check if we are dealing with an array notation request
                        arrayNotation = a[i].match(__reArray);
                        funcNotation = a[i].match(__reFn);

                        if (arrayNotation) {
                            a[i] = a[i].replace(__reArray, '');
                            data[a[i]] = [];

                            // Get the remainder of the nested object to set so we can recurse
                            b = a.slice();
                            b.splice(0, i + 1);
                            innerSrc = b.join('.');

                            // Traverse each entry in the array setting the properties requested
                            if ($.isArray(val)) {
                                for (var j = 0, jLen = val.length; j < jLen; j++) {
                                    o = {};
                                    setData(o, val[j], innerSrc);
                                    data[a[i]].push(o);
                                }
                            }
                            else {
                                // We've been asked to save data to an array, but it
                                // isn't array data to be saved. Best that can be done
                                // is to just save the value.
                                data[a[i]] = val;
                            }

                            // The inner call to setData has already traversed through the remainder
                            // of the source and has set the data, thus we can exit here
                            return;
                        }
                        else if (funcNotation) {
                            // Function call
                            a[i] = a[i].replace(__reFn, '');
                            data = data[a[i]](val);
                        }

                        // If the nested object doesn't currently exist - since we are
                        // trying to set the value - create it
                        if (data[a[i]] === null || data[a[i]] === undefined) {
                            data[a[i]] = {};
                        }
                        data = data[a[i]];
                    }

                    // Last item in the input - i.e, the actual set
                    if (aLast.match(__reFn)) {
                        // Function call
                        data = data[aLast.replace(__reFn, '')](val);
                    }
                    else {
                        // If array notation is used, we just want to strip it and use the property name
                        // and assign the value. If it isn't used, then we get the result we want anyway
                        data[aLast.replace(__reArray, '')] = val;
                    }
                };

                return function (data, val) { // meta is also passed in, but not used
                    return setData(data, val, mSource);
                };
            }
            else {
                /* Array or flat object mapping */
                return function (data, val) { // meta is also passed in, but not used
                    data[mSource] = val;
                };
            }
        }


        /**
         * Return an array with the full table data
         *  @param {object} oSettings dataTables settings object
         *  @returns array {array} aData Master data array
         *  @memberof DataTable#oApi
         */
        function _fnGetDataMaster(settings) {
            return _pluck(settings.aoData, '_aData');
        }


        /**
         * Nuke the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnClearTable(settings) {
            settings.aoData.length = 0;
            settings.aiDisplayMaster.length = 0;
            settings.aiDisplay.length = 0;
            settings.aIds = {};
        }


        /**
        * Take an array of integers (index array) and remove a target integer (value - not
        * the key!)
        *  @param {array} a Index array to target
        *  @param {int} iTarget value to find
        *  @memberof DataTable#oApi
        */
        function _fnDeleteIndex(a, iTarget, splice) {
            var iTargetIndex = -1;

            for (var i = 0, iLen = a.length; i < iLen; i++) {
                if (a[i] == iTarget) {
                    iTargetIndex = i;
                }
                else if (a[i] > iTarget) {
                    a[i]--;
                }
            }

            if (iTargetIndex != -1 && splice === undefined) {
                a.splice(iTargetIndex, 1);
            }
        }


        /**
         * Mark cached data as invalid such that a re-read of the data will occur when
         * the cached data is next requested. Also update from the data source object.
         *
         * @param {object} settings DataTables settings object
         * @param {int}    rowIdx   Row index to invalidate
         * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
         *     or 'data'
         * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
         *     row will be invalidated
         * @memberof DataTable#oApi
         *
         * @todo For the modularisation of v1.11 this will need to become a callback, so
         *   the sort and filter methods can subscribe to it. That will required
         *   initialisation options for sorting, which is why it is not already baked in
         */
        function _fnInvalidate(settings, rowIdx, src, colIdx) {
            var row = settings.aoData[rowIdx];
            var i, ien;
            var cellWrite = function (cell, col) {
                // This is very frustrating, but in IE if you just write directly
                // to innerHTML, and elements that are overwritten are GC'ed,
                // even if there is a reference to them elsewhere
                while (cell.childNodes.length) {
                    cell.removeChild(cell.firstChild);
                }

                cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
            };

            // Are we reading last data from DOM or the data object?
            if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {
                // Read the data from the DOM
                row._aData = _fnGetRowElements(
                    settings, row, colIdx, colIdx === undefined ? undefined : row._aData
                )
                    .data;
            }
            else {
                // Reading from data object, update the DOM
                var cells = row.anCells;

                if (cells) {
                    if (colIdx !== undefined) {
                        cellWrite(cells[colIdx], colIdx);
                    }
                    else {
                        for (i = 0, ien = cells.length; i < ien; i++) {
                            cellWrite(cells[i], i);
                        }
                    }
                }
            }

            // For both row and cell invalidation, the cached data for sorting and
            // filtering is nulled out
            row._aSortData = null;
            row._aFilterData = null;

            // Invalidate the type for a specific column (if given) or all columns since
            // the data might have changed
            var cols = settings.aoColumns;
            if (colIdx !== undefined) {
                cols[colIdx].sType = null;
            }
            else {
                for (i = 0, ien = cols.length; i < ien; i++) {
                    cols[i].sType = null;
                }

                // Update DataTables special `DT_*` attributes for the row
                _fnRowAttributes(settings, row);
            }
        }


        /**
         * Build a data source object from an HTML row, reading the contents of the
         * cells that are in the row.
         *
         * @param {object} settings DataTables settings object
         * @param {node|object} TR element from which to read data or existing row
         *   object from which to re-read the data from the cells
         * @param {int} [colIdx] Optional column index
         * @param {array|object} [d] Data source object. If `colIdx` is given then this
         *   parameter should also be given and will be used to write the data into.
         *   Only the column in question will be written
         * @returns {object} Object with two parameters: `data` the data read, in
         *   document order, and `cells` and array of nodes (they can be useful to the
         *   caller, so rather than needing a second traversal to get them, just return
         *   them from here).
         * @memberof DataTable#oApi
         */
        function _fnGetRowElements(settings, row, colIdx, d) {
            var
                tds = [],
                td = row.firstChild,
                name, col, o, i = 0, contents,
                columns = settings.aoColumns,
                objectRead = settings._rowReadObject;

            // Allow the data object to be passed in, or construct
            d = d !== undefined ?
                d :
                objectRead ?
                    {} :
                    [];

            var attr = function (str, td) {
                if (typeof str === 'string') {
                    var idx = str.indexOf('@');

                    if (idx !== -1) {
                        var attr = str.substring(idx + 1);
                        var setter = _fnSetObjectDataFn(str);
                        setter(d, td.getAttribute(attr));
                    }
                }
            };

            // Read data from a cell and store into the data object
            var cellProcess = function (cell) {
                if (colIdx === undefined || colIdx === i) {
                    col = columns[i];
                    contents = $.trim(cell.innerHTML);

                    if (col && col._bAttrSrc) {
                        var setter = _fnSetObjectDataFn(col.mData._);
                        setter(d, contents);

                        attr(col.mData.sort, cell);
                        attr(col.mData.type, cell);
                        attr(col.mData.filter, cell);
                    }
                    else {
                        // Depending on the `data` option for the columns the data can
                        // be read to either an object or an array.
                        if (objectRead) {
                            if (!col._setter) {
                                // Cache the setter function
                                col._setter = _fnSetObjectDataFn(col.mData);
                            }
                            col._setter(d, contents);
                        }
                        else {
                            d[i] = contents;
                        }
                    }
                }

                i++;
            };

            if (td) {
                // `tr` element was passed in
                while (td) {
                    name = td.nodeName.toUpperCase();

                    if (name == "TD" || name == "TH") {
                        cellProcess(td);
                        tds.push(td);
                    }

                    td = td.nextSibling;
                }
            }
            else {
                // Existing row object passed in
                tds = row.anCells;

                for (var j = 0, jen = tds.length; j < jen; j++) {
                    cellProcess(tds[j]);
                }
            }

            // Read the ID from the DOM if present
            var rowNode = row.firstChild ? row : row.nTr;

            if (rowNode) {
                var id = rowNode.getAttribute('id');

                if (id) {
                    _fnSetObjectDataFn(settings.rowId)(d, id);
                }
            }

            return {
                data: d,
                cells: tds
            };
        }
        /**
         * Create a new TR element (and it's TD children) for a row
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow Row to consider
         *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
         *    DataTables will create a row automatically
         *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
         *    if nTr is.
         *  @memberof DataTable#oApi
         */
        function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
            var
                row = oSettings.aoData[iRow],
                rowData = row._aData,
                cells = [],
                nTr, nTd, oCol,
                i, iLen;

            if (row.nTr === null) {
                nTr = nTrIn || document.createElement('tr');

                row.nTr = nTr;
                row.anCells = cells;

                /* Use a private property on the node to allow reserve mapping from the node
                 * to the aoData array for fast look up
                 */
                nTr._DT_RowIndex = iRow;

                /* Special parameters can be given by the data source to be used on the row */
                _fnRowAttributes(oSettings, row);

                /* Process each column */
                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    oCol = oSettings.aoColumns[i];

                    nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
                    nTd._DT_CellIndex = {
                        row: iRow,
                        column: i
                    };

                    cells.push(nTd);

                    // Need to create the HTML if new, or if a rendering function is defined
                    if ((!nTrIn || oCol.mRender || oCol.mData !== i) &&
                        (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')
                    ) {
                        nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
                    }

                    /* Add user defined class */
                    if (oCol.sClass) {
                        nTd.className += ' ' + oCol.sClass;
                    }

                    // Visibility - add or remove as required
                    if (oCol.bVisible && !nTrIn) {
                        nTr.appendChild(nTd);
                    }
                    else if (!oCol.bVisible && nTrIn) {
                        nTd.parentNode.removeChild(nTd);
                    }

                    if (oCol.fnCreatedCell) {
                        oCol.fnCreatedCell.call(oSettings.oInstance,
                            nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i
                        );
                    }
                }

                _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
            }

            // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
            // and deployed
            row.nTr.setAttribute('role', 'row');
        }


        /**
         * Add attributes to a row based on the special `DT_*` parameters in a data
         * source object.
         *  @param {object} settings DataTables settings object
         *  @param {object} DataTables row object for the row to be modified
         *  @memberof DataTable#oApi
         */
        function _fnRowAttributes(settings, row) {
            var tr = row.nTr;
            var data = row._aData;

            if (tr) {
                var id = settings.rowIdFn(data);

                if (id) {
                    tr.id = id;
                }

                if (data.DT_RowClass) {
                    // Remove any classes added by DT_RowClass before
                    var a = data.DT_RowClass.split(' ');
                    row.__rowc = row.__rowc ?
                        _unique(row.__rowc.concat(a)) :
                        a;

                    $(tr)
                        .removeClass(row.__rowc.join(' '))
                        .addClass(data.DT_RowClass);
                }

                if (data.DT_RowAttr) {
                    $(tr).attr(data.DT_RowAttr);
                }

                if (data.DT_RowData) {
                    $(tr).data(data.DT_RowData);
                }
            }
        }


        /**
         * Create the HTML header for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnBuildHead(oSettings) {
            var i, ien, cell, row, column;
            var thead = oSettings.nTHead;
            var tfoot = oSettings.nTFoot;
            var createHeader = $('th, td', thead).length === 0;
            var classes = oSettings.oClasses;
            var columns = oSettings.aoColumns;

            if (createHeader) {
                row = $('<tr/>').appendTo(thead);
            }

            for (i = 0, ien = columns.length; i < ien; i++) {
                column = columns[i];
                cell = $(column.nTh).addClass(column.sClass);

                if (createHeader) {
                    cell.appendTo(row);
                }

                // 1.11 move into sorting
                if (oSettings.oFeatures.bSort) {
                    cell.addClass(column.sSortingClass);

                    if (column.bSortable !== false) {
                        cell
                            .attr('tabindex', oSettings.iTabIndex)
                            .attr('aria-controls', oSettings.sTableId);

                        _fnSortAttachListener(oSettings, column.nTh, i);
                    }
                }

                if (column.sTitle != cell[0].innerHTML) {
                    cell.html(column.sTitle);
                }

                _fnRenderer(oSettings, 'header')(
                    oSettings, cell, column, classes
                );
            }

            if (createHeader) {
                _fnDetectHeader(oSettings.aoHeader, thead);
            }

            /* ARIA role for the rows */
            $(thead).find('>tr').attr('role', 'row');

            /* Deal with the footer - add classes if required */
            $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
            $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);

            // Cache the footer cells. Note that we only take the cells from the first
            // row in the footer. If there is more than one row the user wants to
            // interact with, they need to use the table().foot() method. Note also this
            // allows cells to be used for multiple columns using colspan
            if (tfoot !== null) {
                var cells = oSettings.aoFooter[0];

                for (i = 0, ien = cells.length; i < ien; i++) {
                    column = columns[i];
                    column.nTf = cells[i].cell;

                    if (column.sClass) {
                        $(column.nTf).addClass(column.sClass);
                    }
                }
            }
        }


        /**
         * Draw the header (or footer) element based on the column visibility states. The
         * methodology here is to use the layout array from _fnDetectHeader, modified for
         * the instantaneous column visibility, to construct the new layout. The grid is
         * traversed over cell at a time in a rows x columns grid fashion, although each
         * cell insert can cover multiple elements in the grid - which is tracks using the
         * aApplied array. Cell inserts in the grid will only occur where there isn't
         * already a cell in that position.
         *  @param {object} oSettings dataTables settings object
         *  @param array {objects} aoSource Layout array from _fnDetectHeader
         *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
         *  @memberof DataTable#oApi
         */
        function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
            var i, iLen, j, jLen, k, kLen, n, nLocalTr;
            var aoLocal = [];
            var aApplied = [];
            var iColumns = oSettings.aoColumns.length;
            var iRowspan, iColspan;

            if (!aoSource) {
                return;
            }

            if (bIncludeHidden === undefined) {
                bIncludeHidden = false;
            }

            /* Make a copy of the master layout array, but without the visible columns in it */
            for (i = 0, iLen = aoSource.length; i < iLen; i++) {
                aoLocal[i] = aoSource[i].slice();
                aoLocal[i].nTr = aoSource[i].nTr;

                /* Remove any columns which are currently hidden */
                for (j = iColumns - 1; j >= 0; j--) {
                    if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
                        aoLocal[i].splice(j, 1);
                    }
                }

                /* Prep the applied array - it needs an element for each row */
                aApplied.push([]);
            }

            for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
                nLocalTr = aoLocal[i].nTr;

                /* All cells are going to be replaced, so empty out the row */
                if (nLocalTr) {
                    while ((n = nLocalTr.firstChild)) {
                        nLocalTr.removeChild(n);
                    }
                }

                for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
                    iRowspan = 1;
                    iColspan = 1;

                    /* Check to see if there is already a cell (row/colspan) covering our target
                     * insert point. If there is, then there is nothing to do.
                     */
                    if (aApplied[i][j] === undefined) {
                        nLocalTr.appendChild(aoLocal[i][j].cell);
                        aApplied[i][j] = 1;

                        /* Expand the cell to cover as many rows as needed */
                        while (aoLocal[i + iRowspan] !== undefined &&
                            aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
                            aApplied[i + iRowspan][j] = 1;
                            iRowspan++;
                        }

                        /* Expand the cell to cover as many columns as needed */
                        while (aoLocal[i][j + iColspan] !== undefined &&
                            aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
                            /* Must update the applied array over the rows for the columns */
                            for (k = 0; k < iRowspan; k++) {
                                aApplied[i + k][j + iColspan] = 1;
                            }
                            iColspan++;
                        }

                        /* Do the actual expansion in the DOM */
                        $(aoLocal[i][j].cell)
                            .attr('rowspan', iRowspan)
                            .attr('colspan', iColspan);
                    }
                }
            }
        }


        /**
         * Insert the required TR nodes into the table for display
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnDraw(oSettings) {
            /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
            var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
            if ($.inArray(false, aPreDraw) !== -1) {
                _fnProcessingDisplay(oSettings, false);
                return;
            }

            var i, iLen, n;
            var anRows = [];
            var iRowCount = 0;
            var asStripeClasses = oSettings.asStripeClasses;
            var iStripes = asStripeClasses.length;
            var iOpenRows = oSettings.aoOpenRows.length;
            var oLang = oSettings.oLanguage;
            var iInitDisplayStart = oSettings.iInitDisplayStart;
            var bServerSide = _fnDataSource(oSettings) == 'ssp';
            var aiDisplay = oSettings.aiDisplay;

            oSettings.bDrawing = true;

            /* Check and see if we have an initial draw position from state saving */
            if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
                oSettings._iDisplayStart = bServerSide ?
                    iInitDisplayStart :
                    iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
                        0 :
                        iInitDisplayStart;

                oSettings.iInitDisplayStart = -1;
            }

            var iDisplayStart = oSettings._iDisplayStart;
            var iDisplayEnd = oSettings.fnDisplayEnd();

            /* Server-side processing draw intercept */
            if (oSettings.bDeferLoading) {
                oSettings.bDeferLoading = false;
                oSettings.iDraw++;
                _fnProcessingDisplay(oSettings, false);
            }
            else if (!bServerSide) {
                oSettings.iDraw++;
            }
            else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
                return;
            }

            if (aiDisplay.length !== 0) {
                var iStart = bServerSide ? 0 : iDisplayStart;
                var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

                for (var j = iStart; j < iEnd; j++) {
                    var iDataIndex = aiDisplay[j];
                    var aoData = oSettings.aoData[iDataIndex];
                    if (aoData.nTr === null) {
                        _fnCreateTr(oSettings, iDataIndex);
                    }

                    var nRow = aoData.nTr;

                    /* Remove the old striping classes and then add the new one */
                    if (iStripes !== 0) {
                        var sStripe = asStripeClasses[iRowCount % iStripes];
                        if (aoData._sRowStripe != sStripe) {
                            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
                            aoData._sRowStripe = sStripe;
                        }
                    }

                    // Row callback functions - might want to manipulate the row
                    // iRowCount and j are not currently documented. Are they at all
                    // useful?
                    _fnCallbackFire(oSettings, 'aoRowCallback', null,
                        [nRow, aoData._aData, iRowCount, j]);

                    anRows.push(nRow);
                    iRowCount++;
                }
            }
            else {
                /* Table is empty - create a row with an empty message in it */
                var sZero = oLang.sZeroRecords;
                if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
                    sZero = oLang.sLoadingRecords;
                }
                else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
                    sZero = oLang.sEmptyTable;
                }

                anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' })
                    .append($('<td />', {
                        'valign': 'top',
                        'colSpan': _fnVisbleColumns(oSettings),
                        'class': oSettings.oClasses.sRowEmpty
                    }).html(sZero))[0];
            }

            /* Header and footer callbacks */
            _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
            _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

            _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
            _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

            var body = $(oSettings.nTBody);

            body.children().detach();
            body.append($(anRows));

            /* Call all required callback functions for the end of a draw */
            _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

            /* Draw is complete, sorting and filtering must be as well */
            oSettings.bSorted = false;
            oSettings.bFiltered = false;
            oSettings.bDrawing = false;
        }


        /**
         * Redraw the table - taking account of the various features which are enabled
         *  @param {object} oSettings dataTables settings object
         *  @param {boolean} [holdPosition] Keep the current paging position. By default
         *    the paging is reset to the first page
         *  @memberof DataTable#oApi
         */
        function _fnReDraw(settings, holdPosition) {
            var
                features = settings.oFeatures,
                sort = features.bSort,
                filter = features.bFilter;

            if (sort) {
                _fnSort(settings);
            }

            if (filter) {
                _fnFilterComplete(settings, settings.oPreviousSearch);
            }
            else {
                // No filtering, so we want to just use the display master
                settings.aiDisplay = settings.aiDisplayMaster.slice();
            }

            if (holdPosition !== true) {
                settings._iDisplayStart = 0;
            }

            // Let any modules know about the draw hold position state (used by
            // scrolling internally)
            settings._drawHold = holdPosition;

            _fnDraw(settings);

            settings._drawHold = false;
        }


        /**
         * Add the options to the page HTML for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnAddOptionsHtml(oSettings) {
            var classes = oSettings.oClasses;
            var table = $(oSettings.nTable);
            var holding = $('<div/>').insertBefore(table); // Holding element for speed
            var features = oSettings.oFeatures;

            // All DataTables are wrapped in a div
            var insert = $('<div/>', {
                id: oSettings.sTableId + '_wrapper',
                'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
            });

            oSettings.nHolding = holding[0];
            oSettings.nTableWrapper = insert[0];
            oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

            /* Loop over the user set positioning and place the elements as needed */
            var aDom = oSettings.sDom.split('');
            var featureNode, cOption, nNewNode, cNext, sAttr, j;
            for (var i = 0; i < aDom.length; i++) {
                featureNode = null;
                cOption = aDom[i];

                if (cOption == '<') {
                    /* New container div */
                    nNewNode = $('<div/>')[0];

                    /* Check to see if we should append an id and/or a class name to the container */
                    cNext = aDom[i + 1];
                    if (cNext == "'" || cNext == '"') {
                        sAttr = "";
                        j = 2;
                        while (aDom[i + j] != cNext) {
                            sAttr += aDom[i + j];
                            j++;
                        }

                        /* Replace jQuery UI constants @todo depreciated */
                        if (sAttr == "H") {
                            sAttr = classes.sJUIHeader;
                        }
                        else if (sAttr == "F") {
                            sAttr = classes.sJUIFooter;
                        }

                        /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
                         * breaks the string into parts and applies them as needed
                         */
                        if (sAttr.indexOf('.') != -1) {
                            var aSplit = sAttr.split('.');
                            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
                            nNewNode.className = aSplit[1];
                        }
                        else if (sAttr.charAt(0) == "#") {
                            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
                        }
                        else {
                            nNewNode.className = sAttr;
                        }

                        i += j; /* Move along the position array */
                    }

                    insert.append(nNewNode);
                    insert = $(nNewNode);
                }
                else if (cOption == '>') {
                    /* End container div */
                    insert = insert.parent();
                }
                // @todo Move options into their own plugins?
                else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
                    /* Length */
                    featureNode = _fnFeatureHtmlLength(oSettings);
                }
                else if (cOption == 'f' && features.bFilter) {
                    /* Filter */
                    featureNode = _fnFeatureHtmlFilter(oSettings);
                }
                else if (cOption == 'r' && features.bProcessing) {
                    /* pRocessing */
                    featureNode = _fnFeatureHtmlProcessing(oSettings);
                }
                else if (cOption == 't') {
                    /* Table */
                    featureNode = _fnFeatureHtmlTable(oSettings);
                }
                else if (cOption == 'i' && features.bInfo) {
                    /* Info */
                    featureNode = _fnFeatureHtmlInfo(oSettings);
                }
                else if (cOption == 'p' && features.bPaginate) {
                    /* Pagination */
                    featureNode = _fnFeatureHtmlPaginate(oSettings);
                }
                else if (DataTable.ext.feature.length !== 0) {
                    /* Plug-in features */
                    var aoFeatures = DataTable.ext.feature;
                    for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
                        if (cOption == aoFeatures[k].cFeature) {
                            featureNode = aoFeatures[k].fnInit(oSettings);
                            break;
                        }
                    }
                }

                /* Add to the 2D features array */
                if (featureNode) {
                    var aanFeatures = oSettings.aanFeatures;

                    if (!aanFeatures[cOption]) {
                        aanFeatures[cOption] = [];
                    }

                    aanFeatures[cOption].push(featureNode);
                    insert.append(featureNode);
                }
            }

            /* Built our DOM structure - replace the holding div with what we want */
            holding.replaceWith(insert);
            oSettings.nHolding = null;
        }


        /**
         * Use the DOM source to create up an array of header cells. The idea here is to
         * create a layout grid (array) of rows x columns, which contains a reference
         * to the cell that that point in the grid (regardless of col/rowspan), such that
         * any column / row could be removed and the new grid constructed
         *  @param array {object} aLayout Array to store the calculated layout in
         *  @param {node} nThead The header/footer element for the table
         *  @memberof DataTable#oApi
         */
        function _fnDetectHeader(aLayout, nThead) {
            var nTrs = $(nThead).children('tr');
            var nTr, nCell;
            var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
            var bUnique;
            var fnShiftCol = function (a, i, j) {
                var k = a[i];
                while (k[j]) {
                    j++;
                }
                return j;
            };

            aLayout.splice(0, aLayout.length);

            /* We know how many rows there are in the layout - so prep it */
            for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                aLayout.push([]);
            }

            /* Calculate a layout array */
            for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                nTr = nTrs[i];
                iColumn = 0;

                /* For every cell in the row... */
                nCell = nTr.firstChild;
                while (nCell) {
                    if (nCell.nodeName.toUpperCase() == "TD" ||
                        nCell.nodeName.toUpperCase() == "TH") {
                        /* Get the col and rowspan attributes from the DOM and sanitise them */
                        iColspan = nCell.getAttribute('colspan') * 1;
                        iRowspan = nCell.getAttribute('rowspan') * 1;
                        iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
                        iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;

                        /* There might be colspan cells already in this row, so shift our target
                         * accordingly
                         */
                        iColShifted = fnShiftCol(aLayout, i, iColumn);

                        /* Cache calculation for unique columns */
                        bUnique = iColspan === 1 ? true : false;

                        /* If there is col / rowspan, copy the information into the layout grid */
                        for (l = 0; l < iColspan; l++) {
                            for (k = 0; k < iRowspan; k++) {
                                aLayout[i + k][iColShifted + l] = {
                                    "cell": nCell,
                                    "unique": bUnique
                                };
                                aLayout[i + k].nTr = nTr;
                            }
                        }
                    }
                    nCell = nCell.nextSibling;
                }
            }
        }


        /**
         * Get an array of unique th elements, one for each column
         *  @param {object} oSettings dataTables settings object
         *  @param {node} nHeader automatically detect the layout from this node - optional
         *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
         *  @returns array {node} aReturn list of unique th's
         *  @memberof DataTable#oApi
         */
        function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
            var aReturn = [];
            if (!aLayout) {
                aLayout = oSettings.aoHeader;
                if (nHeader) {
                    aLayout = [];
                    _fnDetectHeader(aLayout, nHeader);
                }
            }

            for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
                for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
                    if (aLayout[i][j].unique &&
                        (!aReturn[j] || !oSettings.bSortCellsTop)) {
                        aReturn[j] = aLayout[i][j].cell;
                    }
                }
            }

            return aReturn;
        }

        /**
         * Create an Ajax call based on the table's settings, taking into account that
         * parameters can have multiple forms, and backwards compatibility.
         *
         * @param {object} oSettings dataTables settings object
         * @param {array} data Data to send to the server, required by
         *     DataTables - may be augmented by developer callbacks
         * @param {function} fn Callback function to run when data is obtained
         */
        function _fnBuildAjax(oSettings, data, fn) {
            // Compatibility with 1.9-, allow fnServerData and event to manipulate
            _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);

            // Convert to object based for 1.10+ if using the old array scheme which can
            // come from server-side processing or serverParams
            if (data && $.isArray(data)) {
                var tmp = {};
                var rbracket = /(.*?)\[\]$/;

                $.each(data, function (key, val) {
                    var match = val.name.match(rbracket);

                    if (match) {
                        // Support for arrays
                        var name = match[0];

                        if (!tmp[name]) {
                            tmp[name] = [];
                        }
                        tmp[name].push(val.value);
                    }
                    else {
                        tmp[val.name] = val.value;
                    }
                });
                data = tmp;
            }

            var ajaxData;
            var ajax = oSettings.ajax;
            var instance = oSettings.oInstance;
            var callback = function (json) {
                _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);
                fn(json);
            };

            if ($.isPlainObject(ajax) && ajax.data) {
                ajaxData = ajax.data;

                var newData = $.isFunction(ajaxData) ?
                    ajaxData(data, oSettings) :  // fn can manipulate data or return
                    ajaxData;                      // an object object or array to merge

                // If the function returned something, use that alone
                data = $.isFunction(ajaxData) && newData ?
                    newData :
                    $.extend(true, data, newData);

                // Remove the data property as we've resolved it already and don't want
                // jQuery to do it again (it is restored at the end of the function)
                delete ajax.data;
            }

            var baseAjax = {
                "data": data,
                "success": function (json) {
                    var error = json.error || json.sError;
                    if (error) {
                        _fnLog(oSettings, 0, error);
                    }

                    oSettings.json = json;
                    callback(json);
                },
                "dataType": "json",
                "cache": false,
                "type": oSettings.sServerMethod,
                "error": function (xhr, error, thrown) {
                    var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

                    if ($.inArray(true, ret) === -1) {
                        if (error == "parsererror") {
                            _fnLog(oSettings, 0, 'Invalid JSON response', 1);
                        }
                        else if (xhr.readyState === 4) {
                            _fnLog(oSettings, 0, 'Ajax error', 7);
                        }
                    }

                    _fnProcessingDisplay(oSettings, false);
                }
            };

            // Store the data submitted for the API
            oSettings.oAjaxData = data;

            // Allow plug-ins and external processes to modify the data
            _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

            if (oSettings.fnServerData) {
                // DataTables 1.9- compatibility
                oSettings.fnServerData.call(instance,
                    oSettings.sAjaxSource,
                    $.map(data, function (val, key) { // Need to convert back to 1.9 trad format
                        return { name: key, value: val };
                    }),
                    callback,
                    oSettings
                );
            }
            else if (oSettings.sAjaxSource || typeof ajax === 'string') {
                // DataTables 1.9- compatibility
                oSettings.jqXHR = $.ajax($.extend(baseAjax, {
                    url: ajax || oSettings.sAjaxSource
                }));
            }
            else if ($.isFunction(ajax)) {
                // Is a function - let the caller define what needs to be done
                oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
            }
            else {
                // Object to extend the base settings
                oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));

                // Restore for next time around
                ajax.data = ajaxData;
            }
        }


        /**
         * Update the table using an Ajax call
         *  @param {object} settings dataTables settings object
         *  @returns {boolean} Block the table drawing or not
         *  @memberof DataTable#oApi
         */
        function _fnAjaxUpdate(settings) {
            if (settings.bAjaxDataGet) {
                settings.iDraw++;
                _fnProcessingDisplay(settings, true);

                _fnBuildAjax(
                    settings,
                    _fnAjaxParameters(settings),
                    function (json) {
                        _fnAjaxUpdateDraw(settings, json);
                    }
                );

                return false;
            }
            return true;
        }


        /**
         * Build up the parameters in an object needed for a server-side processing
         * request. Note that this is basically done twice, is different ways - a modern
         * method which is used by default in DataTables 1.10 which uses objects and
         * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
         * the sAjaxSource option is used in the initialisation, or the legacyAjax
         * option is set.
         *  @param {object} oSettings dataTables settings object
         *  @returns {bool} block the table drawing or not
         *  @memberof DataTable#oApi
         */
        function _fnAjaxParameters(settings) {
            var
                columns = settings.aoColumns,
                columnCount = columns.length,
                features = settings.oFeatures,
                preSearch = settings.oPreviousSearch,
                preColSearch = settings.aoPreSearchCols,
                i, data = [], dataProp, column, columnSearch,
                sort = _fnSortFlatten(settings),
                displayStart = settings._iDisplayStart,
                displayLength = features.bPaginate !== false ?
                    settings._iDisplayLength :
                    -1;

            var param = function (name, value) {
                data.push({ 'name': name, 'value': value });
            };

            // DataTables 1.9- compatible method
            param('sEcho', settings.iDraw);
            param('iColumns', columnCount);
            param('sColumns', _pluck(columns, 'sName').join(','));
            param('iDisplayStart', displayStart);
            param('iDisplayLength', displayLength);

            // DataTables 1.10+ method
            var d = {
                draw: settings.iDraw,
                columns: [],
                order: [],
                start: displayStart,
                length: displayLength,
                search: {
                    value: preSearch.sSearch,
                    regex: preSearch.bRegex
                }
            };

            for (i = 0; i < columnCount; i++) {
                column = columns[i];
                columnSearch = preColSearch[i];
                dataProp = typeof column.mData == "function" ? 'function' : column.mData;

                d.columns.push({
                    data: dataProp,
                    name: column.sName,
                    searchable: column.bSearchable,
                    orderable: column.bSortable,
                    search: {
                        value: columnSearch.sSearch,
                        regex: columnSearch.bRegex
                    }
                });

                param("mDataProp_" + i, dataProp);

                if (features.bFilter) {
                    param('sSearch_' + i, columnSearch.sSearch);
                    param('bRegex_' + i, columnSearch.bRegex);
                    param('bSearchable_' + i, column.bSearchable);
                }

                if (features.bSort) {
                    param('bSortable_' + i, column.bSortable);
                }
            }

            if (features.bFilter) {
                param('sSearch', preSearch.sSearch);
                param('bRegex', preSearch.bRegex);
            }

            if (features.bSort) {
                $.each(sort, function (i, val) {
                    d.order.push({ column: val.col, dir: val.dir });

                    param('iSortCol_' + i, val.col);
                    param('sSortDir_' + i, val.dir);
                });

                param('iSortingCols', sort.length);
            }

            // If the legacy.ajax parameter is null, then we automatically decide which
            // form to use, based on sAjaxSource
            var legacy = DataTable.ext.legacy.ajax;
            if (legacy === null) {
                return settings.sAjaxSource ? data : d;
            }

            // Otherwise, if legacy has been specified then we use that to decide on the
            // form
            return legacy ? data : d;
        }


        /**
         * Data the data from the server (nuking the old) and redraw the table
         *  @param {object} oSettings dataTables settings object
         *  @param {object} json json data return from the server.
         *  @param {string} json.sEcho Tracking flag for DataTables to match requests
         *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
         *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
         *  @param {array} json.aaData The data to display on this page
         *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
         *  @memberof DataTable#oApi
         */
        function _fnAjaxUpdateDraw(settings, json) {
            // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
            // Support both
            var compat = function (old, modern) {
                return json[old] !== undefined ? json[old] : json[modern];
            };

            var data = _fnAjaxDataSrc(settings, json);
            var draw = compat('sEcho', 'draw');
            var recordsTotal = compat('iTotalRecords', 'recordsTotal');
            var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

            if (draw) {
                // Protect against out of sequence returns
                if (draw * 1 < settings.iDraw) {
                    return;
                }
                settings.iDraw = draw * 1;
            }

            _fnClearTable(settings);
            settings._iRecordsTotal = parseInt(recordsTotal, 10);
            settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

            for (var i = 0, ien = data.length; i < ien; i++) {
                _fnAddData(settings, data[i]);
            }
            settings.aiDisplay = settings.aiDisplayMaster.slice();

            settings.bAjaxDataGet = false;
            _fnDraw(settings);

            if (!settings._bInitComplete) {
                _fnInitComplete(settings, json);
            }

            settings.bAjaxDataGet = true;
            _fnProcessingDisplay(settings, false);
        }


        /**
         * Get the data from the JSON data source to use for drawing a table. Using
         * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
         * source object, or from a processing function.
         *  @param {object} oSettings dataTables settings object
         *  @param  {object} json Data source object / array from the server
         *  @return {array} Array of data to use
         */
        function _fnAjaxDataSrc(oSettings, json) {
            var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ?
                oSettings.ajax.dataSrc :
                oSettings.sAjaxDataProp; // Compatibility with 1.9-.

            // Compatibility with 1.9-. In order to read from aaData, check if the
            // default has been changed, if not, check for aaData
            if (dataSrc === 'data') {
                return json.aaData || json[dataSrc];
            }

            return dataSrc !== "" ?
                _fnGetObjectDataFn(dataSrc)(json) :
                json;
        }

        /**
         * Generate the node required for filtering text
         *  @returns {node} Filter control element
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlFilter(settings) {
            var classes = settings.oClasses;
            var tableId = settings.sTableId;
            var language = settings.oLanguage;
            var previousSearch = settings.oPreviousSearch;
            var features = settings.aanFeatures;
            var input = '<input type="search" class="' + classes.sFilterInput + '"/>';

            var str = language.sSearch;
            str = str.match(/_INPUT_/) ?
                str.replace('_INPUT_', input) :
                str + input;

            var filter = $('<div/>', {
                'id': !features.f ? tableId + '_filter' : null,
                'class': classes.sFilter
            })
                .append($('<label/>').append(str));

            var searchFn = function () {
                /* Update all other filter input elements for the new display */
                var n = features.f;
                var val = !this.value ? "" : this.value; // mental IE8 fix :-(

                /* Now do the filter */
                if (val != previousSearch.sSearch) {
                    _fnFilterComplete(settings, {
                        "sSearch": val,
                        "bRegex": previousSearch.bRegex,
                        "bSmart": previousSearch.bSmart,
                        "bCaseInsensitive": previousSearch.bCaseInsensitive
                    });

                    // Need to redraw, without resorting
                    settings._iDisplayStart = 0;
                    _fnDraw(settings);
                }
            };

            var searchDelay = settings.searchDelay !== null ?
                settings.searchDelay :
                _fnDataSource(settings) === 'ssp' ?
                    400 :
                    0;

            var jqFilter = $('input', filter)
                .val(previousSearch.sSearch)
                .attr('placeholder', language.sSearchPlaceholder)
                .on(
                    'keyup.DT search.DT input.DT paste.DT cut.DT',
                    searchDelay ?
                        _fnThrottle(searchFn, searchDelay) :
                        searchFn
                )
                .on('keypress.DT', function (e) {
                    /* Prevent form submission */
                    if (e.keyCode == 13) {
                        return false;
                    }
                })
                .attr('aria-controls', tableId);

            // Update the input elements whenever the table is filtered
            $(settings.nTable).on('search.dt.DT', function (ev, s) {
                if (settings === s) {
                    // IE9 throws an 'unknown error' if document.activeElement is used
                    // inside an iframe or frame...
                    try {
                        if (jqFilter[0] !== document.activeElement) {
                            jqFilter.val(previousSearch.sSearch);
                        }
                    }
                    catch (e) { }
                }
            });

            return filter[0];
        }


        /**
         * Filter the table using both the global filter and column based filtering
         *  @param {object} oSettings dataTables settings object
         *  @param {object} oSearch search information
         *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
         *  @memberof DataTable#oApi
         */
        function _fnFilterComplete(oSettings, oInput, iForce) {
            var oPrevSearch = oSettings.oPreviousSearch;
            var aoPrevSearch = oSettings.aoPreSearchCols;
            var fnSaveFilter = function (oFilter) {
                /* Save the filtering values */
                oPrevSearch.sSearch = oFilter.sSearch;
                oPrevSearch.bRegex = oFilter.bRegex;
                oPrevSearch.bSmart = oFilter.bSmart;
                oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
            };
            var fnRegex = function (o) {
                // Backwards compatibility with the bEscapeRegex option
                return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
            };

            // Resolve any column types that are unknown due to addition or invalidation
            // @todo As per sort - can this be moved into an event handler?
            _fnColumnTypes(oSettings);

            /* In server-side processing all filtering is done by the server, so no point hanging around here */
            if (_fnDataSource(oSettings) != 'ssp') {
                /* Global filter */
                _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
                fnSaveFilter(oInput);

                /* Now do the individual column filter */
                for (var i = 0; i < aoPrevSearch.length; i++) {
                    _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
                        aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
                }

                /* Custom filtering */
                _fnFilterCustom(oSettings);
            }
            else {
                fnSaveFilter(oInput);
            }

            /* Tell the draw function we have been filtering */
            oSettings.bFiltered = true;
            _fnCallbackFire(oSettings, null, 'search', [oSettings]);
        }


        /**
         * Apply custom filtering functions
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnFilterCustom(settings) {
            var filters = DataTable.ext.search;
            var displayRows = settings.aiDisplay;
            var row, rowIdx;

            for (var i = 0, ien = filters.length; i < ien; i++) {
                var rows = [];

                // Loop over each row and see if it should be included
                for (var j = 0, jen = displayRows.length; j < jen; j++) {
                    rowIdx = displayRows[j];
                    row = settings.aoData[rowIdx];

                    if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
                        rows.push(rowIdx);
                    }
                }

                // So the array reference doesn't break set the results into the
                // existing array
                displayRows.length = 0;
                $.merge(displayRows, rows);
            }
        }


        /**
         * Filter the table on a per-column basis
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sInput string to filter on
         *  @param {int} iColumn column to filter
         *  @param {bool} bRegex treat search string as a regular expression or not
         *  @param {bool} bSmart use smart filtering or not
         *  @param {bool} bCaseInsensitive Do case insenstive matching or not
         *  @memberof DataTable#oApi
         */
        function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
            if (searchStr === '') {
                return;
            }

            var data;
            var out = [];
            var display = settings.aiDisplay;
            var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

            for (var i = 0; i < display.length; i++) {
                data = settings.aoData[display[i]]._aFilterData[colIdx];

                if (rpSearch.test(data)) {
                    out.push(display[i]);
                }
            }

            settings.aiDisplay = out;
        }


        /**
         * Filter the data table based on user input and draw the table
         *  @param {object} settings dataTables settings object
         *  @param {string} input string to filter on
         *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
         *  @param {bool} regex treat as a regular expression or not
         *  @param {bool} smart perform smart filtering or not
         *  @param {bool} caseInsensitive Do case insenstive matching or not
         *  @memberof DataTable#oApi
         */
        function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
            var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
            var prevSearch = settings.oPreviousSearch.sSearch;
            var displayMaster = settings.aiDisplayMaster;
            var display, invalidated, i;
            var filtered = [];

            // Need to take account of custom filtering functions - always filter
            if (DataTable.ext.search.length !== 0) {
                force = true;
            }

            // Check if any of the rows were invalidated
            invalidated = _fnFilterData(settings);

            // If the input is blank - we just want the full data set
            if (input.length <= 0) {
                settings.aiDisplay = displayMaster.slice();
            }
            else {
                // New search - start from the master array
                if (invalidated ||
                    force ||
                    prevSearch.length > input.length ||
                    input.indexOf(prevSearch) !== 0 ||
                    settings.bSorted // On resort, the display master needs to be
                    // re-filtered since indexes will have changed
                ) {
                    settings.aiDisplay = displayMaster.slice();
                }

                // Search the display array
                display = settings.aiDisplay;

                for (i = 0; i < display.length; i++) {
                    if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
                        filtered.push(display[i]);
                    }
                }

                settings.aiDisplay = filtered;
            }
        }


        /**
         * Build a regular expression object suitable for searching a table
         *  @param {string} sSearch string to search for
         *  @param {bool} bRegex treat as a regular expression or not
         *  @param {bool} bSmart perform smart filtering or not
         *  @param {bool} bCaseInsensitive Do case insensitive matching or not
         *  @returns {RegExp} constructed object
         *  @memberof DataTable#oApi
         */
        function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
            search = regex ?
                search :
                _fnEscapeRegex(search);

            if (smart) {
                /* For smart filtering we want to allow the search to work regardless of
                 * word order. We also want double quoted text to be preserved, so word
                 * order is important - a la google. So this is what we want to
                 * generate:
                 * 
                 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
                 */
                var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
                    if (word.charAt(0) === '"') {
                        var m = word.match(/^"(.*)"$/);
                        word = m ? m[1] : word;
                    }

                    return word.replace('"', '');
                });

                search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
            }

            return new RegExp(search, caseInsensitive ? 'i' : '');
        }


        /**
         * Escape a string such that it can be used in a regular expression
         *  @param {string} sVal string to escape
         *  @returns {string} escaped string
         *  @memberof DataTable#oApi
         */
        var _fnEscapeRegex = DataTable.util.escapeRegex;

        var __filter_div = $('<div>')[0];
        var __filter_div_textContent = __filter_div.textContent !== undefined;

        // Update the filtering data for each row if needed (by invalidation or first run)
        function _fnFilterData(settings) {
            var columns = settings.aoColumns;
            var column;
            var i, j, ien, jen, filterData, cellData, row;
            var fomatters = DataTable.ext.type.search;
            var wasInvalidated = false;

            for (i = 0, ien = settings.aoData.length; i < ien; i++) {
                row = settings.aoData[i];

                if (!row._aFilterData) {
                    filterData = [];

                    for (j = 0, jen = columns.length; j < jen; j++) {
                        column = columns[j];

                        if (column.bSearchable) {
                            cellData = _fnGetCellData(settings, i, j, 'filter');

                            if (fomatters[column.sType]) {
                                cellData = fomatters[column.sType](cellData);
                            }

                            // Search in DataTables 1.10 is string based. In 1.11 this
                            // should be altered to also allow strict type checking.
                            if (cellData === null) {
                                cellData = '';
                            }

                            if (typeof cellData !== 'string' && cellData.toString) {
                                cellData = cellData.toString();
                            }
                        }
                        else {
                            cellData = '';
                        }

                        // If it looks like there is an HTML entity in the string,
                        // attempt to decode it so sorting works as expected. Note that
                        // we could use a single line of jQuery to do this, but the DOM
                        // method used here is much faster http://jsperf.com/html-decode
                        if (cellData.indexOf && cellData.indexOf('&') !== -1) {
                            __filter_div.innerHTML = cellData;
                            cellData = __filter_div_textContent ?
                                __filter_div.textContent :
                                __filter_div.innerText;
                        }

                        if (cellData.replace) {
                            cellData = cellData.replace(/[\r\n]/g, '');
                        }

                        filterData.push(cellData);
                    }

                    row._aFilterData = filterData;
                    row._sFilterRow = filterData.join('  ');
                    wasInvalidated = true;
                }
            }

            return wasInvalidated;
        }


        /**
         * Convert from the internal Hungarian notation to camelCase for external
         * interaction
         *  @param {object} obj Object to convert
         *  @returns {object} Inverted object
         *  @memberof DataTable#oApi
         */
        function _fnSearchToCamel(obj) {
            return {
                search: obj.sSearch,
                smart: obj.bSmart,
                regex: obj.bRegex,
                caseInsensitive: obj.bCaseInsensitive
            };
        }



        /**
         * Convert from camelCase notation to the internal Hungarian. We could use the
         * Hungarian convert function here, but this is cleaner
         *  @param {object} obj Object to convert
         *  @returns {object} Inverted object
         *  @memberof DataTable#oApi
         */
        function _fnSearchToHung(obj) {
            return {
                sSearch: obj.search,
                bSmart: obj.smart,
                bRegex: obj.regex,
                bCaseInsensitive: obj.caseInsensitive
            };
        }

        /**
         * Generate the node required for the info display
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Information element
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlInfo(settings) {
            var
                tid = settings.sTableId,
                nodes = settings.aanFeatures.i,
                n = $('<div/>', {
                    'class': settings.oClasses.sInfo,
                    'id': !nodes ? tid + '_info' : null
                });

            if (!nodes) {
                // Update display on each draw
                settings.aoDrawCallback.push({
                    "fn": _fnUpdateInfo,
                    "sName": "information"
                });

                n
                    .attr('role', 'status')
                    .attr('aria-live', 'polite');

                // Table is described by our info div
                $(settings.nTable).attr('aria-describedby', tid + '_info');
            }

            return n[0];
        }


        /**
         * Update the information elements in the display
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnUpdateInfo(settings) {
            /* Show information about the table */
            var nodes = settings.aanFeatures.i;
            if (nodes.length === 0) {
                return;
            }

            var
                lang = settings.oLanguage,
                start = settings._iDisplayStart + 1,
                end = settings.fnDisplayEnd(),
                max = settings.fnRecordsTotal(),
                total = settings.fnRecordsDisplay(),
                out = total ?
                    lang.sInfo :
                    lang.sInfoEmpty;

            if (total !== max) {
                /* Record set after filtering */
                out += ' ' + lang.sInfoFiltered;
            }

            // Convert the macros
            out += lang.sInfoPostFix;
            out = _fnInfoMacros(settings, out);

            var callback = lang.fnInfoCallback;
            if (callback !== null) {
                out = callback.call(settings.oInstance,
                    settings, start, end, max, total, out
                );
            }

            $(nodes).html(out);
        }


        function _fnInfoMacros(settings, str) {
            // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
            // internally
            var
                formatter = settings.fnFormatNumber,
                start = settings._iDisplayStart + 1,
                len = settings._iDisplayLength,
                vis = settings.fnRecordsDisplay(),
                all = len === -1;

            return str.
                replace(/_START_/g, formatter.call(settings, start)).
                replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).
                replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).
                replace(/_TOTAL_/g, formatter.call(settings, vis)).
                replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).
                replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
        }



        /**
         * Draw the table for the first time, adding all required features
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnInitialise(settings) {
            var i, iLen, iAjaxStart = settings.iInitDisplayStart;
            var columns = settings.aoColumns, column;
            var features = settings.oFeatures;
            var deferLoading = settings.bDeferLoading; // value modified by the draw

            /* Ensure that the table data is fully initialised */
            if (!settings.bInitialised) {
                setTimeout(function () { _fnInitialise(settings); }, 200);
                return;
            }

            /* Show the display HTML options */
            _fnAddOptionsHtml(settings);

            /* Build and draw the header / footer for the table */
            _fnBuildHead(settings);
            _fnDrawHead(settings, settings.aoHeader);
            _fnDrawHead(settings, settings.aoFooter);

            /* Okay to show that something is going on now */
            _fnProcessingDisplay(settings, true);

            /* Calculate sizes for columns */
            if (features.bAutoWidth) {
                _fnCalculateColumnWidths(settings);
            }

            for (i = 0, iLen = columns.length; i < iLen; i++) {
                column = columns[i];

                if (column.sWidth) {
                    column.nTh.style.width = _fnStringToCss(column.sWidth);
                }
            }

            _fnCallbackFire(settings, null, 'preInit', [settings]);

            // If there is default sorting required - let's do it. The sort function
            // will do the drawing for us. Otherwise we draw the table regardless of the
            // Ajax source - this allows the table to look initialised for Ajax sourcing
            // data (show 'loading' message possibly)
            _fnReDraw(settings);

            // Server-side processing init complete is done by _fnAjaxUpdateDraw
            var dataSrc = _fnDataSource(settings);
            if (dataSrc != 'ssp' || deferLoading) {
                // if there is an ajax source load the data
                if (dataSrc == 'ajax') {
                    _fnBuildAjax(settings, [], function (json) {
                        var aData = _fnAjaxDataSrc(settings, json);

                        // Got the data - add it to the table
                        for (i = 0; i < aData.length; i++) {
                            _fnAddData(settings, aData[i]);
                        }

                        // Reset the init display for cookie saving. We've already done
                        // a filter, and therefore cleared it before. So we need to make
                        // it appear 'fresh'
                        settings.iInitDisplayStart = iAjaxStart;

                        _fnReDraw(settings);

                        _fnProcessingDisplay(settings, false);
                        _fnInitComplete(settings, json);
                    }, settings);
                }
                else {
                    _fnProcessingDisplay(settings, false);
                    _fnInitComplete(settings);
                }
            }
        }


        /**
         * Draw the table for the first time, adding all required features
         *  @param {object} oSettings dataTables settings object
         *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
         *    with client-side processing (optional)
         *  @memberof DataTable#oApi
         */
        function _fnInitComplete(settings, json) {
            settings._bInitComplete = true;

            // When data was added after the initialisation (data or Ajax) we need to
            // calculate the column sizing
            if (json || settings.oInit.aaData) {
                _fnAdjustColumnSizing(settings);
            }

            _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);
            _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
        }


        function _fnLengthChange(settings, val) {
            var len = parseInt(val, 10);
            settings._iDisplayLength = len;

            _fnLengthOverflow(settings);

            // Fire length change event
            _fnCallbackFire(settings, null, 'length', [settings, len]);
        }


        /**
         * Generate the node required for user display length changing
         *  @param {object} settings dataTables settings object
         *  @returns {node} Display length feature node
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlLength(settings) {
            var
                classes = settings.oClasses,
                tableId = settings.sTableId,
                menu = settings.aLengthMenu,
                d2 = $.isArray(menu[0]),
                lengths = d2 ? menu[0] : menu,
                language = d2 ? menu[1] : menu;

            var select = $('<select/>', {
                'name': tableId + '_length',
                'aria-controls': tableId,
                'class': classes.sLengthSelect
            });

            for (var i = 0, ien = lengths.length; i < ien; i++) {
                select[0][i] = new Option(
                    typeof language[i] === 'number' ?
                        settings.fnFormatNumber(language[i]) :
                        language[i],
                    lengths[i]
                );
            }

            var div = $('<div><label/></div>').addClass(classes.sLength);
            if (!settings.aanFeatures.l) {
                div[0].id = tableId + '_length';
            }

            div.children().append(
                settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)
            );

            // Can't use `select` variable as user might provide their own and the
            // reference is broken by the use of outerHTML
            $('select', div)
                .val(settings._iDisplayLength)
                .on('change.DT', function (e) {
                    _fnLengthChange(settings, $(this).val());
                    _fnDraw(settings);
                });

            // Update node value whenever anything changes the table's length
            $(settings.nTable).on('length.dt.DT', function (e, s, len) {
                if (settings === s) {
                    $('select', div).val(len);
                }
            });

            return div[0];
        }



        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Note that most of the paging logic is done in
         * DataTable.ext.pager
         */

        /**
         * Generate the node required for default pagination
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Pagination feature node
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlPaginate(settings) {
            var
                type = settings.sPaginationType,
                plugin = DataTable.ext.pager[type],
                modern = typeof plugin === 'function',
                redraw = function (settings) {
                    _fnDraw(settings);
                },
                node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
                features = settings.aanFeatures;

            if (!modern) {
                plugin.fnInit(settings, node, redraw);
            }

            /* Add a draw callback for the pagination on first instance, to update the paging display */
            if (!features.p) {
                node.id = settings.sTableId + '_paginate';

                settings.aoDrawCallback.push({
                    "fn": function (settings) {
                        if (modern) {
                            var
                                start = settings._iDisplayStart,
                                len = settings._iDisplayLength,
                                visRecords = settings.fnRecordsDisplay(),
                                all = len === -1,
                                page = all ? 0 : Math.ceil(start / len),
                                pages = all ? 1 : Math.ceil(visRecords / len),
                                buttons = plugin(page, pages),
                                i, ien;

                            for (i = 0, ien = features.p.length; i < ien; i++) {
                                _fnRenderer(settings, 'pageButton')(
                                    settings, features.p[i], i, buttons, page, pages
                                );
                            }
                        }
                        else {
                            plugin.fnUpdate(settings, redraw);
                        }
                    },
                    "sName": "pagination"
                });
            }

            return node;
        }


        /**
         * Alter the display settings to change the page
         *  @param {object} settings DataTables settings object
         *  @param {string|int} action Paging action to take: "first", "previous",
         *    "next" or "last" or page number to jump to (integer)
         *  @param [bool] redraw Automatically draw the update or not
         *  @returns {bool} true page has changed, false - no change
         *  @memberof DataTable#oApi
         */
        function _fnPageChange(settings, action, redraw) {
            var
                start = settings._iDisplayStart,
                len = settings._iDisplayLength,
                records = settings.fnRecordsDisplay();

            if (records === 0 || len === -1) {
                start = 0;
            }
            else if (typeof action === "number") {
                start = action * len;

                if (start > records) {
                    start = 0;
                }
            }
            else if (action == "first") {
                start = 0;
            }
            else if (action == "previous") {
                start = len >= 0 ?
                    start - len :
                    0;

                if (start < 0) {
                    start = 0;
                }
            }
            else if (action == "next") {
                if (start + len < records) {
                    start += len;
                }
            }
            else if (action == "last") {
                start = Math.floor((records - 1) / len) * len;
            }
            else {
                _fnLog(settings, 0, "Unknown paging action: " + action, 5);
            }

            var changed = settings._iDisplayStart !== start;
            settings._iDisplayStart = start;

            if (changed) {
                _fnCallbackFire(settings, null, 'page', [settings]);

                if (redraw) {
                    _fnDraw(settings);
                }
            }

            return changed;
        }



        /**
         * Generate the node required for the processing node
         *  @param {object} settings dataTables settings object
         *  @returns {node} Processing element
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlProcessing(settings) {
            return $('<div/>', {
                'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
                'class': settings.oClasses.sProcessing
            })
                .html(settings.oLanguage.sProcessing)
                .insertBefore(settings.nTable)[0];
        }


        /**
         * Display or hide the processing indicator
         *  @param {object} settings dataTables settings object
         *  @param {bool} show Show the processing indicator (true) or not (false)
         *  @memberof DataTable#oApi
         */
        function _fnProcessingDisplay(settings, show) {
            if (settings.oFeatures.bProcessing) {
                $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
            }

            _fnCallbackFire(settings, null, 'processing', [settings, show]);
        }

        /**
         * Add any control elements for the table - specifically scrolling
         *  @param {object} settings dataTables settings object
         *  @returns {node} Node to add to the DOM
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlTable(settings) {
            var table = $(settings.nTable);

            // Add the ARIA grid role to the table
            table.attr('role', 'grid');

            // Scrolling from here on in
            var scroll = settings.oScroll;

            if (scroll.sX === '' && scroll.sY === '') {
                return settings.nTable;
            }

            var scrollX = scroll.sX;
            var scrollY = scroll.sY;
            var classes = settings.oClasses;
            var caption = table.children('caption');
            var captionSide = caption.length ? caption[0]._captionSide : null;
            var headerClone = $(table[0].cloneNode(false));
            var footerClone = $(table[0].cloneNode(false));
            var footer = table.children('tfoot');
            var _div = '<div/>';
            var size = function (s) {
                return !s ? null : _fnStringToCss(s);
            };

            if (!footer.length) {
                footer = null;
            }

            /*
             * The HTML structure that we want to generate in this function is:
             *  div - scroller
             *    div - scroll head
             *      div - scroll head inner
             *        table - scroll head table
             *          thead - thead
             *    div - scroll body
             *      table - table (master table)
             *        thead - thead clone for sizing
             *        tbody - tbody
             *    div - scroll foot
             *      div - scroll foot inner
             *        table - scroll foot table
             *          tfoot - tfoot
             */
            var scroller = $(_div, { 'class': classes.sScrollWrapper })
                .append(
                    $(_div, { 'class': classes.sScrollHead })
                        .css({
                            overflow: 'hidden',
                            position: 'relative',
                            border: 0,
                            width: scrollX ? size(scrollX) : '100%'
                        })
                        .append(
                            $(_div, { 'class': classes.sScrollHeadInner })
                                .css({
                                    'box-sizing': 'content-box',
                                    width: scroll.sXInner || '100%'
                                })
                                .append(
                                    headerClone
                                        .removeAttr('id')
                                        .css('margin-left', 0)
                                        .append(captionSide === 'top' ? caption : null)
                                        .append(
                                            table.children('thead')
                                        )
                                )
                        )
                )
                .append(
                    $(_div, { 'class': classes.sScrollBody })
                        .css({
                            position: 'relative',
                            overflow: 'auto',
                            width: size(scrollX)
                        })
                        .append(table)
                );

            if (footer) {
                scroller.append(
                    $(_div, { 'class': classes.sScrollFoot })
                        .css({
                            overflow: 'hidden',
                            border: 0,
                            width: scrollX ? size(scrollX) : '100%'
                        })
                        .append(
                            $(_div, { 'class': classes.sScrollFootInner })
                                .append(
                                    footerClone
                                        .removeAttr('id')
                                        .css('margin-left', 0)
                                        .append(captionSide === 'bottom' ? caption : null)
                                        .append(
                                            table.children('tfoot')
                                        )
                                )
                        )
                );
            }

            var children = scroller.children();
            var scrollHead = children[0];
            var scrollBody = children[1];
            var scrollFoot = footer ? children[2] : null;

            // When the body is scrolled, then we also want to scroll the headers
            if (scrollX) {
                $(scrollBody).on('scroll.DT', function (e) {
                    var scrollLeft = this.scrollLeft;

                    scrollHead.scrollLeft = scrollLeft;

                    if (footer) {
                        scrollFoot.scrollLeft = scrollLeft;
                    }
                });
            }

            $(scrollBody).css(
                scrollY && scroll.bCollapse ? 'max-height' : 'height',
                scrollY
            );

            settings.nScrollHead = scrollHead;
            settings.nScrollBody = scrollBody;
            settings.nScrollFoot = scrollFoot;

            // On redraw - align columns
            settings.aoDrawCallback.push({
                "fn": _fnScrollDraw,
                "sName": "scrolling"
            });

            return scroller[0];
        }



        /**
         * Update the header, footer and body tables for resizing - i.e. column
         * alignment.
         *
         * Welcome to the most horrible function DataTables. The process that this
         * function follows is basically:
         *   1. Re-create the table inside the scrolling div
         *   2. Take live measurements from the DOM
         *   3. Apply the measurements to align the columns
         *   4. Clean up
         *
         *  @param {object} settings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnScrollDraw(settings) {
            // Given that this is such a monster function, a lot of variables are use
            // to try and keep the minimised size as small as possible
            var
                scroll = settings.oScroll,
                scrollX = scroll.sX,
                scrollXInner = scroll.sXInner,
                scrollY = scroll.sY,
                barWidth = scroll.iBarWidth,
                divHeader = $(settings.nScrollHead),
                divHeaderStyle = divHeader[0].style,
                divHeaderInner = divHeader.children('div'),
                divHeaderInnerStyle = divHeaderInner[0].style,
                divHeaderTable = divHeaderInner.children('table'),
                divBodyEl = settings.nScrollBody,
                divBody = $(divBodyEl),
                divBodyStyle = divBodyEl.style,
                divFooter = $(settings.nScrollFoot),
                divFooterInner = divFooter.children('div'),
                divFooterTable = divFooterInner.children('table'),
                header = $(settings.nTHead),
                table = $(settings.nTable),
                tableEl = table[0],
                tableStyle = tableEl.style,
                footer = settings.nTFoot ? $(settings.nTFoot) : null,
                browser = settings.oBrowser,
                ie67 = browser.bScrollOversize,
                dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
                headerTrgEls, footerTrgEls,
                headerSrcEls, footerSrcEls,
                headerCopy, footerCopy,
                headerWidths = [], footerWidths = [],
                headerContent = [], footerContent = [],
                idx, correction, sanityWidth,
                zeroOut = function (nSizer) {
                    var style = nSizer.style;
                    style.paddingTop = "0";
                    style.paddingBottom = "0";
                    style.borderTopWidth = "0";
                    style.borderBottomWidth = "0";
                    style.height = 0;
                };

            // If the scrollbar visibility has changed from the last draw, we need to
            // adjust the column sizes as the table width will have changed to account
            // for the scrollbar
            var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

            if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
                settings.scrollBarVis = scrollBarVis;
                _fnAdjustColumnSizing(settings);
                return; // adjust column sizing will call this function again
            }
            else {
                settings.scrollBarVis = scrollBarVis;
            }

            /*
             * 1. Re-create the table inside the scrolling div
             */

            // Remove the old minimised thead and tfoot elements in the inner table
            table.children('thead, tfoot').remove();

            if (footer) {
                footerCopy = footer.clone().prependTo(table);
                footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
                footerSrcEls = footerCopy.find('tr');
            }

            // Clone the current header and footer elements and then place it into the inner table
            headerCopy = header.clone().prependTo(table);
            headerTrgEls = header.find('tr'); // original header is in its own table
            headerSrcEls = headerCopy.find('tr');
            headerCopy.find('th, td').removeAttr('tabindex');


            /*
             * 2. Take live measurements from the DOM - do not alter the DOM itself!
             */

            // Remove old sizing and apply the calculated column widths
            // Get the unique column headers in the newly created (cloned) header. We want to apply the
            // calculated sizes to this header
            if (!scrollX) {
                divBodyStyle.width = '100%';
                divHeader[0].style.width = '100%';
            }

            $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
                idx = _fnVisibleToColumnIndex(settings, i);
                el.style.width = settings.aoColumns[idx].sWidth;
            });

            if (footer) {
                _fnApplyToChildren(function (n) {
                    n.style.width = "";
                }, footerSrcEls);
            }

            // Size the table as a whole
            sanityWidth = table.outerWidth();
            if (scrollX === "") {
                // No x scrolling
                tableStyle.width = "100%";

                // IE7 will make the width of the table when 100% include the scrollbar
                // - which is shouldn't. When there is a scrollbar we need to take this
                // into account.
                if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
                    divBody.css('overflow-y') == "scroll")
                ) {
                    tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
                }

                // Recalculate the sanity width
                sanityWidth = table.outerWidth();
            }
            else if (scrollXInner !== "") {
                // legacy x scroll inner has been given - use it
                tableStyle.width = _fnStringToCss(scrollXInner);

                // Recalculate the sanity width
                sanityWidth = table.outerWidth();
            }

            // Hidden header should have zero height, so remove padding and borders. Then
            // set the width based on the real headers

            // Apply all styles in one pass
            _fnApplyToChildren(zeroOut, headerSrcEls);

            // Read all widths in next pass
            _fnApplyToChildren(function (nSizer) {
                headerContent.push(nSizer.innerHTML);
                headerWidths.push(_fnStringToCss($(nSizer).css('width')));
            }, headerSrcEls);

            // Apply all widths in final pass
            _fnApplyToChildren(function (nToSize, i) {
                // Only apply widths to the DataTables detected header cells - this
                // prevents complex headers from having contradictory sizes applied
                if ($.inArray(nToSize, dtHeaderCells) !== -1) {
                    nToSize.style.width = headerWidths[i];
                }
            }, headerTrgEls);

            $(headerSrcEls).height(0);

            /* Same again with the footer if we have one */
            if (footer) {
                _fnApplyToChildren(zeroOut, footerSrcEls);

                _fnApplyToChildren(function (nSizer) {
                    footerContent.push(nSizer.innerHTML);
                    footerWidths.push(_fnStringToCss($(nSizer).css('width')));
                }, footerSrcEls);

                _fnApplyToChildren(function (nToSize, i) {
                    nToSize.style.width = footerWidths[i];
                }, footerTrgEls);

                $(footerSrcEls).height(0);
            }


            /*
             * 3. Apply the measurements
             */

            // "Hide" the header and footer that we used for the sizing. We need to keep
            // the content of the cell so that the width applied to the header and body
            // both match, but we want to hide it completely. We want to also fix their
            // width to what they currently are
            _fnApplyToChildren(function (nSizer, i) {
                nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
                nSizer.style.width = headerWidths[i];
            }, headerSrcEls);

            if (footer) {
                _fnApplyToChildren(function (nSizer, i) {
                    nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + footerContent[i] + '</div>';
                    nSizer.style.width = footerWidths[i];
                }, footerSrcEls);
            }

            // Sanity check that the table is of a sensible width. If not then we are going to get
            // misalignment - try to prevent this by not allowing the table to shrink below its min width
            if (table.outerWidth() < sanityWidth) {
                // The min width depends upon if we have a vertical scrollbar visible or not */
                correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
                    divBody.css('overflow-y') == "scroll")) ?
                    sanityWidth + barWidth :
                    sanityWidth;

                // IE6/7 are a law unto themselves...
                if (ie67 && (divBodyEl.scrollHeight >
                    divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
                ) {
                    tableStyle.width = _fnStringToCss(correction - barWidth);
                }

                // And give the user a warning that we've stopped the table getting too small
                if (scrollX === "" || scrollXInner !== "") {
                    _fnLog(settings, 1, 'Possible column misalignment', 6);
                }
            }
            else {
                correction = '100%';
            }

            // Apply to the container elements
            divBodyStyle.width = _fnStringToCss(correction);
            divHeaderStyle.width = _fnStringToCss(correction);

            if (footer) {
                settings.nScrollFoot.style.width = _fnStringToCss(correction);
            }


            /*
             * 4. Clean up
             */
            if (!scrollY) {
                /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
                 * the scrollbar height from the visible display, rather than adding it on. We need to
                 * set the height in order to sort this. Don't want to do it in any other browsers.
                 */
                if (ie67) {
                    divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
                }
            }

            /* Finally set the width's of the header and footer tables */
            var iOuterWidth = table.outerWidth();
            divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
            divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);

            // Figure out if there are scrollbar present - if so then we need a the header and footer to
            // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
            var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
            var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
            divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

            if (footer) {
                divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
                divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
                divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
            }

            // Correct DOM ordering for colgroup - comes before the thead
            table.children('colgroup').insertBefore(table.children('thead'));

            /* Adjust the position of the header in case we loose the y-scrollbar */
            divBody.scroll();

            // If sorting or filtering has occurred, jump the scrolling back to the top
            // only if we aren't holding the position
            if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
                divBodyEl.scrollTop = 0;
            }
        }



        /**
         * Apply a given function to the display child nodes of an element array (typically
         * TD children of TR rows
         *  @param {function} fn Method to apply to the objects
         *  @param array {nodes} an1 List of elements to look through for display children
         *  @param array {nodes} an2 Another list (identical structure to the first) - optional
         *  @memberof DataTable#oApi
         */
        function _fnApplyToChildren(fn, an1, an2) {
            var index = 0, i = 0, iLen = an1.length;
            var nNode1, nNode2;

            while (i < iLen) {
                nNode1 = an1[i].firstChild;
                nNode2 = an2 ? an2[i].firstChild : null;

                while (nNode1) {
                    if (nNode1.nodeType === 1) {
                        if (an2) {
                            fn(nNode1, nNode2, index);
                        }
                        else {
                            fn(nNode1, index);
                        }

                        index++;
                    }

                    nNode1 = nNode1.nextSibling;
                    nNode2 = an2 ? nNode2.nextSibling : null;
                }

                i++;
            }
        }



        var __re_html_remove = /<.*?>/g;


        /**
         * Calculate the width of columns for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnCalculateColumnWidths(oSettings) {
            var
                table = oSettings.nTable,
                columns = oSettings.aoColumns,
                scroll = oSettings.oScroll,
                scrollY = scroll.sY,
                scrollX = scroll.sX,
                scrollXInner = scroll.sXInner,
                columnCount = columns.length,
                visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
                headerCells = $('th', oSettings.nTHead),
                tableWidthAttr = table.getAttribute('width'), // from DOM element
                tableContainer = table.parentNode,
                userInputs = false,
                i, column, columnIdx, width, outerWidth,
                browser = oSettings.oBrowser,
                ie67 = browser.bScrollOversize;

            var styleWidth = table.style.width;
            if (styleWidth && styleWidth.indexOf('%') !== -1) {
                tableWidthAttr = styleWidth;
            }

            /* Convert any user input sizes into pixel sizes */
            for (i = 0; i < visibleColumns.length; i++) {
                column = columns[visibleColumns[i]];

                if (column.sWidth !== null) {
                    column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);

                    userInputs = true;
                }
            }

            /* If the number of columns in the DOM equals the number that we have to
             * process in DataTables, then we can use the offsets that are created by
             * the web- browser. No custom sizes can be set in order for this to happen,
             * nor scrolling used
             */
            if (ie67 || !userInputs && !scrollX && !scrollY &&
                columnCount == _fnVisbleColumns(oSettings) &&
                columnCount == headerCells.length
            ) {
                for (i = 0; i < columnCount; i++) {
                    var colIdx = _fnVisibleToColumnIndex(oSettings, i);

                    if (colIdx !== null) {
                        columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
                    }
                }
            }
            else {
                // Otherwise construct a single row, worst case, table with the widest
                // node in the data, assign any user defined widths, then insert it into
                // the DOM and allow the browser to do all the hard work of calculating
                // table widths
                var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
                    .css('visibility', 'hidden')
                    .removeAttr('id');

                // Clean up the table body
                tmpTable.find('tbody tr').remove();
                var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));

                // Clone the table header and footer - we can't use the header / footer
                // from the cloned table, since if scrolling is active, the table's
                // real header and footer are contained in different table tags
                tmpTable.find('thead, tfoot').remove();
                tmpTable
                    .append($(oSettings.nTHead).clone())
                    .append($(oSettings.nTFoot).clone());

                // Remove any assigned widths from the footer (from scrolling)
                tmpTable.find('tfoot th, tfoot td').css('width', '');

                // Apply custom sizing to the cloned header
                headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

                for (i = 0; i < visibleColumns.length; i++) {
                    column = columns[visibleColumns[i]];

                    headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
                        _fnStringToCss(column.sWidthOrig) :
                        '';

                    // For scrollX we need to force the column width otherwise the
                    // browser will collapse it. If this width is smaller than the
                    // width the column requires, then it will have no effect
                    if (column.sWidthOrig && scrollX) {
                        $(headerCells[i]).append($('<div/>').css({
                            width: column.sWidthOrig,
                            margin: 0,
                            padding: 0,
                            border: 0,
                            height: 1
                        }));
                    }
                }

                // Find the widest cell for each column and put it into the table
                if (oSettings.aoData.length) {
                    for (i = 0; i < visibleColumns.length; i++) {
                        columnIdx = visibleColumns[i];
                        column = columns[columnIdx];

                        $(_fnGetWidestNode(oSettings, columnIdx))
                            .clone(false)
                            .append(column.sContentPadding)
                            .appendTo(tr);
                    }
                }

                // Tidy the temporary table - remove name attributes so there aren't
                // duplicated in the dom (radio elements for example)
                $('[name]', tmpTable).removeAttr('name');

                // Table has been built, attach to the document so we can work with it.
                // A holding element is used, positioned at the top of the container
                // with minimal height, so it has no effect on if the container scrolls
                // or not. Otherwise it might trigger scrolling when it actually isn't
                // needed
                var holder = $('<div/>').css(scrollX || scrollY ?
                    {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        height: 1,
                        right: 0,
                        overflow: 'hidden'
                    } :
                    {}
                )
                    .append(tmpTable)
                    .appendTo(tableContainer);

                // When scrolling (X or Y) we want to set the width of the table as 
                // appropriate. However, when not scrolling leave the table width as it
                // is. This results in slightly different, but I think correct behaviour
                if (scrollX && scrollXInner) {
                    tmpTable.width(scrollXInner);
                }
                else if (scrollX) {
                    tmpTable.css('width', 'auto');
                    tmpTable.removeAttr('width');

                    // If there is no width attribute or style, then allow the table to
                    // collapse
                    if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
                        tmpTable.width(tableContainer.clientWidth);
                    }
                }
                else if (scrollY) {
                    tmpTable.width(tableContainer.clientWidth);
                }
                else if (tableWidthAttr) {
                    tmpTable.width(tableWidthAttr);
                }

                // Get the width of each column in the constructed table - we need to
                // know the inner width (so it can be assigned to the other table's
                // cells) and the outer width so we can calculate the full width of the
                // table. This is safe since DataTables requires a unique cell for each
                // column, but if ever a header can span multiple columns, this will
                // need to be modified.
                var total = 0;
                for (i = 0; i < visibleColumns.length; i++) {
                    var cell = $(headerCells[i]);
                    var border = cell.outerWidth() - cell.width();

                    // Use getBounding... where possible (not IE8-) because it can give
                    // sub-pixel accuracy, which we then want to round up!
                    var bounding = browser.bBounding ?
                        Math.ceil(headerCells[i].getBoundingClientRect().width) :
                        cell.outerWidth();

                    // Total is tracked to remove any sub-pixel errors as the outerWidth
                    // of the table might not equal the total given here (IE!).
                    total += bounding;

                    // Width for each column to use
                    columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
                }

                table.style.width = _fnStringToCss(total);

                // Finished with the table - ditch it
                holder.remove();
            }

            // If there is a width attr, we want to attach an event listener which
            // allows the table sizing to automatically adjust when the window is
            // resized. Use the width attr rather than CSS, since we can't know if the
            // CSS is a relative value or absolute - DOM read is always px.
            if (tableWidthAttr) {
                table.style.width = _fnStringToCss(tableWidthAttr);
            }

            if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
                var bindResize = function () {
                    $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
                        _fnAdjustColumnSizing(oSettings);
                    }));
                };

                // IE6/7 will crash if we bind a resize event handler on page load.
                // To be removed in 1.11 which drops IE6/7 support
                if (ie67) {
                    setTimeout(bindResize, 1000);
                }
                else {
                    bindResize();
                }

                oSettings._reszEvt = true;
            }
        }


        /**
         * Throttle the calls to a function. Arguments and context are maintained for
         * the throttled function
         *  @param {function} fn Function to be called
         *  @param {int} [freq=200] call frequency in mS
         *  @returns {function} wrapped function
         *  @memberof DataTable#oApi
         */
        var _fnThrottle = DataTable.util.throttle;


        /**
         * Convert a CSS unit width to pixels (e.g. 2em)
         *  @param {string} width width to be converted
         *  @param {node} parent parent to get the with for (required for relative widths) - optional
         *  @returns {int} width in pixels
         *  @memberof DataTable#oApi
         */
        function _fnConvertToWidth(width, parent) {
            if (!width) {
                return 0;
            }

            var n = $('<div/>')
                .css('width', _fnStringToCss(width))
                .appendTo(parent || document.body);

            var val = n[0].offsetWidth;
            n.remove();

            return val;
        }


        /**
         * Get the widest node
         *  @param {object} settings dataTables settings object
         *  @param {int} colIdx column of interest
         *  @returns {node} widest table node
         *  @memberof DataTable#oApi
         */
        function _fnGetWidestNode(settings, colIdx) {
            var idx = _fnGetMaxLenString(settings, colIdx);
            if (idx < 0) {
                return null;
            }

            var data = settings.aoData[idx];
            return !data.nTr ? // Might not have been created when deferred rendering
                $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] :
                data.anCells[colIdx];
        }


        /**
         * Get the maximum strlen for each data column
         *  @param {object} settings dataTables settings object
         *  @param {int} colIdx column of interest
         *  @returns {string} max string length for each column
         *  @memberof DataTable#oApi
         */
        function _fnGetMaxLenString(settings, colIdx) {
            var s, max = -1, maxIdx = -1;

            for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
                s = _fnGetCellData(settings, i, colIdx, 'display') + '';
                s = s.replace(__re_html_remove, '');
                s = s.replace(/&nbsp;/g, ' ');

                if (s.length > max) {
                    max = s.length;
                    maxIdx = i;
                }
            }

            return maxIdx;
        }


        /**
         * Append a CSS unit (only if required) to a string
         *  @param {string} value to css-ify
         *  @returns {string} value with css unit
         *  @memberof DataTable#oApi
         */
        function _fnStringToCss(s) {
            if (s === null) {
                return '0px';
            }

            if (typeof s == 'number') {
                return s < 0 ?
                    '0px' :
                    s + 'px';
            }

            // Check it has a unit character already
            return s.match(/\d$/) ?
                s + 'px' :
                s;
        }



        function _fnSortFlatten(settings) {
            var
                i, iLen, k, kLen,
                aSort = [],
                aiOrig = [],
                aoColumns = settings.aoColumns,
                aDataSort, iCol, sType, srcCol,
                fixed = settings.aaSortingFixed,
                fixedObj = $.isPlainObject(fixed),
                nestedSort = [],
                add = function (a) {
                    if (a.length && !$.isArray(a[0])) {
                        // 1D array
                        nestedSort.push(a);
                    }
                    else {
                        // 2D array
                        $.merge(nestedSort, a);
                    }
                };

            // Build the sort array, with pre-fix and post-fix options if they have been
            // specified
            if ($.isArray(fixed)) {
                add(fixed);
            }

            if (fixedObj && fixed.pre) {
                add(fixed.pre);
            }

            add(settings.aaSorting);

            if (fixedObj && fixed.post) {
                add(fixed.post);
            }

            for (i = 0; i < nestedSort.length; i++) {
                srcCol = nestedSort[i][0];
                aDataSort = aoColumns[srcCol].aDataSort;

                for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
                    iCol = aDataSort[k];
                    sType = aoColumns[iCol].sType || 'string';

                    if (nestedSort[i]._idx === undefined) {
                        nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
                    }

                    aSort.push({
                        src: srcCol,
                        col: iCol,
                        dir: nestedSort[i][1],
                        index: nestedSort[i]._idx,
                        type: sType,
                        formatter: DataTable.ext.type.order[sType + "-pre"]
                    });
                }
            }

            return aSort;
        }

        /**
         * Change the order of the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         *  @todo This really needs split up!
         */
        function _fnSort(oSettings) {
            var
                i, ien, iLen, j, jLen, k, kLen,
                sDataType, nTh,
                aiOrig = [],
                oExtSort = DataTable.ext.type.order,
                aoData = oSettings.aoData,
                aoColumns = oSettings.aoColumns,
                aDataSort, data, iCol, sType, oSort,
                formatters = 0,
                sortCol,
                displayMaster = oSettings.aiDisplayMaster,
                aSort;

            // Resolve any column types that are unknown due to addition or invalidation
            // @todo Can this be moved into a 'data-ready' handler which is called when
            //   data is going to be used in the table?
            _fnColumnTypes(oSettings);

            aSort = _fnSortFlatten(oSettings);

            for (i = 0, ien = aSort.length; i < ien; i++) {
                sortCol = aSort[i];

                // Track if we can use the fast sort algorithm
                if (sortCol.formatter) {
                    formatters++;
                }

                // Load the data needed for the sort, for each cell
                _fnSortData(oSettings, sortCol.col);
            }

            /* No sorting required if server-side or no sorting array */
            if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
                // Create a value - key array of the current row positions such that we can use their
                // current position during the sort, if values match, in order to perform stable sorting
                for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
                    aiOrig[displayMaster[i]] = i;
                }

                /* Do the sort - here we want multi-column sorting based on a given data source (column)
                 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
                 * follow on it's own, but this is what we want (example two column sorting):
                 *  fnLocalSorting = function(a,b){
                 *    var iTest;
                 *    iTest = oSort['string-asc']('data11', 'data12');
                 *      if (iTest !== 0)
                 *        return iTest;
                 *    iTest = oSort['numeric-desc']('data21', 'data22');
                 *    if (iTest !== 0)
                 *      return iTest;
                 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
                 *  }
                 * Basically we have a test for each sorting column, if the data in that column is equal,
                 * test the next column. If all columns match, then we use a numeric sort on the row
                 * positions in the original data array to provide a stable sort.
                 *
                 * Note - I know it seems excessive to have two sorting methods, but the first is around
                 * 15% faster, so the second is only maintained for backwards compatibility with sorting
                 * methods which do not have a pre-sort formatting function.
                 */
                if (formatters === aSort.length) {
                    // All sort types have formatting functions
                    displayMaster.sort(function (a, b) {
                        var
                            x, y, k, test, sort,
                            len = aSort.length,
                            dataA = aoData[a]._aSortData,
                            dataB = aoData[b]._aSortData;

                        for (k = 0; k < len; k++) {
                            sort = aSort[k];

                            x = dataA[sort.col];
                            y = dataB[sort.col];

                            test = x < y ? -1 : x > y ? 1 : 0;
                            if (test !== 0) {
                                return sort.dir === 'asc' ? test : -test;
                            }
                        }

                        x = aiOrig[a];
                        y = aiOrig[b];
                        return x < y ? -1 : x > y ? 1 : 0;
                    });
                }
                else {
                    // Depreciated - remove in 1.11 (providing a plug-in option)
                    // Not all sort types have formatting methods, so we have to call their sorting
                    // methods.
                    displayMaster.sort(function (a, b) {
                        var
                            x, y, k, l, test, sort, fn,
                            len = aSort.length,
                            dataA = aoData[a]._aSortData,
                            dataB = aoData[b]._aSortData;

                        for (k = 0; k < len; k++) {
                            sort = aSort[k];

                            x = dataA[sort.col];
                            y = dataB[sort.col];

                            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
                            test = fn(x, y);
                            if (test !== 0) {
                                return test;
                            }
                        }

                        x = aiOrig[a];
                        y = aiOrig[b];
                        return x < y ? -1 : x > y ? 1 : 0;
                    });
                }
            }

            /* Tell the draw function that we have sorted the data */
            oSettings.bSorted = true;
        }


        function _fnSortAria(settings) {
            var label;
            var nextSort;
            var columns = settings.aoColumns;
            var aSort = _fnSortFlatten(settings);
            var oAria = settings.oLanguage.oAria;

            // ARIA attributes - need to loop all columns, to update all (removing old
            // attributes as needed)
            for (var i = 0, iLen = columns.length; i < iLen; i++) {
                var col = columns[i];
                var asSorting = col.asSorting;
                var sTitle = col.sTitle.replace(/<.*?>/g, "");
                var th = col.nTh;

                // IE7 is throwing an error when setting these properties with jQuery's
                // attr() and removeAttr() methods...
                th.removeAttribute('aria-sort');

                /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
                if (col.bSortable) {
                    if (aSort.length > 0 && aSort[0].col == i) {
                        th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
                        nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
                    }
                    else {
                        nextSort = asSorting[0];
                    }

                    label = sTitle + (nextSort === "asc" ?
                        oAria.sSortAscending :
                        oAria.sSortDescending
                    );
                }
                else {
                    label = sTitle;
                }

                th.setAttribute('aria-label', label);
            }
        }


        /**
         * Function to run on user sort request
         *  @param {object} settings dataTables settings object
         *  @param {node} attachTo node to attach the handler to
         *  @param {int} colIdx column sorting index
         *  @param {boolean} [append=false] Append the requested sort to the existing
         *    sort if true (i.e. multi-column sort)
         *  @param {function} [callback] callback function
         *  @memberof DataTable#oApi
         */
        function _fnSortListener(settings, colIdx, append, callback) {
            var col = settings.aoColumns[colIdx];
            var sorting = settings.aaSorting;
            var asSorting = col.asSorting;
            var nextSortIdx;
            var next = function (a, overflow) {
                var idx = a._idx;
                if (idx === undefined) {
                    idx = $.inArray(a[1], asSorting);
                }

                return idx + 1 < asSorting.length ?
                    idx + 1 :
                    overflow ?
                        null :
                        0;
            };

            // Convert to 2D array if needed
            if (typeof sorting[0] === 'number') {
                sorting = settings.aaSorting = [sorting];
            }

            // If appending the sort then we are multi-column sorting
            if (append && settings.oFeatures.bSortMulti) {
                // Are we already doing some kind of sort on this column?
                var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

                if (sortIdx !== -1) {
                    // Yes, modify the sort
                    nextSortIdx = next(sorting[sortIdx], true);

                    if (nextSortIdx === null && sorting.length === 1) {
                        nextSortIdx = 0; // can't remove sorting completely
                    }

                    if (nextSortIdx === null) {
                        sorting.splice(sortIdx, 1);
                    }
                    else {
                        sorting[sortIdx][1] = asSorting[nextSortIdx];
                        sorting[sortIdx]._idx = nextSortIdx;
                    }
                }
                else {
                    // No sort on this column yet
                    sorting.push([colIdx, asSorting[0], 0]);
                    sorting[sorting.length - 1]._idx = 0;
                }
            }
            else if (sorting.length && sorting[0][0] == colIdx) {
                // Single column - already sorting on this column, modify the sort
                nextSortIdx = next(sorting[0]);

                sorting.length = 1;
                sorting[0][1] = asSorting[nextSortIdx];
                sorting[0]._idx = nextSortIdx;
            }
            else {
                // Single column - sort only on this column
                sorting.length = 0;
                sorting.push([colIdx, asSorting[0]]);
                sorting[0]._idx = 0;
            }

            // Run the sort by calling a full redraw
            _fnReDraw(settings);

            // callback used for async user interaction
            if (typeof callback == 'function') {
                callback(settings);
            }
        }


        /**
         * Attach a sort handler (click) to a node
         *  @param {object} settings dataTables settings object
         *  @param {node} attachTo node to attach the handler to
         *  @param {int} colIdx column sorting index
         *  @param {function} [callback] callback function
         *  @memberof DataTable#oApi
         */
        function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
            var col = settings.aoColumns[colIdx];

            _fnBindAction(attachTo, {}, function (e) {
                /* If the column is not sortable - don't to anything */
                if (col.bSortable === false) {
                    return;
                }

                // If processing is enabled use a timeout to allow the processing
                // display to be shown - otherwise to it synchronously
                if (settings.oFeatures.bProcessing) {
                    _fnProcessingDisplay(settings, true);

                    setTimeout(function () {
                        _fnSortListener(settings, colIdx, e.shiftKey, callback);

                        // In server-side processing, the draw callback will remove the
                        // processing display
                        if (_fnDataSource(settings) !== 'ssp') {
                            _fnProcessingDisplay(settings, false);
                        }
                    }, 0);
                }
                else {
                    _fnSortListener(settings, colIdx, e.shiftKey, callback);
                }
            });
        }


        /**
         * Set the sorting classes on table's body, Note: it is safe to call this function
         * when bSort and bSortClasses are false
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnSortingClasses(settings) {
            var oldSort = settings.aLastSort;
            var sortClass = settings.oClasses.sSortColumn;
            var sort = _fnSortFlatten(settings);
            var features = settings.oFeatures;
            var i, ien, colIdx;

            if (features.bSort && features.bSortClasses) {
                // Remove old sorting classes
                for (i = 0, ien = oldSort.length; i < ien; i++) {
                    colIdx = oldSort[i].src;

                    // Remove column sorting
                    $(_pluck(settings.aoData, 'anCells', colIdx))
                        .removeClass(sortClass + (i < 2 ? i + 1 : 3));
                }

                // Add new column sorting
                for (i = 0, ien = sort.length; i < ien; i++) {
                    colIdx = sort[i].src;

                    $(_pluck(settings.aoData, 'anCells', colIdx))
                        .addClass(sortClass + (i < 2 ? i + 1 : 3));
                }
            }

            settings.aLastSort = sort;
        }


        // Get the data to sort a column, be it from cache, fresh (populating the
        // cache), or from a sort formatter
        function _fnSortData(settings, idx) {
            // Custom sorting function - provided by the sort data type
            var column = settings.aoColumns[idx];
            var customSort = DataTable.ext.order[column.sSortDataType];
            var customData;

            if (customSort) {
                customData = customSort.call(settings.oInstance, settings, idx,
                    _fnColumnIndexToVisible(settings, idx)
                );
            }

            // Use / populate cache
            var row, cellData;
            var formatter = DataTable.ext.type.order[column.sType + "-pre"];

            for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
                row = settings.aoData[i];

                if (!row._aSortData) {
                    row._aSortData = [];
                }

                if (!row._aSortData[idx] || customSort) {
                    cellData = customSort ?
                        customData[i] : // If there was a custom sort function, use data from there
                        _fnGetCellData(settings, i, idx, 'sort');

                    row._aSortData[idx] = formatter ?
                        formatter(cellData) :
                        cellData;
                }
            }
        }



        /**
         * Save the state of a table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnSaveState(settings) {
            if (!settings.oFeatures.bStateSave || settings.bDestroying) {
                return;
            }

            /* Store the interesting variables */
            var state = {
                time: +new Date(),
                start: settings._iDisplayStart,
                length: settings._iDisplayLength,
                order: $.extend(true, [], settings.aaSorting),
                search: _fnSearchToCamel(settings.oPreviousSearch),
                columns: $.map(settings.aoColumns, function (col, i) {
                    return {
                        visible: col.bVisible,
                        search: _fnSearchToCamel(settings.aoPreSearchCols[i])
                    };
                })
            };

            _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

            settings.oSavedState = state;
            settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
        }


        /**
         * Attempt to load a saved table state
         *  @param {object} oSettings dataTables settings object
         *  @param {object} oInit DataTables init object so we can override settings
         *  @param {function} callback Callback to execute when the state has been loaded
         *  @memberof DataTable#oApi
         */
        function _fnLoadState(settings, oInit, callback) {
            var i, ien;
            var columns = settings.aoColumns;
            var loaded = function (s) {
                if (!s || !s.time) {
                    callback();
                    return;
                }

                // Allow custom and plug-in manipulation functions to alter the saved data set and
                // cancelling of loading by returning false
                var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);
                if ($.inArray(false, abStateLoad) !== -1) {
                    callback();
                    return;
                }

                // Reject old data
                var duration = settings.iStateDuration;
                if (duration > 0 && s.time < +new Date() - (duration * 1000)) {
                    callback();
                    return;
                }

                // Number of columns have changed - all bets are off, no restore of settings
                if (s.columns && columns.length !== s.columns.length) {
                    callback();
                    return;
                }

                // Store the saved state so it might be accessed at any time
                settings.oLoadedState = $.extend(true, {}, s);

                // Restore key features - todo - for 1.11 this needs to be done by
                // subscribed events
                if (s.start !== undefined) {
                    settings._iDisplayStart = s.start;
                    settings.iInitDisplayStart = s.start;
                }
                if (s.length !== undefined) {
                    settings._iDisplayLength = s.length;
                }

                // Order
                if (s.order !== undefined) {
                    settings.aaSorting = [];
                    $.each(s.order, function (i, col) {
                        settings.aaSorting.push(col[0] >= columns.length ?
                            [0, col[1]] :
                            col
                        );
                    });
                }

                // Search
                if (s.search !== undefined) {
                    $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
                }

                // Columns
                //
                if (s.columns) {
                    for (i = 0, ien = s.columns.length; i < ien; i++) {
                        var col = s.columns[i];

                        // Visibility
                        if (col.visible !== undefined) {
                            columns[i].bVisible = col.visible;
                        }

                        // Search
                        if (col.search !== undefined) {
                            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
                        }
                    }
                }

                _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);
                callback();
            }

            if (!settings.oFeatures.bStateSave) {
                callback();
                return;
            }

            var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

            if (state !== undefined) {
                loaded(state);
            }
            // otherwise, wait for the loaded callback to be executed
        }


        /**
         * Return the settings object for a particular table
         *  @param {node} table table we are using as a dataTable
         *  @returns {object} Settings object - or null if not found
         *  @memberof DataTable#oApi
         */
        function _fnSettingsFromNode(table) {
            var settings = DataTable.settings;
            var idx = $.inArray(table, _pluck(settings, 'nTable'));

            return idx !== -1 ?
                settings[idx] :
                null;
        }


        /**
         * Log an error message
         *  @param {object} settings dataTables settings object
         *  @param {int} level log error messages, or display them to the user
         *  @param {string} msg error message
         *  @param {int} tn Technical note id to get more information about the error.
         *  @memberof DataTable#oApi
         */
        function _fnLog(settings, level, msg, tn) {
            msg = 'DataTables warning: ' +
                (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

            if (tn) {
                msg += '. For more information about this error, please see ' +
                    'http://datatables.net/tn/' + tn;
            }

            if (!level) {
                // Backwards compatibility pre 1.10
                var ext = DataTable.ext;
                var type = ext.sErrMode || ext.errMode;

                if (settings) {
                    _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
                }

                if (type == 'alert') {
                    alert(msg);
                }
                else if (type == 'throw') {
                    throw new Error(msg);
                }
                else if (typeof type == 'function') {
                    type(settings, tn, msg);
                }
            }
            else if (window.console && console.log) {
                console.log(msg);
            }
        }


        /**
         * See if a property is defined on one object, if so assign it to the other object
         *  @param {object} ret target object
         *  @param {object} src source object
         *  @param {string} name property
         *  @param {string} [mappedName] name to map too - optional, name used if not given
         *  @memberof DataTable#oApi
         */
        function _fnMap(ret, src, name, mappedName) {
            if ($.isArray(name)) {
                $.each(name, function (i, val) {
                    if ($.isArray(val)) {
                        _fnMap(ret, src, val[0], val[1]);
                    }
                    else {
                        _fnMap(ret, src, val);
                    }
                });

                return;
            }

            if (mappedName === undefined) {
                mappedName = name;
            }

            if (src[name] !== undefined) {
                ret[mappedName] = src[name];
            }
        }


        /**
         * Extend objects - very similar to jQuery.extend, but deep copy objects, and
         * shallow copy arrays. The reason we need to do this, is that we don't want to
         * deep copy array init values (such as aaSorting) since the dev wouldn't be
         * able to override them, but we do want to deep copy arrays.
         *  @param {object} out Object to extend
         *  @param {object} extender Object from which the properties will be applied to
         *      out
         *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
         *      independent copy with the exception of the `data` or `aaData` parameters
         *      if they are present. This is so you can pass in a collection to
         *      DataTables and have that used as your data source without breaking the
         *      references
         *  @returns {object} out Reference, just for convenience - out === the return.
         *  @memberof DataTable#oApi
         *  @todo This doesn't take account of arrays inside the deep copied objects.
         */
        function _fnExtend(out, extender, breakRefs) {
            var val;

            for (var prop in extender) {
                if (extender.hasOwnProperty(prop)) {
                    val = extender[prop];

                    if ($.isPlainObject(val)) {
                        if (!$.isPlainObject(out[prop])) {
                            out[prop] = {};
                        }
                        $.extend(true, out[prop], val);
                    }
                    else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
                        out[prop] = val.slice();
                    }
                    else {
                        out[prop] = val;
                    }
                }
            }

            return out;
        }


        /**
         * Bind an event handers to allow a click or return key to activate the callback.
         * This is good for accessibility since a return on the keyboard will have the
         * same effect as a click, if the element has focus.
         *  @param {element} n Element to bind the action to
         *  @param {object} oData Data object to pass to the triggered function
         *  @param {function} fn Callback function for when the event is triggered
         *  @memberof DataTable#oApi
         */
        function _fnBindAction(n, oData, fn) {
            $(n)
                .on('click.DT', oData, function (e) {
                    n.blur(); // Remove focus outline for mouse users
                    fn(e);
                })
                .on('keypress.DT', oData, function (e) {
                    if (e.which === 13) {
                        e.preventDefault();
                        fn(e);
                    }
                })
                .on('selectstart.DT', function () {
                    /* Take the brutal approach to cancelling text selection */
                    return false;
                });
        }


        /**
         * Register a callback function. Easily allows a callback function to be added to
         * an array store of callback functions that can then all be called together.
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sStore Name of the array storage for the callbacks in oSettings
         *  @param {function} fn Function to be called back
         *  @param {string} sName Identifying name for the callback (i.e. a label)
         *  @memberof DataTable#oApi
         */
        function _fnCallbackReg(oSettings, sStore, fn, sName) {
            if (fn) {
                oSettings[sStore].push({
                    "fn": fn,
                    "sName": sName
                });
            }
        }


        /**
         * Fire callback functions and trigger events. Note that the loop over the
         * callback array store is done backwards! Further note that you do not want to
         * fire off triggers in time sensitive applications (for example cell creation)
         * as its slow.
         *  @param {object} settings dataTables settings object
         *  @param {string} callbackArr Name of the array storage for the callbacks in
         *      oSettings
         *  @param {string} eventName Name of the jQuery custom event to trigger. If
         *      null no trigger is fired
         *  @param {array} args Array of arguments to pass to the callback function /
         *      trigger
         *  @memberof DataTable#oApi
         */
        function _fnCallbackFire(settings, callbackArr, eventName, args) {
            var ret = [];

            if (callbackArr) {
                ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
                    return val.fn.apply(settings.oInstance, args);
                });
            }

            if (eventName !== null) {
                var e = $.Event(eventName + '.dt');

                $(settings.nTable).trigger(e, args);

                ret.push(e.result);
            }

            return ret;
        }


        function _fnLengthOverflow(settings) {
            var
                start = settings._iDisplayStart,
                end = settings.fnDisplayEnd(),
                len = settings._iDisplayLength;

            /* If we have space to show extra rows (backing up from the end point - then do so */
            if (start >= end) {
                start = end - len;
            }

            // Keep the start record on the current page
            start -= (start % len);

            if (len === -1 || start < 0) {
                start = 0;
            }

            settings._iDisplayStart = start;
        }


        function _fnRenderer(settings, type) {
            var renderer = settings.renderer;
            var host = DataTable.ext.renderer[type];

            if ($.isPlainObject(renderer) && renderer[type]) {
                // Specific renderer for this type. If available use it, otherwise use
                // the default.
                return host[renderer[type]] || host._;
            }
            else if (typeof renderer === 'string') {
                // Common renderer - if there is one available for this type use it,
                // otherwise use the default
                return host[renderer] || host._;
            }

            // Use the default
            return host._;
        }


        /**
         * Detect the data source being used for the table. Used to simplify the code
         * a little (ajax) and to make it compress a little smaller.
         *
         *  @param {object} settings dataTables settings object
         *  @returns {string} Data source
         *  @memberof DataTable#oApi
         */
        function _fnDataSource(settings) {
            if (settings.oFeatures.bServerSide) {
                return 'ssp';
            }
            else if (settings.ajax || settings.sAjaxSource) {
                return 'ajax';
            }
            return 'dom';
        }




        /**
         * Computed structure of the DataTables API, defined by the options passed to
         * `DataTable.Api.register()` when building the API.
         *
         * The structure is built in order to speed creation and extension of the Api
         * objects since the extensions are effectively pre-parsed.
         *
         * The array is an array of objects with the following structure, where this
         * base array represents the Api prototype base:
         *
         *     [
         *       {
         *         name:      'data'                -- string   - Property name
         *         val:       function () {},       -- function - Api method (or undefined if just an object
         *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
         *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
         *       },
         *       {
         *         name:     'row'
         *         val:       {},
         *         methodExt: [ ... ],
         *         propExt:   [
         *           {
         *             name:      'data'
         *             val:       function () {},
         *             methodExt: [ ... ],
         *             propExt:   [ ... ]
         *           },
         *           ...
         *         ]
         *       }
         *     ]
         *
         * @type {Array}
         * @ignore
         */
        var __apiStruct = [];


        /**
         * `Array.prototype` reference.
         *
         * @type object
         * @ignore
         */
        var __arrayProto = Array.prototype;


        /**
         * Abstraction for `context` parameter of the `Api` constructor to allow it to
         * take several different forms for ease of use.
         *
         * Each of the input parameter types will be converted to a DataTables settings
         * object where possible.
         *
         * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
         *   of:
         *
         *   * `string` - jQuery selector. Any DataTables' matching the given selector
         *     with be found and used.
         *   * `node` - `TABLE` node which has already been formed into a DataTable.
         *   * `jQuery` - A jQuery object of `TABLE` nodes.
         *   * `object` - DataTables settings object
         *   * `DataTables.Api` - API instance
         * @return {array|null} Matching DataTables settings objects. `null` or
         *   `undefined` is returned if no matching DataTable is found.
         * @ignore
         */
        var _toSettings = function (mixed) {
            var idx, jq;
            var settings = DataTable.settings;
            var tables = $.map(settings, function (el, i) {
                return el.nTable;
            });

            if (!mixed) {
                return [];
            }
            else if (mixed.nTable && mixed.oApi) {
                // DataTables settings object
                return [mixed];
            }
            else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
                // Table node
                idx = $.inArray(mixed, tables);
                return idx !== -1 ? [settings[idx]] : null;
            }
            else if (mixed && typeof mixed.settings === 'function') {
                return mixed.settings().toArray();
            }
            else if (typeof mixed === 'string') {
                // jQuery selector
                jq = $(mixed);
            }
            else if (mixed instanceof $) {
                // jQuery object (also DataTables instance)
                jq = mixed;
            }

            if (jq) {
                return jq.map(function (i) {
                    idx = $.inArray(this, tables);
                    return idx !== -1 ? settings[idx] : null;
                }).toArray();
            }
        };


        /**
         * DataTables API class - used to control and interface with  one or more
         * DataTables enhanced tables.
         *
         * The API class is heavily based on jQuery, presenting a chainable interface
         * that you can use to interact with tables. Each instance of the API class has
         * a "context" - i.e. the tables that it will operate on. This could be a single
         * table, all tables on a page or a sub-set thereof.
         *
         * Additionally the API is designed to allow you to easily work with the data in
         * the tables, retrieving and manipulating it as required. This is done by
         * presenting the API class as an array like interface. The contents of the
         * array depend upon the actions requested by each method (for example
         * `rows().nodes()` will return an array of nodes, while `rows().data()` will
         * return an array of objects or arrays depending upon your table's
         * configuration). The API object has a number of array like methods (`push`,
         * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
         * `unique` etc) to assist your working with the data held in a table.
         *
         * Most methods (those which return an Api instance) are chainable, which means
         * the return from a method call also has all of the methods available that the
         * top level object had. For example, these two calls are equivalent:
         *
         *     // Not chained
         *     api.row.add( {...} );
         *     api.draw();
         *
         *     // Chained
         *     api.row.add( {...} ).draw();
         *
         * @class DataTable.Api
         * @param {array|object|string|jQuery} context DataTable identifier. This is
         *   used to define which DataTables enhanced tables this API will operate on.
         *   Can be one of:
         *
         *   * `string` - jQuery selector. Any DataTables' matching the given selector
         *     with be found and used.
         *   * `node` - `TABLE` node which has already been formed into a DataTable.
         *   * `jQuery` - A jQuery object of `TABLE` nodes.
         *   * `object` - DataTables settings object
         * @param {array} [data] Data to initialise the Api instance with.
         *
         * @example
         *   // Direct initialisation during DataTables construction
         *   var api = $('#example').DataTable();
         *
         * @example
         *   // Initialisation using a DataTables jQuery object
         *   var api = $('#example').dataTable().api();
         *
         * @example
         *   // Initialisation as a constructor
         *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
         */
        _Api = function (context, data) {
            if (!(this instanceof _Api)) {
                return new _Api(context, data);
            }

            var settings = [];
            var ctxSettings = function (o) {
                var a = _toSettings(o);
                if (a) {
                    settings = settings.concat(a);
                }
            };

            if ($.isArray(context)) {
                for (var i = 0, ien = context.length; i < ien; i++) {
                    ctxSettings(context[i]);
                }
            }
            else {
                ctxSettings(context);
            }

            // Remove duplicates
            this.context = _unique(settings);

            // Initial data
            if (data) {
                $.merge(this, data);
            }

            // selector
            this.selector = {
                rows: null,
                cols: null,
                opts: null
            };

            _Api.extend(this, this, __apiStruct);
        };

        DataTable.Api = _Api;

        // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
        // isPlainObject.
        $.extend(_Api.prototype, {
            any: function () {
                return this.count() !== 0;
            },


            concat: __arrayProto.concat,


            context: [], // array of table settings objects


            count: function () {
                return this.flatten().length;
            },


            each: function (fn) {
                for (var i = 0, ien = this.length; i < ien; i++) {
                    fn.call(this, this[i], i, this);
                }

                return this;
            },


            eq: function (idx) {
                var ctx = this.context;

                return ctx.length > idx ?
                    new _Api(ctx[idx], this[idx]) :
                    null;
            },


            filter: function (fn) {
                var a = [];

                if (__arrayProto.filter) {
                    a = __arrayProto.filter.call(this, fn, this);
                }
                else {
                    // Compatibility for browsers without EMCA-252-5 (JS 1.6)
                    for (var i = 0, ien = this.length; i < ien; i++) {
                        if (fn.call(this, this[i], i, this)) {
                            a.push(this[i]);
                        }
                    }
                }

                return new _Api(this.context, a);
            },


            flatten: function () {
                var a = [];
                return new _Api(this.context, a.concat.apply(a, this.toArray()));
            },


            join: __arrayProto.join,


            indexOf: __arrayProto.indexOf || function (obj, start) {
                for (var i = (start || 0), ien = this.length; i < ien; i++) {
                    if (this[i] === obj) {
                        return i;
                    }
                }
                return -1;
            },

            iterator: function (flatten, type, fn, alwaysNew) {
                var
                    a = [], ret,
                    i, ien, j, jen,
                    context = this.context,
                    rows, items, item,
                    selector = this.selector;

                // Argument shifting
                if (typeof flatten === 'string') {
                    alwaysNew = fn;
                    fn = type;
                    type = flatten;
                    flatten = false;
                }

                for (i = 0, ien = context.length; i < ien; i++) {
                    var apiInst = new _Api(context[i]);

                    if (type === 'table') {
                        ret = fn.call(apiInst, context[i], i);

                        if (ret !== undefined) {
                            a.push(ret);
                        }
                    }
                    else if (type === 'columns' || type === 'rows') {
                        // this has same length as context - one entry for each table
                        ret = fn.call(apiInst, context[i], this[i], i);

                        if (ret !== undefined) {
                            a.push(ret);
                        }
                    }
                    else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
                        // columns and rows share the same structure.
                        // 'this' is an array of column indexes for each context
                        items = this[i];

                        if (type === 'column-rows') {
                            rows = _selector_row_indexes(context[i], selector.opts);
                        }

                        for (j = 0, jen = items.length; j < jen; j++) {
                            item = items[j];

                            if (type === 'cell') {
                                ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
                            }
                            else {
                                ret = fn.call(apiInst, context[i], item, i, j, rows);
                            }

                            if (ret !== undefined) {
                                a.push(ret);
                            }
                        }
                    }
                }

                if (a.length || alwaysNew) {
                    var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
                    var apiSelector = api.selector;
                    apiSelector.rows = selector.rows;
                    apiSelector.cols = selector.cols;
                    apiSelector.opts = selector.opts;
                    return api;
                }
                return this;
            },


            lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
                // Bit cheeky...
                return this.indexOf.apply(this.toArray.reverse(), arguments);
            },


            length: 0,


            map: function (fn) {
                var a = [];

                if (__arrayProto.map) {
                    a = __arrayProto.map.call(this, fn, this);
                }
                else {
                    // Compatibility for browsers without EMCA-252-5 (JS 1.6)
                    for (var i = 0, ien = this.length; i < ien; i++) {
                        a.push(fn.call(this, this[i], i));
                    }
                }

                return new _Api(this.context, a);
            },


            pluck: function (prop) {
                return this.map(function (el) {
                    return el[prop];
                });
            },

            pop: __arrayProto.pop,


            push: __arrayProto.push,


            // Does not return an API instance
            reduce: __arrayProto.reduce || function (fn, init) {
                return _fnReduce(this, fn, init, 0, this.length, 1);
            },


            reduceRight: __arrayProto.reduceRight || function (fn, init) {
                return _fnReduce(this, fn, init, this.length - 1, -1, -1);
            },


            reverse: __arrayProto.reverse,


            // Object with rows, columns and opts
            selector: null,


            shift: __arrayProto.shift,


            slice: function () {
                return new _Api(this.context, this);
            },


            sort: __arrayProto.sort, // ? name - order?


            splice: __arrayProto.splice,


            toArray: function () {
                return __arrayProto.slice.call(this);
            },


            to$: function () {
                return $(this);
            },


            toJQuery: function () {
                return $(this);
            },


            unique: function () {
                return new _Api(this.context, _unique(this));
            },


            unshift: __arrayProto.unshift
        });


        _Api.extend = function (scope, obj, ext) {
            // Only extend API instances and static properties of the API
            if (!ext.length || !obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {
                return;
            }

            var
                i, ien,
                j, jen,
                struct, inner,
                methodScoping = function (scope, fn, struc) {
                    return function () {
                        var ret = fn.apply(scope, arguments);

                        // Method extension
                        _Api.extend(ret, ret, struc.methodExt);
                        return ret;
                    };
                };

            for (i = 0, ien = ext.length; i < ien; i++) {
                struct = ext[i];

                // Value
                obj[struct.name] = typeof struct.val === 'function' ?
                    methodScoping(scope, struct.val, struct) :
                    $.isPlainObject(struct.val) ?
                        {} :
                        struct.val;

                obj[struct.name].__dt_wrapper = true;

                // Property extension
                _Api.extend(scope, obj[struct.name], struct.propExt);
            }
        };


        // @todo - Is there need for an augment function?
        // _Api.augment = function ( inst, name )
        // {
        // 	// Find src object in the structure from the name
        // 	var parts = name.split('.');

        // 	_Api.extend( inst, obj );
        // };


        //     [
        //       {
        //         name:      'data'                -- string   - Property name
        //         val:       function () {},       -- function - Api method (or undefined if just an object
        //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
        //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
        //       },
        //       {
        //         name:     'row'
        //         val:       {},
        //         methodExt: [ ... ],
        //         propExt:   [
        //           {
        //             name:      'data'
        //             val:       function () {},
        //             methodExt: [ ... ],
        //             propExt:   [ ... ]
        //           },
        //           ...
        //         ]
        //       }
        //     ]

        _Api.register = _api_register = function (name, val) {
            if ($.isArray(name)) {
                for (var j = 0, jen = name.length; j < jen; j++) {
                    _Api.register(name[j], val);
                }
                return;
            }

            var
                i, ien,
                heir = name.split('.'),
                struct = __apiStruct,
                key, method;

            var find = function (src, name) {
                for (var i = 0, ien = src.length; i < ien; i++) {
                    if (src[i].name === name) {
                        return src[i];
                    }
                }
                return null;
            };

            for (i = 0, ien = heir.length; i < ien; i++) {
                method = heir[i].indexOf('()') !== -1;
                key = method ?
                    heir[i].replace('()', '') :
                    heir[i];

                var src = find(struct, key);
                if (!src) {
                    src = {
                        name: key,
                        val: {},
                        methodExt: [],
                        propExt: []
                    };
                    struct.push(src);
                }

                if (i === ien - 1) {
                    src.val = val;
                }
                else {
                    struct = method ?
                        src.methodExt :
                        src.propExt;
                }
            }
        };


        _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
            _Api.register(pluralName, val);

            _Api.register(singularName, function () {
                var ret = val.apply(this, arguments);

                if (ret === this) {
                    // Returned item is the API instance that was passed in, return it
                    return this;
                }
                else if (ret instanceof _Api) {
                    // New API instance returned, want the value from the first item
                    // in the returned array for the singular result.
                    return ret.length ?
                        $.isArray(ret[0]) ?
                            new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
                            ret[0] :
                        undefined;
                }

                // Non-API return - just fire it back
                return ret;
            });
        };


        /**
         * Selector for HTML tables. Apply the given selector to the give array of
         * DataTables settings objects.
         *
         * @param {string|integer} [selector] jQuery selector string or integer
         * @param  {array} Array of DataTables settings objects to be filtered
         * @return {array}
         * @ignore
         */
        var __table_selector = function (selector, a) {
            // Integer is used to pick out a table by index
            if (typeof selector === 'number') {
                return [a[selector]];
            }

            // Perform a jQuery selector on the table nodes
            var nodes = $.map(a, function (el, i) {
                return el.nTable;
            });

            return $(nodes)
                .filter(selector)
                .map(function (i) {
                    // Need to translate back from the table node to the settings
                    var idx = $.inArray(this, nodes);
                    return a[idx];
                })
                .toArray();
        };



        /**
         * Context selector for the API's context (i.e. the tables the API instance
         * refers to.
         *
         * @name    DataTable.Api#tables
         * @param {string|integer} [selector] Selector to pick which tables the iterator
         *   should operate on. If not given, all tables in the current context are
         *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
         *   select multiple tables or as an integer to select a single table.
         * @returns {DataTable.Api} Returns a new API instance if a selector is given.
         */
        _api_register('tables()', function (selector) {
            // A new instance is created if there was a selector specified
            return selector ?
                new _Api(__table_selector(selector, this.context)) :
                this;
        });


        _api_register('table()', function (selector) {
            var tables = this.tables(selector);
            var ctx = tables.context;

            // Truncate to the first matched table
            return ctx.length ?
                new _Api(ctx[0]) :
                tables;
        });


        _api_registerPlural('tables().nodes()', 'table().node()', function () {
            return this.iterator('table', function (ctx) {
                return ctx.nTable;
            }, 1);
        });


        _api_registerPlural('tables().body()', 'table().body()', function () {
            return this.iterator('table', function (ctx) {
                return ctx.nTBody;
            }, 1);
        });


        _api_registerPlural('tables().header()', 'table().header()', function () {
            return this.iterator('table', function (ctx) {
                return ctx.nTHead;
            }, 1);
        });


        _api_registerPlural('tables().footer()', 'table().footer()', function () {
            return this.iterator('table', function (ctx) {
                return ctx.nTFoot;
            }, 1);
        });


        _api_registerPlural('tables().containers()', 'table().container()', function () {
            return this.iterator('table', function (ctx) {
                return ctx.nTableWrapper;
            }, 1);
        });



        /**
         * Redraw the tables in the current context.
         */
        _api_register('draw()', function (paging) {
            return this.iterator('table', function (settings) {
                if (paging === 'page') {
                    _fnDraw(settings);
                }
                else {
                    if (typeof paging === 'string') {
                        paging = paging === 'full-hold' ?
                            false :
                            true;
                    }

                    _fnReDraw(settings, paging === false);
                }
            });
        });



        /**
         * Get the current page index.
         *
         * @return {integer} Current page index (zero based)
         *//**
        * Set the current page.
        *
        * Note that if you attempt to show a page which does not exist, DataTables will
        * not throw an error, but rather reset the paging.
        *
        * @param {integer|string} action The paging action to take. This can be one of:
        *  * `integer` - The page index to jump to
        *  * `string` - An action to take:
        *    * `first` - Jump to first page.
        *    * `next` - Jump to the next page
        *    * `previous` - Jump to previous page
        *    * `last` - Jump to the last page.
        * @returns {DataTables.Api} this
        */
        _api_register('page()', function (action) {
            if (action === undefined) {
                return this.page.info().page; // not an expensive call
            }

            // else, have an action to take on all tables
            return this.iterator('table', function (settings) {
                _fnPageChange(settings, action);
            });
        });


        /**
         * Paging information for the first table in the current context.
         *
         * If you require paging information for another table, use the `table()` method
         * with a suitable selector.
         *
         * @return {object} Object with the following properties set:
         *  * `page` - Current page index (zero based - i.e. the first page is `0`)
         *  * `pages` - Total number of pages
         *  * `start` - Display index for the first record shown on the current page
         *  * `end` - Display index for the last record shown on the current page
         *  * `length` - Display length (number of records). Note that generally `start
         *    + length = end`, but this is not always true, for example if there are
         *    only 2 records to show on the final page, with a length of 10.
         *  * `recordsTotal` - Full data set length
         *  * `recordsDisplay` - Data set length once the current filtering criterion
         *    are applied.
         */
        _api_register('page.info()', function (action) {
            if (this.context.length === 0) {
                return undefined;
            }

            var
                settings = this.context[0],
                start = settings._iDisplayStart,
                len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
                visRecords = settings.fnRecordsDisplay(),
                all = len === -1;

            return {
                "page": all ? 0 : Math.floor(start / len),
                "pages": all ? 1 : Math.ceil(visRecords / len),
                "start": start,
                "end": settings.fnDisplayEnd(),
                "length": len,
                "recordsTotal": settings.fnRecordsTotal(),
                "recordsDisplay": visRecords,
                "serverSide": _fnDataSource(settings) === 'ssp'
            };
        });


        /**
         * Get the current page length.
         *
         * @return {integer} Current page length. Note `-1` indicates that all records
         *   are to be shown.
         *//**
        * Set the current page length.
        *
        * @param {integer} Page length to set. Use `-1` to show all records.
        * @returns {DataTables.Api} this
        */
        _api_register('page.len()', function (len) {
            // Note that we can't call this function 'length()' because `length`
            // is a Javascript property of functions which defines how many arguments
            // the function expects.
            if (len === undefined) {
                return this.context.length !== 0 ?
                    this.context[0]._iDisplayLength :
                    undefined;
            }

            // else, set the page length
            return this.iterator('table', function (settings) {
                _fnLengthChange(settings, len);
            });
        });



        var __reload = function (settings, holdPosition, callback) {
            // Use the draw event to trigger a callback
            if (callback) {
                var api = new _Api(settings);

                api.one('draw', function () {
                    callback(api.ajax.json());
                });
            }

            if (_fnDataSource(settings) == 'ssp') {
                _fnReDraw(settings, holdPosition);
            }
            else {
                _fnProcessingDisplay(settings, true);

                // Cancel an existing request
                var xhr = settings.jqXHR;
                if (xhr && xhr.readyState !== 4) {
                    xhr.abort();
                }

                // Trigger xhr
                _fnBuildAjax(settings, [], function (json) {
                    _fnClearTable(settings);

                    var data = _fnAjaxDataSrc(settings, json);
                    for (var i = 0, ien = data.length; i < ien; i++) {
                        _fnAddData(settings, data[i]);
                    }

                    _fnReDraw(settings, holdPosition);
                    _fnProcessingDisplay(settings, false);
                });
            }
        };


        /**
         * Get the JSON response from the last Ajax request that DataTables made to the
         * server. Note that this returns the JSON from the first table in the current
         * context.
         *
         * @return {object} JSON received from the server.
         */
        _api_register('ajax.json()', function () {
            var ctx = this.context;

            if (ctx.length > 0) {
                return ctx[0].json;
            }

            // else return undefined;
        });


        /**
         * Get the data submitted in the last Ajax request
         */
        _api_register('ajax.params()', function () {
            var ctx = this.context;

            if (ctx.length > 0) {
                return ctx[0].oAjaxData;
            }

            // else return undefined;
        });


        /**
         * Reload tables from the Ajax data source. Note that this function will
         * automatically re-draw the table when the remote data has been loaded.
         *
         * @param {boolean} [reset=true] Reset (default) or hold the current paging
         *   position. A full re-sort and re-filter is performed when this method is
         *   called, which is why the pagination reset is the default action.
         * @returns {DataTables.Api} this
         */
        _api_register('ajax.reload()', function (callback, resetPaging) {
            return this.iterator('table', function (settings) {
                __reload(settings, resetPaging === false, callback);
            });
        });


        /**
         * Get the current Ajax URL. Note that this returns the URL from the first
         * table in the current context.
         *
         * @return {string} Current Ajax source URL
         *//**
        * Set the Ajax URL. Note that this will set the URL for all tables in the
        * current context.
        *
        * @param {string} url URL to set.
        * @returns {DataTables.Api} this
        */
        _api_register('ajax.url()', function (url) {
            var ctx = this.context;

            if (url === undefined) {
                // get
                if (ctx.length === 0) {
                    return undefined;
                }
                ctx = ctx[0];

                return ctx.ajax ?
                    $.isPlainObject(ctx.ajax) ?
                        ctx.ajax.url :
                        ctx.ajax :
                    ctx.sAjaxSource;
            }

            // set
            return this.iterator('table', function (settings) {
                if ($.isPlainObject(settings.ajax)) {
                    settings.ajax.url = url;
                }
                else {
                    settings.ajax = url;
                }
                // No need to consider sAjaxSource here since DataTables gives priority
                // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
                // value of `sAjaxSource` redundant.
            });
        });


        /**
         * Load data from the newly set Ajax URL. Note that this method is only
         * available when `ajax.url()` is used to set a URL. Additionally, this method
         * has the same effect as calling `ajax.reload()` but is provided for
         * convenience when setting a new URL. Like `ajax.reload()` it will
         * automatically redraw the table once the remote data has been loaded.
         *
         * @returns {DataTables.Api} this
         */
        _api_register('ajax.url().load()', function (callback, resetPaging) {
            // Same as a reload, but makes sense to present it for easy access after a
            // url change
            return this.iterator('table', function (ctx) {
                __reload(ctx, resetPaging === false, callback);
            });
        });




        var _selector_run = function (type, selector, selectFn, settings, opts) {
            var
                out = [], res,
                a, i, ien, j, jen,
                selectorType = typeof selector;

            // Can't just check for isArray here, as an API or jQuery instance might be
            // given with their array like look
            if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
                selector = [selector];
            }

            for (i = 0, ien = selector.length; i < ien; i++) {
                // Only split on simple strings - complex expressions will be jQuery selectors
                a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ?
                    selector[i].split(',') :
                    [selector[i]];

                for (j = 0, jen = a.length; j < jen; j++) {
                    res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

                    if (res && res.length) {
                        out = out.concat(res);
                    }
                }
            }

            // selector extensions
            var ext = _ext.selector[type];
            if (ext.length) {
                for (i = 0, ien = ext.length; i < ien; i++) {
                    out = ext[i](settings, opts, out);
                }
            }

            return _unique(out);
        };


        var _selector_opts = function (opts) {
            if (!opts) {
                opts = {};
            }

            // Backwards compatibility for 1.9- which used the terminology filter rather
            // than search
            if (opts.filter && opts.search === undefined) {
                opts.search = opts.filter;
            }

            return $.extend({
                search: 'none',
                order: 'current',
                page: 'all'
            }, opts);
        };


        var _selector_first = function (inst) {
            // Reduce the API instance to the first item found
            for (var i = 0, ien = inst.length; i < ien; i++) {
                if (inst[i].length > 0) {
                    // Assign the first element to the first item in the instance
                    // and truncate the instance and context
                    inst[0] = inst[i];
                    inst[0].length = 1;
                    inst.length = 1;
                    inst.context = [inst.context[i]];

                    return inst;
                }
            }

            // Not found - return an empty instance
            inst.length = 0;
            return inst;
        };


        var _selector_row_indexes = function (settings, opts) {
            var
                i, ien, tmp, a = [],
                displayFiltered = settings.aiDisplay,
                displayMaster = settings.aiDisplayMaster;

            var
                search = opts.search,  // none, applied, removed
                order = opts.order,   // applied, current, index (original - compatibility with 1.9)
                page = opts.page;    // all, current

            if (_fnDataSource(settings) == 'ssp') {
                // In server-side processing mode, most options are irrelevant since
                // rows not shown don't exist and the index order is the applied order
                // Removed is a special case - for consistency just return an empty
                // array
                return search === 'removed' ?
                    [] :
                    _range(0, displayMaster.length);
            }
            else if (page == 'current') {
                // Current page implies that order=current and fitler=applied, since it is
                // fairly senseless otherwise, regardless of what order and search actually
                // are
                for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
                    a.push(displayFiltered[i]);
                }
            }
            else if (order == 'current' || order == 'applied') {
                a = search == 'none' ?
                    displayMaster.slice() :                      // no search
                    search == 'applied' ?
                        displayFiltered.slice() :                // applied search
                        $.map(displayMaster, function (el, i) { // removed search
                            return $.inArray(el, displayFiltered) === -1 ? el : null;
                        });
            }
            else if (order == 'index' || order == 'original') {
                for (i = 0, ien = settings.aoData.length; i < ien; i++) {
                    if (search == 'none') {
                        a.push(i);
                    }
                    else { // applied | removed
                        tmp = $.inArray(i, displayFiltered);

                        if ((tmp === -1 && search == 'removed') ||
                            (tmp >= 0 && search == 'applied')) {
                            a.push(i);
                        }
                    }
                }
            }

            return a;
        };


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Rows
         *
         * {}          - no selector - use all available rows
         * {integer}   - row aoData index
         * {node}      - TR node
         * {string}    - jQuery selector to apply to the TR elements
         * {array}     - jQuery array of nodes, or simply an array of TR nodes
         *
         */


        var __row_selector = function (settings, selector, opts) {
            var rows;
            var run = function (sel) {
                var selInt = _intVal(sel);
                var i, ien;

                // Short cut - selector is a number and no options provided (default is
                // all records, so no need to check if the index is in there, since it
                // must be - dev error if the index doesn't exist).
                if (selInt !== null && !opts) {
                    return [selInt];
                }

                if (!rows) {
                    rows = _selector_row_indexes(settings, opts);
                }

                if (selInt !== null && $.inArray(selInt, rows) !== -1) {
                    // Selector - integer
                    return [selInt];
                }
                else if (sel === null || sel === undefined || sel === '') {
                    // Selector - none
                    return rows;
                }

                // Selector - function
                if (typeof sel === 'function') {
                    return $.map(rows, function (idx) {
                        var row = settings.aoData[idx];
                        return sel(idx, row._aData, row.nTr) ? idx : null;
                    });
                }

                // Get nodes in the order from the `rows` array with null values removed
                var nodes = _removeEmpty(
                    _pluck_order(settings.aoData, rows, 'nTr')
                );

                // Selector - node
                if (sel.nodeName) {
                    if (sel._DT_RowIndex !== undefined) {
                        return [sel._DT_RowIndex]; // Property added by DT for fast lookup
                    }
                    else if (sel._DT_CellIndex) {
                        return [sel._DT_CellIndex.row];
                    }
                    else {
                        var host = $(sel).closest('*[data-dt-row]');
                        return host.length ?
                            [host.data('dt-row')] :
                            [];
                    }
                }

                // ID selector. Want to always be able to select rows by id, regardless
                // of if the tr element has been created or not, so can't rely upon
                // jQuery here - hence a custom implementation. This does not match
                // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
                // but to select it using a CSS selector engine (like Sizzle or
                // querySelect) it would need to need to be escaped for some characters.
                // DataTables simplifies this for row selectors since you can select
                // only a row. A # indicates an id any anything that follows is the id -
                // unescaped.
                if (typeof sel === 'string' && sel.charAt(0) === '#') {
                    // get row index from id
                    var rowObj = settings.aIds[sel.replace(/^#/, '')];
                    if (rowObj !== undefined) {
                        return [rowObj.idx];
                    }

                    // need to fall through to jQuery in case there is DOM id that
                    // matches
                }

                // Selector - jQuery selector string, array of nodes or jQuery object/
                // As jQuery's .filter() allows jQuery objects to be passed in filter,
                // it also allows arrays, so this will cope with all three options
                return $(nodes)
                    .filter(sel)
                    .map(function () {
                        return this._DT_RowIndex;
                    })
                    .toArray();
            };

            return _selector_run('row', selector, run, settings, opts);
        };


        _api_register('rows()', function (selector, opts) {
            // argument shifting
            if (selector === undefined) {
                selector = '';
            }
            else if ($.isPlainObject(selector)) {
                opts = selector;
                selector = '';
            }

            opts = _selector_opts(opts);

            var inst = this.iterator('table', function (settings) {
                return __row_selector(settings, selector, opts);
            }, 1);

            // Want argument shifting here and in __row_selector?
            inst.selector.rows = selector;
            inst.selector.opts = opts;

            return inst;
        });

        _api_register('rows().nodes()', function () {
            return this.iterator('row', function (settings, row) {
                return settings.aoData[row].nTr || undefined;
            }, 1);
        });

        _api_register('rows().data()', function () {
            return this.iterator(true, 'rows', function (settings, rows) {
                return _pluck_order(settings.aoData, rows, '_aData');
            }, 1);
        });

        _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
            return this.iterator('row', function (settings, row) {
                var r = settings.aoData[row];
                return type === 'search' ? r._aFilterData : r._aSortData;
            }, 1);
        });

        _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
            return this.iterator('row', function (settings, row) {
                _fnInvalidate(settings, row, src);
            });
        });

        _api_registerPlural('rows().indexes()', 'row().index()', function () {
            return this.iterator('row', function (settings, row) {
                return row;
            }, 1);
        });

        _api_registerPlural('rows().ids()', 'row().id()', function (hash) {
            var a = [];
            var context = this.context;

            // `iterator` will drop undefined values, but in this case we want them
            for (var i = 0, ien = context.length; i < ien; i++) {
                for (var j = 0, jen = this[i].length; j < jen; j++) {
                    var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
                    a.push((hash === true ? '#' : '') + id);
                }
            }

            return new _Api(context, a);
        });

        _api_registerPlural('rows().remove()', 'row().remove()', function () {
            var that = this;

            this.iterator('row', function (settings, row, thatIdx) {
                var data = settings.aoData;
                var rowData = data[row];
                var i, ien, j, jen;
                var loopRow, loopCells;

                data.splice(row, 1);

                // Update the cached indexes
                for (i = 0, ien = data.length; i < ien; i++) {
                    loopRow = data[i];
                    loopCells = loopRow.anCells;

                    // Rows
                    if (loopRow.nTr !== null) {
                        loopRow.nTr._DT_RowIndex = i;
                    }

                    // Cells
                    if (loopCells !== null) {
                        for (j = 0, jen = loopCells.length; j < jen; j++) {
                            loopCells[j]._DT_CellIndex.row = i;
                        }
                    }
                }

                // Delete from the display arrays
                _fnDeleteIndex(settings.aiDisplayMaster, row);
                _fnDeleteIndex(settings.aiDisplay, row);
                _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes

                // For server-side processing tables - subtract the deleted row from the count
                if (settings._iRecordsDisplay > 0) {
                    settings._iRecordsDisplay--;
                }

                // Check for an 'overflow' they case for displaying the table
                _fnLengthOverflow(settings);

                // Remove the row's ID reference if there is one
                var id = settings.rowIdFn(rowData._aData);
                if (id !== undefined) {
                    delete settings.aIds[id];
                }
            });

            this.iterator('table', function (settings) {
                for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
                    settings.aoData[i].idx = i;
                }
            });

            return this;
        });


        _api_register('rows.add()', function (rows) {
            var newRows = this.iterator('table', function (settings) {
                var row, i, ien;
                var out = [];

                for (i = 0, ien = rows.length; i < ien; i++) {
                    row = rows[i];

                    if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
                        out.push(_fnAddTr(settings, row)[0]);
                    }
                    else {
                        out.push(_fnAddData(settings, row));
                    }
                }

                return out;
            }, 1);

            // Return an Api.rows() extended instance, so rows().nodes() etc can be used
            var modRows = this.rows(-1);
            modRows.pop();
            $.merge(modRows, newRows);

            return modRows;
        });





        /**
         *
         */
        _api_register('row()', function (selector, opts) {
            return _selector_first(this.rows(selector, opts));
        });


        _api_register('row().data()', function (data) {
            var ctx = this.context;

            if (data === undefined) {
                // Get
                return ctx.length && this.length ?
                    ctx[0].aoData[this[0]]._aData :
                    undefined;
            }

            // Set
            ctx[0].aoData[this[0]]._aData = data;

            // Automatically invalidate
            _fnInvalidate(ctx[0], this[0], 'data');

            return this;
        });


        _api_register('row().node()', function () {
            var ctx = this.context;

            return ctx.length && this.length ?
                ctx[0].aoData[this[0]].nTr || null :
                null;
        });


        _api_register('row.add()', function (row) {
            // Allow a jQuery object to be passed in - only a single row is added from
            // it though - the first element in the set
            if (row instanceof $ && row.length) {
                row = row[0];
            }

            var rows = this.iterator('table', function (settings) {
                if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
                    return _fnAddTr(settings, row)[0];
                }
                return _fnAddData(settings, row);
            });

            // Return an Api.rows() extended instance, with the newly added row selected
            return this.row(rows[0]);
        });



        var __details_add = function (ctx, row, data, klass) {
            // Convert to array of TR elements
            var rows = [];
            var addRow = function (r, k) {
                // Recursion to allow for arrays of jQuery objects
                if ($.isArray(r) || r instanceof $) {
                    for (var i = 0, ien = r.length; i < ien; i++) {
                        addRow(r[i], k);
                    }
                    return;
                }

                // If we get a TR element, then just add it directly - up to the dev
                // to add the correct number of columns etc
                if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
                    rows.push(r);
                }
                else {
                    // Otherwise create a row with a wrapper
                    var created = $('<tr><td/></tr>').addClass(k);
                    $('td', created)
                        .addClass(k)
                        .html(r)
                    [0].colSpan = _fnVisbleColumns(ctx);

                    rows.push(created[0]);
                }
            };

            addRow(data, klass);

            if (row._details) {
                row._details.detach();
            }

            row._details = $(rows);

            // If the children were already shown, that state should be retained
            if (row._detailsShow) {
                row._details.insertAfter(row.nTr);
            }
        };


        var __details_remove = function (api, idx) {
            var ctx = api.context;

            if (ctx.length) {
                var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

                if (row && row._details) {
                    row._details.remove();

                    row._detailsShow = undefined;
                    row._details = undefined;
                }
            }
        };


        var __details_display = function (api, show) {
            var ctx = api.context;

            if (ctx.length && api.length) {
                var row = ctx[0].aoData[api[0]];

                if (row._details) {
                    row._detailsShow = show;

                    if (show) {
                        row._details.insertAfter(row.nTr);
                    }
                    else {
                        row._details.detach();
                    }

                    __details_events(ctx[0]);
                }
            }
        };


        var __details_events = function (settings) {
            var api = new _Api(settings);
            var namespace = '.dt.DT_details';
            var drawEvent = 'draw' + namespace;
            var colvisEvent = 'column-visibility' + namespace;
            var destroyEvent = 'destroy' + namespace;
            var data = settings.aoData;

            api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

            if (_pluck(data, '_details').length > 0) {
                // On each draw, insert the required elements into the document
                api.on(drawEvent, function (e, ctx) {
                    if (settings !== ctx) {
                        return;
                    }

                    api.rows({ page: 'current' }).eq(0).each(function (idx) {
                        // Internal data grab
                        var row = data[idx];

                        if (row._detailsShow) {
                            row._details.insertAfter(row.nTr);
                        }
                    });
                });

                // Column visibility change - update the colspan
                api.on(colvisEvent, function (e, ctx, idx, vis) {
                    if (settings !== ctx) {
                        return;
                    }

                    // Update the colspan for the details rows (note, only if it already has
                    // a colspan)
                    var row, visible = _fnVisbleColumns(ctx);

                    for (var i = 0, ien = data.length; i < ien; i++) {
                        row = data[i];

                        if (row._details) {
                            row._details.children('td[colspan]').attr('colspan', visible);
                        }
                    }
                });

                // Table destroyed - nuke any child rows
                api.on(destroyEvent, function (e, ctx) {
                    if (settings !== ctx) {
                        return;
                    }

                    for (var i = 0, ien = data.length; i < ien; i++) {
                        if (data[i]._details) {
                            __details_remove(api, i);
                        }
                    }
                });
            }
        };

        // Strings for the method names to help minification
        var _emp = '';
        var _child_obj = _emp + 'row().child';
        var _child_mth = _child_obj + '()';

        // data can be:
        //  tr
        //  string
        //  jQuery or array of any of the above
        _api_register(_child_mth, function (data, klass) {
            var ctx = this.context;

            if (data === undefined) {
                // get
                return ctx.length && this.length ?
                    ctx[0].aoData[this[0]]._details :
                    undefined;
            }
            else if (data === true) {
                // show
                this.child.show();
            }
            else if (data === false) {
                // remove
                __details_remove(this);
            }
            else if (ctx.length && this.length) {
                // set
                __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
            }

            return this;
        });


        _api_register([
            _child_obj + '.show()',
            _child_mth + '.show()' // only when `child()` was called with parameters (without
        ], function (show) {   // it returns an object and this method is not executed)
            __details_display(this, true);
            return this;
        });


        _api_register([
            _child_obj + '.hide()',
            _child_mth + '.hide()' // only when `child()` was called with parameters (without
        ], function () {         // it returns an object and this method is not executed)
            __details_display(this, false);
            return this;
        });


        _api_register([
            _child_obj + '.remove()',
            _child_mth + '.remove()' // only when `child()` was called with parameters (without
        ], function () {           // it returns an object and this method is not executed)
            __details_remove(this);
            return this;
        });


        _api_register(_child_obj + '.isShown()', function () {
            var ctx = this.context;

            if (ctx.length && this.length) {
                // _detailsShown as false or undefined will fall through to return false
                return ctx[0].aoData[this[0]]._detailsShow || false;
            }
            return false;
        });



        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Columns
         *
         * {integer}           - column index (>=0 count from left, <0 count from right)
         * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
         * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
         * "{string}:name"     - column name
         * "{string}"          - jQuery selector on column header nodes
         *
         */

        // can be an array of these items, comma separated list, or an array of comma
        // separated lists

        var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;


        // r1 and r2 are redundant - but it means that the parameters match for the
        // iterator callback in columns().data()
        var __columnData = function (settings, column, r1, r2, rows) {
            var a = [];
            for (var row = 0, ien = rows.length; row < ien; row++) {
                a.push(_fnGetCellData(settings, rows[row], column));
            }
            return a;
        };


        var __column_selector = function (settings, selector, opts) {
            var
                columns = settings.aoColumns,
                names = _pluck(columns, 'sName'),
                nodes = _pluck(columns, 'nTh');

            var run = function (s) {
                var selInt = _intVal(s);

                // Selector - all
                if (s === '') {
                    return _range(columns.length);
                }

                // Selector - index
                if (selInt !== null) {
                    return [selInt >= 0 ?
                        selInt : // Count from left
                        columns.length + selInt // Count from right (+ because its a negative value)
                    ];
                }

                // Selector = function
                if (typeof s === 'function') {
                    var rows = _selector_row_indexes(settings, opts);

                    return $.map(columns, function (col, idx) {
                        return s(
                            idx,
                            __columnData(settings, idx, 0, 0, rows),
                            nodes[idx]
                        ) ? idx : null;
                    });
                }

                // jQuery or string selector
                var match = typeof s === 'string' ?
                    s.match(__re_column_selector) :
                    '';

                if (match) {
                    switch (match[2]) {
                        case 'visIdx':
                        case 'visible':
                            var idx = parseInt(match[1], 10);
                            // Visible index given, convert to column index
                            if (idx < 0) {
                                // Counting from the right
                                var visColumns = $.map(columns, function (col, i) {
                                    return col.bVisible ? i : null;
                                });
                                return [visColumns[visColumns.length + idx]];
                            }
                            // Counting from the left
                            return [_fnVisibleToColumnIndex(settings, idx)];

                        case 'name':
                            // match by name. `names` is column index complete and in order
                            return $.map(names, function (name, i) {
                                return name === match[1] ? i : null;
                            });

                        default:
                            return [];
                    }
                }

                // Cell in the table body
                if (s.nodeName && s._DT_CellIndex) {
                    return [s._DT_CellIndex.column];
                }

                // jQuery selector on the TH elements for the columns
                var jqResult = $(nodes)
                    .filter(s)
                    .map(function () {
                        return $.inArray(this, nodes); // `nodes` is column index complete and in order
                    })
                    .toArray();

                if (jqResult.length || !s.nodeName) {
                    return jqResult;
                }

                // Otherwise a node which might have a `dt-column` data attribute, or be
                // a child or such an element
                var host = $(s).closest('*[data-dt-column]');
                return host.length ?
                    [host.data('dt-column')] :
                    [];
            };

            return _selector_run('column', selector, run, settings, opts);
        };


        var __setColumnVis = function (settings, column, vis) {
            var
                cols = settings.aoColumns,
                col = cols[column],
                data = settings.aoData,
                row, cells, i, ien, tr;

            // Get
            if (vis === undefined) {
                return col.bVisible;
            }

            // Set
            // No change
            if (col.bVisible === vis) {
                return;
            }

            if (vis) {
                // Insert column
                // Need to decide if we should use appendChild or insertBefore
                var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

                for (i = 0, ien = data.length; i < ien; i++) {
                    tr = data[i].nTr;
                    cells = data[i].anCells;

                    if (tr) {
                        // insertBefore can act like appendChild if 2nd arg is null
                        tr.insertBefore(cells[column], cells[insertBefore] || null);
                    }
                }
            }
            else {
                // Remove column
                $(_pluck(settings.aoData, 'anCells', column)).detach();
            }

            // Common actions
            col.bVisible = vis;
            _fnDrawHead(settings, settings.aoHeader);
            _fnDrawHead(settings, settings.aoFooter);

            _fnSaveState(settings);
        };


        _api_register('columns()', function (selector, opts) {
            // argument shifting
            if (selector === undefined) {
                selector = '';
            }
            else if ($.isPlainObject(selector)) {
                opts = selector;
                selector = '';
            }

            opts = _selector_opts(opts);

            var inst = this.iterator('table', function (settings) {
                return __column_selector(settings, selector, opts);
            }, 1);

            // Want argument shifting here and in _row_selector?
            inst.selector.cols = selector;
            inst.selector.opts = opts;

            return inst;
        });

        _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
            return this.iterator('column', function (settings, column) {
                return settings.aoColumns[column].nTh;
            }, 1);
        });

        _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
            return this.iterator('column', function (settings, column) {
                return settings.aoColumns[column].nTf;
            }, 1);
        });

        _api_registerPlural('columns().data()', 'column().data()', function () {
            return this.iterator('column-rows', __columnData, 1);
        });

        _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
            return this.iterator('column', function (settings, column) {
                return settings.aoColumns[column].mData;
            }, 1);
        });

        _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
            return this.iterator('column-rows', function (settings, column, i, j, rows) {
                return _pluck_order(settings.aoData, rows,
                    type === 'search' ? '_aFilterData' : '_aSortData', column
                );
            }, 1);
        });

        _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
            return this.iterator('column-rows', function (settings, column, i, j, rows) {
                return _pluck_order(settings.aoData, rows, 'anCells', column);
            }, 1);
        });

        _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
            var ret = this.iterator('column', function (settings, column) {
                if (vis === undefined) {
                    return settings.aoColumns[column].bVisible;
                } // else
                __setColumnVis(settings, column, vis);
            });

            // Group the column visibility changes
            if (vis !== undefined) {
                // Second loop once the first is done for events
                this.iterator('column', function (settings, column) {
                    _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
                });

                if (calc === undefined || calc) {
                    this.columns.adjust();
                }
            }

            return ret;
        });

        _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
            return this.iterator('column', function (settings, column) {
                return type === 'visible' ?
                    _fnColumnIndexToVisible(settings, column) :
                    column;
            }, 1);
        });

        _api_register('columns.adjust()', function () {
            return this.iterator('table', function (settings) {
                _fnAdjustColumnSizing(settings);
            }, 1);
        });

        _api_register('column.index()', function (type, idx) {
            if (this.context.length !== 0) {
                var ctx = this.context[0];

                if (type === 'fromVisible' || type === 'toData') {
                    return _fnVisibleToColumnIndex(ctx, idx);
                }
                else if (type === 'fromData' || type === 'toVisible') {
                    return _fnColumnIndexToVisible(ctx, idx);
                }
            }
        });

        _api_register('column()', function (selector, opts) {
            return _selector_first(this.columns(selector, opts));
        });



        var __cell_selector = function (settings, selector, opts) {
            var data = settings.aoData;
            var rows = _selector_row_indexes(settings, opts);
            var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
            var allCells = $([].concat.apply([], cells));
            var row;
            var columns = settings.aoColumns.length;
            var a, i, ien, j, o, host;

            var run = function (s) {
                var fnSelector = typeof s === 'function';

                if (s === null || s === undefined || fnSelector) {
                    // All cells and function selectors
                    a = [];

                    for (i = 0, ien = rows.length; i < ien; i++) {
                        row = rows[i];

                        for (j = 0; j < columns; j++) {
                            o = {
                                row: row,
                                column: j
                            };

                            if (fnSelector) {
                                // Selector - function
                                host = data[row];

                                if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                                    a.push(o);
                                }
                            }
                            else {
                                // Selector - all
                                a.push(o);
                            }
                        }
                    }

                    return a;
                }

                // Selector - index
                if ($.isPlainObject(s)) {
                    return [s];
                }

                // Selector - jQuery filtered cells
                var jqResult = allCells
                    .filter(s)
                    .map(function (i, el) {
                        return { // use a new object, in case someone changes the values
                            row: el._DT_CellIndex.row,
                            column: el._DT_CellIndex.column
                        };
                    })
                    .toArray();

                if (jqResult.length || !s.nodeName) {
                    return jqResult;
                }

                // Otherwise the selector is a node, and there is one last option - the
                // element might be a child of an element which has dt-row and dt-column
                // data attributes
                host = $(s).closest('*[data-dt-row]');
                return host.length ?
                    [{
                        row: host.data('dt-row'),
                        column: host.data('dt-column')
                    }] :
                    [];
            };

            return _selector_run('cell', selector, run, settings, opts);
        };




        _api_register('cells()', function (rowSelector, columnSelector, opts) {
            // Argument shifting
            if ($.isPlainObject(rowSelector)) {
                // Indexes
                if (rowSelector.row === undefined) {
                    // Selector options in first parameter
                    opts = rowSelector;
                    rowSelector = null;
                }
                else {
                    // Cell index objects in first parameter
                    opts = columnSelector;
                    columnSelector = null;
                }
            }
            if ($.isPlainObject(columnSelector)) {
                opts = columnSelector;
                columnSelector = null;
            }

            // Cell selector
            if (columnSelector === null || columnSelector === undefined) {
                return this.iterator('table', function (settings) {
                    return __cell_selector(settings, rowSelector, _selector_opts(opts));
                });
            }

            // Row + column selector
            var columns = this.columns(columnSelector, opts);
            var rows = this.rows(rowSelector, opts);
            var a, i, ien, j, jen;

            var cells = this.iterator('table', function (settings, idx) {
                a = [];

                for (i = 0, ien = rows[idx].length; i < ien; i++) {
                    for (j = 0, jen = columns[idx].length; j < jen; j++) {
                        a.push({
                            row: rows[idx][i],
                            column: columns[idx][j]
                        });
                    }
                }

                return a;
            }, 1);

            $.extend(cells.selector, {
                cols: columnSelector,
                rows: rowSelector,
                opts: opts
            });

            return cells;
        });


        _api_registerPlural('cells().nodes()', 'cell().node()', function () {
            return this.iterator('cell', function (settings, row, column) {
                var data = settings.aoData[row];

                return data && data.anCells ?
                    data.anCells[column] :
                    undefined;
            }, 1);
        });


        _api_register('cells().data()', function () {
            return this.iterator('cell', function (settings, row, column) {
                return _fnGetCellData(settings, row, column);
            }, 1);
        });


        _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
            type = type === 'search' ? '_aFilterData' : '_aSortData';

            return this.iterator('cell', function (settings, row, column) {
                return settings.aoData[row][type][column];
            }, 1);
        });


        _api_registerPlural('cells().render()', 'cell().render()', function (type) {
            return this.iterator('cell', function (settings, row, column) {
                return _fnGetCellData(settings, row, column, type);
            }, 1);
        });


        _api_registerPlural('cells().indexes()', 'cell().index()', function () {
            return this.iterator('cell', function (settings, row, column) {
                return {
                    row: row,
                    column: column,
                    columnVisible: _fnColumnIndexToVisible(settings, column)
                };
            }, 1);
        });


        _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
            return this.iterator('cell', function (settings, row, column) {
                _fnInvalidate(settings, row, src, column);
            });
        });



        _api_register('cell()', function (rowSelector, columnSelector, opts) {
            return _selector_first(this.cells(rowSelector, columnSelector, opts));
        });


        _api_register('cell().data()', function (data) {
            var ctx = this.context;
            var cell = this[0];

            if (data === undefined) {
                // Get
                return ctx.length && cell.length ?
                    _fnGetCellData(ctx[0], cell[0].row, cell[0].column) :
                    undefined;
            }

            // Set
            _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
            _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

            return this;
        });



        /**
         * Get current ordering (sorting) that has been applied to the table.
         *
         * @returns {array} 2D array containing the sorting information for the first
         *   table in the current context. Each element in the parent array represents
         *   a column being sorted upon (i.e. multi-sorting with two columns would have
         *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
         *   the column index that the sorting condition applies to, the second is the
         *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
         *   index of the sorting order from the `column.sorting` initialisation array.
         *//**
        * Set the ordering for the table.
        *
        * @param {integer} order Column index to sort upon.
        * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
        * @returns {DataTables.Api} this
        *//**
        * Set the ordering for the table.
        *
        * @param {array} order 1D array of sorting information to be applied.
        * @param {array} [...] Optional additional sorting conditions
        * @returns {DataTables.Api} this
        *//**
        * Set the ordering for the table.
        *
        * @param {array} order 2D array of sorting information to be applied.
        * @returns {DataTables.Api} this
        */
        _api_register('order()', function (order, dir) {
            var ctx = this.context;

            if (order === undefined) {
                // get
                return ctx.length !== 0 ?
                    ctx[0].aaSorting :
                    undefined;
            }

            // set
            if (typeof order === 'number') {
                // Simple column / direction passed in
                order = [[order, dir]];
            }
            else if (order.length && !$.isArray(order[0])) {
                // Arguments passed in (list of 1D arrays)
                order = Array.prototype.slice.call(arguments);
            }
            // otherwise a 2D array was passed in

            return this.iterator('table', function (settings) {
                settings.aaSorting = order.slice();
            });
        });


        /**
         * Attach a sort listener to an element for a given column
         *
         * @param {node|jQuery|string} node Identifier for the element(s) to attach the
         *   listener to. This can take the form of a single DOM node, a jQuery
         *   collection of nodes or a jQuery selector which will identify the node(s).
         * @param {integer} column the column that a click on this node will sort on
         * @param {function} [callback] callback function when sort is run
         * @returns {DataTables.Api} this
         */
        _api_register('order.listener()', function (node, column, callback) {
            return this.iterator('table', function (settings) {
                _fnSortAttachListener(settings, node, column, callback);
            });
        });


        _api_register('order.fixed()', function (set) {
            if (!set) {
                var ctx = this.context;
                var fixed = ctx.length ?
                    ctx[0].aaSortingFixed :
                    undefined;

                return $.isArray(fixed) ?
                    { pre: fixed } :
                    fixed;
            }

            return this.iterator('table', function (settings) {
                settings.aaSortingFixed = $.extend(true, {}, set);
            });
        });


        // Order by the selected column(s)
        _api_register([
            'columns().order()',
            'column().order()'
        ], function (dir) {
            var that = this;

            return this.iterator('table', function (settings, i) {
                var sort = [];

                $.each(that[i], function (j, col) {
                    sort.push([col, dir]);
                });

                settings.aaSorting = sort;
            });
        });



        _api_register('search()', function (input, regex, smart, caseInsen) {
            var ctx = this.context;

            if (input === undefined) {
                // get
                return ctx.length !== 0 ?
                    ctx[0].oPreviousSearch.sSearch :
                    undefined;
            }

            // set
            return this.iterator('table', function (settings) {
                if (!settings.oFeatures.bFilter) {
                    return;
                }

                _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
                    "sSearch": input + "",
                    "bRegex": regex === null ? false : regex,
                    "bSmart": smart === null ? true : smart,
                    "bCaseInsensitive": caseInsen === null ? true : caseInsen
                }), 1);
            });
        });


        _api_registerPlural(
            'columns().search()',
            'column().search()',
            function (input, regex, smart, caseInsen) {
                return this.iterator('column', function (settings, column) {
                    var preSearch = settings.aoPreSearchCols;

                    if (input === undefined) {
                        // get
                        return preSearch[column].sSearch;
                    }

                    // set
                    if (!settings.oFeatures.bFilter) {
                        return;
                    }

                    $.extend(preSearch[column], {
                        "sSearch": input + "",
                        "bRegex": regex === null ? false : regex,
                        "bSmart": smart === null ? true : smart,
                        "bCaseInsensitive": caseInsen === null ? true : caseInsen
                    });

                    _fnFilterComplete(settings, settings.oPreviousSearch, 1);
                });
            }
        );

        /*
         * State API methods
         */

        _api_register('state()', function () {
            return this.context.length ?
                this.context[0].oSavedState :
                null;
        });


        _api_register('state.clear()', function () {
            return this.iterator('table', function (settings) {
                // Save an empty object
                settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
            });
        });


        _api_register('state.loaded()', function () {
            return this.context.length ?
                this.context[0].oLoadedState :
                null;
        });


        _api_register('state.save()', function () {
            return this.iterator('table', function (settings) {
                _fnSaveState(settings);
            });
        });



        /**
         * Provide a common method for plug-ins to check the version of DataTables being
         * used, in order to ensure compatibility.
         *
         *  @param {string} version Version string to check for, in the format "X.Y.Z".
         *    Note that the formats "X" and "X.Y" are also acceptable.
         *  @returns {boolean} true if this version of DataTables is greater or equal to
         *    the required version, or false if this version of DataTales is not
         *    suitable
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
         */
        DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
            var aThis = DataTable.version.split('.');
            var aThat = version.split('.');
            var iThis, iThat;

            for (var i = 0, iLen = aThat.length; i < iLen; i++) {
                iThis = parseInt(aThis[i], 10) || 0;
                iThat = parseInt(aThat[i], 10) || 0;

                // Parts are the same, keep comparing
                if (iThis === iThat) {
                    continue;
                }

                // Parts are different, return immediately
                return iThis > iThat;
            }

            return true;
        };


        /**
         * Check if a `<table>` node is a DataTable table already or not.
         *
         *  @param {node|jquery|string} table Table node, jQuery object or jQuery
         *      selector for the table to test. Note that if more than more than one
         *      table is passed on, only the first will be checked
         *  @returns {boolean} true the table given is a DataTable, or false otherwise
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
         *      $('#example').dataTable();
         *    }
         */
        DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
            var t = $(table).get(0);
            var is = false;

            if (table instanceof DataTable.Api) {
                return true;
            }

            $.each(DataTable.settings, function (i, o) {
                var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
                var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

                if (o.nTable === t || head === t || foot === t) {
                    is = true;
                }
            });

            return is;
        };


        /**
         * Get all DataTable tables that have been initialised - optionally you can
         * select to get only currently visible tables.
         *
         *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
         *    or visible tables only.
         *  @returns {array} Array of `table` nodes (not DataTable instances) which are
         *    DataTables
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    $.each( $.fn.dataTable.tables(true), function () {
         *      $(table).DataTable().columns.adjust();
         *    } );
         */
        DataTable.tables = DataTable.fnTables = function (visible) {
            var api = false;

            if ($.isPlainObject(visible)) {
                api = visible.api;
                visible = visible.visible;
            }

            var a = $.map(DataTable.settings, function (o) {
                if (!visible || (visible && $(o.nTable).is(':visible'))) {
                    return o.nTable;
                }
            });

            return api ?
                new _Api(a) :
                a;
        };


        /**
         * Convert from camel case parameters to Hungarian notation. This is made public
         * for the extensions to provide the same ability as DataTables core to accept
         * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
         * parameters.
         *
         *  @param {object} src The model object which holds all parameters that can be
         *    mapped.
         *  @param {object} user The object to convert from camel case to Hungarian.
         *  @param {boolean} force When set to `true`, properties which already have a
         *    Hungarian value in the `user` object will be overwritten. Otherwise they
         *    won't be.
         */
        DataTable.camelToHungarian = _fnCamelToHungarian;



        /**
         *
         */
        _api_register('$()', function (selector, opts) {
            var
                rows = this.rows(opts).nodes(), // Get all rows
                jqRows = $(rows);

            return $([].concat(
                jqRows.filter(selector).toArray(),
                jqRows.find(selector).toArray()
            ));
        });


        // jQuery functions to operate on the tables
        $.each(['on', 'one', 'off'], function (i, key) {
            _api_register(key + '()', function ( /* event, handler */) {
                var args = Array.prototype.slice.call(arguments);

                // Add the `dt` namespace automatically if it isn't already present
                args[0] = $.map(args[0].split(/\s/), function (e) {
                    return !e.match(/\.dt\b/) ?
                        e + '.dt' :
                        e;
                }).join(' ');

                var inst = $(this.tables().nodes());
                inst[key].apply(inst, args);
                return this;
            });
        });


        _api_register('clear()', function () {
            return this.iterator('table', function (settings) {
                _fnClearTable(settings);
            });
        });


        _api_register('settings()', function () {
            return new _Api(this.context, this.context);
        });


        _api_register('init()', function () {
            var ctx = this.context;
            return ctx.length ? ctx[0].oInit : null;
        });


        _api_register('data()', function () {
            return this.iterator('table', function (settings) {
                return _pluck(settings.aoData, '_aData');
            }).flatten();
        });


        _api_register('destroy()', function (remove) {
            remove = remove || false;

            return this.iterator('table', function (settings) {
                var orig = settings.nTableWrapper.parentNode;
                var classes = settings.oClasses;
                var table = settings.nTable;
                var tbody = settings.nTBody;
                var thead = settings.nTHead;
                var tfoot = settings.nTFoot;
                var jqTable = $(table);
                var jqTbody = $(tbody);
                var jqWrapper = $(settings.nTableWrapper);
                var rows = $.map(settings.aoData, function (r) { return r.nTr; });
                var i, ien;

                // Flag to note that the table is currently being destroyed - no action
                // should be taken
                settings.bDestroying = true;

                // Fire off the destroy callbacks for plug-ins etc
                _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);

                // If not being removed from the document, make all columns visible
                if (!remove) {
                    new _Api(settings).columns().visible(true);
                }

                // Blitz all `DT` namespaced events (these are internal events, the
                // lowercase, `dt` events are user subscribed and they are responsible
                // for removing them
                jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
                $(window).off('.DT-' + settings.sInstance);

                // When scrolling we had to break the table up - restore it
                if (table != thead.parentNode) {
                    jqTable.children('thead').detach();
                    jqTable.append(thead);
                }

                if (tfoot && table != tfoot.parentNode) {
                    jqTable.children('tfoot').detach();
                    jqTable.append(tfoot);
                }

                settings.aaSorting = [];
                settings.aaSortingFixed = [];
                _fnSortingClasses(settings);

                $(rows).removeClass(settings.asStripeClasses.join(' '));

                $('th, td', thead).removeClass(classes.sSortable + ' ' +
                    classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone
                );

                // Add the TR elements back into the table in their original order
                jqTbody.children().detach();
                jqTbody.append(rows);

                // Remove the DataTables generated nodes, events and classes
                var removedMethod = remove ? 'remove' : 'detach';
                jqTable[removedMethod]();
                jqWrapper[removedMethod]();

                // If we need to reattach the table to the document
                if (!remove && orig) {
                    // insertBefore acts like appendChild if !arg[1]
                    orig.insertBefore(table, settings.nTableReinsertBefore);

                    // Restore the width of the original table - was read from the style property,
                    // so we can restore directly to that
                    jqTable
                        .css('width', settings.sDestroyWidth)
                        .removeClass(classes.sTable);

                    // If the were originally stripe classes - then we add them back here.
                    // Note this is not fool proof (for example if not all rows had stripe
                    // classes - but it's a good effort without getting carried away
                    ien = settings.asDestroyStripes.length;

                    if (ien) {
                        jqTbody.children().each(function (i) {
                            $(this).addClass(settings.asDestroyStripes[i % ien]);
                        });
                    }
                }

                /* Remove the settings object from the settings array */
                var idx = $.inArray(settings, DataTable.settings);
                if (idx !== -1) {
                    DataTable.settings.splice(idx, 1);
                }
            });
        });


        // Add the `every()` method for rows, columns and cells in a compact form
        $.each(['column', 'row', 'cell'], function (i, type) {
            _api_register(type + 's().every()', function (fn) {
                var opts = this.selector.opts;
                var api = this;

                return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
                    // Rows and columns:
                    //  arg1 - index
                    //  arg2 - table counter
                    //  arg3 - loop counter
                    //  arg4 - undefined
                    // Cells:
                    //  arg1 - row index
                    //  arg2 - column index
                    //  arg3 - table counter
                    //  arg4 - loop counter
                    fn.call(
                        api[type](
                            arg1,
                            type === 'cell' ? arg2 : opts,
                            type === 'cell' ? opts : undefined
                        ),
                        arg1, arg2, arg3, arg4
                    );
                });
            });
        });


        // i18n method for extensions to be able to use the language object from the
        // DataTable
        _api_register('i18n()', function (token, def, plural) {
            var ctx = this.context[0];
            var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

            if (resolved === undefined) {
                resolved = def;
            }

            if (plural !== undefined && $.isPlainObject(resolved)) {
                resolved = resolved[plural] !== undefined ?
                    resolved[plural] :
                    resolved._;
            }

            return resolved.replace('%d', plural); // nb: plural might be undefined,
        });

        /**
         * Version string for plug-ins to check compatibility. Allowed format is
         * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
         * only for non-release builds. See http://semver.org/ for more information.
         *  @member
         *  @type string
         *  @default Version number
         */
        DataTable.version = "1.10.16";

        /**
         * Private data store, containing all of the settings objects that are
         * created for the tables on a given page.
         *
         * Note that the `DataTable.settings` object is aliased to
         * `jQuery.fn.dataTableExt` through which it may be accessed and
         * manipulated, or `jQuery.fn.dataTable.settings`.
         *  @member
         *  @type array
         *  @default []
         *  @private
         */
        DataTable.settings = [];

        /**
         * Object models container, for the various models that DataTables has
         * available to it. These models define the objects that are used to hold
         * the active state and configuration of the table.
         *  @namespace
         */
        DataTable.models = {};



        /**
         * Template object for the way in which DataTables holds information about
         * search information for the global filter and individual column filters.
         *  @namespace
         */
        DataTable.models.oSearch = {
            /**
             * Flag to indicate if the filtering should be case insensitive or not
             *  @type boolean
             *  @default true
             */
            "bCaseInsensitive": true,

            /**
             * Applied search term
             *  @type string
             *  @default <i>Empty string</i>
             */
            "sSearch": "",

            /**
             * Flag to indicate if the search term should be interpreted as a
             * regular expression (true) or not (false) and therefore and special
             * regex characters escaped.
             *  @type boolean
             *  @default false
             */
            "bRegex": false,

            /**
             * Flag to indicate if DataTables is to use its smart filtering or not.
             *  @type boolean
             *  @default true
             */
            "bSmart": true
        };




        /**
         * Template object for the way in which DataTables holds information about
         * each individual row. This is the object format used for the settings
         * aoData array.
         *  @namespace
         */
        DataTable.models.oRow = {
            /**
             * TR element for the row
             *  @type node
             *  @default null
             */
            "nTr": null,

            /**
             * Array of TD elements for each row. This is null until the row has been
             * created.
             *  @type array nodes
             *  @default []
             */
            "anCells": null,

            /**
             * Data object from the original data source for the row. This is either
             * an array if using the traditional form of DataTables, or an object if
             * using mData options. The exact type will depend on the passed in
             * data from the data source, or will be an array if using DOM a data
             * source.
             *  @type array|object
             *  @default []
             */
            "_aData": [],

            /**
             * Sorting data cache - this array is ostensibly the same length as the
             * number of columns (although each index is generated only as it is
             * needed), and holds the data that is used for sorting each column in the
             * row. We do this cache generation at the start of the sort in order that
             * the formatting of the sort data need be done only once for each cell
             * per sort. This array should not be read from or written to by anything
             * other than the master sorting methods.
             *  @type array
             *  @default null
             *  @private
             */
            "_aSortData": null,

            /**
             * Per cell filtering data cache. As per the sort data cache, used to
             * increase the performance of the filtering in DataTables
             *  @type array
             *  @default null
             *  @private
             */
            "_aFilterData": null,

            /**
             * Filtering data cache. This is the same as the cell filtering cache, but
             * in this case a string rather than an array. This is easily computed with
             * a join on `_aFilterData`, but is provided as a cache so the join isn't
             * needed on every search (memory traded for performance)
             *  @type array
             *  @default null
             *  @private
             */
            "_sFilterRow": null,

            /**
             * Cache of the class name that DataTables has applied to the row, so we
             * can quickly look at this variable rather than needing to do a DOM check
             * on className for the nTr property.
             *  @type string
             *  @default <i>Empty string</i>
             *  @private
             */
            "_sRowStripe": "",

            /**
             * Denote if the original data source was from the DOM, or the data source
             * object. This is used for invalidating data, so DataTables can
             * automatically read data from the original source, unless uninstructed
             * otherwise.
             *  @type string
             *  @default null
             *  @private
             */
            "src": null,

            /**
             * Index in the aoData array. This saves an indexOf lookup when we have the
             * object, but want to know the index
             *  @type integer
             *  @default -1
             *  @private
             */
            "idx": -1
        };


        /**
         * Template object for the column information object in DataTables. This object
         * is held in the settings aoColumns array and contains all the information that
         * DataTables needs about each individual column.
         *
         * Note that this object is related to {@link DataTable.defaults.column}
         * but this one is the internal data store for DataTables's cache of columns.
         * It should NOT be manipulated outside of DataTables. Any configuration should
         * be done through the initialisation options.
         *  @namespace
         */
        DataTable.models.oColumn = {
            /**
             * Column index. This could be worked out on-the-fly with $.inArray, but it
             * is faster to just hold it as a variable
             *  @type integer
             *  @default null
             */
            "idx": null,

            /**
             * A list of the columns that sorting should occur on when this column
             * is sorted. That this property is an array allows multi-column sorting
             * to be defined for a column (for example first name / last name columns
             * would benefit from this). The values are integers pointing to the
             * columns to be sorted on (typically it will be a single integer pointing
             * at itself, but that doesn't need to be the case).
             *  @type array
             */
            "aDataSort": null,

            /**
             * Define the sorting directions that are applied to the column, in sequence
             * as the column is repeatedly sorted upon - i.e. the first value is used
             * as the sorting direction when the column if first sorted (clicked on).
             * Sort it again (click again) and it will move on to the next index.
             * Repeat until loop.
             *  @type array
             */
            "asSorting": null,

            /**
             * Flag to indicate if the column is searchable, and thus should be included
             * in the filtering or not.
             *  @type boolean
             */
            "bSearchable": null,

            /**
             * Flag to indicate if the column is sortable or not.
             *  @type boolean
             */
            "bSortable": null,

            /**
             * Flag to indicate if the column is currently visible in the table or not
             *  @type boolean
             */
            "bVisible": null,

            /**
             * Store for manual type assignment using the `column.type` option. This
             * is held in store so we can manipulate the column's `sType` property.
             *  @type string
             *  @default null
             *  @private
             */
            "_sManualType": null,

            /**
             * Flag to indicate if HTML5 data attributes should be used as the data
             * source for filtering or sorting. True is either are.
             *  @type boolean
             *  @default false
             *  @private
             */
            "_bAttrSrc": false,

            /**
             * Developer definable function that is called whenever a cell is created (Ajax source,
             * etc) or processed for input (DOM source). This can be used as a compliment to mRender
             * allowing you to modify the DOM element (add background colour for example) when the
             * element is available.
             *  @type function
             *  @param {element} nTd The TD node that has been created
             *  @param {*} sData The Data for the cell
             *  @param {array|object} oData The data for the whole row
             *  @param {int} iRow The row index for the aoData data store
             *  @default null
             */
            "fnCreatedCell": null,

            /**
             * Function to get data from a cell in a column. You should <b>never</b>
             * access data directly through _aData internally in DataTables - always use
             * the method attached to this property. It allows mData to function as
             * required. This function is automatically assigned by the column
             * initialisation method
             *  @type function
             *  @param {array|object} oData The data array/object for the array
             *    (i.e. aoData[]._aData)
             *  @param {string} sSpecific The specific data type you want to get -
             *    'display', 'type' 'filter' 'sort'
             *  @returns {*} The data for the cell from the given row's data
             *  @default null
             */
            "fnGetData": null,

            /**
             * Function to set data for a cell in the column. You should <b>never</b>
             * set the data directly to _aData internally in DataTables - always use
             * this method. It allows mData to function as required. This function
             * is automatically assigned by the column initialisation method
             *  @type function
             *  @param {array|object} oData The data array/object for the array
             *    (i.e. aoData[]._aData)
             *  @param {*} sValue Value to set
             *  @default null
             */
            "fnSetData": null,

            /**
             * Property to read the value for the cells in the column from the data
             * source array / object. If null, then the default content is used, if a
             * function is given then the return from the function is used.
             *  @type function|int|string|null
             *  @default null
             */
            "mData": null,

            /**
             * Partner property to mData which is used (only when defined) to get
             * the data - i.e. it is basically the same as mData, but without the
             * 'set' option, and also the data fed to it is the result from mData.
             * This is the rendering method to match the data method of mData.
             *  @type function|int|string|null
             *  @default null
             */
            "mRender": null,

            /**
             * Unique header TH/TD element for this column - this is what the sorting
             * listener is attached to (if sorting is enabled.)
             *  @type node
             *  @default null
             */
            "nTh": null,

            /**
             * Unique footer TH/TD element for this column (if there is one). Not used
             * in DataTables as such, but can be used for plug-ins to reference the
             * footer for each column.
             *  @type node
             *  @default null
             */
            "nTf": null,

            /**
             * The class to apply to all TD elements in the table's TBODY for the column
             *  @type string
             *  @default null
             */
            "sClass": null,

            /**
             * When DataTables calculates the column widths to assign to each column,
             * it finds the longest string in each column and then constructs a
             * temporary table and reads the widths from that. The problem with this
             * is that "mmm" is much wider then "iiii", but the latter is a longer
             * string - thus the calculation can go wrong (doing it properly and putting
             * it into an DOM object and measuring that is horribly(!) slow). Thus as
             * a "work around" we provide this option. It will append its value to the
             * text that is found to be the longest string for the column - i.e. padding.
             *  @type string
             */
            "sContentPadding": null,

            /**
             * Allows a default value to be given for a column's data, and will be used
             * whenever a null data source is encountered (this can be because mData
             * is set to null, or because the data source itself is null).
             *  @type string
             *  @default null
             */
            "sDefaultContent": null,

            /**
             * Name for the column, allowing reference to the column by name as well as
             * by index (needs a lookup to work by name).
             *  @type string
             */
            "sName": null,

            /**
             * Custom sorting data type - defines which of the available plug-ins in
             * afnSortData the custom sorting will use - if any is defined.
             *  @type string
             *  @default std
             */
            "sSortDataType": 'std',

            /**
             * Class to be applied to the header element when sorting on this column
             *  @type string
             *  @default null
             */
            "sSortingClass": null,

            /**
             * Class to be applied to the header element when sorting on this column -
             * when jQuery UI theming is used.
             *  @type string
             *  @default null
             */
            "sSortingClassJUI": null,

            /**
             * Title of the column - what is seen in the TH element (nTh).
             *  @type string
             */
            "sTitle": null,

            /**
             * Column sorting and filtering type
             *  @type string
             *  @default null
             */
            "sType": null,

            /**
             * Width of the column
             *  @type string
             *  @default null
             */
            "sWidth": null,

            /**
             * Width of the column when it was first "encountered"
             *  @type string
             *  @default null
             */
            "sWidthOrig": null
        };


        /*
         * Developer note: The properties of the object below are given in Hungarian
         * notation, that was used as the interface for DataTables prior to v1.10, however
         * from v1.10 onwards the primary interface is camel case. In order to avoid
         * breaking backwards compatibility utterly with this change, the Hungarian
         * version is still, internally the primary interface, but is is not documented
         * - hence the @name tags in each doc comment. This allows a Javascript function
         * to create a map from Hungarian notation to camel case (going the other direction
         * would require each property to be listed, which would at around 3K to the size
         * of DataTables, while this method is about a 0.5K hit.
         *
         * Ultimately this does pave the way for Hungarian notation to be dropped
         * completely, but that is a massive amount of work and will break current
         * installs (therefore is on-hold until v2).
         */

        /**
         * Initialisation options that can be given to DataTables at initialisation
         * time.
         *  @namespace
         */
        DataTable.defaults = {
            /**
             * An array of data to use for the table, passed in at initialisation which
             * will be used in preference to any data which is already in the DOM. This is
             * particularly useful for constructing tables purely in Javascript, for
             * example with a custom Ajax call.
             *  @type array
             *  @default null
             *
             *  @dtopt Option
             *  @name DataTable.defaults.data
             *
             *  @example
             *    // Using a 2D array data source
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "data": [
             *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
             *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
             *        ],
             *        "columns": [
             *          { "title": "Engine" },
             *          { "title": "Browser" },
             *          { "title": "Platform" },
             *          { "title": "Version" },
             *          { "title": "Grade" }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using an array of objects as a data source (`data`)
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "data": [
             *          {
             *            "engine":   "Trident",
             *            "browser":  "Internet Explorer 4.0",
             *            "platform": "Win 95+",
             *            "version":  4,
             *            "grade":    "X"
             *          },
             *          {
             *            "engine":   "Trident",
             *            "browser":  "Internet Explorer 5.0",
             *            "platform": "Win 95+",
             *            "version":  5,
             *            "grade":    "C"
             *          }
             *        ],
             *        "columns": [
             *          { "title": "Engine",   "data": "engine" },
             *          { "title": "Browser",  "data": "browser" },
             *          { "title": "Platform", "data": "platform" },
             *          { "title": "Version",  "data": "version" },
             *          { "title": "Grade",    "data": "grade" }
             *        ]
             *      } );
             *    } );
             */
            "aaData": null,


            /**
             * If ordering is enabled, then DataTables will perform a first pass sort on
             * initialisation. You can define which column(s) the sort is performed
             * upon, and the sorting direction, with this variable. The `sorting` array
             * should contain an array for each column to be sorted initially containing
             * the column's index and a direction string ('asc' or 'desc').
             *  @type array
             *  @default [[0,'asc']]
             *
             *  @dtopt Option
             *  @name DataTable.defaults.order
             *
             *  @example
             *    // Sort by 3rd column first, and then 4th column
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "order": [[2,'asc'], [3,'desc']]
             *      } );
             *    } );
             *
             *    // No initial sorting
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "order": []
             *      } );
             *    } );
             */
            "aaSorting": [[0, 'asc']],


            /**
             * This parameter is basically identical to the `sorting` parameter, but
             * cannot be overridden by user interaction with the table. What this means
             * is that you could have a column (visible or hidden) which the sorting
             * will always be forced on first - any sorting after that (from the user)
             * will then be performed as required. This can be useful for grouping rows
             * together.
             *  @type array
             *  @default null
             *
             *  @dtopt Option
             *  @name DataTable.defaults.orderFixed
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "orderFixed": [[0,'asc']]
             *      } );
             *    } )
             */
            "aaSortingFixed": [],


            /**
             * DataTables can be instructed to load data to display in the table from a
             * Ajax source. This option defines how that Ajax call is made and where to.
             *
             * The `ajax` property has three different modes of operation, depending on
             * how it is defined. These are:
             *
             * * `string` - Set the URL from where the data should be loaded from.
             * * `object` - Define properties for `jQuery.ajax`.
             * * `function` - Custom data get function
             *
             * `string`
             * --------
             *
             * As a string, the `ajax` property simply defines the URL from which
             * DataTables will load data.
             *
             * `object`
             * --------
             *
             * As an object, the parameters in the object are passed to
             * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
             * of the Ajax request. DataTables has a number of default parameters which
             * you can override using this option. Please refer to the jQuery
             * documentation for a full description of the options available, although
             * the following parameters provide additional options in DataTables or
             * require special consideration:
             *
             * * `data` - As with jQuery, `data` can be provided as an object, but it
             *   can also be used as a function to manipulate the data DataTables sends
             *   to the server. The function takes a single parameter, an object of
             *   parameters with the values that DataTables has readied for sending. An
             *   object may be returned which will be merged into the DataTables
             *   defaults, or you can add the items to the object that was passed in and
             *   not return anything from the function. This supersedes `fnServerParams`
             *   from DataTables 1.9-.
             *
             * * `dataSrc` - By default DataTables will look for the property `data` (or
             *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
             *   from an Ajax source or for server-side processing - this parameter
             *   allows that property to be changed. You can use Javascript dotted
             *   object notation to get a data source for multiple levels of nesting, or
             *   it my be used as a function. As a function it takes a single parameter,
             *   the JSON returned from the server, which can be manipulated as
             *   required, with the returned value being that used by DataTables as the
             *   data source for the table. This supersedes `sAjaxDataProp` from
             *   DataTables 1.9-.
             *
             * * `success` - Should not be overridden it is used internally in
             *   DataTables. To manipulate / transform the data returned by the server
             *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
             *
             * `function`
             * ----------
             *
             * As a function, making the Ajax call is left up to yourself allowing
             * complete control of the Ajax request. Indeed, if desired, a method other
             * than Ajax could be used to obtain the required data, such as Web storage
             * or an AIR database.
             *
             * The function is given four parameters and no return is required. The
             * parameters are:
             *
             * 1. _object_ - Data to send to the server
             * 2. _function_ - Callback function that must be executed when the required
             *    data has been obtained. That data should be passed into the callback
             *    as the only parameter
             * 3. _object_ - DataTables settings object for the table
             *
             * Note that this supersedes `fnServerData` from DataTables 1.9-.
             *
             *  @type string|object|function
             *  @default null
             *
             *  @dtopt Option
             *  @name DataTable.defaults.ajax
             *  @since 1.10.0
             *
             * @example
             *   // Get JSON data from a file via Ajax.
             *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
             *   $('#example').dataTable( {
             *     "ajax": "data.json"
             *   } );
             *
             * @example
             *   // Get JSON data from a file via Ajax, using `dataSrc` to change
             *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
             *   $('#example').dataTable( {
             *     "ajax": {
             *       "url": "data.json",
             *       "dataSrc": "tableData"
             *     }
             *   } );
             *
             * @example
             *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
             *   // from a plain array rather than an array in an object
             *   $('#example').dataTable( {
             *     "ajax": {
             *       "url": "data.json",
             *       "dataSrc": ""
             *     }
             *   } );
             *
             * @example
             *   // Manipulate the data returned from the server - add a link to data
             *   // (note this can, should, be done using `render` for the column - this
             *   // is just a simple example of how the data can be manipulated).
             *   $('#example').dataTable( {
             *     "ajax": {
             *       "url": "data.json",
             *       "dataSrc": function ( json ) {
             *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
             *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
             *         }
             *         return json;
             *       }
             *     }
             *   } );
             *
             * @example
             *   // Add data to the request
             *   $('#example').dataTable( {
             *     "ajax": {
             *       "url": "data.json",
             *       "data": function ( d ) {
             *         return {
             *           "extra_search": $('#extra').val()
             *         };
             *       }
             *     }
             *   } );
             *
             * @example
             *   // Send request as POST
             *   $('#example').dataTable( {
             *     "ajax": {
             *       "url": "data.json",
             *       "type": "POST"
             *     }
             *   } );
             *
             * @example
             *   // Get the data from localStorage (could interface with a form for
             *   // adding, editing and removing rows).
             *   $('#example').dataTable( {
             *     "ajax": function (data, callback, settings) {
             *       callback(
             *         JSON.parse( localStorage.getItem('dataTablesData') )
             *       );
             *     }
             *   } );
             */
            "ajax": null,


            /**
             * This parameter allows you to readily specify the entries in the length drop
             * down menu that DataTables shows when pagination is enabled. It can be
             * either a 1D array of options which will be used for both the displayed
             * option and the value, or a 2D array which will use the array in the first
             * position as the value, and the array in the second position as the
             * displayed options (useful for language strings such as 'All').
             *
             * Note that the `pageLength` property will be automatically set to the
             * first value given in this array, unless `pageLength` is also provided.
             *  @type array
             *  @default [ 10, 25, 50, 100 ]
             *
             *  @dtopt Option
             *  @name DataTable.defaults.lengthMenu
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
             *      } );
             *    } );
             */
            "aLengthMenu": [10, 25, 50, 100],


            /**
             * The `columns` option in the initialisation parameter allows you to define
             * details about the way individual columns behave. For a full list of
             * column options that can be set, please see
             * {@link DataTable.defaults.column}. Note that if you use `columns` to
             * define your columns, you must have an entry in the array for every single
             * column that you have in your table (these can be null if you don't which
             * to specify any options).
             *  @member
             *
             *  @name DataTable.defaults.column
             */
            "aoColumns": null,

            /**
             * Very similar to `columns`, `columnDefs` allows you to target a specific
             * column, multiple columns, or all columns, using the `targets` property of
             * each object in the array. This allows great flexibility when creating
             * tables, as the `columnDefs` arrays can be of any length, targeting the
             * columns you specifically want. `columnDefs` may use any of the column
             * options available: {@link DataTable.defaults.column}, but it _must_
             * have `targets` defined in each object in the array. Values in the `targets`
             * array may be:
             *   <ul>
             *     <li>a string - class name will be matched on the TH for the column</li>
             *     <li>0 or a positive integer - column index counting from the left</li>
             *     <li>a negative integer - column index counting from the right</li>
             *     <li>the string "_all" - all columns (i.e. assign a default)</li>
             *   </ul>
             *  @member
             *
             *  @name DataTable.defaults.columnDefs
             */
            "aoColumnDefs": null,


            /**
             * Basically the same as `search`, this parameter defines the individual column
             * filtering state at initialisation time. The array must be of the same size
             * as the number of columns, and each element be an object with the parameters
             * `search` and `escapeRegex` (the latter is optional). 'null' is also
             * accepted and the default will be used.
             *  @type array
             *  @default []
             *
             *  @dtopt Option
             *  @name DataTable.defaults.searchCols
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "searchCols": [
             *          null,
             *          { "search": "My filter" },
             *          null,
             *          { "search": "^[0-9]", "escapeRegex": false }
             *        ]
             *      } );
             *    } )
             */
            "aoSearchCols": [],


            /**
             * An array of CSS classes that should be applied to displayed rows. This
             * array may be of any length, and DataTables will apply each class
             * sequentially, looping when required.
             *  @type array
             *  @default null <i>Will take the values determined by the `oClasses.stripe*`
             *    options</i>
             *
             *  @dtopt Option
             *  @name DataTable.defaults.stripeClasses
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
             *      } );
             *    } )
             */
            "asStripeClasses": null,


            /**
             * Enable or disable automatic column width calculation. This can be disabled
             * as an optimisation (it takes some time to calculate the widths) if the
             * tables widths are passed in using `columns`.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.autoWidth
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "autoWidth": false
             *      } );
             *    } );
             */
            "bAutoWidth": true,


            /**
             * Deferred rendering can provide DataTables with a huge speed boost when you
             * are using an Ajax or JS data source for the table. This option, when set to
             * true, will cause DataTables to defer the creation of the table elements for
             * each row until they are needed for a draw - saving a significant amount of
             * time.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Features
             *  @name DataTable.defaults.deferRender
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "ajax": "sources/arrays.txt",
             *        "deferRender": true
             *      } );
             *    } );
             */
            "bDeferRender": false,


            /**
             * Replace a DataTable which matches the given selector and replace it with
             * one which has the properties of the new initialisation object passed. If no
             * table matches the selector, then the new DataTable will be constructed as
             * per normal.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Options
             *  @name DataTable.defaults.destroy
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "srollY": "200px",
             *        "paginate": false
             *      } );
             *
             *      // Some time later....
             *      $('#example').dataTable( {
             *        "filter": false,
             *        "destroy": true
             *      } );
             *    } );
             */
            "bDestroy": false,


            /**
             * Enable or disable filtering of data. Filtering in DataTables is "smart" in
             * that it allows the end user to input multiple words (space separated) and
             * will match a row containing those words, even if not in the order that was
             * specified (this allow matching across multiple columns). Note that if you
             * wish to use filtering in DataTables this must remain 'true' - to remove the
             * default filtering input box and retain filtering abilities, please use
             * {@link DataTable.defaults.dom}.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.searching
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "searching": false
             *      } );
             *    } );
             */
            "bFilter": true,


            /**
             * Enable or disable the table information display. This shows information
             * about the data that is currently visible on the page, including information
             * about filtered data if that action is being performed.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.info
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "info": false
             *      } );
             *    } );
             */
            "bInfo": true,


            /**
             * Allows the end user to select the size of a formatted page from a select
             * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.lengthChange
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "lengthChange": false
             *      } );
             *    } );
             */
            "bLengthChange": true,


            /**
             * Enable or disable pagination.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.paging
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "paging": false
             *      } );
             *    } );
             */
            "bPaginate": true,


            /**
             * Enable or disable the display of a 'processing' indicator when the table is
             * being processed (e.g. a sort). This is particularly useful for tables with
             * large amounts of data where it can take a noticeable amount of time to sort
             * the entries.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Features
             *  @name DataTable.defaults.processing
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "processing": true
             *      } );
             *    } );
             */
            "bProcessing": false,


            /**
             * Retrieve the DataTables object for the given selector. Note that if the
             * table has already been initialised, this parameter will cause DataTables
             * to simply return the object that has already been set up - it will not take
             * account of any changes you might have made to the initialisation object
             * passed to DataTables (setting this parameter to true is an acknowledgement
             * that you understand this). `destroy` can be used to reinitialise a table if
             * you need.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Options
             *  @name DataTable.defaults.retrieve
             *
             *  @example
             *    $(document).ready( function() {
             *      initTable();
             *      tableActions();
             *    } );
             *
             *    function initTable ()
             *    {
             *      return $('#example').dataTable( {
             *        "scrollY": "200px",
             *        "paginate": false,
             *        "retrieve": true
             *      } );
             *    }
             *
             *    function tableActions ()
             *    {
             *      var table = initTable();
             *      // perform API operations with oTable
             *    }
             */
            "bRetrieve": false,


            /**
             * When vertical (y) scrolling is enabled, DataTables will force the height of
             * the table's viewport to the given height at all times (useful for layout).
             * However, this can look odd when filtering data down to a small data set,
             * and the footer is left "floating" further down. This parameter (when
             * enabled) will cause DataTables to collapse the table's viewport down when
             * the result set will fit within the given Y height.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Options
             *  @name DataTable.defaults.scrollCollapse
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "scrollY": "200",
             *        "scrollCollapse": true
             *      } );
             *    } );
             */
            "bScrollCollapse": false,


            /**
             * Configure DataTables to use server-side processing. Note that the
             * `ajax` parameter must also be given in order to give DataTables a
             * source to obtain the required data for each draw.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Features
             *  @dtopt Server-side
             *  @name DataTable.defaults.serverSide
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "serverSide": true,
             *        "ajax": "xhr.php"
             *      } );
             *    } );
             */
            "bServerSide": false,


            /**
             * Enable or disable sorting of columns. Sorting of individual columns can be
             * disabled by the `sortable` option for each column.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.ordering
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "ordering": false
             *      } );
             *    } );
             */
            "bSort": true,


            /**
             * Enable or display DataTables' ability to sort multiple columns at the
             * same time (activated by shift-click by the user).
             *  @type boolean
             *  @default true
             *
             *  @dtopt Options
             *  @name DataTable.defaults.orderMulti
             *
             *  @example
             *    // Disable multiple column sorting ability
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "orderMulti": false
             *      } );
             *    } );
             */
            "bSortMulti": true,


            /**
             * Allows control over whether DataTables should use the top (true) unique
             * cell that is found for a single column, or the bottom (false - default).
             * This is useful when using complex headers.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Options
             *  @name DataTable.defaults.orderCellsTop
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "orderCellsTop": true
             *      } );
             *    } );
             */
            "bSortCellsTop": false,


            /**
             * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
             * `sorting\_3` to the columns which are currently being sorted on. This is
             * presented as a feature switch as it can increase processing time (while
             * classes are removed and added) so for large data sets you might want to
             * turn this off.
             *  @type boolean
             *  @default true
             *
             *  @dtopt Features
             *  @name DataTable.defaults.orderClasses
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "orderClasses": false
             *      } );
             *    } );
             */
            "bSortClasses": true,


            /**
             * Enable or disable state saving. When enabled HTML5 `localStorage` will be
             * used to save table display information such as pagination information,
             * display length, filtering and sorting. As such when the end user reloads
             * the page the display display will match what thy had previously set up.
             *
             * Due to the use of `localStorage` the default state saving is not supported
             * in IE6 or 7. If state saving is required in those browsers, use
             * `stateSaveCallback` to provide a storage solution such as cookies.
             *  @type boolean
             *  @default false
             *
             *  @dtopt Features
             *  @name DataTable.defaults.stateSave
             *
             *  @example
             *    $(document).ready( function () {
             *      $('#example').dataTable( {
             *        "stateSave": true
             *      } );
             *    } );
             */
            "bStateSave": false,


            /**
             * This function is called when a TR element is created (and all TD child
             * elements have been inserted), or registered if using a DOM source, allowing
             * manipulation of the TR element (adding classes etc).
             *  @type function
             *  @param {node} row "TR" element for the current row
             *  @param {array} data Raw data array for this row
             *  @param {int} dataIndex The index of this row in the internal aoData array
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.createdRow
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "createdRow": function( row, data, dataIndex ) {
             *          // Bold the grade for all 'A' grade browsers
             *          if ( data[4] == "A" )
             *          {
             *            $('td:eq(4)', row).html( '<b>A</b>' );
             *          }
             *        }
             *      } );
             *    } );
             */
            "fnCreatedRow": null,


            /**
             * This function is called on every 'draw' event, and allows you to
             * dynamically modify any aspect you want about the created DOM.
             *  @type function
             *  @param {object} settings DataTables settings object
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.drawCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "drawCallback": function( settings ) {
             *          alert( 'DataTables has redrawn the table' );
             *        }
             *      } );
             *    } );
             */
            "fnDrawCallback": null,


            /**
             * Identical to fnHeaderCallback() but for the table footer this function
             * allows you to modify the table footer on every 'draw' event.
             *  @type function
             *  @param {node} foot "TR" element for the footer
             *  @param {array} data Full table data (as derived from the original HTML)
             *  @param {int} start Index for the current display starting point in the
             *    display array
             *  @param {int} end Index for the current display ending point in the
             *    display array
             *  @param {array int} display Index array to translate the visual position
             *    to the full data array
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.footerCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "footerCallback": function( tfoot, data, start, end, display ) {
             *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
             *        }
             *      } );
             *    } )
             */
            "fnFooterCallback": null,


            /**
             * When rendering large numbers in the information element for the table
             * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
             * to have a comma separator for the 'thousands' units (e.g. 1 million is
             * rendered as "1,000,000") to help readability for the end user. This
             * function will override the default method DataTables uses.
             *  @type function
             *  @member
             *  @param {int} toFormat number to be formatted
             *  @returns {string} formatted string for DataTables to show the number
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.formatNumber
             *
             *  @example
             *    // Format a number using a single quote for the separator (note that
             *    // this can also be done with the language.thousands option)
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "formatNumber": function ( toFormat ) {
             *          return toFormat.toString().replace(
             *            /\B(?=(\d{3})+(?!\d))/g, "'"
             *          );
             *        };
             *      } );
             *    } );
             */
            "fnFormatNumber": function (toFormat) {
                return toFormat.toString().replace(
                    /\B(?=(\d{3})+(?!\d))/g,
                    this.oLanguage.sThousands
                );
            },


            /**
             * This function is called on every 'draw' event, and allows you to
             * dynamically modify the header row. This can be used to calculate and
             * display useful information about the table.
             *  @type function
             *  @param {node} head "TR" element for the header
             *  @param {array} data Full table data (as derived from the original HTML)
             *  @param {int} start Index for the current display starting point in the
             *    display array
             *  @param {int} end Index for the current display ending point in the
             *    display array
             *  @param {array int} display Index array to translate the visual position
             *    to the full data array
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.headerCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "fheaderCallback": function( head, data, start, end, display ) {
             *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
             *        }
             *      } );
             *    } )
             */
            "fnHeaderCallback": null,


            /**
             * The information element can be used to convey information about the current
             * state of the table. Although the internationalisation options presented by
             * DataTables are quite capable of dealing with most customisations, there may
             * be times where you wish to customise the string further. This callback
             * allows you to do exactly that.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {int} start Starting position in data for the draw
             *  @param {int} end End position in data for the draw
             *  @param {int} max Total number of rows in the table (regardless of
             *    filtering)
             *  @param {int} total Total number of rows in the data set, after filtering
             *  @param {string} pre The string that DataTables has formatted using it's
             *    own rules
             *  @returns {string} The string to be displayed in the information element.
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.infoCallback
             *
             *  @example
             *    $('#example').dataTable( {
             *      "infoCallback": function( settings, start, end, max, total, pre ) {
             *        return start +" to "+ end;
             *      }
             *    } );
             */
            "fnInfoCallback": null,


            /**
             * Called when the table has been initialised. Normally DataTables will
             * initialise sequentially and there will be no need for this function,
             * however, this does not hold true when using external language information
             * since that is obtained using an async XHR call.
             *  @type function
             *  @param {object} settings DataTables settings object
             *  @param {object} json The JSON object request from the server - only
             *    present if client-side Ajax sourced data is used
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.initComplete
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "initComplete": function(settings, json) {
             *          alert( 'DataTables has finished its initialisation.' );
             *        }
             *      } );
             *    } )
             */
            "fnInitComplete": null,


            /**
             * Called at the very start of each table draw and can be used to cancel the
             * draw by returning false, any other return (including undefined) results in
             * the full draw occurring).
             *  @type function
             *  @param {object} settings DataTables settings object
             *  @returns {boolean} False will cancel the draw, anything else (including no
             *    return) will allow it to complete.
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.preDrawCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "preDrawCallback": function( settings ) {
             *          if ( $('#test').val() == 1 ) {
             *            return false;
             *          }
             *        }
             *      } );
             *    } );
             */
            "fnPreDrawCallback": null,


            /**
             * This function allows you to 'post process' each row after it have been
             * generated for each table draw, but before it is rendered on screen. This
             * function might be used for setting the row class name etc.
             *  @type function
             *  @param {node} row "TR" element for the current row
             *  @param {array} data Raw data array for this row
             *  @param {int} displayIndex The display index for the current table draw
             *  @param {int} displayIndexFull The index of the data in the full list of
             *    rows (after filtering)
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.rowCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
             *          // Bold the grade for all 'A' grade browsers
             *          if ( data[4] == "A" ) {
             *            $('td:eq(4)', row).html( '<b>A</b>' );
             *          }
             *        }
             *      } );
             *    } );
             */
            "fnRowCallback": null,


            /**
             * __Deprecated__ The functionality provided by this parameter has now been
             * superseded by that provided through `ajax`, which should be used instead.
             *
             * This parameter allows you to override the default function which obtains
             * the data from the server so something more suitable for your application.
             * For example you could use POST data, or pull information from a Gears or
             * AIR database.
             *  @type function
             *  @member
             *  @param {string} source HTTP source to obtain the data from (`ajax`)
             *  @param {array} data A key/value pair object containing the data to send
             *    to the server
             *  @param {function} callback to be called on completion of the data get
             *    process that will draw the data on the page.
             *  @param {object} settings DataTables settings object
             *
             *  @dtopt Callbacks
             *  @dtopt Server-side
             *  @name DataTable.defaults.serverData
             *
             *  @deprecated 1.10. Please use `ajax` for this functionality now.
             */
            "fnServerData": null,


            /**
             * __Deprecated__ The functionality provided by this parameter has now been
             * superseded by that provided through `ajax`, which should be used instead.
             *
             *  It is often useful to send extra data to the server when making an Ajax
             * request - for example custom filtering information, and this callback
             * function makes it trivial to send extra information to the server. The
             * passed in parameter is the data set that has been constructed by
             * DataTables, and you can add to this or modify it as you require.
             *  @type function
             *  @param {array} data Data array (array of objects which are name/value
             *    pairs) that has been constructed by DataTables and will be sent to the
             *    server. In the case of Ajax sourced data with server-side processing
             *    this will be an empty array, for server-side processing there will be a
             *    significant number of parameters!
             *  @returns {undefined} Ensure that you modify the data array passed in,
             *    as this is passed by reference.
             *
             *  @dtopt Callbacks
             *  @dtopt Server-side
             *  @name DataTable.defaults.serverParams
             *
             *  @deprecated 1.10. Please use `ajax` for this functionality now.
             */
            "fnServerParams": null,


            /**
             * Load the table state. With this function you can define from where, and how, the
             * state of a table is loaded. By default DataTables will load from `localStorage`
             * but you might wish to use a server-side database or cookies.
             *  @type function
             *  @member
             *  @param {object} settings DataTables settings object
             *  @param {object} callback Callback that can be executed when done. It
             *    should be passed the loaded state object.
             *  @return {object} The DataTables state object to be loaded
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.stateLoadCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateLoadCallback": function (settings, callback) {
             *          $.ajax( {
             *            "url": "/state_load",
             *            "dataType": "json",
             *            "success": function (json) {
             *              callback( json );
             *            }
             *          } );
             *        }
             *      } );
             *    } );
             */
            "fnStateLoadCallback": function (settings) {
                try {
                    return JSON.parse(
                        (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
                            'DataTables_' + settings.sInstance + '_' + location.pathname
                        )
                    );
                } catch (e) { }
            },


            /**
             * Callback which allows modification of the saved state prior to loading that state.
             * This callback is called when the table is loading state from the stored data, but
             * prior to the settings object being modified by the saved state. Note that for
             * plug-in authors, you should use the `stateLoadParams` event to load parameters for
             * a plug-in.
             *  @type function
             *  @param {object} settings DataTables settings object
             *  @param {object} data The state object that is to be loaded
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.stateLoadParams
             *
             *  @example
             *    // Remove a saved filter, so filtering is never loaded
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateLoadParams": function (settings, data) {
             *          data.oSearch.sSearch = "";
             *        }
             *      } );
             *    } );
             *
             *  @example
             *    // Disallow state loading by returning false
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateLoadParams": function (settings, data) {
             *          return false;
             *        }
             *      } );
             *    } );
             */
            "fnStateLoadParams": null,


            /**
             * Callback that is called when the state has been loaded from the state saving method
             * and the DataTables settings object has been modified as a result of the loaded state.
             *  @type function
             *  @param {object} settings DataTables settings object
             *  @param {object} data The state object that was loaded
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.stateLoaded
             *
             *  @example
             *    // Show an alert with the filtering value that was saved
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateLoaded": function (settings, data) {
             *          alert( 'Saved filter was: '+data.oSearch.sSearch );
             *        }
             *      } );
             *    } );
             */
            "fnStateLoaded": null,


            /**
             * Save the table state. This function allows you to define where and how the state
             * information for the table is stored By default DataTables will use `localStorage`
             * but you might wish to use a server-side database or cookies.
             *  @type function
             *  @member
             *  @param {object} settings DataTables settings object
             *  @param {object} data The state object to be saved
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.stateSaveCallback
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateSaveCallback": function (settings, data) {
             *          // Send an Ajax request to the server with the state object
             *          $.ajax( {
             *            "url": "/state_save",
             *            "data": data,
             *            "dataType": "json",
             *            "method": "POST"
             *            "success": function () {}
             *          } );
             *        }
             *      } );
             *    } );
             */
            "fnStateSaveCallback": function (settings, data) {
                try {
                    (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
                        'DataTables_' + settings.sInstance + '_' + location.pathname,
                        JSON.stringify(data)
                    );
                } catch (e) { }
            },


            /**
             * Callback which allows modification of the state to be saved. Called when the table
             * has changed state a new state save is required. This method allows modification of
             * the state saving object prior to actually doing the save, including addition or
             * other state properties or modification. Note that for plug-in authors, you should
             * use the `stateSaveParams` event to save parameters for a plug-in.
             *  @type function
             *  @param {object} settings DataTables settings object
             *  @param {object} data The state object to be saved
             *
             *  @dtopt Callbacks
             *  @name DataTable.defaults.stateSaveParams
             *
             *  @example
             *    // Remove a saved filter, so filtering is never saved
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateSave": true,
             *        "stateSaveParams": function (settings, data) {
             *          data.oSearch.sSearch = "";
             *        }
             *      } );
             *    } );
             */
            "fnStateSaveParams": null,


            /**
             * Duration for which the saved state information is considered valid. After this period
             * has elapsed the state will be returned to the default.
             * Value is given in seconds.
             *  @type int
             *  @default 7200 <i>(2 hours)</i>
             *
             *  @dtopt Options
             *  @name DataTable.defaults.stateDuration
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "stateDuration": 60*60*24; // 1 day
             *      } );
             *    } )
             */
            "iStateDuration": 7200,


            /**
             * When enabled DataTables will not make a request to the server for the first
             * page draw - rather it will use the data already on the page (no sorting etc
             * will be applied to it), thus saving on an XHR at load time. `deferLoading`
             * is used to indicate that deferred loading is required, but it is also used
             * to tell DataTables how many records there are in the full table (allowing
             * the information element and pagination to be displayed correctly). In the case
             * where a filtering is applied to the table on initial load, this can be
             * indicated by giving the parameter as an array, where the first element is
             * the number of records available after filtering and the second element is the
             * number of records without filtering (allowing the table information element
             * to be shown correctly).
             *  @type int | array
             *  @default null
             *
             *  @dtopt Options
             *  @name DataTable.defaults.deferLoading
             *
             *  @example
             *    // 57 records available in the table, no filtering applied
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "serverSide": true,
             *        "ajax": "scripts/server_processing.php",
             *        "deferLoading": 57
             *      } );
             *    } );
             *
             *  @example
             *    // 57 records after filtering, 100 without filtering (an initial filter applied)
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "serverSide": true,
             *        "ajax": "scripts/server_processing.php",
             *        "deferLoading": [ 57, 100 ],
             *        "search": {
             *          "search": "my_filter"
             *        }
             *      } );
             *    } );
             */
            "iDeferLoading": null,


            /**
             * Number of rows to display on a single page when using pagination. If
             * feature enabled (`lengthChange`) then the end user will be able to override
             * this to a custom setting using a pop-up menu.
             *  @type int
             *  @default 10
             *
             *  @dtopt Options
             *  @name DataTable.defaults.pageLength
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "pageLength": 50
             *      } );
             *    } )
             */
            "iDisplayLength": 10,


            /**
             * Define the starting point for data display when using DataTables with
             * pagination. Note that this parameter is the number of records, rather than
             * the page number, so if you have 10 records per page and want to start on
             * the third page, it should be "20".
             *  @type int
             *  @default 0
             *
             *  @dtopt Options
             *  @name DataTable.defaults.displayStart
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "displayStart": 20
             *      } );
             *    } )
             */
            "iDisplayStart": 0,


            /**
             * By default DataTables allows keyboard navigation of the table (sorting, paging,
             * and filtering) by adding a `tabindex` attribute to the required elements. This
             * allows you to tab through the controls and press the enter key to activate them.
             * The tabindex is default 0, meaning that the tab follows the flow of the document.
             * You can overrule this using this parameter if you wish. Use a value of -1 to
             * disable built-in keyboard navigation.
             *  @type int
             *  @default 0
             *
             *  @dtopt Options
             *  @name DataTable.defaults.tabIndex
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "tabIndex": 1
             *      } );
             *    } );
             */
            "iTabIndex": 0,


            /**
             * Classes that DataTables assigns to the various components and features
             * that it adds to the HTML table. This allows classes to be configured
             * during initialisation in addition to through the static
             * {@link DataTable.ext.oStdClasses} object).
             *  @namespace
             *  @name DataTable.defaults.classes
             */
            "oClasses": {},


            /**
             * All strings that DataTables uses in the user interface that it creates
             * are defined in this object, allowing you to modified them individually or
             * completely replace them all as required.
             *  @namespace
             *  @name DataTable.defaults.language
             */
            "oLanguage": {
                /**
                 * Strings that are used for WAI-ARIA labels and controls only (these are not
                 * actually visible on the page, but will be read by screenreaders, and thus
                 * must be internationalised as well).
                 *  @namespace
                 *  @name DataTable.defaults.language.aria
                 */
                "oAria": {
                    /**
                     * ARIA label that is added to the table headers when the column may be
                     * sorted ascending by activing the column (click or return when focused).
                     * Note that the column header is prefixed to this string.
                     *  @type string
                     *  @default : activate to sort column ascending
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.aria.sortAscending
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "aria": {
                     *            "sortAscending": " - click/return to sort ascending"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sSortAscending": ": activate to sort column ascending",

                    /**
                     * ARIA label that is added to the table headers when the column may be
                     * sorted descending by activing the column (click or return when focused).
                     * Note that the column header is prefixed to this string.
                     *  @type string
                     *  @default : activate to sort column ascending
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.aria.sortDescending
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "aria": {
                     *            "sortDescending": " - click/return to sort descending"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sSortDescending": ": activate to sort column descending"
                },

                /**
                 * Pagination string used by DataTables for the built-in pagination
                 * control types.
                 *  @namespace
                 *  @name DataTable.defaults.language.paginate
                 */
                "oPaginate": {
                    /**
                     * Text to use when using the 'full_numbers' type of pagination for the
                     * button to take the user to the first page.
                     *  @type string
                     *  @default First
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.paginate.first
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "paginate": {
                     *            "first": "First page"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sFirst": "First",


                    /**
                     * Text to use when using the 'full_numbers' type of pagination for the
                     * button to take the user to the last page.
                     *  @type string
                     *  @default Last
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.paginate.last
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "paginate": {
                     *            "last": "Last page"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sLast": "Last",


                    /**
                     * Text to use for the 'next' pagination button (to take the user to the
                     * next page).
                     *  @type string
                     *  @default Next
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.paginate.next
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "paginate": {
                     *            "next": "Next page"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sNext": "Next",


                    /**
                     * Text to use for the 'previous' pagination button (to take the user to
                     * the previous page).
                     *  @type string
                     *  @default Previous
                     *
                     *  @dtopt Language
                     *  @name DataTable.defaults.language.paginate.previous
                     *
                     *  @example
                     *    $(document).ready( function() {
                     *      $('#example').dataTable( {
                     *        "language": {
                     *          "paginate": {
                     *            "previous": "Previous page"
                     *          }
                     *        }
                     *      } );
                     *    } );
                     */
                    "sPrevious": "Previous"
                },

                /**
                 * This string is shown in preference to `zeroRecords` when the table is
                 * empty of data (regardless of filtering). Note that this is an optional
                 * parameter - if it is not given, the value of `zeroRecords` will be used
                 * instead (either the default or given value).
                 *  @type string
                 *  @default No data available in table
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.emptyTable
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "emptyTable": "No data available in table"
                 *        }
                 *      } );
                 *    } );
                 */
                "sEmptyTable": "No data available in table",


                /**
                 * This string gives information to the end user about the information
                 * that is current on display on the page. The following tokens can be
                 * used in the string and will be dynamically replaced as the table
                 * display updates. This tokens can be placed anywhere in the string, or
                 * removed as needed by the language requires:
                 *
                 * * `\_START\_` - Display index of the first record on the current page
                 * * `\_END\_` - Display index of the last record on the current page
                 * * `\_TOTAL\_` - Number of records in the table after filtering
                 * * `\_MAX\_` - Number of records in the table without filtering
                 * * `\_PAGE\_` - Current page number
                 * * `\_PAGES\_` - Total number of pages of data in the table
                 *
                 *  @type string
                 *  @default Showing _START_ to _END_ of _TOTAL_ entries
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.info
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "info": "Showing page _PAGE_ of _PAGES_"
                 *        }
                 *      } );
                 *    } );
                 */
                "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


                /**
                 * Display information string for when the table is empty. Typically the
                 * format of this string should match `info`.
                 *  @type string
                 *  @default Showing 0 to 0 of 0 entries
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.infoEmpty
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "infoEmpty": "No entries to show"
                 *        }
                 *      } );
                 *    } );
                 */
                "sInfoEmpty": "Showing 0 to 0 of 0 entries",


                /**
                 * When a user filters the information in a table, this string is appended
                 * to the information (`info`) to give an idea of how strong the filtering
                 * is. The variable _MAX_ is dynamically updated.
                 *  @type string
                 *  @default (filtered from _MAX_ total entries)
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.infoFiltered
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "infoFiltered": " - filtering from _MAX_ records"
                 *        }
                 *      } );
                 *    } );
                 */
                "sInfoFiltered": "(filtered from _MAX_ total entries)",


                /**
                 * If can be useful to append extra information to the info string at times,
                 * and this variable does exactly that. This information will be appended to
                 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
                 * being used) at all times.
                 *  @type string
                 *  @default <i>Empty string</i>
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.infoPostFix
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "infoPostFix": "All records shown are derived from real information."
                 *        }
                 *      } );
                 *    } );
                 */
                "sInfoPostFix": "",


                /**
                 * This decimal place operator is a little different from the other
                 * language options since DataTables doesn't output floating point
                 * numbers, so it won't ever use this for display of a number. Rather,
                 * what this parameter does is modify the sort methods of the table so
                 * that numbers which are in a format which has a character other than
                 * a period (`.`) as a decimal place will be sorted numerically.
                 *
                 * Note that numbers with different decimal places cannot be shown in
                 * the same table and still be sortable, the table must be consistent.
                 * However, multiple different tables on the page can use different
                 * decimal place characters.
                 *  @type string
                 *  @default 
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.decimal
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "decimal": ","
                 *          "thousands": "."
                 *        }
                 *      } );
                 *    } );
                 */
                "sDecimal": "",


                /**
                 * DataTables has a build in number formatter (`formatNumber`) which is
                 * used to format large numbers that are used in the table information.
                 * By default a comma is used, but this can be trivially changed to any
                 * character you wish with this parameter.
                 *  @type string
                 *  @default ,
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.thousands
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "thousands": "'"
                 *        }
                 *      } );
                 *    } );
                 */
                "sThousands": ",",


                /**
                 * Detail the action that will be taken when the drop down menu for the
                 * pagination length option is changed. The '_MENU_' variable is replaced
                 * with a default select list of 10, 25, 50 and 100, and can be replaced
                 * with a custom select box if required.
                 *  @type string
                 *  @default Show _MENU_ entries
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.lengthMenu
                 *
                 *  @example
                 *    // Language change only
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "lengthMenu": "Display _MENU_ records"
                 *        }
                 *      } );
                 *    } );
                 *
                 *  @example
                 *    // Language and options change
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "lengthMenu": 'Display <select>'+
                 *            '<option value="10">10</option>'+
                 *            '<option value="20">20</option>'+
                 *            '<option value="30">30</option>'+
                 *            '<option value="40">40</option>'+
                 *            '<option value="50">50</option>'+
                 *            '<option value="-1">All</option>'+
                 *            '</select> records'
                 *        }
                 *      } );
                 *    } );
                 */
                "sLengthMenu": "Show _MENU_ entries",


                /**
                 * When using Ajax sourced data and during the first draw when DataTables is
                 * gathering the data, this message is shown in an empty row in the table to
                 * indicate to the end user the the data is being loaded. Note that this
                 * parameter is not used when loading data by server-side processing, just
                 * Ajax sourced data with client-side processing.
                 *  @type string
                 *  @default Loading...
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.loadingRecords
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "loadingRecords": "Please wait - loading..."
                 *        }
                 *      } );
                 *    } );
                 */
                "sLoadingRecords": "Loading...",


                /**
                 * Text which is displayed when the table is processing a user action
                 * (usually a sort command or similar).
                 *  @type string
                 *  @default Processing...
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.processing
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "processing": "DataTables is currently busy"
                 *        }
                 *      } );
                 *    } );
                 */
                "sProcessing": "Processing...",


                /**
                 * Details the actions that will be taken when the user types into the
                 * filtering input text box. The variable "_INPUT_", if used in the string,
                 * is replaced with the HTML text box for the filtering input allowing
                 * control over where it appears in the string. If "_INPUT_" is not given
                 * then the input box is appended to the string automatically.
                 *  @type string
                 *  @default Search:
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.search
                 *
                 *  @example
                 *    // Input text box will be appended at the end automatically
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "search": "Filter records:"
                 *        }
                 *      } );
                 *    } );
                 *
                 *  @example
                 *    // Specify where the filter should appear
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "search": "Apply filter _INPUT_ to table"
                 *        }
                 *      } );
                 *    } );
                 */
                "sSearch": "Search:",


                /**
                 * Assign a `placeholder` attribute to the search `input` element
                 *  @type string
                 *  @default 
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.searchPlaceholder
                 */
                "sSearchPlaceholder": "",


                /**
                 * All of the language information can be stored in a file on the
                 * server-side, which DataTables will look up if this parameter is passed.
                 * It must store the URL of the language file, which is in a JSON format,
                 * and the object has the same properties as the oLanguage object in the
                 * initialiser object (i.e. the above parameters). Please refer to one of
                 * the example language files to see how this works in action.
                 *  @type string
                 *  @default <i>Empty string - i.e. disabled</i>
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.url
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
                 *        }
                 *      } );
                 *    } );
                 */
                "sUrl": "",


                /**
                 * Text shown inside the table records when the is no information to be
                 * displayed after filtering. `emptyTable` is shown when there is simply no
                 * information in the table at all (regardless of filtering).
                 *  @type string
                 *  @default No matching records found
                 *
                 *  @dtopt Language
                 *  @name DataTable.defaults.language.zeroRecords
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "language": {
                 *          "zeroRecords": "No records to display"
                 *        }
                 *      } );
                 *    } );
                 */
                "sZeroRecords": "No matching records found"
            },


            /**
             * This parameter allows you to have define the global filtering state at
             * initialisation time. As an object the `search` parameter must be
             * defined, but all other parameters are optional. When `regex` is true,
             * the search string will be treated as a regular expression, when false
             * (default) it will be treated as a straight string. When `smart`
             * DataTables will use it's smart filtering methods (to word match at
             * any point in the data), when false this will not be done.
             *  @namespace
             *  @extends DataTable.models.oSearch
             *
             *  @dtopt Options
             *  @name DataTable.defaults.search
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "search": {"search": "Initial search"}
             *      } );
             *    } )
             */
            "oSearch": $.extend({}, DataTable.models.oSearch),


            /**
             * __Deprecated__ The functionality provided by this parameter has now been
             * superseded by that provided through `ajax`, which should be used instead.
             *
             * By default DataTables will look for the property `data` (or `aaData` for
             * compatibility with DataTables 1.9-) when obtaining data from an Ajax
             * source or for server-side processing - this parameter allows that
             * property to be changed. You can use Javascript dotted object notation to
             * get a data source for multiple levels of nesting.
             *  @type string
             *  @default data
             *
             *  @dtopt Options
             *  @dtopt Server-side
             *  @name DataTable.defaults.ajaxDataProp
             *
             *  @deprecated 1.10. Please use `ajax` for this functionality now.
             */
            "sAjaxDataProp": "data",


            /**
             * __Deprecated__ The functionality provided by this parameter has now been
             * superseded by that provided through `ajax`, which should be used instead.
             *
             * You can instruct DataTables to load data from an external
             * source using this parameter (use aData if you want to pass data in you
             * already have). Simply provide a url a JSON object can be obtained from.
             *  @type string
             *  @default null
             *
             *  @dtopt Options
             *  @dtopt Server-side
             *  @name DataTable.defaults.ajaxSource
             *
             *  @deprecated 1.10. Please use `ajax` for this functionality now.
             */
            "sAjaxSource": null,


            /**
             * This initialisation variable allows you to specify exactly where in the
             * DOM you want DataTables to inject the various controls it adds to the page
             * (for example you might want the pagination controls at the top of the
             * table). DIV elements (with or without a custom class) can also be added to
             * aid styling. The follow syntax is used:
             *   <ul>
             *     <li>The following options are allowed:
             *       <ul>
             *         <li>'l' - Length changing</li>
             *         <li>'f' - Filtering input</li>
             *         <li>'t' - The table!</li>
             *         <li>'i' - Information</li>
             *         <li>'p' - Pagination</li>
             *         <li>'r' - pRocessing</li>
             *       </ul>
             *     </li>
             *     <li>The following constants are allowed:
             *       <ul>
             *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
             *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
             *       </ul>
             *     </li>
             *     <li>The following syntax is expected:
             *       <ul>
             *         <li>'&lt;' and '&gt;' - div elements</li>
             *         <li>'&lt;"class" and '&gt;' - div with a class</li>
             *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
             *       </ul>
             *     </li>
             *     <li>Examples:
             *       <ul>
             *         <li>'&lt;"wrapper"flipt&gt;'</li>
             *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
             *       </ul>
             *     </li>
             *   </ul>
             *  @type string
             *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
             *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
             *
             *  @dtopt Options
             *  @name DataTable.defaults.dom
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
             *      } );
             *    } );
             */
            "sDom": "lfrtip",


            /**
             * Search delay option. This will throttle full table searches that use the
             * DataTables provided search input element (it does not effect calls to
             * `dt-api search()`, providing a delay before the search is made.
             *  @type integer
             *  @default 0
             *
             *  @dtopt Options
             *  @name DataTable.defaults.searchDelay
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "searchDelay": 200
             *      } );
             *    } )
             */
            "searchDelay": null,


            /**
             * DataTables features six different built-in options for the buttons to
             * display for pagination control:
             *
             * * `numbers` - Page number buttons only
             * * `simple` - 'Previous' and 'Next' buttons only
             * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
             * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
             * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
             * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
             *  
             * Further methods can be added using {@link DataTable.ext.oPagination}.
             *  @type string
             *  @default simple_numbers
             *
             *  @dtopt Options
             *  @name DataTable.defaults.pagingType
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "pagingType": "full_numbers"
             *      } );
             *    } )
             */
            "sPaginationType": "simple_numbers",


            /**
             * Enable horizontal scrolling. When a table is too wide to fit into a
             * certain layout, or you have a large number of columns in the table, you
             * can enable x-scrolling to show the table in a viewport, which can be
             * scrolled. This property can be `true` which will allow the table to
             * scroll horizontally when needed, or any CSS unit, or a number (in which
             * case it will be treated as a pixel measurement). Setting as simply `true`
             * is recommended.
             *  @type boolean|string
             *  @default <i>blank string - i.e. disabled</i>
             *
             *  @dtopt Features
             *  @name DataTable.defaults.scrollX
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "scrollX": true,
             *        "scrollCollapse": true
             *      } );
             *    } );
             */
            "sScrollX": "",


            /**
             * This property can be used to force a DataTable to use more width than it
             * might otherwise do when x-scrolling is enabled. For example if you have a
             * table which requires to be well spaced, this parameter is useful for
             * "over-sizing" the table, and thus forcing scrolling. This property can by
             * any CSS unit, or a number (in which case it will be treated as a pixel
             * measurement).
             *  @type string
             *  @default <i>blank string - i.e. disabled</i>
             *
             *  @dtopt Options
             *  @name DataTable.defaults.scrollXInner
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "scrollX": "100%",
             *        "scrollXInner": "110%"
             *      } );
             *    } );
             */
            "sScrollXInner": "",


            /**
             * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
             * to the given height, and enable scrolling for any data which overflows the
             * current viewport. This can be used as an alternative to paging to display
             * a lot of data in a small area (although paging and scrolling can both be
             * enabled at the same time). This property can be any CSS unit, or a number
             * (in which case it will be treated as a pixel measurement).
             *  @type string
             *  @default <i>blank string - i.e. disabled</i>
             *
             *  @dtopt Features
             *  @name DataTable.defaults.scrollY
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "scrollY": "200px",
             *        "paginate": false
             *      } );
             *    } );
             */
            "sScrollY": "",


            /**
             * __Deprecated__ The functionality provided by this parameter has now been
             * superseded by that provided through `ajax`, which should be used instead.
             *
             * Set the HTTP method that is used to make the Ajax call for server-side
             * processing or Ajax sourced data.
             *  @type string
             *  @default GET
             *
             *  @dtopt Options
             *  @dtopt Server-side
             *  @name DataTable.defaults.serverMethod
             *
             *  @deprecated 1.10. Please use `ajax` for this functionality now.
             */
            "sServerMethod": "GET",


            /**
             * DataTables makes use of renderers when displaying HTML elements for
             * a table. These renderers can be added or modified by plug-ins to
             * generate suitable mark-up for a site. For example the Bootstrap
             * integration plug-in for DataTables uses a paging button renderer to
             * display pagination buttons in the mark-up required by Bootstrap.
             *
             * For further information about the renderers available see
             * DataTable.ext.renderer
             *  @type string|object
             *  @default null
             *
             *  @name DataTable.defaults.renderer
             *
             */
            "renderer": null,


            /**
             * Set the data property name that DataTables should use to get a row's id
             * to set as the `id` property in the node.
             *  @type string
             *  @default DT_RowId
             *
             *  @name DataTable.defaults.rowId
             */
            "rowId": "DT_RowId"
        };

        _fnHungarianMap(DataTable.defaults);



        /*
         * Developer note - See note in model.defaults.js about the use of Hungarian
         * notation and camel case.
         */

        /**
         * Column options that can be given to DataTables at initialisation time.
         *  @namespace
         */
        DataTable.defaults.column = {
            /**
             * Define which column(s) an order will occur on for this column. This
             * allows a column's ordering to take multiple columns into account when
             * doing a sort or use the data from a different column. For example first
             * name / last name columns make sense to do a multi-column sort over the
             * two columns.
             *  @type array|int
             *  @default null <i>Takes the value of the column index automatically</i>
             *
             *  @name DataTable.defaults.column.orderData
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
             *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
             *          { "orderData": 2, "targets": [ 2 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "orderData": [ 0, 1 ] },
             *          { "orderData": [ 1, 0 ] },
             *          { "orderData": 2 },
             *          null,
             *          null
             *        ]
             *      } );
             *    } );
             */
            "aDataSort": null,
            "iDataSort": -1,


            /**
             * You can control the default ordering direction, and even alter the
             * behaviour of the sort handler (i.e. only allow ascending ordering etc)
             * using this parameter.
             *  @type array
             *  @default [ 'asc', 'desc' ]
             *
             *  @name DataTable.defaults.column.orderSequence
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
             *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
             *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          null,
             *          { "orderSequence": [ "asc" ] },
             *          { "orderSequence": [ "desc", "asc", "asc" ] },
             *          { "orderSequence": [ "desc" ] },
             *          null
             *        ]
             *      } );
             *    } );
             */
            "asSorting": ['asc', 'desc'],


            /**
             * Enable or disable filtering on the data in this column.
             *  @type boolean
             *  @default true
             *
             *  @name DataTable.defaults.column.searchable
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "searchable": false, "targets": [ 0 ] }
             *        ] } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "searchable": false },
             *          null,
             *          null,
             *          null,
             *          null
             *        ] } );
             *    } );
             */
            "bSearchable": true,


            /**
             * Enable or disable ordering on this column.
             *  @type boolean
             *  @default true
             *
             *  @name DataTable.defaults.column.orderable
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "orderable": false, "targets": [ 0 ] }
             *        ] } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "orderable": false },
             *          null,
             *          null,
             *          null,
             *          null
             *        ] } );
             *    } );
             */
            "bSortable": true,


            /**
             * Enable or disable the display of this column.
             *  @type boolean
             *  @default true
             *
             *  @name DataTable.defaults.column.visible
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "visible": false, "targets": [ 0 ] }
             *        ] } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "visible": false },
             *          null,
             *          null,
             *          null,
             *          null
             *        ] } );
             *    } );
             */
            "bVisible": true,


            /**
             * Developer definable function that is called whenever a cell is created (Ajax source,
             * etc) or processed for input (DOM source). This can be used as a compliment to mRender
             * allowing you to modify the DOM element (add background colour for example) when the
             * element is available.
             *  @type function
             *  @param {element} td The TD node that has been created
             *  @param {*} cellData The Data for the cell
             *  @param {array|object} rowData The data for the whole row
             *  @param {int} row The row index for the aoData data store
             *  @param {int} col The column index for aoColumns
             *
             *  @name DataTable.defaults.column.createdCell
             *  @dtopt Columns
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [3],
             *          "createdCell": function (td, cellData, rowData, row, col) {
             *            if ( cellData == "1.7" ) {
             *              $(td).css('color', 'blue')
             *            }
             *          }
             *        } ]
             *      });
             *    } );
             */
            "fnCreatedCell": null,


            /**
             * This parameter has been replaced by `data` in DataTables to ensure naming
             * consistency. `dataProp` can still be used, as there is backwards
             * compatibility in DataTables for this option, but it is strongly
             * recommended that you use `data` in preference to `dataProp`.
             *  @name DataTable.defaults.column.dataProp
             */


            /**
             * This property can be used to read data from any data source property,
             * including deeply nested objects / properties. `data` can be given in a
             * number of different ways which effect its behaviour:
             *
             * * `integer` - treated as an array index for the data source. This is the
             *   default that DataTables uses (incrementally increased for each column).
             * * `string` - read an object property from the data source. There are
             *   three 'special' options that can be used in the string to alter how
             *   DataTables reads the data from the source object:
             *    * `.` - Dotted Javascript notation. Just as you use a `.` in
             *      Javascript to read from nested objects, so to can the options
             *      specified in `data`. For example: `browser.version` or
             *      `browser.name`. If your object parameter name contains a period, use
             *      `\\` to escape it - i.e. `first\\.name`.
             *    * `[]` - Array notation. DataTables can automatically combine data
             *      from and array source, joining the data with the characters provided
             *      between the two brackets. For example: `name[, ]` would provide a
             *      comma-space separated list from the source array. If no characters
             *      are provided between the brackets, the original array source is
             *      returned.
             *    * `()` - Function notation. Adding `()` to the end of a parameter will
             *      execute a function of the name given. For example: `browser()` for a
             *      simple function on the data source, `browser.version()` for a
             *      function in a nested property or even `browser().version` to get an
             *      object property if the function called returns an object. Note that
             *      function notation is recommended for use in `render` rather than
             *      `data` as it is much simpler to use as a renderer.
             * * `null` - use the original data source for the row rather than plucking
             *   data directly from it. This action has effects on two other
             *   initialisation options:
             *    * `defaultContent` - When null is given as the `data` option and
             *      `defaultContent` is specified for the column, the value defined by
             *      `defaultContent` will be used for the cell.
             *    * `render` - When null is used for the `data` option and the `render`
             *      option is specified for the column, the whole data source for the
             *      row is used for the renderer.
             * * `function` - the function given will be executed whenever DataTables
             *   needs to set or get the data for a cell in the column. The function
             *   takes three parameters:
             *    * Parameters:
             *      * `{array|object}` The data source for the row
             *      * `{string}` The type call data requested - this will be 'set' when
             *        setting data or 'filter', 'display', 'type', 'sort' or undefined
             *        when gathering data. Note that when `undefined` is given for the
             *        type DataTables expects to get the raw data for the object back<
             *      * `{*}` Data to set when the second parameter is 'set'.
             *    * Return:
             *      * The return value from the function is not required when 'set' is
             *        the type of call, but otherwise the return is what will be used
             *        for the data requested.
             *
             * Note that `data` is a getter and setter option. If you just require
             * formatting of data for output, you will likely want to use `render` which
             * is simply a getter and thus simpler to use.
             *
             * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
             * name change reflects the flexibility of this property and is consistent
             * with the naming of mRender. If 'mDataProp' is given, then it will still
             * be used by DataTables, as it automatically maps the old name to the new
             * if required.
             *
             *  @type string|int|function|null
             *  @default null <i>Use automatically calculated column index</i>
             *
             *  @name DataTable.defaults.column.data
             *  @dtopt Columns
             *
             *  @example
             *    // Read table data from objects
             *    // JSON structure for each row:
             *    //   {
             *    //      "engine": {value},
             *    //      "browser": {value},
             *    //      "platform": {value},
             *    //      "version": {value},
             *    //      "grade": {value}
             *    //   }
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "ajaxSource": "sources/objects.txt",
             *        "columns": [
             *          { "data": "engine" },
             *          { "data": "browser" },
             *          { "data": "platform" },
             *          { "data": "version" },
             *          { "data": "grade" }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Read information from deeply nested objects
             *    // JSON structure for each row:
             *    //   {
             *    //      "engine": {value},
             *    //      "browser": {value},
             *    //      "platform": {
             *    //         "inner": {value}
             *    //      },
             *    //      "details": [
             *    //         {value}, {value}
             *    //      ]
             *    //   }
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "ajaxSource": "sources/deep.txt",
             *        "columns": [
             *          { "data": "engine" },
             *          { "data": "browser" },
             *          { "data": "platform.inner" },
             *          { "data": "platform.details.0" },
             *          { "data": "platform.details.1" }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `data` as a function to provide different information for
             *    // sorting, filtering and display. In this case, currency (price)
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": function ( source, type, val ) {
             *            if (type === 'set') {
             *              source.price = val;
             *              // Store the computed dislay and filter values for efficiency
             *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
             *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
             *              return;
             *            }
             *            else if (type === 'display') {
             *              return source.price_display;
             *            }
             *            else if (type === 'filter') {
             *              return source.price_filter;
             *            }
             *            // 'sort', 'type' and undefined all just use the integer
             *            return source.price;
             *          }
             *        } ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using default content
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": null,
             *          "defaultContent": "Click to edit"
             *        } ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using array notation - outputting a list from an array
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": "name[, ]"
             *        } ]
             *      } );
             *    } );
             *
             */
            "mData": null,


            /**
             * This property is the rendering partner to `data` and it is suggested that
             * when you want to manipulate data for display (including filtering,
             * sorting etc) without altering the underlying data for the table, use this
             * property. `render` can be considered to be the the read only companion to
             * `data` which is read / write (then as such more complex). Like `data`
             * this option can be given in a number of different ways to effect its
             * behaviour:
             *
             * * `integer` - treated as an array index for the data source. This is the
             *   default that DataTables uses (incrementally increased for each column).
             * * `string` - read an object property from the data source. There are
             *   three 'special' options that can be used in the string to alter how
             *   DataTables reads the data from the source object:
             *    * `.` - Dotted Javascript notation. Just as you use a `.` in
             *      Javascript to read from nested objects, so to can the options
             *      specified in `data`. For example: `browser.version` or
             *      `browser.name`. If your object parameter name contains a period, use
             *      `\\` to escape it - i.e. `first\\.name`.
             *    * `[]` - Array notation. DataTables can automatically combine data
             *      from and array source, joining the data with the characters provided
             *      between the two brackets. For example: `name[, ]` would provide a
             *      comma-space separated list from the source array. If no characters
             *      are provided between the brackets, the original array source is
             *      returned.
             *    * `()` - Function notation. Adding `()` to the end of a parameter will
             *      execute a function of the name given. For example: `browser()` for a
             *      simple function on the data source, `browser.version()` for a
             *      function in a nested property or even `browser().version` to get an
             *      object property if the function called returns an object.
             * * `object` - use different data for the different data types requested by
             *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
             *   of the object is the data type the property refers to and the value can
             *   defined using an integer, string or function using the same rules as
             *   `render` normally does. Note that an `_` option _must_ be specified.
             *   This is the default value to use if you haven't specified a value for
             *   the data type requested by DataTables.
             * * `function` - the function given will be executed whenever DataTables
             *   needs to set or get the data for a cell in the column. The function
             *   takes three parameters:
             *    * Parameters:
             *      * {array|object} The data source for the row (based on `data`)
             *      * {string} The type call data requested - this will be 'filter',
             *        'display', 'type' or 'sort'.
             *      * {array|object} The full data source for the row (not based on
             *        `data`)
             *    * Return:
             *      * The return value from the function is what will be used for the
             *        data requested.
             *
             *  @type string|int|function|object|null
             *  @default null Use the data source value.
             *
             *  @name DataTable.defaults.column.render
             *  @dtopt Columns
             *
             *  @example
             *    // Create a comma separated list from an array of objects
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "ajaxSource": "sources/deep.txt",
             *        "columns": [
             *          { "data": "engine" },
             *          { "data": "browser" },
             *          {
             *            "data": "platform",
             *            "render": "[, ].name"
             *          }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Execute a function to obtain data
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": null, // Use the full data source object for the renderer's source
             *          "render": "browserName()"
             *        } ]
             *      } );
             *    } );
             *
             *  @example
             *    // As an object, extracting different data for the different types
             *    // This would be used with a data source such as:
             *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
             *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
             *    // (which has both forms) is used for filtering for if a user inputs either format, while
             *    // the formatted phone number is the one that is shown in the table.
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": null, // Use the full data source object for the renderer's source
             *          "render": {
             *            "_": "phone",
             *            "filter": "phone_filter",
             *            "display": "phone_display"
             *          }
             *        } ]
             *      } );
             *    } );
             *
             *  @example
             *    // Use as a function to create a link from the data source
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "data": "download_link",
             *          "render": function ( data, type, full ) {
             *            return '<a href="'+data+'">Download</a>';
             *          }
             *        } ]
             *      } );
             *    } );
             */
            "mRender": null,


            /**
             * Change the cell type created for the column - either TD cells or TH cells. This
             * can be useful as TH cells have semantic meaning in the table body, allowing them
             * to act as a header for a row (you may wish to add scope='row' to the TH elements).
             *  @type string
             *  @default td
             *
             *  @name DataTable.defaults.column.cellType
             *  @dtopt Columns
             *
             *  @example
             *    // Make the first column use TH cells
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [ {
             *          "targets": [ 0 ],
             *          "cellType": "th"
             *        } ]
             *      } );
             *    } );
             */
            "sCellType": "td",


            /**
             * Class to give to each cell in this column.
             *  @type string
             *  @default <i>Empty string</i>
             *
             *  @name DataTable.defaults.column.class
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "class": "my_class", "targets": [ 0 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "class": "my_class" },
             *          null,
             *          null,
             *          null,
             *          null
             *        ]
             *      } );
             *    } );
             */
            "sClass": "",

            /**
             * When DataTables calculates the column widths to assign to each column,
             * it finds the longest string in each column and then constructs a
             * temporary table and reads the widths from that. The problem with this
             * is that "mmm" is much wider then "iiii", but the latter is a longer
             * string - thus the calculation can go wrong (doing it properly and putting
             * it into an DOM object and measuring that is horribly(!) slow). Thus as
             * a "work around" we provide this option. It will append its value to the
             * text that is found to be the longest string for the column - i.e. padding.
             * Generally you shouldn't need this!
             *  @type string
             *  @default <i>Empty string<i>
             *
             *  @name DataTable.defaults.column.contentPadding
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          null,
             *          null,
             *          null,
             *          {
             *            "contentPadding": "mmm"
             *          }
             *        ]
             *      } );
             *    } );
             */
            "sContentPadding": "",


            /**
             * Allows a default value to be given for a column's data, and will be used
             * whenever a null data source is encountered (this can be because `data`
             * is set to null, or because the data source itself is null).
             *  @type string
             *  @default null
             *
             *  @name DataTable.defaults.column.defaultContent
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          {
             *            "data": null,
             *            "defaultContent": "Edit",
             *            "targets": [ -1 ]
             *          }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          null,
             *          null,
             *          null,
             *          {
             *            "data": null,
             *            "defaultContent": "Edit"
             *          }
             *        ]
             *      } );
             *    } );
             */
            "sDefaultContent": null,


            /**
             * This parameter is only used in DataTables' server-side processing. It can
             * be exceptionally useful to know what columns are being displayed on the
             * client side, and to map these to database fields. When defined, the names
             * also allow DataTables to reorder information from the server if it comes
             * back in an unexpected order (i.e. if you switch your columns around on the
             * client-side, your server-side code does not also need updating).
             *  @type string
             *  @default <i>Empty string</i>
             *
             *  @name DataTable.defaults.column.name
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "name": "engine", "targets": [ 0 ] },
             *          { "name": "browser", "targets": [ 1 ] },
             *          { "name": "platform", "targets": [ 2 ] },
             *          { "name": "version", "targets": [ 3 ] },
             *          { "name": "grade", "targets": [ 4 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "name": "engine" },
             *          { "name": "browser" },
             *          { "name": "platform" },
             *          { "name": "version" },
             *          { "name": "grade" }
             *        ]
             *      } );
             *    } );
             */
            "sName": "",


            /**
             * Defines a data source type for the ordering which can be used to read
             * real-time information from the table (updating the internally cached
             * version) prior to ordering. This allows ordering to occur on user
             * editable elements such as form inputs.
             *  @type string
             *  @default std
             *
             *  @name DataTable.defaults.column.orderDataType
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
             *          { "type": "numeric", "targets": [ 3 ] },
             *          { "orderDataType": "dom-select", "targets": [ 4 ] },
             *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          null,
             *          null,
             *          { "orderDataType": "dom-text" },
             *          { "orderDataType": "dom-text", "type": "numeric" },
             *          { "orderDataType": "dom-select" },
             *          { "orderDataType": "dom-checkbox" }
             *        ]
             *      } );
             *    } );
             */
            "sSortDataType": "std",


            /**
             * The title of this column.
             *  @type string
             *  @default null <i>Derived from the 'TH' value for this column in the
             *    original HTML table.</i>
             *
             *  @name DataTable.defaults.column.title
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "title": "My column title", "targets": [ 0 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "title": "My column title" },
             *          null,
             *          null,
             *          null,
             *          null
             *        ]
             *      } );
             *    } );
             */
            "sTitle": null,


            /**
             * The type allows you to specify how the data for this column will be
             * ordered. Four types (string, numeric, date and html (which will strip
             * HTML tags before ordering)) are currently available. Note that only date
             * formats understood by Javascript's Date() object will be accepted as type
             * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
             * 'numeric', 'date' or 'html' (by default). Further types can be adding
             * through plug-ins.
             *  @type string
             *  @default null <i>Auto-detected from raw data</i>
             *
             *  @name DataTable.defaults.column.type
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "type": "html", "targets": [ 0 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "type": "html" },
             *          null,
             *          null,
             *          null,
             *          null
             *        ]
             *      } );
             *    } );
             */
            "sType": null,


            /**
             * Defining the width of the column, this parameter may take any CSS value
             * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
             * been given a specific width through this interface ensuring that the table
             * remains readable.
             *  @type string
             *  @default null <i>Automatic</i>
             *
             *  @name DataTable.defaults.column.width
             *  @dtopt Columns
             *
             *  @example
             *    // Using `columnDefs`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columnDefs": [
             *          { "width": "20%", "targets": [ 0 ] }
             *        ]
             *      } );
             *    } );
             *
             *  @example
             *    // Using `columns`
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "columns": [
             *          { "width": "20%" },
             *          null,
             *          null,
             *          null,
             *          null
             *        ]
             *      } );
             *    } );
             */
            "sWidth": null
        };

        _fnHungarianMap(DataTable.defaults.column);



        /**
         * DataTables settings object - this holds all the information needed for a
         * given table, including configuration, data and current application of the
         * table options. DataTables does not have a single instance for each DataTable
         * with the settings attached to that instance, but rather instances of the
         * DataTable "class" are created on-the-fly as needed (typically by a
         * $().dataTable() call) and the settings object is then applied to that
         * instance.
         *
         * Note that this object is related to {@link DataTable.defaults} but this
         * one is the internal data store for DataTables's cache of columns. It should
         * NOT be manipulated outside of DataTables. Any configuration should be done
         * through the initialisation options.
         *  @namespace
         *  @todo Really should attach the settings object to individual instances so we
         *    don't need to create new instances on each $().dataTable() call (if the
         *    table already exists). It would also save passing oSettings around and
         *    into every single function. However, this is a very significant
         *    architecture change for DataTables and will almost certainly break
         *    backwards compatibility with older installations. This is something that
         *    will be done in 2.0.
         */
        DataTable.models.oSettings = {
            /**
             * Primary features of DataTables and their enablement state.
             *  @namespace
             */
            "oFeatures": {

                /**
                 * Flag to say if DataTables should automatically try to calculate the
                 * optimum table and columns widths (true) or not (false).
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bAutoWidth": null,

                /**
                 * Delay the creation of TR and TD elements until they are actually
                 * needed by a driven page draw. This can give a significant speed
                 * increase for Ajax source and Javascript source data, but makes no
                 * difference at all fro DOM and server-side processing tables.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bDeferRender": null,

                /**
                 * Enable filtering on the table or not. Note that if this is disabled
                 * then there is no filtering at all on the table, including fnFilter.
                 * To just remove the filtering input use sDom and remove the 'f' option.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bFilter": null,

                /**
                 * Table information element (the 'Showing x of y records' div) enable
                 * flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bInfo": null,

                /**
                 * Present a user control allowing the end user to change the page size
                 * when pagination is enabled.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bLengthChange": null,

                /**
                 * Pagination enabled or not. Note that if this is disabled then length
                 * changing must also be disabled.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bPaginate": null,

                /**
                 * Processing indicator enable flag whenever DataTables is enacting a
                 * user request - typically an Ajax request for server-side processing.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bProcessing": null,

                /**
                 * Server-side processing enabled flag - when enabled DataTables will
                 * get all data from the server for every draw - there is no filtering,
                 * sorting or paging done on the client-side.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bServerSide": null,

                /**
                 * Sorting enablement flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bSort": null,

                /**
                 * Multi-column sorting
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bSortMulti": null,

                /**
                 * Apply a class to the columns which are being sorted to provide a
                 * visual highlight or not. This can slow things down when enabled since
                 * there is a lot of DOM interaction.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bSortClasses": null,

                /**
                 * State saving enablement flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bStateSave": null
            },


            /**
             * Scrolling settings for a table.
             *  @namespace
             */
            "oScroll": {
                /**
                 * When the table is shorter in height than sScrollY, collapse the
                 * table container down to the height of the table (when true).
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bCollapse": null,

                /**
                 * Width of the scrollbar for the web-browser's platform. Calculated
                 * during table initialisation.
                 *  @type int
                 *  @default 0
                 */
                "iBarWidth": 0,

                /**
                 * Viewport width for horizontal scrolling. Horizontal scrolling is
                 * disabled if an empty string.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 */
                "sX": null,

                /**
                 * Width to expand the table to when using x-scrolling. Typically you
                 * should not need to use this.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 *  @deprecated
                 */
                "sXInner": null,

                /**
                 * Viewport height for vertical scrolling. Vertical scrolling is disabled
                 * if an empty string.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 */
                "sY": null
            },

            /**
             * Language information for the table.
             *  @namespace
             *  @extends DataTable.defaults.oLanguage
             */
            "oLanguage": {
                /**
                 * Information callback function. See
                 * {@link DataTable.defaults.fnInfoCallback}
                 *  @type function
                 *  @default null
                 */
                "fnInfoCallback": null
            },

            /**
             * Browser support parameters
             *  @namespace
             */
            "oBrowser": {
                /**
                 * Indicate if the browser incorrectly calculates width:100% inside a
                 * scrolling element (IE6/7)
                 *  @type boolean
                 *  @default false
                 */
                "bScrollOversize": false,

                /**
                 * Determine if the vertical scrollbar is on the right or left of the
                 * scrolling container - needed for rtl language layout, although not
                 * all browsers move the scrollbar (Safari).
                 *  @type boolean
                 *  @default false
                 */
                "bScrollbarLeft": false,

                /**
                 * Flag for if `getBoundingClientRect` is fully supported or not
                 *  @type boolean
                 *  @default false
                 */
                "bBounding": false,

                /**
                 * Browser scrollbar width
                 *  @type integer
                 *  @default 0
                 */
                "barWidth": 0
            },


            "ajax": null,


            /**
             * Array referencing the nodes which are used for the features. The
             * parameters of this object match what is allowed by sDom - i.e.
             *   <ul>
             *     <li>'l' - Length changing</li>
             *     <li>'f' - Filtering input</li>
             *     <li>'t' - The table!</li>
             *     <li>'i' - Information</li>
             *     <li>'p' - Pagination</li>
             *     <li>'r' - pRocessing</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aanFeatures": [],

            /**
             * Store data information - see {@link DataTable.models.oRow} for detailed
             * information.
             *  @type array
             *  @default []
             */
            "aoData": [],

            /**
             * Array of indexes which are in the current display (after filtering etc)
             *  @type array
             *  @default []
             */
            "aiDisplay": [],

            /**
             * Array of indexes for display - no filtering
             *  @type array
             *  @default []
             */
            "aiDisplayMaster": [],

            /**
             * Map of row ids to data indexes
             *  @type object
             *  @default {}
             */
            "aIds": {},

            /**
             * Store information about each column that is in use
             *  @type array
             *  @default []
             */
            "aoColumns": [],

            /**
             * Store information about the table's header
             *  @type array
             *  @default []
             */
            "aoHeader": [],

            /**
             * Store information about the table's footer
             *  @type array
             *  @default []
             */
            "aoFooter": [],

            /**
             * Store the applied global search information in case we want to force a
             * research or compare the old search to a new one.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @namespace
             *  @extends DataTable.models.oSearch
             */
            "oPreviousSearch": {},

            /**
             * Store the applied search for each column - see
             * {@link DataTable.models.oSearch} for the format that is used for the
             * filtering information for each column.
             *  @type array
             *  @default []
             */
            "aoPreSearchCols": [],

            /**
             * Sorting that is applied to the table. Note that the inner arrays are
             * used in the following manner:
             * <ul>
             *   <li>Index 0 - column number</li>
             *   <li>Index 1 - current sorting direction</li>
             * </ul>
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @todo These inner arrays should really be objects
             */
            "aaSorting": null,

            /**
             * Sorting that is always applied to the table (i.e. prefixed in front of
             * aaSorting).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @default []
             */
            "aaSortingFixed": [],

            /**
             * Classes to use for the striping of a table.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @default []
             */
            "asStripeClasses": null,

            /**
             * If restoring a table - we should restore its striping classes as well
             *  @type array
             *  @default []
             */
            "asDestroyStripes": [],

            /**
             * If restoring a table - we should restore its width
             *  @type int
             *  @default 0
             */
            "sDestroyWidth": 0,

            /**
             * Callback functions array for every time a row is inserted (i.e. on a draw).
             *  @type array
             *  @default []
             */
            "aoRowCallback": [],

            /**
             * Callback functions for the header on each draw.
             *  @type array
             *  @default []
             */
            "aoHeaderCallback": [],

            /**
             * Callback function for the footer on each draw.
             *  @type array
             *  @default []
             */
            "aoFooterCallback": [],

            /**
             * Array of callback functions for draw callback functions
             *  @type array
             *  @default []
             */
            "aoDrawCallback": [],

            /**
             * Array of callback functions for row created function
             *  @type array
             *  @default []
             */
            "aoRowCreatedCallback": [],

            /**
             * Callback functions for just before the table is redrawn. A return of
             * false will be used to cancel the draw.
             *  @type array
             *  @default []
             */
            "aoPreDrawCallback": [],

            /**
             * Callback functions for when the table has been initialised.
             *  @type array
             *  @default []
             */
            "aoInitComplete": [],


            /**
             * Callbacks for modifying the settings to be stored for state saving, prior to
             * saving state.
             *  @type array
             *  @default []
             */
            "aoStateSaveParams": [],

            /**
             * Callbacks for modifying the settings that have been stored for state saving
             * prior to using the stored values to restore the state.
             *  @type array
             *  @default []
             */
            "aoStateLoadParams": [],

            /**
             * Callbacks for operating on the settings object once the saved state has been
             * loaded
             *  @type array
             *  @default []
             */
            "aoStateLoaded": [],

            /**
             * Cache the table ID for quick access
             *  @type string
             *  @default <i>Empty string</i>
             */
            "sTableId": "",

            /**
             * The TABLE node for the main table
             *  @type node
             *  @default null
             */
            "nTable": null,

            /**
             * Permanent ref to the thead element
             *  @type node
             *  @default null
             */
            "nTHead": null,

            /**
             * Permanent ref to the tfoot element - if it exists
             *  @type node
             *  @default null
             */
            "nTFoot": null,

            /**
             * Permanent ref to the tbody element
             *  @type node
             *  @default null
             */
            "nTBody": null,

            /**
             * Cache the wrapper node (contains all DataTables controlled elements)
             *  @type node
             *  @default null
             */
            "nTableWrapper": null,

            /**
             * Indicate if when using server-side processing the loading of data
             * should be deferred until the second draw.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             *  @default false
             */
            "bDeferLoading": false,

            /**
             * Indicate if all required information has been read in
             *  @type boolean
             *  @default false
             */
            "bInitialised": false,

            /**
             * Information about open rows. Each object in the array has the parameters
             * 'nTr' and 'nParent'
             *  @type array
             *  @default []
             */
            "aoOpenRows": [],

            /**
             * Dictate the positioning of DataTables' control elements - see
             * {@link DataTable.model.oInit.sDom}.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default null
             */
            "sDom": null,

            /**
             * Search delay (in mS)
             *  @type integer
             *  @default null
             */
            "searchDelay": null,

            /**
             * Which type of pagination should be used.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default two_button
             */
            "sPaginationType": "two_button",

            /**
             * The state duration (for `stateSave`) in seconds.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type int
             *  @default 0
             */
            "iStateDuration": 0,

            /**
             * Array of callback functions for state saving. Each array element is an
             * object with the following parameters:
             *   <ul>
             *     <li>function:fn - function to call. Takes two parameters, oSettings
             *       and the JSON string to save that has been thus far created. Returns
             *       a JSON string to be inserted into a json object
             *       (i.e. '"param": [ 0, 1, 2]')</li>
             *     <li>string:sName - name of callback</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aoStateSave": [],

            /**
             * Array of callback functions for state loading. Each array element is an
             * object with the following parameters:
             *   <ul>
             *     <li>function:fn - function to call. Takes two parameters, oSettings
             *       and the object stored. May return false to cancel state loading</li>
             *     <li>string:sName - name of callback</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aoStateLoad": [],

            /**
             * State that was saved. Useful for back reference
             *  @type object
             *  @default null
             */
            "oSavedState": null,

            /**
             * State that was loaded. Useful for back reference
             *  @type object
             *  @default null
             */
            "oLoadedState": null,

            /**
             * Source url for AJAX data for the table.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default null
             */
            "sAjaxSource": null,

            /**
             * Property from a given object from which to read the table data from. This
             * can be an empty string (when not server-side processing), in which case
             * it is  assumed an an array is given directly.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sAjaxDataProp": null,

            /**
             * Note if draw should be blocked while getting data
             *  @type boolean
             *  @default true
             */
            "bAjaxDataGet": true,

            /**
             * The last jQuery XHR object that was used for server-side data gathering.
             * This can be used for working with the XHR information in one of the
             * callbacks
             *  @type object
             *  @default null
             */
            "jqXHR": null,

            /**
             * JSON returned from the server in the last Ajax request
             *  @type object
             *  @default undefined
             */
            "json": undefined,

            /**
             * Data submitted as part of the last Ajax request
             *  @type object
             *  @default undefined
             */
            "oAjaxData": undefined,

            /**
             * Function to get the server-side data.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type function
             */
            "fnServerData": null,

            /**
             * Functions which are called prior to sending an Ajax request so extra
             * parameters can easily be sent to the server
             *  @type array
             *  @default []
             */
            "aoServerParams": [],

            /**
             * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
             * required).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sServerMethod": null,

            /**
             * Format numbers for display.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type function
             */
            "fnFormatNumber": null,

            /**
             * List of options that can be used for the user selectable length menu.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @default []
             */
            "aLengthMenu": null,

            /**
             * Counter for the draws that the table does. Also used as a tracker for
             * server-side processing
             *  @type int
             *  @default 0
             */
            "iDraw": 0,

            /**
             * Indicate if a redraw is being done - useful for Ajax
             *  @type boolean
             *  @default false
             */
            "bDrawing": false,

            /**
             * Draw index (iDraw) of the last error when parsing the returned data
             *  @type int
             *  @default -1
             */
            "iDrawError": -1,

            /**
             * Paging display length
             *  @type int
             *  @default 10
             */
            "_iDisplayLength": 10,

            /**
             * Paging start point - aiDisplay index
             *  @type int
             *  @default 0
             */
            "_iDisplayStart": 0,

            /**
             * Server-side processing - number of records in the result set
             * (i.e. before filtering), Use fnRecordsTotal rather than
             * this property to get the value of the number of records, regardless of
             * the server-side processing setting.
             *  @type int
             *  @default 0
             *  @private
             */
            "_iRecordsTotal": 0,

            /**
             * Server-side processing - number of records in the current display set
             * (i.e. after filtering). Use fnRecordsDisplay rather than
             * this property to get the value of the number of records, regardless of
             * the server-side processing setting.
             *  @type boolean
             *  @default 0
             *  @private
             */
            "_iRecordsDisplay": 0,

            /**
             * The classes to use for the table
             *  @type object
             *  @default {}
             */
            "oClasses": {},

            /**
             * Flag attached to the settings object so you can check in the draw
             * callback if filtering has been done in the draw. Deprecated in favour of
             * events.
             *  @type boolean
             *  @default false
             *  @deprecated
             */
            "bFiltered": false,

            /**
             * Flag attached to the settings object so you can check in the draw
             * callback if sorting has been done in the draw. Deprecated in favour of
             * events.
             *  @type boolean
             *  @default false
             *  @deprecated
             */
            "bSorted": false,

            /**
             * Indicate that if multiple rows are in the header and there is more than
             * one unique cell per column, if the top one (true) or bottom one (false)
             * should be used for sorting / title by DataTables.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bSortCellsTop": null,

            /**
             * Initialisation object that is used for the table
             *  @type object
             *  @default null
             */
            "oInit": null,

            /**
             * Destroy callback functions - for plug-ins to attach themselves to the
             * destroy so they can clean up markup and events.
             *  @type array
             *  @default []
             */
            "aoDestroyCallback": [],


            /**
             * Get the number of records in the current record set, before filtering
             *  @type function
             */
            "fnRecordsTotal": function () {
                return _fnDataSource(this) == 'ssp' ?
                    this._iRecordsTotal * 1 :
                    this.aiDisplayMaster.length;
            },

            /**
             * Get the number of records in the current record set, after filtering
             *  @type function
             */
            "fnRecordsDisplay": function () {
                return _fnDataSource(this) == 'ssp' ?
                    this._iRecordsDisplay * 1 :
                    this.aiDisplay.length;
            },

            /**
             * Get the display end point - aiDisplay index
             *  @type function
             */
            "fnDisplayEnd": function () {
                var
                    len = this._iDisplayLength,
                    start = this._iDisplayStart,
                    calc = start + len,
                    records = this.aiDisplay.length,
                    features = this.oFeatures,
                    paginate = features.bPaginate;

                if (features.bServerSide) {
                    return paginate === false || len === -1 ?
                        start + records :
                        Math.min(start + len, this._iRecordsDisplay);
                }
                else {
                    return !paginate || calc > records || len === -1 ?
                        records :
                        calc;
                }
            },

            /**
             * The DataTables object for this table
             *  @type object
             *  @default null
             */
            "oInstance": null,

            /**
             * Unique identifier for each instance of the DataTables object. If there
             * is an ID on the table node, then it takes that value, otherwise an
             * incrementing internal counter is used.
             *  @type string
             *  @default null
             */
            "sInstance": null,

            /**
             * tabindex attribute value that is added to DataTables control elements, allowing
             * keyboard navigation of the table and its controls.
             */
            "iTabIndex": 0,

            /**
             * DIV container for the footer scrolling table if scrolling
             */
            "nScrollHead": null,

            /**
             * DIV container for the footer scrolling table if scrolling
             */
            "nScrollFoot": null,

            /**
             * Last applied sort
             *  @type array
             *  @default []
             */
            "aLastSort": [],

            /**
             * Stored plug-in instances
             *  @type object
             *  @default {}
             */
            "oPlugins": {},

            /**
             * Function used to get a row's id from the row's data
             *  @type function
             *  @default null
             */
            "rowIdFn": null,

            /**
             * Data location where to store a row's id
             *  @type string
             *  @default null
             */
            "rowId": null
        };

        /**
         * Extension object for DataTables that is used to provide all extension
         * options.
         *
         * Note that the `DataTable.ext` object is available through
         * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
         * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
         *  @namespace
         *  @extends DataTable.models.ext
         */


        /**
         * DataTables extensions
         * 
         * This namespace acts as a collection area for plug-ins that can be used to
         * extend DataTables capabilities. Indeed many of the build in methods
         * use this method to provide their own capabilities (sorting methods for
         * example).
         *
         * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
         * reasons
         *
         *  @namespace
         */
        DataTable.ext = _ext = {
            /**
             * Buttons. For use with the Buttons extension for DataTables. This is
             * defined here so other extensions can define buttons regardless of load
             * order. It is _not_ used by DataTables core.
             *
             *  @type object
             *  @default {}
             */
            buttons: {},


            /**
             * Element class names
             *
             *  @type object
             *  @default {}
             */
            classes: {},


            /**
             * DataTables build type (expanded by the download builder)
             *
             *  @type string
             */
            builder: "-source-",


            /**
             * Error reporting.
             * 
             * How should DataTables report an error. Can take the value 'alert',
             * 'throw', 'none' or a function.
             *
             *  @type string|function
             *  @default alert
             */
            errMode: "alert",


            /**
             * Feature plug-ins.
             * 
             * This is an array of objects which describe the feature plug-ins that are
             * available to DataTables. These feature plug-ins are then available for
             * use through the `dom` initialisation option.
             * 
             * Each feature plug-in is described by an object which must have the
             * following properties:
             * 
             * * `fnInit` - function that is used to initialise the plug-in,
             * * `cFeature` - a character so the feature can be enabled by the `dom`
             *   instillation option. This is case sensitive.
             *
             * The `fnInit` function has the following input parameters:
             *
             * 1. `{object}` DataTables settings object: see
             *    {@link DataTable.models.oSettings}
             *
             * And the following return is expected:
             * 
             * * {node|null} The element which contains your feature. Note that the
             *   return may also be void if your plug-in does not require to inject any
             *   DOM elements into DataTables control (`dom`) - for example this might
             *   be useful when developing a plug-in which allows table control via
             *   keyboard entry
             *
             *  @type array
             *
             *  @example
             *    $.fn.dataTable.ext.features.push( {
             *      "fnInit": function( oSettings ) {
             *        return new TableTools( { "oDTSettings": oSettings } );
             *      },
             *      "cFeature": "T"
             *    } );
             */
            feature: [],


            /**
             * Row searching.
             * 
             * This method of searching is complimentary to the default type based
             * searching, and a lot more comprehensive as it allows you complete control
             * over the searching logic. Each element in this array is a function
             * (parameters described below) that is called for every row in the table,
             * and your logic decides if it should be included in the searching data set
             * or not.
             *
             * Searching functions have the following input parameters:
             *
             * 1. `{object}` DataTables settings object: see
             *    {@link DataTable.models.oSettings}
             * 2. `{array|object}` Data for the row to be processed (same as the
             *    original format that was passed in as the data source, or an array
             *    from a DOM data source
             * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
             *    can be useful to retrieve the `TR` element if you need DOM interaction.
             *
             * And the following return is expected:
             *
             * * {boolean} Include the row in the searched result set (true) or not
             *   (false)
             *
             * Note that as with the main search ability in DataTables, technically this
             * is "filtering", since it is subtractive. However, for consistency in
             * naming we call it searching here.
             *
             *  @type array
             *  @default []
             *
             *  @example
             *    // The following example shows custom search being applied to the
             *    // fourth column (i.e. the data[3] index) based on two input values
             *    // from the end-user, matching the data in a certain range.
             *    $.fn.dataTable.ext.search.push(
             *      function( settings, data, dataIndex ) {
             *        var min = document.getElementById('min').value * 1;
             *        var max = document.getElementById('max').value * 1;
             *        var version = data[3] == "-" ? 0 : data[3]*1;
             *
             *        if ( min == "" && max == "" ) {
             *          return true;
             *        }
             *        else if ( min == "" && version < max ) {
             *          return true;
             *        }
             *        else if ( min < version && "" == max ) {
             *          return true;
             *        }
             *        else if ( min < version && version < max ) {
             *          return true;
             *        }
             *        return false;
             *      }
             *    );
             */
            search: [],


            /**
             * Selector extensions
             *
             * The `selector` option can be used to extend the options available for the
             * selector modifier options (`selector-modifier` object data type) that
             * each of the three built in selector types offer (row, column and cell +
             * their plural counterparts). For example the Select extension uses this
             * mechanism to provide an option to select only rows, columns and cells
             * that have been marked as selected by the end user (`{selected: true}`),
             * which can be used in conjunction with the existing built in selector
             * options.
             *
             * Each property is an array to which functions can be pushed. The functions
             * take three attributes:
             *
             * * Settings object for the host table
             * * Options object (`selector-modifier` object type)
             * * Array of selected item indexes
             *
             * The return is an array of the resulting item indexes after the custom
             * selector has been applied.
             *
             *  @type object
             */
            selector: {
                cell: [],
                column: [],
                row: []
            },


            /**
             * Internal functions, exposed for used in plug-ins.
             * 
             * Please note that you should not need to use the internal methods for
             * anything other than a plug-in (and even then, try to avoid if possible).
             * The internal function may change between releases.
             *
             *  @type object
             *  @default {}
             */
            internal: {},


            /**
             * Legacy configuration options. Enable and disable legacy options that
             * are available in DataTables.
             *
             *  @type object
             */
            legacy: {
                /**
                 * Enable / disable DataTables 1.9 compatible server-side processing
                 * requests
                 *
                 *  @type boolean
                 *  @default null
                 */
                ajax: null
            },


            /**
             * Pagination plug-in methods.
             * 
             * Each entry in this object is a function and defines which buttons should
             * be shown by the pagination rendering method that is used for the table:
             * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
             * buttons are displayed in the document, while the functions here tell it
             * what buttons to display. This is done by returning an array of button
             * descriptions (what each button will do).
             *
             * Pagination types (the four built in options and any additional plug-in
             * options defined here) can be used through the `paginationType`
             * initialisation parameter.
             *
             * The functions defined take two parameters:
             *
             * 1. `{int} page` The current page index
             * 2. `{int} pages` The number of pages in the table
             *
             * Each function is expected to return an array where each element of the
             * array can be one of:
             *
             * * `first` - Jump to first page when activated
             * * `last` - Jump to last page when activated
             * * `previous` - Show previous page when activated
             * * `next` - Show next page when activated
             * * `{int}` - Show page of the index given
             * * `{array}` - A nested array containing the above elements to add a
             *   containing 'DIV' element (might be useful for styling).
             *
             * Note that DataTables v1.9- used this object slightly differently whereby
             * an object with two functions would be defined for each plug-in. That
             * ability is still supported by DataTables 1.10+ to provide backwards
             * compatibility, but this option of use is now decremented and no longer
             * documented in DataTables 1.10+.
             *
             *  @type object
             *  @default {}
             *
             *  @example
             *    // Show previous, next and current page buttons only
             *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
             *      return [ 'previous', page, 'next' ];
             *    };
             */
            pager: {},


            renderer: {
                pageButton: {},
                header: {}
            },


            /**
             * Ordering plug-ins - custom data source
             * 
             * The extension options for ordering of data available here is complimentary
             * to the default type based ordering that DataTables typically uses. It
             * allows much greater control over the the data that is being used to
             * order a column, but is necessarily therefore more complex.
             * 
             * This type of ordering is useful if you want to do ordering based on data
             * live from the DOM (for example the contents of an 'input' element) rather
             * than just the static string that DataTables knows of.
             * 
             * The way these plug-ins work is that you create an array of the values you
             * wish to be ordering for the column in question and then return that
             * array. The data in the array much be in the index order of the rows in
             * the table (not the currently ordering order!). Which order data gathering
             * function is run here depends on the `dt-init columns.orderDataType`
             * parameter that is used for the column (if any).
             *
             * The functions defined take two parameters:
             *
             * 1. `{object}` DataTables settings object: see
             *    {@link DataTable.models.oSettings}
             * 2. `{int}` Target column index
             *
             * Each function is expected to return an array:
             *
             * * `{array}` Data for the column to be ordering upon
             *
             *  @type array
             *
             *  @example
             *    // Ordering using `input` node values
             *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
             *    {
             *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
             *        return $('input', td).val();
             *      } );
             *    }
             */
            order: {},


            /**
             * Type based plug-ins.
             *
             * Each column in DataTables has a type assigned to it, either by automatic
             * detection or by direct assignment using the `type` option for the column.
             * The type of a column will effect how it is ordering and search (plug-ins
             * can also make use of the column type if required).
             *
             * @namespace
             */
            type: {
                /**
                 * Type detection functions.
                 *
                 * The functions defined in this object are used to automatically detect
                 * a column's type, making initialisation of DataTables super easy, even
                 * when complex data is in the table.
                 *
                 * The functions defined take two parameters:
                 *
                 *  1. `{*}` Data from the column cell to be analysed
                 *  2. `{settings}` DataTables settings object. This can be used to
                 *     perform context specific type detection - for example detection
                 *     based on language settings such as using a comma for a decimal
                 *     place. Generally speaking the options from the settings will not
                 *     be required
                 *
                 * Each function is expected to return:
                 *
                 * * `{string|null}` Data type detected, or null if unknown (and thus
                 *   pass it on to the other type detection functions.
                 *
                 *  @type array
                 *
                 *  @example
                 *    // Currency type detection plug-in:
                 *    $.fn.dataTable.ext.type.detect.push(
                 *      function ( data, settings ) {
                 *        // Check the numeric part
                 *        if ( ! $.isNumeric( data.substring(1) ) ) {
                 *          return null;
                 *        }
                 *
                 *        // Check prefixed by currency
                 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
                 *          return 'currency';
                 *        }
                 *        return null;
                 *      }
                 *    );
                 */
                detect: [],


                /**
                 * Type based search formatting.
                 *
                 * The type based searching functions can be used to pre-format the
                 * data to be search on. For example, it can be used to strip HTML
                 * tags or to de-format telephone numbers for numeric only searching.
                 *
                 * Note that is a search is not defined for a column of a given type,
                 * no search formatting will be performed.
                 * 
                 * Pre-processing of searching data plug-ins - When you assign the sType
                 * for a column (or have it automatically detected for you by DataTables
                 * or a type detection plug-in), you will typically be using this for
                 * custom sorting, but it can also be used to provide custom searching
                 * by allowing you to pre-processing the data and returning the data in
                 * the format that should be searched upon. This is done by adding
                 * functions this object with a parameter name which matches the sType
                 * for that target column. This is the corollary of <i>afnSortData</i>
                 * for searching data.
                 *
                 * The functions defined take a single parameter:
                 *
                 *  1. `{*}` Data from the column cell to be prepared for searching
                 *
                 * Each function is expected to return:
                 *
                 * * `{string|null}` Formatted string that will be used for the searching.
                 *
                 *  @type object
                 *  @default {}
                 *
                 *  @example
                 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
                 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
                 *    }
                 */
                search: {},


                /**
                 * Type based ordering.
                 *
                 * The column type tells DataTables what ordering to apply to the table
                 * when a column is sorted upon. The order for each type that is defined,
                 * is defined by the functions available in this object.
                 *
                 * Each ordering option can be described by three properties added to
                 * this object:
                 *
                 * * `{type}-pre` - Pre-formatting function
                 * * `{type}-asc` - Ascending order function
                 * * `{type}-desc` - Descending order function
                 *
                 * All three can be used together, only `{type}-pre` or only
                 * `{type}-asc` and `{type}-desc` together. It is generally recommended
                 * that only `{type}-pre` is used, as this provides the optimal
                 * implementation in terms of speed, although the others are provided
                 * for compatibility with existing Javascript sort functions.
                 *
                 * `{type}-pre`: Functions defined take a single parameter:
                 *
                 *  1. `{*}` Data from the column cell to be prepared for ordering
                 *
                 * And return:
                 *
                 * * `{*}` Data to be sorted upon
                 *
                 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
                 * functions, taking two parameters:
                 *
                 *  1. `{*}` Data to compare to the second parameter
                 *  2. `{*}` Data to compare to the first parameter
                 *
                 * And returning:
                 *
                 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
                 *   than the second parameter, ===0 if the two parameters are equal and
                 *   >0 if the first parameter should be sorted height than the second
                 *   parameter.
                 * 
                 *  @type object
                 *  @default {}
                 *
                 *  @example
                 *    // Numeric ordering of formatted numbers with a pre-formatter
                 *    $.extend( $.fn.dataTable.ext.type.order, {
                 *      "string-pre": function(x) {
                 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
                 *        return parseFloat( a );
                 *      }
                 *    } );
                 *
                 *  @example
                 *    // Case-sensitive string ordering, with no pre-formatting method
                 *    $.extend( $.fn.dataTable.ext.order, {
                 *      "string-case-asc": function(x,y) {
                 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
                 *      },
                 *      "string-case-desc": function(x,y) {
                 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
                 *      }
                 *    } );
                 */
                order: {}
            },

            /**
             * Unique DataTables instance counter
             *
             * @type int
             * @private
             */
            _unique: 0,


            //
            // Depreciated
            // The following properties are retained for backwards compatiblity only.
            // The should not be used in new projects and will be removed in a future
            // version
            //

            /**
             * Version check function.
             *  @type function
             *  @depreciated Since 1.10
             */
            fnVersionCheck: DataTable.fnVersionCheck,


            /**
             * Index for what 'this' index API functions should use
             *  @type int
             *  @deprecated Since v1.10
             */
            iApiIndex: 0,


            /**
             * jQuery UI class container
             *  @type object
             *  @deprecated Since v1.10
             */
            oJUIClasses: {},


            /**
             * Software version
             *  @type string
             *  @deprecated Since v1.10
             */
            sVersion: DataTable.version
        };


        //
        // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
        //
        $.extend(_ext, {
            afnFiltering: _ext.search,
            aTypes: _ext.type.detect,
            ofnSearch: _ext.type.search,
            oSort: _ext.type.order,
            afnSortData: _ext.order,
            aoFeatures: _ext.feature,
            oApi: _ext.internal,
            oStdClasses: _ext.classes,
            oPagination: _ext.pager
        });


        $.extend(DataTable.ext.classes, {
            "sTable": "dataTable",
            "sNoFooter": "no-footer",

            /* Paging buttons */
            "sPageButton": "paginate_button",
            "sPageButtonActive": "current",
            "sPageButtonDisabled": "disabled",

            /* Striping classes */
            "sStripeOdd": "odd",
            "sStripeEven": "even",

            /* Empty row */
            "sRowEmpty": "dataTables_empty",

            /* Features */
            "sWrapper": "dataTables_wrapper",
            "sFilter": "dataTables_filter",
            "sInfo": "dataTables_info",
            "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
            "sLength": "dataTables_length",
            "sProcessing": "dataTables_processing",

            /* Sorting */
            "sSortAsc": "sorting_asc",
            "sSortDesc": "sorting_desc",
            "sSortable": "sorting", /* Sortable in both directions */
            "sSortableAsc": "sorting_asc_disabled",
            "sSortableDesc": "sorting_desc_disabled",
            "sSortableNone": "sorting_disabled",
            "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */

            /* Filtering */
            "sFilterInput": "",

            /* Page length */
            "sLengthSelect": "",

            /* Scrolling */
            "sScrollWrapper": "dataTables_scroll",
            "sScrollHead": "dataTables_scrollHead",
            "sScrollHeadInner": "dataTables_scrollHeadInner",
            "sScrollBody": "dataTables_scrollBody",
            "sScrollFoot": "dataTables_scrollFoot",
            "sScrollFootInner": "dataTables_scrollFootInner",

            /* Misc */
            "sHeaderTH": "",
            "sFooterTH": "",

            // Deprecated
            "sSortJUIAsc": "",
            "sSortJUIDesc": "",
            "sSortJUI": "",
            "sSortJUIAscAllowed": "",
            "sSortJUIDescAllowed": "",
            "sSortJUIWrapper": "",
            "sSortIcon": "",
            "sJUIHeader": "",
            "sJUIFooter": ""
        });


        var extPagination = DataTable.ext.pager;

        function _numbers(page, pages) {
            var
                numbers = [],
                buttons = extPagination.numbers_length,
                half = Math.floor(buttons / 2),
                i = 1;

            if (pages <= buttons) {
                numbers = _range(0, pages);
            }
            else if (page <= half) {
                numbers = _range(0, buttons - 2);
                numbers.push('ellipsis');
                numbers.push(pages - 1);
            }
            else if (page >= pages - 1 - half) {
                numbers = _range(pages - (buttons - 2), pages);
                numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6
                numbers.splice(0, 0, 0);
            }
            else {
                numbers = _range(page - half + 2, page + half - 1);
                numbers.push('ellipsis');
                numbers.push(pages - 1);
                numbers.splice(0, 0, 'ellipsis');
                numbers.splice(0, 0, 0);
            }

            numbers.DT_el = 'span';
            return numbers;
        }


        $.extend(extPagination, {
            simple: function (page, pages) {
                return ['previous', 'next'];
            },

            full: function (page, pages) {
                return ['first', 'previous', 'next', 'last'];
            },

            numbers: function (page, pages) {
                return [_numbers(page, pages)];
            },

            simple_numbers: function (page, pages) {
                return ['previous', _numbers(page, pages), 'next'];
            },

            full_numbers: function (page, pages) {
                return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
            },

            first_last_numbers: function (page, pages) {
                return ['first', _numbers(page, pages), 'last'];
            },

            // For testing and plug-ins to use
            _numbers: _numbers,

            // Number of number buttons (including ellipsis) to show. _Must be odd!_
            numbers_length: 7
        });


        $.extend(true, DataTable.ext.renderer, {
            pageButton: {
                _: function (settings, host, idx, buttons, page, pages) {
                    var classes = settings.oClasses;
                    var lang = settings.oLanguage.oPaginate;
                    var aria = settings.oLanguage.oAria.paginate || {};
                    var btnDisplay, btnClass, counter = 0;

                    var attach = function (container, buttons) {
                        var i, ien, node, button;
                        var clickHandler = function (e) {
                            _fnPageChange(settings, e.data.action, true);
                        };

                        for (i = 0, ien = buttons.length; i < ien; i++) {
                            button = buttons[i];

                            if ($.isArray(button)) {
                                var inner = $('<' + (button.DT_el || 'div') + '/>')
                                    .appendTo(container);
                                attach(inner, button);
                            }
                            else {
                                btnDisplay = null;
                                btnClass = '';

                                switch (button) {
                                    case 'ellipsis':
                                        container.append('<span class="ellipsis">&#x2026;</span>');
                                        break;

                                    case 'first':
                                        btnDisplay = lang.sFirst;
                                        btnClass = button + (page > 0 ?
                                            '' : ' ' + classes.sPageButtonDisabled);
                                        break;

                                    case 'previous':
                                        btnDisplay = lang.sPrevious;
                                        btnClass = button + (page > 0 ?
                                            '' : ' ' + classes.sPageButtonDisabled);
                                        break;

                                    case 'next':
                                        btnDisplay = lang.sNext;
                                        btnClass = button + (page < pages - 1 ?
                                            '' : ' ' + classes.sPageButtonDisabled);
                                        break;

                                    case 'last':
                                        btnDisplay = lang.sLast;
                                        btnClass = button + (page < pages - 1 ?
                                            '' : ' ' + classes.sPageButtonDisabled);
                                        break;

                                    default:
                                        btnDisplay = button + 1;
                                        btnClass = page === button ?
                                            classes.sPageButtonActive : '';
                                        break;
                                }

                                if (btnDisplay !== null) {
                                    node = $('<a>', {
                                        'class': classes.sPageButton + ' ' + btnClass,
                                        'aria-controls': settings.sTableId,
                                        'aria-label': aria[button],
                                        'data-dt-idx': counter,
                                        'tabindex': settings.iTabIndex,
                                        'id': idx === 0 && typeof button === 'string' ?
                                            settings.sTableId + '_' + button :
                                            null
                                    })
                                        .html(btnDisplay)
                                        .appendTo(container);

                                    _fnBindAction(
                                        node, { action: button }, clickHandler
                                    );

                                    counter++;
                                }
                            }
                        }
                    };

                    // IE9 throws an 'unknown error' if document.activeElement is used
                    // inside an iframe or frame. Try / catch the error. Not good for
                    // accessibility, but neither are frames.
                    var activeEl;

                    try {
                        // Because this approach is destroying and recreating the paging
                        // elements, focus is lost on the select button which is bad for
                        // accessibility. So we want to restore focus once the draw has
                        // completed
                        activeEl = $(host).find(document.activeElement).data('dt-idx');
                    }
                    catch (e) { }

                    attach($(host).empty(), buttons);

                    if (activeEl !== undefined) {
                        $(host).find('[data-dt-idx=' + activeEl + ']').focus();
                    }
                }
            }
        });



        // Built in type detection. See model.ext.aTypes for information about
        // what is required from this methods.
        $.extend(DataTable.ext.type.detect, [
            // Plain numbers - first since V8 detects some plain numbers as dates
            // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
            function (d, settings) {
                var decimal = settings.oLanguage.sDecimal;
                return _isNumber(d, decimal) ? 'num' + decimal : null;
            },

            // Dates (only those recognised by the browser's Date.parse)
            function (d, settings) {
                // V8 tries _very_ hard to make a string passed into `Date.parse()`
                // valid, so we need to use a regex to restrict date formats. Use a
                // plug-in for anything other than ISO8601 style strings
                if (d && !(d instanceof Date) && !_re_date.test(d)) {
                    return null;
                }
                var parsed = Date.parse(d);
                return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
            },

            // Formatted numbers
            function (d, settings) {
                var decimal = settings.oLanguage.sDecimal;
                return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
            },

            // HTML numeric
            function (d, settings) {
                var decimal = settings.oLanguage.sDecimal;
                return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
            },

            // HTML numeric, formatted
            function (d, settings) {
                var decimal = settings.oLanguage.sDecimal;
                return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
            },

            // HTML (this is strict checking - there must be html)
            function (d, settings) {
                return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
                    'html' : null;
            }
        ]);



        // Filter formatting functions. See model.ext.ofnSearch for information about
        // what is required from these methods.
        // 
        // Note that additional search methods are added for the html numbers and
        // html formatted numbers by `_addNumericSort()` when we know what the decimal
        // place is


        $.extend(DataTable.ext.type.search, {
            html: function (data) {
                return _empty(data) ?
                    data :
                    typeof data === 'string' ?
                        data
                            .replace(_re_new_lines, " ")
                            .replace(_re_html, "") :
                        '';
            },

            string: function (data) {
                return _empty(data) ?
                    data :
                    typeof data === 'string' ?
                        data.replace(_re_new_lines, " ") :
                        data;
            }
        });



        var __numericReplace = function (d, decimalPlace, re1, re2) {
            if (d !== 0 && (!d || d === '-')) {
                return -Infinity;
            }

            // If a decimal place other than `.` is used, it needs to be given to the
            // function so we can detect it and replace with a `.` which is the only
            // decimal place Javascript recognises - it is not locale aware.
            if (decimalPlace) {
                d = _numToDecimal(d, decimalPlace);
            }

            if (d.replace) {
                if (re1) {
                    d = d.replace(re1, '');
                }

                if (re2) {
                    d = d.replace(re2, '');
                }
            }

            return d * 1;
        };


        // Add the numeric 'deformatting' functions for sorting and search. This is done
        // in a function to provide an easy ability for the language options to add
        // additional methods if a non-period decimal place is used.
        function _addNumericSort(decimalPlace) {
            $.each(
                {
                    // Plain numbers
                    "num": function (d) {
                        return __numericReplace(d, decimalPlace);
                    },

                    // Formatted numbers
                    "num-fmt": function (d) {
                        return __numericReplace(d, decimalPlace, _re_formatted_numeric);
                    },

                    // HTML numeric
                    "html-num": function (d) {
                        return __numericReplace(d, decimalPlace, _re_html);
                    },

                    // HTML numeric, formatted
                    "html-num-fmt": function (d) {
                        return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
                    }
                },
                function (key, fn) {
                    // Add the ordering method
                    _ext.type.order[key + decimalPlace + '-pre'] = fn;

                    // For HTML types add a search formatter that will strip the HTML
                    if (key.match(/^html\-/)) {
                        _ext.type.search[key + decimalPlace] = _ext.type.search.html;
                    }
                }
            );
        }


        // Default sort methods
        $.extend(_ext.type.order, {
            // Dates
            "date-pre": function (d) {
                return Date.parse(d) || -Infinity;
            },

            // html
            "html-pre": function (a) {
                return _empty(a) ?
                    '' :
                    a.replace ?
                        a.replace(/<.*?>/g, "").toLowerCase() :
                        a + '';
            },

            // string
            "string-pre": function (a) {
                // This is a little complex, but faster than always calling toString,
                // http://jsperf.com/tostring-v-check
                return _empty(a) ?
                    '' :
                    typeof a === 'string' ?
                        a.toLowerCase() :
                        !a.toString ?
                            '' :
                            a.toString();
            },

            // string-asc and -desc are retained only for compatibility with the old
            // sort methods
            "string-asc": function (x, y) {
                return ((x < y) ? -1 : ((x > y) ? 1 : 0));
            },

            "string-desc": function (x, y) {
                return ((x < y) ? 1 : ((x > y) ? -1 : 0));
            }
        });


        // Numeric sorting types - order doesn't matter here
        _addNumericSort('');


        $.extend(true, DataTable.ext.renderer, {
            header: {
                _: function (settings, cell, column, classes) {
                    // No additional mark-up required
                    // Attach a sort listener to update on sort - note that using the
                    // `DT` namespace will allow the event to be removed automatically
                    // on destroy, while the `dt` namespaced event is the one we are
                    // listening for
                    $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
                        if (settings !== ctx) { // need to check this this is the host
                            return;               // table, not a nested one
                        }

                        var colIdx = column.idx;

                        cell
                            .removeClass(
                                column.sSortingClass + ' ' +
                                classes.sSortAsc + ' ' +
                                classes.sSortDesc
                            )
                            .addClass(columns[colIdx] == 'asc' ?
                                classes.sSortAsc : columns[colIdx] == 'desc' ?
                                    classes.sSortDesc :
                                    column.sSortingClass
                            );
                    });
                },

                jqueryui: function (settings, cell, column, classes) {
                    $('<div/>')
                        .addClass(classes.sSortJUIWrapper)
                        .append(cell.contents())
                        .append($('<span/>')
                            .addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)
                        )
                        .appendTo(cell);

                    // Attach a sort listener to update on sort
                    $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
                        if (settings !== ctx) {
                            return;
                        }

                        var colIdx = column.idx;

                        cell
                            .removeClass(classes.sSortAsc + " " + classes.sSortDesc)
                            .addClass(columns[colIdx] == 'asc' ?
                                classes.sSortAsc : columns[colIdx] == 'desc' ?
                                    classes.sSortDesc :
                                    column.sSortingClass
                            );

                        cell
                            .find('span.' + classes.sSortIcon)
                            .removeClass(
                                classes.sSortJUIAsc + " " +
                                classes.sSortJUIDesc + " " +
                                classes.sSortJUI + " " +
                                classes.sSortJUIAscAllowed + " " +
                                classes.sSortJUIDescAllowed
                            )
                            .addClass(columns[colIdx] == 'asc' ?
                                classes.sSortJUIAsc : columns[colIdx] == 'desc' ?
                                    classes.sSortJUIDesc :
                                    column.sSortingClassJUI
                            );
                    });
                }
            }
        });

        /*
         * Public helper functions. These aren't used internally by DataTables, or
         * called by any of the options passed into DataTables, but they can be used
         * externally by developers working with DataTables. They are helper functions
         * to make working with DataTables a little bit easier.
         */

        var __htmlEscapeEntities = function (d) {
            return typeof d === 'string' ?
                d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
                d;
        };

        /**
         * Helpers for `columns.render`.
         *
         * The options defined here can be used with the `columns.render` initialisation
         * option to provide a display renderer. The following functions are defined:
         *
         * * `number` - Will format numeric data (defined by `columns.data`) for
         *   display, retaining the original unformatted data for sorting and filtering.
         *   It takes 5 parameters:
         *   * `string` - Thousands grouping separator
         *   * `string` - Decimal point indicator
         *   * `integer` - Number of decimal points to show
         *   * `string` (optional) - Prefix.
         *   * `string` (optional) - Postfix (/suffix).
         * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
         *   parameters.
         *
         * @example
         *   // Column definition using the number renderer
         *   {
         *     data: "salary",
         *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
         *   }
         *
         * @namespace
         */
        DataTable.render = {
            number: function (thousands, decimal, precision, prefix, postfix) {
                return {
                    display: function (d) {
                        if (typeof d !== 'number' && typeof d !== 'string') {
                            return d;
                        }

                        var negative = d < 0 ? '-' : '';
                        var flo = parseFloat(d);

                        // If NaN then there isn't much formatting that we can do - just
                        // return immediately, escaping any HTML (this was supposed to
                        // be a number after all)
                        if (isNaN(flo)) {
                            return __htmlEscapeEntities(d);
                        }

                        flo = flo.toFixed(precision);
                        d = Math.abs(flo);

                        var intPart = parseInt(d, 10);
                        var floatPart = precision ?
                            decimal + (d - intPart).toFixed(precision).substring(2) :
                            '';

                        return negative + (prefix || '') +
                            intPart.toString().replace(
                                /\B(?=(\d{3})+(?!\d))/g, thousands
                            ) +
                            floatPart +
                            (postfix || '');
                    }
                };
            },

            text: function () {
                return {
                    display: __htmlEscapeEntities
                };
            }
        };


        /*
         * This is really a good bit rubbish this method of exposing the internal methods
         * publicly... - To be fixed in 2.0 using methods on the prototype
         */


        /**
         * Create a wrapper function for exporting an internal functions to an external API.
         *  @param {string} fn API function name
         *  @returns {function} wrapped function
         *  @memberof DataTable#internal
         */
        function _fnExternApiFunc(fn) {
            return function () {
                var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
                    Array.prototype.slice.call(arguments)
                );
                return DataTable.ext.internal[fn].apply(this, args);
            };
        }


        /**
         * Reference to internal functions for use by plug-in developers. Note that
         * these methods are references to internal functions and are considered to be
         * private. If you use these methods, be aware that they are liable to change
         * between versions.
         *  @namespace
         */
        $.extend(DataTable.ext.internal, {
            _fnExternApiFunc: _fnExternApiFunc,
            _fnBuildAjax: _fnBuildAjax,
            _fnAjaxUpdate: _fnAjaxUpdate,
            _fnAjaxParameters: _fnAjaxParameters,
            _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
            _fnAjaxDataSrc: _fnAjaxDataSrc,
            _fnAddColumn: _fnAddColumn,
            _fnColumnOptions: _fnColumnOptions,
            _fnAdjustColumnSizing: _fnAdjustColumnSizing,
            _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
            _fnColumnIndexToVisible: _fnColumnIndexToVisible,
            _fnVisbleColumns: _fnVisbleColumns,
            _fnGetColumns: _fnGetColumns,
            _fnColumnTypes: _fnColumnTypes,
            _fnApplyColumnDefs: _fnApplyColumnDefs,
            _fnHungarianMap: _fnHungarianMap,
            _fnCamelToHungarian: _fnCamelToHungarian,
            _fnLanguageCompat: _fnLanguageCompat,
            _fnBrowserDetect: _fnBrowserDetect,
            _fnAddData: _fnAddData,
            _fnAddTr: _fnAddTr,
            _fnNodeToDataIndex: _fnNodeToDataIndex,
            _fnNodeToColumnIndex: _fnNodeToColumnIndex,
            _fnGetCellData: _fnGetCellData,
            _fnSetCellData: _fnSetCellData,
            _fnSplitObjNotation: _fnSplitObjNotation,
            _fnGetObjectDataFn: _fnGetObjectDataFn,
            _fnSetObjectDataFn: _fnSetObjectDataFn,
            _fnGetDataMaster: _fnGetDataMaster,
            _fnClearTable: _fnClearTable,
            _fnDeleteIndex: _fnDeleteIndex,
            _fnInvalidate: _fnInvalidate,
            _fnGetRowElements: _fnGetRowElements,
            _fnCreateTr: _fnCreateTr,
            _fnBuildHead: _fnBuildHead,
            _fnDrawHead: _fnDrawHead,
            _fnDraw: _fnDraw,
            _fnReDraw: _fnReDraw,
            _fnAddOptionsHtml: _fnAddOptionsHtml,
            _fnDetectHeader: _fnDetectHeader,
            _fnGetUniqueThs: _fnGetUniqueThs,
            _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
            _fnFilterComplete: _fnFilterComplete,
            _fnFilterCustom: _fnFilterCustom,
            _fnFilterColumn: _fnFilterColumn,
            _fnFilter: _fnFilter,
            _fnFilterCreateSearch: _fnFilterCreateSearch,
            _fnEscapeRegex: _fnEscapeRegex,
            _fnFilterData: _fnFilterData,
            _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
            _fnUpdateInfo: _fnUpdateInfo,
            _fnInfoMacros: _fnInfoMacros,
            _fnInitialise: _fnInitialise,
            _fnInitComplete: _fnInitComplete,
            _fnLengthChange: _fnLengthChange,
            _fnFeatureHtmlLength: _fnFeatureHtmlLength,
            _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
            _fnPageChange: _fnPageChange,
            _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
            _fnProcessingDisplay: _fnProcessingDisplay,
            _fnFeatureHtmlTable: _fnFeatureHtmlTable,
            _fnScrollDraw: _fnScrollDraw,
            _fnApplyToChildren: _fnApplyToChildren,
            _fnCalculateColumnWidths: _fnCalculateColumnWidths,
            _fnThrottle: _fnThrottle,
            _fnConvertToWidth: _fnConvertToWidth,
            _fnGetWidestNode: _fnGetWidestNode,
            _fnGetMaxLenString: _fnGetMaxLenString,
            _fnStringToCss: _fnStringToCss,
            _fnSortFlatten: _fnSortFlatten,
            _fnSort: _fnSort,
            _fnSortAria: _fnSortAria,
            _fnSortListener: _fnSortListener,
            _fnSortAttachListener: _fnSortAttachListener,
            _fnSortingClasses: _fnSortingClasses,
            _fnSortData: _fnSortData,
            _fnSaveState: _fnSaveState,
            _fnLoadState: _fnLoadState,
            _fnSettingsFromNode: _fnSettingsFromNode,
            _fnLog: _fnLog,
            _fnMap: _fnMap,
            _fnBindAction: _fnBindAction,
            _fnCallbackReg: _fnCallbackReg,
            _fnCallbackFire: _fnCallbackFire,
            _fnLengthOverflow: _fnLengthOverflow,
            _fnRenderer: _fnRenderer,
            _fnDataSource: _fnDataSource,
            _fnRowAttributes: _fnRowAttributes,
            _fnCalculateEnd: function () { } // Used by a lot of plug-ins, but redundant
            // in 1.10, so this dead-end function is
            // added to prevent errors
        });


        // jQuery access
        $.fn.dataTable = DataTable;

        // Provide access to the host jQuery object (circular reference)
        DataTable.$ = $;

        // Legacy aliases
        $.fn.dataTableSettings = DataTable.settings;
        $.fn.dataTableExt = DataTable.ext;

        // With a capital `D` we return a DataTables API instance rather than a
        // jQuery object
        $.fn.DataTable = function (opts) {
            return $(this).dataTable(opts).api();
        };

        // All properties that are available to $.fn.dataTable should also be
        // available on $.fn.DataTable
        $.each(DataTable, function (prop, val) {
            $.fn.DataTable[prop] = val;
        });


        // Information about events fired by DataTables - for documentation.
        /**
         * Draw event, fired whenever the table is redrawn on the page, at the same
         * point as fnDrawCallback. This may be useful for binding events or
         * performing calculations when the table is altered at all.
         *  @name DataTable#draw.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Search event, fired when the searching applied to the table (using the
         * built-in global search, or column filters) is altered.
         *  @name DataTable#search.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Page change event, fired when the paging of the table is altered.
         *  @name DataTable#page.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Order event, fired when the ordering applied to the table is altered.
         *  @name DataTable#order.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * DataTables initialisation complete event, fired when the table is fully
         * drawn, including Ajax data loaded, if Ajax data is required.
         *  @name DataTable#init.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The JSON object request from the server - only
         *    present if client-side Ajax sourced data is used</li></ol>
         */

        /**
         * State save event, fired when the table has changed state a new state save
         * is required. This event allows modification of the state saving object
         * prior to actually doing the save, including addition or other state
         * properties (for plug-ins) or modification of a DataTables core property.
         *  @name DataTable#stateSaveParams.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The state information to be saved
         */

        /**
         * State load event, fired when the table is loading state from the stored
         * data, but prior to the settings object being modified by the saved state
         * - allowing modification of the saved state is required or loading of
         * state for a plug-in.
         *  @name DataTable#stateLoadParams.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The saved state information
         */

        /**
         * State loaded event, fired when state has been loaded from stored data and
         * the settings object has been modified by the loaded data.
         *  @name DataTable#stateLoaded.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The saved state information
         */

        /**
         * Processing event, fired when DataTables is doing some kind of processing
         * (be it, order, searcg or anything else). It can be used to indicate to
         * the end user that there is something happening, or that something has
         * finished.
         *  @name DataTable#processing.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {boolean} bShow Flag for if DataTables is doing processing or not
         */

        /**
         * Ajax (XHR) event, fired whenever an Ajax request is completed from a
         * request to made to the server for new data. This event is called before
         * DataTables processed the returned data, so it can also be used to pre-
         * process the data returned from the server, if needed.
         *
         * Note that this trigger is called in `fnServerData`, if you override
         * `fnServerData` and which to use this event, you need to trigger it in you
         * success function.
         *  @name DataTable#xhr.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         *  @param {object} json JSON returned from the server
         *
         *  @example
         *     // Use a custom property returned from the server in another DOM element
         *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
         *       $('#status').html( json.status );
         *     } );
         *
         *  @example
         *     // Pre-process the data returned from the server
         *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
         *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
         *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
         *       }
         *       // Note no return - manipulate the data directly in the JSON object.
         *     } );
         */

        /**
         * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
         * or passing the bDestroy:true parameter in the initialisation object. This
         * can be used to remove bound events, added DOM nodes, etc.
         *  @name DataTable#destroy.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Page length change event, fired when number of records to show on each
         * page (the length) is changed.
         *  @name DataTable#length.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         *  @param {integer} len New length
         */

        /**
         * Column sizing has changed.
         *  @name DataTable#column-sizing.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Column visibility has changed.
         *  @name DataTable#column-visibility.dt
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         *  @param {int} column Column index
         *  @param {bool} vis `false` if column now hidden, or `true` if visible
         */

        return $.fn.dataTable;
    }));
/*! Buttons for DataTables 1.5.1
 * Â©2016-2017 SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                root = window;
            }

            if (!$ || !$.fn.dataTable) {
                $ = require('datatables.net')(root, $).$;
            }

            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document, undefined) {
    'use strict';
    var DataTable = $.fn.dataTable;


    // Used for namespacing events added to the document by each instance, so they
    // can be removed on destroy
    var _instCounter = 0;

    // Button namespacing counter for namespacing events on individual buttons
    var _buttonCounter = 0;

    var _dtButtons = DataTable.ext.buttons;

    /**
     * [Buttons description]
     * @param {[type]}
     * @param {[type]}
     */
    var Buttons = function (dt, config) {
        // If there is no config set it to an empty object
        if (typeof (config) === 'undefined') {
            config = {};
        }

        // Allow a boolean true for defaults
        if (config === true) {
            config = {};
        }

        // For easy configuration of buttons an array can be given
        if ($.isArray(config)) {
            config = { buttons: config };
        }

        this.c = $.extend(true, {}, Buttons.defaults, config);

        // Don't want a deep copy for the buttons
        if (config.buttons) {
            this.c.buttons = config.buttons;
        }

        this.s = {
            dt: new DataTable.Api(dt),
            buttons: [],
            listenKeys: '',
            namespace: 'dtb' + (_instCounter++)
        };

        this.dom = {
            container: $('<' + this.c.dom.container.tag + '/>')
                .addClass(this.c.dom.container.className)
        };

        this._constructor();
    };


    $.extend(Buttons.prototype, {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Public methods
         */

        /**
         * Get the action of a button
         * @param  {int|string} Button index
         * @return {function}
         *//**
        * Set the action of a button
        * @param  {node} node Button element
        * @param  {function} action Function to set
        * @return {Buttons} Self for chaining
        */
        action: function (node, action) {
            var button = this._nodeToButton(node);

            if (action === undefined) {
                return button.conf.action;
            }

            button.conf.action = action;

            return this;
        },

        /**
         * Add an active class to the button to make to look active or get current
         * active state.
         * @param  {node} node Button element
         * @param  {boolean} [flag] Enable / disable flag
         * @return {Buttons} Self for chaining or boolean for getter
         */
        active: function (node, flag) {
            var button = this._nodeToButton(node);
            var klass = this.c.dom.button.active;
            var jqNode = $(button.node);

            if (flag === undefined) {
                return jqNode.hasClass(klass);
            }

            jqNode.toggleClass(klass, flag === undefined ? true : flag);

            return this;
        },

        /**
         * Add a new button
         * @param {object} config Button configuration object, base string name or function
         * @param {int|string} [idx] Button index for where to insert the button
         * @return {Buttons} Self for chaining
         */
        add: function (config, idx) {
            var buttons = this.s.buttons;

            if (typeof idx === 'string') {
                var split = idx.split('-');
                var base = this.s;

                for (var i = 0, ien = split.length - 1; i < ien; i++) {
                    base = base.buttons[split[i] * 1];
                }

                buttons = base.buttons;
                idx = split[split.length - 1] * 1;
            }

            this._expandButton(buttons, config, false, idx);
            this._draw();

            return this;
        },

        /**
         * Get the container node for the buttons
         * @return {jQuery} Buttons node
         */
        container: function () {
            return this.dom.container;
        },

        /**
         * Disable a button
         * @param  {node} node Button node
         * @return {Buttons} Self for chaining
         */
        disable: function (node) {
            var button = this._nodeToButton(node);

            $(button.node).addClass(this.c.dom.button.disabled);

            return this;
        },

        /**
         * Destroy the instance, cleaning up event handlers and removing DOM
         * elements
         * @return {Buttons} Self for chaining
         */
        destroy: function () {
            // Key event listener
            $('body').off('keyup.' + this.s.namespace);

            // Individual button destroy (so they can remove their own events if
            // needed). Take a copy as the array is modified by `remove`
            var buttons = this.s.buttons.slice();
            var i, ien;

            for (i = 0, ien = buttons.length; i < ien; i++) {
                this.remove(buttons[i].node);
            }

            // Container
            this.dom.container.remove();

            // Remove from the settings object collection
            var buttonInsts = this.s.dt.settings()[0];

            for (i = 0, ien = buttonInsts.length; i < ien; i++) {
                if (buttonInsts.inst === this) {
                    buttonInsts.splice(i, 1);
                    break;
                }
            }

            return this;
        },

        /**
         * Enable / disable a button
         * @param  {node} node Button node
         * @param  {boolean} [flag=true] Enable / disable flag
         * @return {Buttons} Self for chaining
         */
        enable: function (node, flag) {
            if (flag === false) {
                return this.disable(node);
            }

            var button = this._nodeToButton(node);
            $(button.node).removeClass(this.c.dom.button.disabled);

            return this;
        },

        /**
         * Get the instance name for the button set selector
         * @return {string} Instance name
         */
        name: function () {
            return this.c.name;
        },

        /**
         * Get a button's node
         * @param  {node} node Button node
         * @return {jQuery} Button element
         */
        node: function (node) {
            var button = this._nodeToButton(node);
            return $(button.node);
        },

        /**
         * Set / get a processing class on the selected button
         * @param  {boolean} flag true to add, false to remove, undefined to get
         * @return {boolean|Buttons} Getter value or this if a setter.
         */
        processing: function (node, flag) {
            var button = this._nodeToButton(node);

            if (flag === undefined) {
                return $(button.node).hasClass('processing');
            }

            $(button.node).toggleClass('processing', flag);

            return this;
        },

        /**
         * Remove a button.
         * @param  {node} node Button node
         * @return {Buttons} Self for chaining
         */
        remove: function (node) {
            var button = this._nodeToButton(node);
            var host = this._nodeToHost(node);
            var dt = this.s.dt;

            // Remove any child buttons first
            if (button.buttons.length) {
                for (var i = button.buttons.length - 1; i >= 0; i--) {
                    this.remove(button.buttons[i].node);
                }
            }

            // Allow the button to remove event handlers, etc
            if (button.conf.destroy) {
                button.conf.destroy.call(dt.button(node), dt, $(node), button.conf);
            }

            this._removeKey(button.conf);

            $(button.node).remove();

            var idx = $.inArray(button, host);
            host.splice(idx, 1);

            return this;
        },

        /**
         * Get the text for a button
         * @param  {int|string} node Button index
         * @return {string} Button text
         *//**
        * Set the text for a button
        * @param  {int|string|function} node Button index
        * @param  {string} label Text
        * @return {Buttons} Self for chaining
        */
        text: function (node, label) {
            var button = this._nodeToButton(node);
            var buttonLiner = this.c.dom.collection.buttonLiner;
            var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?
                buttonLiner.tag :
                this.c.dom.buttonLiner.tag;
            var dt = this.s.dt;
            var jqNode = $(button.node);
            var text = function (opt) {
                return typeof opt === 'function' ?
                    opt(dt, jqNode, button.conf) :
                    opt;
            };

            if (label === undefined) {
                return text(button.conf.text);
            }

            button.conf.text = label;

            if (linerTag) {
                jqNode.children(linerTag).html(text(label));
            }
            else {
                jqNode.html(text(label));
            }

            return this;
        },


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Constructor
         */

        /**
         * Buttons constructor
         * @private
         */
        _constructor: function () {
            var that = this;
            var dt = this.s.dt;
            var dtSettings = dt.settings()[0];
            var buttons = this.c.buttons;

            if (!dtSettings._buttons) {
                dtSettings._buttons = [];
            }

            dtSettings._buttons.push({
                inst: this,
                name: this.c.name
            });

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                this.add(buttons[i]);
            }

            dt.on('destroy', function () {
                that.destroy();
            });

            // Global key event binding to listen for button keys
            $('body').on('keyup.' + this.s.namespace, function (e) {
                if (!document.activeElement || document.activeElement === document.body) {
                    // SUse a string of characters for fast lookup of if we need to
                    // handle this
                    var character = String.fromCharCode(e.keyCode).toLowerCase();

                    if (that.s.listenKeys.toLowerCase().indexOf(character) !== -1) {
                        that._keypress(character, e);
                    }
                }
            });
        },


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Private methods
         */

        /**
         * Add a new button to the key press listener
         * @param {object} conf Resolved button configuration object
         * @private
         */
        _addKey: function (conf) {
            if (conf.key) {
                this.s.listenKeys += $.isPlainObject(conf.key) ?
                    conf.key.key :
                    conf.key;
            }
        },

        /**
         * Insert the buttons into the container. Call without parameters!
         * @param  {node} [container] Recursive only - Insert point
         * @param  {array} [buttons] Recursive only - Buttons array
         * @private
         */
        _draw: function (container, buttons) {
            if (!container) {
                container = this.dom.container;
                buttons = this.s.buttons;
            }

            container.children().detach();

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                container.append(buttons[i].inserter);
                container.append(' ');

                if (buttons[i].buttons && buttons[i].buttons.length) {
                    this._draw(buttons[i].collection, buttons[i].buttons);
                }
            }
        },

        /**
         * Create buttons from an array of buttons
         * @param  {array} attachTo Buttons array to attach to
         * @param  {object} button Button definition
         * @param  {boolean} inCollection true if the button is in a collection
         * @private
         */
        _expandButton: function (attachTo, button, inCollection, attachPoint) {
            var dt = this.s.dt;
            var buttonCounter = 0;
            var buttons = !$.isArray(button) ?
                [button] :
                button;

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                var conf = this._resolveExtends(buttons[i]);

                if (!conf) {
                    continue;
                }

                // If the configuration is an array, then expand the buttons at this
                // point
                if ($.isArray(conf)) {
                    this._expandButton(attachTo, conf, inCollection, attachPoint);
                    continue;
                }

                var built = this._buildButton(conf, inCollection);
                if (!built) {
                    continue;
                }

                if (attachPoint !== undefined) {
                    attachTo.splice(attachPoint, 0, built);
                    attachPoint++;
                }
                else {
                    attachTo.push(built);
                }

                if (built.conf.buttons) {
                    var collectionDom = this.c.dom.collection;
                    built.collection = $('<' + collectionDom.tag + '/>')
                        .addClass(collectionDom.className)
                        .attr('role', 'menu');
                    built.conf._collection = built.collection;

                    this._expandButton(built.buttons, built.conf.buttons, true, attachPoint);
                }

                // init call is made here, rather than buildButton as it needs to
                // be selectable, and for that it needs to be in the buttons array
                if (conf.init) {
                    conf.init.call(dt.button(built.node), dt, $(built.node), conf);
                }

                buttonCounter++;
            }
        },

        /**
         * Create an individual button
         * @param  {object} config            Resolved button configuration
         * @param  {boolean} inCollection `true` if a collection button
         * @return {jQuery} Created button node (jQuery)
         * @private
         */
        _buildButton: function (config, inCollection) {
            var buttonDom = this.c.dom.button;
            var linerDom = this.c.dom.buttonLiner;
            var collectionDom = this.c.dom.collection;
            var dt = this.s.dt;
            var text = function (opt) {
                return typeof opt === 'function' ?
                    opt(dt, button, config) :
                    opt;
            };

            if (inCollection && collectionDom.button) {
                buttonDom = collectionDom.button;
            }

            if (inCollection && collectionDom.buttonLiner) {
                linerDom = collectionDom.buttonLiner;
            }

            // Make sure that the button is available based on whatever requirements
            // it has. For example, Flash buttons require Flash
            if (config.available && !config.available(dt, config)) {
                return false;
            }

            var action = function (e, dt, button, config) {
                config.action.call(dt.button(button), e, dt, button, config);

                $(dt.table().node()).triggerHandler('buttons-action.dt', [
                    dt.button(button), dt, button, config
                ]);
            };

            var button = $('<' + buttonDom.tag + '/>')
                .addClass(buttonDom.className)
                .attr('tabindex', this.s.dt.settings()[0].iTabIndex)
                .attr('aria-controls', this.s.dt.table().node().id)
                .on('click.dtb', function (e) {
                    e.preventDefault();

                    if (!button.hasClass(buttonDom.disabled) && config.action) {
                        action(e, dt, button, config);
                    }

                    button.blur();
                })
                .on('keyup.dtb', function (e) {
                    if (e.keyCode === 13) {
                        if (!button.hasClass(buttonDom.disabled) && config.action) {
                            action(e, dt, button, config);
                        }
                    }
                });

            // Make `a` tags act like a link
            if (buttonDom.tag.toLowerCase() === 'a') {
                button.attr('href', '#');
            }

            if (linerDom.tag) {
                var liner = $('<' + linerDom.tag + '/>')
                    .html(text(config.text))
                    .addClass(linerDom.className);

                if (linerDom.tag.toLowerCase() === 'a') {
                    liner.attr('href', '#');
                }

                button.append(liner);
            }
            else {
                button.html(text(config.text));
            }

            if (config.enabled === false) {
                button.addClass(buttonDom.disabled);
            }

            if (config.className) {
                button.addClass(config.className);
            }

            if (config.titleAttr) {
                button.attr('title', text(config.titleAttr));
            }

            if (config.attr) {
                button.attr(config.attr);
            }

            if (!config.namespace) {
                config.namespace = '.dt-button-' + (_buttonCounter++);
            }

            var buttonContainer = this.c.dom.buttonContainer;
            var inserter;
            if (buttonContainer && buttonContainer.tag) {
                inserter = $('<' + buttonContainer.tag + '/>')
                    .addClass(buttonContainer.className)
                    .append(button);
            }
            else {
                inserter = button;
            }

            this._addKey(config);

            return {
                conf: config,
                node: button.get(0),
                inserter: inserter,
                buttons: [],
                inCollection: inCollection,
                collection: null
            };
        },

        /**
         * Get the button object from a node (recursive)
         * @param  {node} node Button node
         * @param  {array} [buttons] Button array, uses base if not defined
         * @return {object} Button object
         * @private
         */
        _nodeToButton: function (node, buttons) {
            if (!buttons) {
                buttons = this.s.buttons;
            }

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                if (buttons[i].node === node) {
                    return buttons[i];
                }

                if (buttons[i].buttons.length) {
                    var ret = this._nodeToButton(node, buttons[i].buttons);

                    if (ret) {
                        return ret;
                    }
                }
            }
        },

        /**
         * Get container array for a button from a button node (recursive)
         * @param  {node} node Button node
         * @param  {array} [buttons] Button array, uses base if not defined
         * @return {array} Button's host array
         * @private
         */
        _nodeToHost: function (node, buttons) {
            if (!buttons) {
                buttons = this.s.buttons;
            }

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                if (buttons[i].node === node) {
                    return buttons;
                }

                if (buttons[i].buttons.length) {
                    var ret = this._nodeToHost(node, buttons[i].buttons);

                    if (ret) {
                        return ret;
                    }
                }
            }
        },

        /**
         * Handle a key press - determine if any button's key configured matches
         * what was typed and trigger the action if so.
         * @param  {string} character The character pressed
         * @param  {object} e Key event that triggered this call
         * @private
         */
        _keypress: function (character, e) {
            // Check if this button press already activated on another instance of Buttons
            if (e._buttonsHandled) {
                return;
            }

            var run = function (conf, node) {
                if (!conf.key) {
                    return;
                }

                if (conf.key === character) {
                    e._buttonsHandled = true;
                    $(node).click();
                }
                else if ($.isPlainObject(conf.key)) {
                    if (conf.key.key !== character) {
                        return;
                    }

                    if (conf.key.shiftKey && !e.shiftKey) {
                        return;
                    }

                    if (conf.key.altKey && !e.altKey) {
                        return;
                    }

                    if (conf.key.ctrlKey && !e.ctrlKey) {
                        return;
                    }

                    if (conf.key.metaKey && !e.metaKey) {
                        return;
                    }

                    // Made it this far - it is good
                    e._buttonsHandled = true;
                    $(node).click();
                }
            };

            var recurse = function (a) {
                for (var i = 0, ien = a.length; i < ien; i++) {
                    run(a[i].conf, a[i].node);

                    if (a[i].buttons.length) {
                        recurse(a[i].buttons);
                    }
                }
            };

            recurse(this.s.buttons);
        },

        /**
         * Remove a key from the key listener for this instance (to be used when a
         * button is removed)
         * @param  {object} conf Button configuration
         * @private
         */
        _removeKey: function (conf) {
            if (conf.key) {
                var character = $.isPlainObject(conf.key) ?
                    conf.key.key :
                    conf.key;

                // Remove only one character, as multiple buttons could have the
                // same listening key
                var a = this.s.listenKeys.split('');
                var idx = $.inArray(character, a);
                a.splice(idx, 1);
                this.s.listenKeys = a.join('');
            }
        },

        /**
         * Resolve a button configuration
         * @param  {string|function|object} conf Button config to resolve
         * @return {object} Button configuration
         * @private
         */
        _resolveExtends: function (conf) {
            var dt = this.s.dt;
            var i, ien;
            var toConfObject = function (base) {
                var loop = 0;

                // Loop until we have resolved to a button configuration, or an
                // array of button configurations (which will be iterated
                // separately)
                while (!$.isPlainObject(base) && !$.isArray(base)) {
                    if (base === undefined) {
                        return;
                    }

                    if (typeof base === 'function') {
                        base = base(dt, conf);

                        if (!base) {
                            return false;
                        }
                    }
                    else if (typeof base === 'string') {
                        if (!_dtButtons[base]) {
                            throw 'Unknown button type: ' + base;
                        }

                        base = _dtButtons[base];
                    }

                    loop++;
                    if (loop > 30) {
                        // Protect against misconfiguration killing the browser
                        throw 'Buttons: Too many iterations';
                    }
                }

                return $.isArray(base) ?
                    base :
                    $.extend({}, base);
            };

            conf = toConfObject(conf);

            while (conf && conf.extend) {
                // Use `toConfObject` in case the button definition being extended
                // is itself a string or a function
                if (!_dtButtons[conf.extend]) {
                    throw 'Cannot extend unknown button type: ' + conf.extend;
                }

                var objArray = toConfObject(_dtButtons[conf.extend]);
                if ($.isArray(objArray)) {
                    return objArray;
                }
                else if (!objArray) {
                    // This is a little brutal as it might be possible to have a
                    // valid button without the extend, but if there is no extend
                    // then the host button would be acting in an undefined state
                    return false;
                }

                // Stash the current class name
                var originalClassName = objArray.className;

                conf = $.extend({}, objArray, conf);

                // The extend will have overwritten the original class name if the
                // `conf` object also assigned a class, but we want to concatenate
                // them so they are list that is combined from all extended buttons
                if (originalClassName && conf.className !== originalClassName) {
                    conf.className = originalClassName + ' ' + conf.className;
                }

                // Buttons to be added to a collection  -gives the ability to define
                // if buttons should be added to the start or end of a collection
                var postfixButtons = conf.postfixButtons;
                if (postfixButtons) {
                    if (!conf.buttons) {
                        conf.buttons = [];
                    }

                    for (i = 0, ien = postfixButtons.length; i < ien; i++) {
                        conf.buttons.push(postfixButtons[i]);
                    }

                    conf.postfixButtons = null;
                }

                var prefixButtons = conf.prefixButtons;
                if (prefixButtons) {
                    if (!conf.buttons) {
                        conf.buttons = [];
                    }

                    for (i = 0, ien = prefixButtons.length; i < ien; i++) {
                        conf.buttons.splice(i, 0, prefixButtons[i]);
                    }

                    conf.prefixButtons = null;
                }

                // Although we want the `conf` object to overwrite almost all of
                // the properties of the object being extended, the `extend`
                // property should come from the object being extended
                conf.extend = objArray.extend;
            }

            return conf;
        }
    });



    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Statics
     */

    /**
     * Show / hide a background layer behind a collection
     * @param  {boolean} Flag to indicate if the background should be shown or
     *   hidden 
     * @param  {string} Class to assign to the background
     * @static
     */
    Buttons.background = function (show, className, fade) {
        if (fade === undefined) {
            fade = 400;
        }

        if (show) {
            $('<div/>')
                .addClass(className)
                .css('display', 'none')
                .appendTo('body')
                .fadeIn(fade);
        }
        else {
            $('body > div.' + className)
                .fadeOut(fade, function () {
                    $(this)
                        .removeClass(className)
                        .remove();
                });
        }
    };

    /**
     * Instance selector - select Buttons instances based on an instance selector
     * value from the buttons assigned to a DataTable. This is only useful if
     * multiple instances are attached to a DataTable.
     * @param  {string|int|array} Instance selector - see `instance-selector`
     *   documentation on the DataTables site
     * @param  {array} Button instance array that was attached to the DataTables
     *   settings object
     * @return {array} Buttons instances
     * @static
     */
    Buttons.instanceSelector = function (group, buttons) {
        if (!group) {
            return $.map(buttons, function (v) {
                return v.inst;
            });
        }

        var ret = [];
        var names = $.map(buttons, function (v) {
            return v.name;
        });

        // Flatten the group selector into an array of single options
        var process = function (input) {
            if ($.isArray(input)) {
                for (var i = 0, ien = input.length; i < ien; i++) {
                    process(input[i]);
                }
                return;
            }

            if (typeof input === 'string') {
                if (input.indexOf(',') !== -1) {
                    // String selector, list of names
                    process(input.split(','));
                }
                else {
                    // String selector individual name
                    var idx = $.inArray($.trim(input), names);

                    if (idx !== -1) {
                        ret.push(buttons[idx].inst);
                    }
                }
            }
            else if (typeof input === 'number') {
                // Index selector
                ret.push(buttons[input].inst);
            }
        };

        process(group);

        return ret;
    };

    /**
     * Button selector - select one or more buttons from a selector input so some
     * operation can be performed on them.
     * @param  {array} Button instances array that the selector should operate on
     * @param  {string|int|node|jQuery|array} Button selector - see
     *   `button-selector` documentation on the DataTables site
     * @return {array} Array of objects containing `inst` and `idx` properties of
     *   the selected buttons so you know which instance each button belongs to.
     * @static
     */
    Buttons.buttonSelector = function (insts, selector) {
        var ret = [];
        var nodeBuilder = function (a, buttons, baseIdx) {
            var button;
            var idx;

            for (var i = 0, ien = buttons.length; i < ien; i++) {
                button = buttons[i];

                if (button) {
                    idx = baseIdx !== undefined ?
                        baseIdx + i :
                        i + '';

                    a.push({
                        node: button.node,
                        name: button.conf.name,
                        idx: idx
                    });

                    if (button.buttons) {
                        nodeBuilder(a, button.buttons, idx + '-');
                    }
                }
            }
        };

        var run = function (selector, inst) {
            var i, ien;
            var buttons = [];
            nodeBuilder(buttons, inst.s.buttons);

            var nodes = $.map(buttons, function (v) {
                return v.node;
            });

            if ($.isArray(selector) || selector instanceof $) {
                for (i = 0, ien = selector.length; i < ien; i++) {
                    run(selector[i], inst);
                }
                return;
            }

            if (selector === null || selector === undefined || selector === '*') {
                // Select all
                for (i = 0, ien = buttons.length; i < ien; i++) {
                    ret.push({
                        inst: inst,
                        node: buttons[i].node
                    });
                }
            }
            else if (typeof selector === 'number') {
                // Main button index selector
                ret.push({
                    inst: inst,
                    node: inst.s.buttons[selector].node
                });
            }
            else if (typeof selector === 'string') {
                if (selector.indexOf(',') !== -1) {
                    // Split
                    var a = selector.split(',');

                    for (i = 0, ien = a.length; i < ien; i++) {
                        run($.trim(a[i]), inst);
                    }
                }
                else if (selector.match(/^\d+(\-\d+)*$/)) {
                    // Sub-button index selector
                    var indexes = $.map(buttons, function (v) {
                        return v.idx;
                    });

                    ret.push({
                        inst: inst,
                        node: buttons[$.inArray(selector, indexes)].node
                    });
                }
                else if (selector.indexOf(':name') !== -1) {
                    // Button name selector
                    var name = selector.replace(':name', '');

                    for (i = 0, ien = buttons.length; i < ien; i++) {
                        if (buttons[i].name === name) {
                            ret.push({
                                inst: inst,
                                node: buttons[i].node
                            });
                        }
                    }
                }
                else {
                    // jQuery selector on the nodes
                    $(nodes).filter(selector).each(function () {
                        ret.push({
                            inst: inst,
                            node: this
                        });
                    });
                }
            }
            else if (typeof selector === 'object' && selector.nodeName) {
                // Node selector
                var idx = $.inArray(selector, nodes);

                if (idx !== -1) {
                    ret.push({
                        inst: inst,
                        node: nodes[idx]
                    });
                }
            }
        };


        for (var i = 0, ien = insts.length; i < ien; i++) {
            var inst = insts[i];

            run(selector, inst);
        }

        return ret;
    };


    /**
     * Buttons defaults. For full documentation, please refer to the docs/option
     * directory or the DataTables site.
     * @type {Object}
     * @static
     */
    Buttons.defaults = {
        buttons: ['copy', 'excel', 'csv', 'pdf', 'print'],
        name: 'main',
        tabIndex: 0,
        dom: {
            container: {
                tag: 'div',
                className: 'dt-buttons'
            },
            collection: {
                tag: 'div',
                className: 'dt-button-collection'
            },
            button: {
                tag: 'button',
                className: 'dt-button',
                active: 'active',
                disabled: 'disabled'
            },
            buttonLiner: {
                tag: 'span',
                className: ''
            }
        }
    };

    /**
     * Version information
     * @type {string}
     * @static
     */
    Buttons.version = '1.5.1';


    $.extend(_dtButtons, {
        collection: {
            text: function (dt) {
                return dt.i18n('buttons.collection', 'Collection');
            },
            className: 'buttons-collection',
            action: function (e, dt, button, config) {
                var host = button;
                var collectionParent = $(button).parents('div.dt-button-collection');
                var hostPosition = host.position();
                var tableContainer = $(dt.table().container());
                var multiLevel = false;
                var insertPoint = host;

                // Remove any old collection
                if (collectionParent.length) {
                    multiLevel = $('.dt-button-collection').position();
                    insertPoint = collectionParent;
                    $('body').trigger('click.dtb-collection');
                }

                config._collection
                    .addClass(config.collectionLayout)
                    .css('display', 'none')
                    .insertAfter(insertPoint)
                    .fadeIn(config.fade);


                var position = config._collection.css('position');

                if (multiLevel && position === 'absolute') {
                    config._collection.css({
                        top: multiLevel.top,
                        left: multiLevel.left
                    });
                }
                else if (position === 'absolute') {
                    config._collection.css({
                        top: hostPosition.top + host.outerHeight(),
                        left: hostPosition.left
                    });

                    // calculate overflow when positioned beneath
                    var tableBottom = tableContainer.offset().top + tableContainer.height();
                    var listBottom = hostPosition.top + host.outerHeight() + config._collection.outerHeight();
                    var bottomOverflow = listBottom - tableBottom;

                    // calculate overflow when positioned above
                    var listTop = hostPosition.top - config._collection.outerHeight();
                    var tableTop = tableContainer.offset().top;
                    var topOverflow = tableTop - listTop;

                    // if bottom overflow is larger, move to the top because it fits better
                    if (bottomOverflow > topOverflow) {
                        config._collection.css('top', hostPosition.top - config._collection.outerHeight() - 5);
                    }

                    var listRight = hostPosition.left + config._collection.outerWidth();
                    var tableRight = tableContainer.offset().left + tableContainer.width();
                    if (listRight > tableRight) {
                        config._collection.css('left', hostPosition.left - (listRight - tableRight));
                    }
                }
                else {
                    // Fix position - centre on screen
                    var top = config._collection.height() / 2;
                    if (top > $(window).height() / 2) {
                        top = $(window).height() / 2;
                    }

                    config._collection.css('marginTop', top * -1);
                }

                if (config.background) {
                    Buttons.background(true, config.backgroundClassName, config.fade);
                }

                // Need to break the 'thread' for the collection button being
                // activated by a click - it would also trigger this event
                setTimeout(function () {
                    // This is bonkers, but if we don't have a click listener on the
                    // background element, iOS Safari will ignore the body click
                    // listener below. An empty function here is all that is
                    // required to make it work...
                    $('div.dt-button-background').on('click.dtb-collection', function () { });

                    $('body').on('click.dtb-collection', function (e) {
                        // andSelf is deprecated in jQ1.8, but we want 1.7 compat
                        var back = $.fn.addBack ? 'addBack' : 'andSelf';

                        if (!$(e.target).parents()[back]().filter(config._collection).length) {
                            config._collection
                                .fadeOut(config.fade, function () {
                                    config._collection.detach();
                                });

                            $('div.dt-button-background').off('click.dtb-collection');
                            Buttons.background(false, config.backgroundClassName, config.fade);

                            $('body').off('click.dtb-collection');
                            dt.off('buttons-action.b-internal');
                        }
                    });
                }, 10);

                if (config.autoClose) {
                    dt.on('buttons-action.b-internal', function () {
                        $('div.dt-button-background').click();
                    });
                }
            },
            background: true,
            collectionLayout: '',
            backgroundClassName: 'dt-button-background',
            autoClose: false,
            fade: 400,
            attr: {
                'aria-haspopup': true
            }
        },
        copy: function (dt, conf) {
            if (_dtButtons.copyHtml5) {
                return 'copyHtml5';
            }
            if (_dtButtons.copyFlash && _dtButtons.copyFlash.available(dt, conf)) {
                return 'copyFlash';
            }
        },
        csv: function (dt, conf) {
            // Common option that will use the HTML5 or Flash export buttons
            if (_dtButtons.csvHtml5 && _dtButtons.csvHtml5.available(dt, conf)) {
                return 'csvHtml5';
            }
            if (_dtButtons.csvFlash && _dtButtons.csvFlash.available(dt, conf)) {
                return 'csvFlash';
            }
        },
        excel: function (dt, conf) {
            // Common option that will use the HTML5 or Flash export buttons
            if (_dtButtons.excelHtml5 && _dtButtons.excelHtml5.available(dt, conf)) {
                return 'excelHtml5';
            }
            if (_dtButtons.excelFlash && _dtButtons.excelFlash.available(dt, conf)) {
                return 'excelFlash';
            }
        },
        pdf: function (dt, conf) {
            // Common option that will use the HTML5 or Flash export buttons
            if (_dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available(dt, conf)) {
                return 'pdfHtml5';
            }
            if (_dtButtons.pdfFlash && _dtButtons.pdfFlash.available(dt, conf)) {
                return 'pdfFlash';
            }
        },
        pageLength: function (dt) {
            var lengthMenu = dt.settings()[0].aLengthMenu;
            var vals = $.isArray(lengthMenu[0]) ? lengthMenu[0] : lengthMenu;
            var lang = $.isArray(lengthMenu[0]) ? lengthMenu[1] : lengthMenu;
            var text = function (dt) {
                return dt.i18n('buttons.pageLength', {
                    "-1": 'Show all rows',
                    _: 'Show %d rows'
                }, dt.page.len());
            };

            return {
                extend: 'collection',
                text: text,
                className: 'buttons-page-length',
                autoClose: true,
                buttons: $.map(vals, function (val, i) {
                    return {
                        text: lang[i],
                        className: 'button-page-length',
                        action: function (e, dt) {
                            dt.page.len(val).draw();
                        },
                        init: function (dt, node, conf) {
                            var that = this;
                            var fn = function () {
                                that.active(dt.page.len() === val);
                            };

                            dt.on('length.dt' + conf.namespace, fn);
                            fn();
                        },
                        destroy: function (dt, node, conf) {
                            dt.off('length.dt' + conf.namespace);
                        }
                    };
                }),
                init: function (dt, node, conf) {
                    var that = this;
                    dt.on('length.dt' + conf.namespace, function () {
                        that.text(text(dt));
                    });
                },
                destroy: function (dt, node, conf) {
                    dt.off('length.dt' + conf.namespace);
                }
            };
        }
    });


    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * DataTables API
     *
     * For complete documentation, please refer to the docs/api directory or the
     * DataTables site
     */

    // Buttons group and individual button selector
    DataTable.Api.register('buttons()', function (group, selector) {
        // Argument shifting
        if (selector === undefined) {
            selector = group;
            group = undefined;
        }

        this.selector.buttonGroup = group;

        var res = this.iterator(true, 'table', function (ctx) {
            if (ctx._buttons) {
                return Buttons.buttonSelector(
                    Buttons.instanceSelector(group, ctx._buttons),
                    selector
                );
            }
        }, true);

        res._groupSelector = group;
        return res;
    });

    // Individual button selector
    DataTable.Api.register('button()', function (group, selector) {
        // just run buttons() and truncate
        var buttons = this.buttons(group, selector);

        if (buttons.length > 1) {
            buttons.splice(1, buttons.length);
        }

        return buttons;
    });

    // Active buttons
    DataTable.Api.registerPlural('buttons().active()', 'button().active()', function (flag) {
        if (flag === undefined) {
            return this.map(function (set) {
                return set.inst.active(set.node);
            });
        }

        return this.each(function (set) {
            set.inst.active(set.node, flag);
        });
    });

    // Get / set button action
    DataTable.Api.registerPlural('buttons().action()', 'button().action()', function (action) {
        if (action === undefined) {
            return this.map(function (set) {
                return set.inst.action(set.node);
            });
        }

        return this.each(function (set) {
            set.inst.action(set.node, action);
        });
    });

    // Enable / disable buttons
    DataTable.Api.register(['buttons().enable()', 'button().enable()'], function (flag) {
        return this.each(function (set) {
            set.inst.enable(set.node, flag);
        });
    });

    // Disable buttons
    DataTable.Api.register(['buttons().disable()', 'button().disable()'], function () {
        return this.each(function (set) {
            set.inst.disable(set.node);
        });
    });

    // Get button nodes
    DataTable.Api.registerPlural('buttons().nodes()', 'button().node()', function () {
        var jq = $();

        // jQuery will automatically reduce duplicates to a single entry
        $(this.each(function (set) {
            jq = jq.add(set.inst.node(set.node));
        }));

        return jq;
    });

    // Get / set button processing state
    DataTable.Api.registerPlural('buttons().processing()', 'button().processing()', function (flag) {
        if (flag === undefined) {
            return this.map(function (set) {
                return set.inst.processing(set.node);
            });
        }

        return this.each(function (set) {
            set.inst.processing(set.node, flag);
        });
    });

    // Get / set button text (i.e. the button labels)
    DataTable.Api.registerPlural('buttons().text()', 'button().text()', function (label) {
        if (label === undefined) {
            return this.map(function (set) {
                return set.inst.text(set.node);
            });
        }

        return this.each(function (set) {
            set.inst.text(set.node, label);
        });
    });

    // Trigger a button's action
    DataTable.Api.registerPlural('buttons().trigger()', 'button().trigger()', function () {
        return this.each(function (set) {
            set.inst.node(set.node).trigger('click');
        });
    });

    // Get the container elements
    DataTable.Api.registerPlural('buttons().containers()', 'buttons().container()', function () {
        var jq = $();
        var groupSelector = this._groupSelector;

        // We need to use the group selector directly, since if there are no buttons
        // the result set will be empty
        this.iterator(true, 'table', function (ctx) {
            if (ctx._buttons) {
                var insts = Buttons.instanceSelector(groupSelector, ctx._buttons);

                for (var i = 0, ien = insts.length; i < ien; i++) {
                    jq = jq.add(insts[i].container());
                }
            }
        });

        return jq;
    });

    // Add a new button
    DataTable.Api.register('button().add()', function (idx, conf) {
        var ctx = this.context;

        // Don't use `this` as it could be empty - select the instances directly
        if (ctx.length) {
            var inst = Buttons.instanceSelector(this._groupSelector, ctx[0]._buttons);

            if (inst.length) {
                inst[0].add(conf, idx);
            }
        }

        return this.button(this._groupSelector, idx);
    });

    // Destroy the button sets selected
    DataTable.Api.register('buttons().destroy()', function () {
        this.pluck('inst').unique().each(function (inst) {
            inst.destroy();
        });

        return this;
    });

    // Remove a button
    DataTable.Api.registerPlural('buttons().remove()', 'buttons().remove()', function () {
        this.each(function (set) {
            set.inst.remove(set.node);
        });

        return this;
    });

    // Information box that can be used by buttons
    var _infoTimer;
    DataTable.Api.register('buttons.info()', function (title, message, time) {
        var that = this;

        if (title === false) {
            $('#datatables_buttons_info').fadeOut(function () {
                $(this).remove();
            });
            clearTimeout(_infoTimer);
            _infoTimer = null;

            return this;
        }

        if (_infoTimer) {
            clearTimeout(_infoTimer);
        }

        if ($('#datatables_buttons_info').length) {
            $('#datatables_buttons_info').remove();
        }

        title = title ? '<h2>' + title + '</h2>' : '';

        $('<div id="datatables_buttons_info" class="dt-button-info"/>')
            .html(title)
            .append($('<div/>')[typeof message === 'string' ? 'html' : 'append'](message))
            .css('display', 'none')
            .appendTo('body')
            .fadeIn();

        if (time !== undefined && time !== 0) {
            _infoTimer = setTimeout(function () {
                that.buttons.info(false);
            }, time);
        }

        return this;
    });

    // Get data from the table for export - this is common to a number of plug-in
    // buttons so it is included in the Buttons core library
    DataTable.Api.register('buttons.exportData()', function (options) {
        if (this.context.length) {
            return _exportData(new DataTable.Api(this.context[0]), options);
        }
    });

    // Get information about the export that is common to many of the export data
    // types (DRY)
    DataTable.Api.register('buttons.exportInfo()', function (conf) {
        if (!conf) {
            conf = {};
        }

        return {
            filename: _filename(conf),
            title: _title(conf),
            messageTop: _message(this, conf.message || conf.messageTop, 'top'),
            messageBottom: _message(this, conf.messageBottom, 'bottom')
        };
    });



    /**
     * Get the file name for an exported file.
     *
     * @param {object}	config Button configuration
     * @param {boolean} incExtension Include the file name extension
     */
    var _filename = function (config) {
        // Backwards compatibility
        var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ?
            config.title :
            config.filename;

        if (typeof filename === 'function') {
            filename = filename();
        }

        if (filename === undefined || filename === null) {
            return null;
        }

        if (filename.indexOf('*') !== -1) {
            filename = $.trim(filename.replace('*', $('head > title').text()));
        }

        // Strip characters which the OS will object to
        filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");

        var extension = _stringOrFunction(config.extension);
        if (!extension) {
            extension = '';
        }

        return filename + extension;
    };

    /**
     * Simply utility method to allow parameters to be given as a function
     *
     * @param {undefined|string|function} option Option
     * @return {null|string} Resolved value
     */
    var _stringOrFunction = function (option) {
        if (option === null || option === undefined) {
            return null;
        }
        else if (typeof option === 'function') {
            return option();
        }
        return option;
    };

    /**
     * Get the title for an exported file.
     *
     * @param {object} config	Button configuration
     */
    var _title = function (config) {
        var title = _stringOrFunction(config.title);

        return title === null ?
            null : title.indexOf('*') !== -1 ?
                title.replace('*', $('head > title').text() || 'Exported data') :
                title;
    };

    var _message = function (dt, option, position) {
        var message = _stringOrFunction(option);
        if (message === null) {
            return null;
        }

        var caption = $('caption', dt.table().container()).eq(0);
        if (message === '*') {
            var side = caption.css('caption-side');
            if (side !== position) {
                return null;
            }

            return caption.length ?
                caption.text() :
                '';
        }

        return message;
    };







    var _exportTextarea = $('<textarea/>')[0];
    var _exportData = function (dt, inOpts) {
        var config = $.extend(true, {}, {
            rows: null,
            columns: '',
            modifier: {
                search: 'applied',
                order: 'applied'
            },
            orthogonal: 'display',
            stripHtml: true,
            stripNewlines: true,
            decodeEntities: true,
            trim: true,
            format: {
                header: function (d) {
                    return strip(d);
                },
                footer: function (d) {
                    return strip(d);
                },
                body: function (d) {
                    return strip(d);
                }
            }
        }, inOpts);

        var strip = function (str) {
            if (typeof str !== 'string') {
                return str;
            }

            // Always remove script tags
            str = str.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');

            if (config.stripHtml) {
                str = str.replace(/<[^>]*>/g, '');
            }

            if (config.trim) {
                str = str.replace(/^\s+|\s+$/g, '');
            }

            if (config.stripNewlines) {
                str = str.replace(/\n/g, ' ');
            }

            if (config.decodeEntities) {
                _exportTextarea.innerHTML = str;
                str = _exportTextarea.value;
            }

            return str;
        };


        var header = dt.columns(config.columns).indexes().map(function (idx) {
            var el = dt.column(idx).header();
            return config.format.header(el.innerHTML, idx, el);
        }).toArray();

        var footer = dt.table().footer() ?
            dt.columns(config.columns).indexes().map(function (idx) {
                var el = dt.column(idx).footer();
                return config.format.footer(el ? el.innerHTML : '', idx, el);
            }).toArray() :
            null;

        // If Select is available on this table, and any rows are selected, limit the export
        // to the selected rows. If no rows are selected, all rows will be exported. Specify
        // a `selected` modifier to control directly.
        var modifier = $.extend({}, config.modifier);
        if (dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined) {
            if (dt.rows(config.rows, $.extend({ selected: true }, modifier)).any()) {
                $.extend(modifier, { selected: true })
            }
        }

        var rowIndexes = dt.rows(config.rows, modifier).indexes().toArray();
        var selectedCells = dt.cells(rowIndexes, config.columns);
        var cells = selectedCells
            .render(config.orthogonal)
            .toArray();
        var cellNodes = selectedCells
            .nodes()
            .toArray();

        var columns = header.length;
        var rows = columns > 0 ? cells.length / columns : 0;
        var body = [rows];
        var cellCounter = 0;

        for (var i = 0, ien = rows; i < ien; i++) {
            var row = [columns];

            for (var j = 0; j < columns; j++) {
                row[j] = config.format.body(cells[cellCounter], i, j, cellNodes[cellCounter]);
                cellCounter++;
            }

            body[i] = row;
        }

        return {
            header: header,
            footer: footer,
            body: body
        };
    };


    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * DataTables interface
     */

    // Attach to DataTables objects for global access
    $.fn.dataTable.Buttons = Buttons;
    $.fn.DataTable.Buttons = Buttons;



    // DataTables creation - check if the buttons have been defined for this table,
    // they will have been if the `B` option was used in `dom`, otherwise we should
    // create the buttons instance here so they can be inserted into the document
    // using the API. Listen for `init` for compatibility with pre 1.10.10, but to
    // be removed in future.
    $(document).on('init.dt plugin-init.dt', function (e, settings) {
        if (e.namespace !== 'dt') {
            return;
        }

        var opts = settings.oInit.buttons || DataTable.defaults.buttons;

        if (opts && !settings._buttons) {
            new Buttons(settings, opts).container();
        }
    });

    // DataTables `dom` feature option
    DataTable.ext.feature.push({
        fnInit: function (settings) {
            var api = new DataTable.Api(settings);
            var opts = api.init().buttons || DataTable.defaults.buttons;

            return new Buttons(api, opts).container();
        },
        cFeature: "B"
    });


    return Buttons;
}));
/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;"undefined"!=typeof window?b=window:"undefined"!=typeof global?b=global:"undefined"!=typeof self&&(b=self),b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,f,g,h,i,j="",k=0;k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),e=a.charCodeAt(k++),f=b>>2,g=(3&b)<<4|c>>4,h=(15&c)<<2|e>>6,i=63&e,isNaN(c)?h=i=64:isNaN(e)&&(i=64),j=j+d.charAt(f)+d.charAt(g)+d.charAt(h)+d.charAt(i);return j},c.decode=function(a){var b,c,e,f,g,h,i,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)f=d.indexOf(a.charAt(k++)),g=d.indexOf(a.charAt(k++)),h=d.indexOf(a.charAt(k++)),i=d.indexOf(a.charAt(k++)),b=f<<2|g>>4,c=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(b),64!=h&&(j+=String.fromCharCode(c)),64!=i&&(j+=String.fromCharCode(e));return j}},{}],2:[function(a,b){"use strict";function c(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}c.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=c},{}],3:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":8}],4:[function(a,b){"use strict";var c=a("./utils"),d=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var e="string"!==c.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=e?a[i]:a.charCodeAt(i),g=255&(b^h),f=d[g],b=b>>>8^f;return-1^b}},{"./utils":21}],5:[function(a,b){"use strict";function c(){this.data=null,this.length=0,this.index=0}var d=a("./utils");c.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return d.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=c},{"./utils":21}],6:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],7:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":21}],8:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a,b){return e.deflateRaw(a,{level:b.level||-1})},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:24}],9:[function(a,b){"use strict";function c(a,b){return this instanceof c?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new c;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new c(a,b)}var d=a("./base64");c.prototype=a("./object"),c.prototype.load=a("./load"),c.support=a("./support"),c.defaults=a("./defaults"),c.utils=a("./deprecatedPublicUtils"),c.base64={encode:function(a){return d.encode(a)},decode:function(a){return d.decode(a)}},c.compressions=a("./compressions"),b.exports=c},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(a,b){"use strict";var c=a("./base64"),d=a("./zipEntries");b.exports=function(a,b){var e,f,g,h;for(b=b||{},b.base64&&(a=c.decode(a)),f=new d(a,b),e=f.files,g=0;g<e.length;g++)h=e[g],this.file(h.fileName,h.decompressed,{binary:!0,optimizedBinaryString:!0,date:h.date,dir:h.dir,comment:h.fileComment.length?h.fileComment:null,unixPermissions:h.unixPermissions,dosPermissions:h.dosPermissions,createFolders:b.createFolders});return f.zipComment.length&&(this.comment=f.zipComment),this}},{"./base64":1,"./zipEntries":22}],11:[function(a,b){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],12:[function(a,b){"use strict";function c(a){this.data=a,this.length=this.data.length,this.index=0}var d=a("./uint8ArrayReader");c.prototype=new d,c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./uint8ArrayReader":18}],13:[function(a,b){"use strict";var c=a("./support"),d=a("./utils"),e=a("./crc32"),f=a("./signature"),g=a("./defaults"),h=a("./base64"),i=a("./compressions"),j=a("./compressedObject"),k=a("./nodeBuffer"),l=a("./utf8"),m=a("./stringWriter"),n=a("./uint8ArrayWriter"),o=function(a){if(a._data instanceof j&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===d.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},p=function(a){var b=o(a),e=d.getTypeOf(b);return"string"===e?!a.options.binary&&c.nodebuffer?k(b,"utf-8"):a.asBinary():b},q=function(a){var b=o(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=h.decode(b)),b=a&&this.options.binary?D.utf8decode(b):d.transformTo("string",b),a||this.options.binary||(b=d.transformTo("string",D.utf8encode(b))),b)},r=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};r.prototype={asText:function(){return q.call(this,!0)},asBinary:function(){return q.call(this,!1)},asNodeBuffer:function(){var a=p(this);return d.transformTo("nodebuffer",a)},asUint8Array:function(){var a=p(this);return d.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var s=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},t=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=t(a,g),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var e,f=d.getTypeOf(b);if(c=u(c),"string"==typeof c.unixPermissions&&(c.unixPermissions=parseInt(c.unixPermissions,8)),c.unixPermissions&&16384&c.unixPermissions&&(c.dir=!0),c.dosPermissions&&16&c.dosPermissions&&(c.dir=!0),c.dir&&(a=x(a)),c.createFolders&&(e=w(a))&&y.call(this,e,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null,f=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=d.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof j))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=d.transformTo("uint8array",b))}var g=new r(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a){return"/"!=a.slice(-1)&&(a+="/"),a},y=function(a,b){return b="undefined"!=typeof b?b:!1,a=x(a),this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},z=function(a,b,c){var f,g=new j;return a._data instanceof j?(g.uncompressedSize=a._data.uncompressedSize,g.crc32=a._data.crc32,0===g.uncompressedSize||a.dir?(b=i.STORE,g.compressedContent="",g.crc32=0):a._data.compressionMethod===b.magic?g.compressedContent=a._data.getCompressedContent():(f=a._data.getContent(),g.compressedContent=b.compress(d.transformTo(b.compressInputType,f),c))):(f=p(a),(!f||0===f.length||a.dir)&&(b=i.STORE,f=""),g.uncompressedSize=f.length,g.crc32=e(f),g.compressedContent=b.compress(d.transformTo(b.compressInputType,f),c)),g.compressedSize=g.compressedContent.length,g.compressionMethod=b.magic,g},A=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},B=function(a){return 63&(a||0)},C=function(a,b,c,g,h){var i,j,k,m,n=(c.compressedContent,d.transformTo("string",l.utf8encode(b.name))),o=b.comment||"",p=d.transformTo("string",l.utf8encode(o)),q=n.length!==b.name.length,r=p.length!==o.length,t=b.options,u="",v="",w="";k=b._initialMetadata.dir!==b.dir?b.dir:t.dir,m=b._initialMetadata.date!==b.date?b.date:t.date;var x=0,y=0;k&&(x|=16),"UNIX"===h?(y=798,x|=A(b.unixPermissions,k)):(y=20,x|=B(b.dosPermissions,k)),i=m.getHours(),i<<=6,i|=m.getMinutes(),i<<=5,i|=m.getSeconds()/2,j=m.getFullYear()-1980,j<<=4,j|=m.getMonth()+1,j<<=5,j|=m.getDate(),q&&(v=s(1,1)+s(e(n),4)+n,u+="up"+s(v.length,2)+v),r&&(w=s(1,1)+s(this.crc32(p),4)+p,u+="uc"+s(w.length,2)+w);var z="";z+="\n\x00",z+=q||r?"\x00\b":"\x00\x00",z+=c.compressionMethod,z+=s(i,2),z+=s(j,2),z+=s(c.crc32,4),z+=s(c.compressedSize,4),z+=s(c.uncompressedSize,4),z+=s(n.length,2),z+=s(u.length,2);var C=f.LOCAL_FILE_HEADER+z+n+u,D=f.CENTRAL_FILE_HEADER+s(y,2)+z+s(p.length,2)+"\x00\x00\x00\x00"+s(x,4)+s(g,4)+n+u+p;return{fileRecord:C,dirRecord:D,compressedObject:c}},D={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,e,f=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],e=new r(d.name,d._data,t(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,e)&&f.push(e));return f},file:function(a,b,c){if(1===arguments.length){if(d.isRegExp(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=y.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=t(a||{},{base64:!0,compression:"STORE",compressionOptions:null,type:"base64",platform:"DOS",comment:null,mimeType:"application/zip"}),d.checkSupport(a.type),("darwin"===a.platform||"freebsd"===a.platform||"linux"===a.platform||"sunos"===a.platform)&&(a.platform="UNIX"),"win32"===a.platform&&(a.platform="DOS");var b,c,e=[],g=0,j=0,k=d.transformTo("string",this.utf8encode(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var o=this.files[l],p=o.options.compression||a.compression.toUpperCase(),q=i[p];if(!q)throw new Error(p+" is not a valid compression method !");var r=o.options.compressionOptions||a.compressionOptions||{},u=z.call(this,o,q,r),v=C.call(this,l,o,u,g,a.platform);g+=v.fileRecord.length+u.compressedSize,j+=v.dirRecord.length,e.push(v)}var w="";w=f.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+s(e.length,2)+s(e.length,2)+s(j,4)+s(g,4)+s(k.length,2)+k;var x=a.type.toLowerCase();for(b="uint8array"===x||"arraybuffer"===x||"blob"===x||"nodebuffer"===x?new n(g+j+w.length):new m(g+j+w.length),c=0;c<e.length;c++)b.append(e[c].fileRecord),b.append(e[c].compressedObject.compressedContent);for(c=0;c<e.length;c++)b.append(e[c].dirRecord);b.append(w);var y=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return d.transformTo(a.type.toLowerCase(),y);case"blob":return d.arrayBuffer2Blob(d.transformTo("arraybuffer",y),a.mimeType);case"base64":return a.base64?h.encode(y):y;default:return y}},crc32:function(a,b){return e(a,b)},utf8encode:function(a){return d.transformTo("string",l.utf8encode(a))},utf8decode:function(a){return l.utf8decode(a)}};b.exports=D},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],15:[function(a,b){"use strict";function c(a,b){this.data=a,b||(this.data=e.string2binary(this.data)),this.length=this.data.length,this.index=0}var d=a("./dataReader"),e=a("./utils");c.prototype=new d,c.prototype.byteAt=function(a){return this.data.charCodeAt(a)},c.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5,"./utils":21}],16:[function(a,b){"use strict";var c=a("./utils"),d=function(){this.data=[]};d.prototype={append:function(a){a=c.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=d},{"./utils":21}],17:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],18:[function(a,b){"use strict";function c(a){a&&(this.data=a,this.length=this.data.length,this.index=0)}var d=a("./dataReader");c.prototype=new d,c.prototype.byteAt=function(a){return this.data[a]},c.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f;return-1},c.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5}],19:[function(a,b){"use strict";var c=a("./utils"),d=function(a){this.data=new Uint8Array(a),this.index=0};d.prototype={append:function(a){0!==a.length&&(a=c.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=d},{"./utils":21}],20:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;h>b;)if(e=a[b++],128>e)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&h>b;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:65536>e?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;f>c;){var h=j(a,Math.min(c+g,f));b.push(e.uint8array?k(a.subarray(c,h)):k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{d.push("array"===f||"nodebuffer"===f?String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e))):String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a,b){c.checkSupport("blob"),b=b||"application/zip";try{return new Blob([a],{type:b})}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(a,b){"use strict";function c(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var d=a("./stringReader"),e=a("./nodeBufferReader"),f=a("./uint8ArrayReader"),g=a("./utils"),h=a("./signature"),i=a("./zipEntry"),j=a("./support"),k=a("./object");c.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+g.pretty(b)+", expected "+g.pretty(a)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength),this.zipComment=k.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(h.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===h.CENTRAL_FILE_HEADER;)a=new i({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if(-1===a){var b=!0;try{this.reader.setIndex(0),this.checkSignature(h.LOCAL_FILE_HEADER),b=!1}catch(c){}throw new Error(b?"Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html":"Corrupted zip : can't find end of central directory")}if(this.reader.setIndex(a),this.checkSignature(h.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===g.MAX_VALUE_16BITS||this.diskWithCentralDirStart===g.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===g.MAX_VALUE_16BITS||this.centralDirRecords===g.MAX_VALUE_16BITS||this.centralDirSize===g.MAX_VALUE_32BITS||this.centralDirOffset===g.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),-1===a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(a){var b=g.getTypeOf(a);this.reader="string"!==b||j.uint8array?"nodebuffer"===b?new e(a):new f(g.transformTo("uint8array",a)):new d(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=c},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(a,b){"use strict";function c(a,b){this.options=a,this.loadOptions=b}var d=a("./stringReader"),e=a("./utils"),f=a("./compressedObject"),g=a("./object"),h=0,i=3;c.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,f){return function(){var a=e.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==f)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readString(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=e.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+e.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new f,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=e.transformTo("string",this.decompressed.getContent()),g.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readInt(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readString(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readString(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=16&this.externalFileAttributes?!0:!1,a===h&&(this.dosPermissions=63&this.externalFileAttributes),a===i&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileName.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var a=new d(this.extraFields[1].value);this.uncompressedSize===e.MAX_VALUE_32BITS&&(this.uncompressedSize=a.readInt(8)),this.compressedSize===e.MAX_VALUE_32BITS&&(this.compressedSize=a.readInt(8)),this.localHeaderOffset===e.MAX_VALUE_32BITS&&(this.localHeaderOffset=a.readInt(8)),this.diskNumberStart===e.MAX_VALUE_32BITS&&(this.diskNumberStart=a.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){if(this.useUTF8())this.fileName=g.utf8decode(this.fileName),this.fileComment=g.utf8decode(this.fileComment);else{var a=this.findExtraFieldUnicodePath();null!==a&&(this.fileName=a);var b=this.findExtraFieldUnicodeComment();null!==b&&(this.fileComment=b)}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileName)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))
}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileComment)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null}},b.exports=c},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(a,b){"use strict";var c=a("./lib/utils/common").assign,d=a("./lib/deflate"),e=a("./lib/inflate"),f=a("./lib/zlib/constants"),g={};c(g,d,e,f),b.exports=g},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(a,b,c){"use strict";function d(a,b){var c=new s(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}function f(a,b){return b=b||{},b.gzip=!0,d(a,b)}var g=a("./zlib/deflate.js"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=0,m=4,n=0,o=1,p=-1,q=0,r=8,s=function(a){this.options=h.assign({level:p,method:r,chunkSize:16384,windowBits:15,memLevel:8,strategy:q,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=g.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==n)throw new Error(j[c]);b.header&&g.deflateSetHeader(this.strm,b.header)};s.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?m:l,e.input="string"==typeof a?i.string2buf(a):a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new h.Buf8(f),e.next_out=0,e.avail_out=f),c=g.deflate(e,d),c!==o&&c!==n)return this.onEnd(c),this.ended=!0,!1;(0===e.avail_out||0===e.avail_in&&d===m)&&this.onData("string"===this.options.to?i.buf2binstring(h.shrinkBuf(e.output,e.next_out)):h.shrinkBuf(e.output,e.next_out))}while((e.avail_in>0||0===e.avail_out)&&c!==o);return d===m?(c=g.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===n):!0},s.prototype.onData=function(a){this.chunks.push(a)},s.prototype.onEnd=function(a){a===n&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=s,c.deflate=d,c.deflateRaw=e,c.gzip=f},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(a,b,c){"use strict";function d(a,b){var c=new m(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}var f=a("./zlib/inflate.js"),g=a("./utils/common"),h=a("./utils/strings"),i=a("./zlib/constants"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=a("./zlib/gzheader"),m=function(a){this.options=g.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=f.inflateInit2(this.strm,b.windowBits);if(c!==i.Z_OK)throw new Error(j[c]);this.header=new l,f.inflateGetHeader(this.strm,this.header)};m.prototype.push=function(a,b){var c,d,e,j,k,l=this.strm,m=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?i.Z_FINISH:i.Z_NO_FLUSH,l.input="string"==typeof a?h.binstring2buf(a):a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new g.Buf8(m),l.next_out=0,l.avail_out=m),c=f.inflate(l,i.Z_NO_FLUSH),c!==i.Z_STREAM_END&&c!==i.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0===l.avail_out||c===i.Z_STREAM_END||0===l.avail_in&&d===i.Z_FINISH)&&("string"===this.options.to?(e=h.utf8border(l.output,l.next_out),j=l.next_out-e,k=h.buf2string(l.output,e),l.next_out=j,l.avail_out=m-j,j&&g.arraySet(l.output,l.output,e,j,0),this.onData(k)):this.onData(g.shrinkBuf(l.output,l.next_out)))}while(l.avail_in>0&&c!==i.Z_STREAM_END);return c===i.Z_STREAM_END&&(d=i.Z_FINISH),d===i.Z_FINISH?(c=f.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===i.Z_OK):!0},m.prototype.onData=function(a){this.chunks.push(a)},m.prototype.onEnd=function(a){a===i.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):g.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=m,c.inflate=d,c.inflateRaw=e,c.ungzip=d},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],28:[function(a,b,c){"use strict";function d(a,b){if(65537>b&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;b>d;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;256>j;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new e.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;d>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;h>c;)if(f=a[c++],128>f)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&h>c;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:65536>f?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":27}],29:[function(a,b){"use strict";function c(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=c},{}],30:[function(a,b){b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(a,b){"use strict";function c(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function d(a,b,c,d){var f=e,g=d+c;a=-1^a;for(var h=d;g>h;h++)a=a>>>8^f[255&(a^b[h])];return-1^a}var e=c();b.exports=d},{}],32:[function(a,b,c){"use strict";function d(a,b){return a.msg=G[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(C.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){D._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,C.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=E(a.adler,b,e,c):2===a.state.wrap&&(a.adler=F(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-jb?a.strstart-(a.w_size-jb):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ib,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ib-(m-f),f=m-ib,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-jb)){C.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=hb)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+hb-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<hb)););}while(a.lookahead<jb&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===H)return sb;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return sb;if(a.strstart-a.block_start>=a.w_size-jb&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?sb:sb}function o(a,b){for(var c,d;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c)),a.match_length>=hb)if(d=D._tr_tally(a,a.strstart-a.match_start,a.match_length-hb),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=hb){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function p(a,b){for(var c,d,e;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=hb-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===S||a.match_length===hb&&a.strstart-a.match_start>4096)&&(a.match_length=hb-1)),a.prev_length>=hb&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-hb,d=D._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-hb),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=hb-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return sb}else if(a.match_available){if(d=D._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return sb}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=D._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ib){if(m(a),a.lookahead<=ib&&b===H)return sb;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=hb&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ib;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ib-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=hb?(c=D._tr_tally(a,1,a.match_length-hb),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===H)return sb;break}if(a.match_length=0,c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function s(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=B[a.level].max_lazy,a.good_match=B[a.level].good_length,a.nice_match=B[a.level].nice_length,a.max_chain_length=B[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=hb-1,a.match_available=0,a.ins_h=0}function t(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new C.Buf16(2*fb),this.dyn_dtree=new C.Buf16(2*(2*db+1)),this.bl_tree=new C.Buf16(2*(2*eb+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new C.Buf16(gb+1),this.heap=new C.Buf16(2*cb+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new C.Buf16(2*cb+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function u(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=X,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?lb:qb,a.adler=2===b.wrap?0:1,b.last_flush=H,D._tr_init(b),M):d(a,O)}function v(a){var b=u(a);return b===M&&s(a.state),b}function w(a,b){return a&&a.state?2!==a.state.wrap?O:(a.state.gzhead=b,M):O}function x(a,b,c,e,f,g){if(!a)return O;var h=1;if(b===R&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>Z||c!==Y||8>e||e>15||0>b||b>9||0>g||g>V)return d(a,O);8===e&&(e=9);var i=new t;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+hb-1)/hb),i.window=new C.Buf8(2*i.w_size),i.head=new C.Buf16(i.hash_size),i.prev=new C.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new C.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,v(a)}function y(a,b){return x(a,b,Y,$,_,W)}function z(a,b){var c,h,k,l;if(!a||!a.state||b>L||0>b)return a?d(a,O):O;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===rb&&b!==K)return d(a,0===a.avail_out?Q:O);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===lb)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=F(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=mb):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,wb),h.status=qb);else{var m=Y+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=T||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=kb),m+=31-m%31,h.status=qb,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===mb)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=nb)}else h.status=nb;if(h.status===nb)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=ob)}else h.status=ob;if(h.status===ob)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=pb)}else h.status=pb;if(h.status===pb&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=qb)):h.status=qb),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,M}else if(0===a.avail_in&&e(b)<=e(c)&&b!==K)return d(a,Q);if(h.status===rb&&0!==a.avail_in)return d(a,Q);if(0!==a.avail_in||0!==h.lookahead||b!==H&&h.status!==rb){var o=h.strategy===T?r(h,b):h.strategy===U?q(h,b):B[h.level].func(h,b);if((o===ub||o===vb)&&(h.status=rb),o===sb||o===ub)return 0===a.avail_out&&(h.last_flush=-1),M;if(o===tb&&(b===I?D._tr_align(h):b!==L&&(D._tr_stored_block(h,0,0,!1),b===J&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,M}return b!==K?M:h.wrap<=0?N:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?M:N)}function A(a){var b;return a&&a.state?(b=a.state.status,b!==lb&&b!==mb&&b!==nb&&b!==ob&&b!==pb&&b!==qb&&b!==rb?d(a,O):(a.state=null,b===qb?d(a,P):M)):O}var B,C=a("../utils/common"),D=a("./trees"),E=a("./adler32"),F=a("./crc32"),G=a("./messages"),H=0,I=1,J=3,K=4,L=5,M=0,N=1,O=-2,P=-3,Q=-5,R=-1,S=1,T=2,U=3,V=4,W=0,X=2,Y=8,Z=9,$=15,_=8,ab=29,bb=256,cb=bb+1+ab,db=30,eb=19,fb=2*cb+1,gb=15,hb=3,ib=258,jb=ib+hb+1,kb=32,lb=42,mb=69,nb=73,ob=91,pb=103,qb=113,rb=666,sb=1,tb=2,ub=3,vb=4,wb=3,xb=function(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e};B=[new xb(0,0,0,0,n),new xb(4,4,8,4,o),new xb(4,5,16,8,o),new xb(4,6,32,32,o),new xb(4,4,16,16,p),new xb(8,16,32,32,p),new xb(8,16,128,128,p),new xb(8,32,128,256,p),new xb(32,128,258,1024,p),new xb(32,258,258,4096,p)],c.deflateInit=y,c.deflateInit2=x,c.deflateReset=v,c.deflateResetKeep=u,c.deflateSetHeader=w,c.deflate=z,c.deflateEnd=A,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(a,b){"use strict";function c(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=c},{}],34:[function(a,b){"use strict";var c=30,d=12;b.exports=function(a,b){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;e=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=e.dmax,l=e.wsize,m=e.whave,n=e.wnext,o=e.window,p=e.hold,q=e.bits,r=e.lencode,s=e.distcode,t=(1<<e.lenbits)-1,u=(1<<e.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){e.mode=d;break a}a.msg="invalid literal/length code",e.mode=c;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",e.mode=c;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",e.mode=c;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&e.sane){a.msg="invalid distance too far back",e.mode=c;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),e.hold=p,e.bits=q}},{}],35:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(ob),b.distcode=b.distdyn=new r.Buf32(pb),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,rb)}function k(a){if(sb){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sb=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,ob,pb,qb,rb,sb,tb,ub,vb,wb,xb,yb,zb,Ab=0,Bb=new r.Buf8(4),Cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xb=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=lb;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=lb;break}if(m>>>=4,n-=4,wb=(15&m)+8,0===c.wbits)c.wbits=wb;else if(wb>c.wbits){a.msg="invalid window size",c.mode=lb;break}c.dmax=1<<wb,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=lb;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=lb;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,Bb[2]=m>>>16&255,Bb[3]=m>>>24&255,c.check=t(c.check,Bb,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wb=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wb)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.name+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.comment+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=lb;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ib;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=bb,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=lb}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=lb;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=lb;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Cb[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Cb[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,yb={bits:c.lenbits},xb=v(w,c.lens,0,19,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid code lengths set",c.mode=lb;break}c.have=0,c.mode=ab;case ab:for(;c.have<c.nlen+c.ndist;){for(;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sb)m>>>=qb,n-=qb,c.lens[c.have++]=sb;else{if(16===sb){for(zb=qb+2;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qb,n-=qb,0===c.have){a.msg="invalid bit length repeat",c.mode=lb;break}wb=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sb){for(zb=qb+3;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=3+(7&m),m>>>=3,n-=3}else{for(zb=qb+7;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=lb;break}for(;q--;)c.lens[c.have++]=wb}}if(c.mode===lb)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=lb;break}if(c.lenbits=9,yb={bits:c.lenbits},xb=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid literal/lengths set",c.mode=lb;break}if(c.distbits=6,c.distcode=c.distdyn,yb={bits:c.distbits},xb=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,yb),c.distbits=yb.bits,xb){a.msg="invalid distances set",c.mode=lb;break}if(c.mode=bb,b===B)break a;case bb:c.mode=cb;case cb:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);
break}for(c.back=0;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(rb&&0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.lencode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,c.length=sb,0===rb){c.mode=hb;break}if(32&rb){c.back=-1,c.mode=V;break}if(64&rb){a.msg="invalid literal/length code",c.mode=lb;break}c.extra=15&rb,c.mode=db;case db:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=eb;case eb:for(;Ab=c.distcode[m&(1<<c.distbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.distcode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,64&rb){a.msg="invalid distance code",c.mode=lb;break}c.offset=sb,c.extra=15&rb,c.mode=fb;case fb:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=lb;break}c.mode=gb;case gb:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=lb;break}q>c.wnext?(q-=c.wnext,ob=c.wsize-q):ob=c.wnext-q,q>c.length&&(q=c.length),pb=c.window}else pb=f,ob=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pb[ob++];while(--q);0===c.length&&(c.mode=cb);break;case hb:if(0===j)break a;f[h++]=c.length,j--,c.mode=cb;break;case ib:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=lb;break}m=0,n=0}c.mode=jb;case jb:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=lb;break}m=0,n=0}c.mode=kb;case kb:xb=D;break a;case lb:xb=G;break a;case mb:return H;case nb:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<lb&&(c.mode<ib||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=mb,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===bb||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xb===C&&(xb=I),xb)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,ab=19,bb=20,cb=21,db=22,eb=23,fb=24,gb=25,hb=26,ib=27,jb=28,kb=29,lb=30,mb=31,nb=32,ob=852,pb=592,qb=15,rb=qb,sb=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(a,b){"use strict";var c=a("../utils/common"),d=15,e=852,f=592,g=0,h=1,i=2,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],k=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],m=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,n,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new c.Buf16(d+1),Q=new c.Buf16(d+1),R=null,S=0;for(D=0;d>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[n+E]]++;for(H=C,G=d;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;d>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===g||1!==G))return-1;for(Q[1]=0,D=1;d>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[n+E]&&(r[Q[b[n+E]]++]=E);if(a===g?(N=R=r,y=19):a===h?(N=j,O-=257,R=k,S-=257,y=256):(N=l,R=m,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===h&&L>e||a===i&&L>f)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[n+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===h&&L>e||a===i&&L>f)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":27}],37:[function(a,b){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a){return 256>a?gb[a]:gb[256+(a>>>7)]}function f(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function g(a,b,c){a.bi_valid>V-c?(a.bi_buf|=b<<a.bi_valid&65535,f(a,a.bi_buf),a.bi_buf=b>>V-a.bi_valid,a.bi_valid+=c-V):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function h(a,b,c){g(a,c[2*b],c[2*b+1])}function i(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function j(a){16===a.bi_valid?(f(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function k(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;U>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;T>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function l(a,b,c){var d,e,f=new Array(U+1),g=0;for(d=1;U>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=i(f[h]++,h))}}function m(){var a,b,c,d,e,f=new Array(U+1);for(c=0,d=0;O-1>d;d++)for(ib[d]=c,a=0;a<1<<_[d];a++)hb[c++]=d;for(hb[c-1]=d,e=0,d=0;16>d;d++)for(jb[d]=e,a=0;a<1<<ab[d];a++)gb[e++]=d;for(e>>=7;R>d;d++)for(jb[d]=e<<7,a=0;a<1<<ab[d]-7;a++)gb[256+e++]=d;for(b=0;U>=b;b++)f[b]=0;for(a=0;143>=a;)eb[2*a+1]=8,a++,f[8]++;for(;255>=a;)eb[2*a+1]=9,a++,f[9]++;for(;279>=a;)eb[2*a+1]=7,a++,f[7]++;for(;287>=a;)eb[2*a+1]=8,a++,f[8]++;for(l(eb,Q+1,f),a=0;R>a;a++)fb[2*a+1]=5,fb[2*a]=i(a,5);kb=new nb(eb,_,P+1,Q,U),lb=new nb(fb,ab,0,R,U),mb=new nb(new Array(0),bb,0,S,W)}function n(a){var b;for(b=0;Q>b;b++)a.dyn_ltree[2*b]=0;for(b=0;R>b;b++)a.dyn_dtree[2*b]=0;for(b=0;S>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*X]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function o(a){a.bi_valid>8?f(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function p(a,b,c,d){o(a),d&&(f(a,c),f(a,~c)),E.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function q(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function r(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&q(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!q(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function s(a,b,c){var d,f,i,j,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],f=a.pending_buf[a.l_buf+k],k++,0===d?h(a,f,b):(i=hb[f],h(a,i+P+1,b),j=_[i],0!==j&&(f-=ib[i],g(a,f,j)),d--,i=e(d),h(a,i,c),j=ab[i],0!==j&&(d-=jb[i],g(a,d,j)));while(k<a.last_lit);h(a,X,b)}function t(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=T,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)r(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],r(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,r(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],k(a,b),l(f,j,a.bl_count)}function u(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*Y]++):10>=h?a.bl_tree[2*Z]++:a.bl_tree[2*$]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function v(a,b,c){var d,e,f=-1,i=b[1],j=0,k=7,l=4;for(0===i&&(k=138,l=3),d=0;c>=d;d++)if(e=i,i=b[2*(d+1)+1],!(++j<k&&e===i)){if(l>j){do h(a,e,a.bl_tree);while(0!==--j)}else 0!==e?(e!==f&&(h(a,e,a.bl_tree),j--),h(a,Y,a.bl_tree),g(a,j-3,2)):10>=j?(h(a,Z,a.bl_tree),g(a,j-3,3)):(h(a,$,a.bl_tree),g(a,j-11,7));j=0,f=e,0===i?(k=138,l=3):e===i?(k=6,l=3):(k=7,l=4)}}function w(a){var b;for(u(a,a.dyn_ltree,a.l_desc.max_code),u(a,a.dyn_dtree,a.d_desc.max_code),t(a,a.bl_desc),b=S-1;b>=3&&0===a.bl_tree[2*cb[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function x(a,b,c,d){var e;for(g(a,b-257,5),g(a,c-1,5),g(a,d-4,4),e=0;d>e;e++)g(a,a.bl_tree[2*cb[e]+1],3);v(a,a.dyn_ltree,b-1),v(a,a.dyn_dtree,c-1)}function y(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return G;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return H;for(b=32;P>b;b++)if(0!==a.dyn_ltree[2*b])return H;return G}function z(a){pb||(m(),pb=!0),a.l_desc=new ob(a.dyn_ltree,kb),a.d_desc=new ob(a.dyn_dtree,lb),a.bl_desc=new ob(a.bl_tree,mb),a.bi_buf=0,a.bi_valid=0,n(a)}function A(a,b,c,d){g(a,(J<<1)+(d?1:0),3),p(a,b,c,!0)}function B(a){g(a,K<<1,3),h(a,X,eb),j(a)}function C(a,b,c,d){var e,f,h=0;a.level>0?(a.strm.data_type===I&&(a.strm.data_type=y(a)),t(a,a.l_desc),t(a,a.d_desc),h=w(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?A(a,b,c,d):a.strategy===F||f===e?(g(a,(K<<1)+(d?1:0),3),s(a,eb,fb)):(g(a,(L<<1)+(d?1:0),3),x(a,a.l_desc.max_code+1,a.d_desc.max_code+1,h+1),s(a,a.dyn_ltree,a.dyn_dtree)),n(a),d&&o(a)}function D(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(hb[c]+P+1)]++,a.dyn_dtree[2*e(b)]++),a.last_lit===a.lit_bufsize-1}var E=a("../utils/common"),F=4,G=0,H=1,I=2,J=0,K=1,L=2,M=3,N=258,O=29,P=256,Q=P+1+O,R=30,S=19,T=2*Q+1,U=15,V=16,W=7,X=256,Y=16,Z=17,$=18,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],bb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],db=512,eb=new Array(2*(Q+2));d(eb);var fb=new Array(2*R);d(fb);var gb=new Array(db);d(gb);var hb=new Array(N-M+1);d(hb);var ib=new Array(O);d(ib);var jb=new Array(R);d(jb);var kb,lb,mb,nb=function(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length},ob=function(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b},pb=!1;c._tr_init=z,c._tr_stored_block=A,c._tr_flush_block=C,c._tr_tally=D,c._tr_align=B},{"../utils/common":27}],39:[function(a,b){"use strict";function c(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=c},{}]},{},[9])(9)});
/*!
 * HTML5 export buttons for Buttons and DataTables.
 * 2016 SpryMedia Ltd - datatables.net/license
 *
 * FileSaver.js (1.3.3) - MIT license
 * Copyright Â© 2016 Eli Grey - http://eligrey.com
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net', 'datatables.net-buttons'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $, jszip, pdfmake) {
            if (!root) {
                root = window;
            }

            if (!$ || !$.fn.dataTable) {
                $ = require('datatables.net')(root, $).$;
            }

            if (!$.fn.dataTable.Buttons) {
                require('datatables.net-buttons')(root, $);
            }

            return factory($, root, root.document, jszip, pdfmake);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document, jszip, pdfmake, undefined) {
    'use strict';
    var DataTable = $.fn.dataTable;

    // Allow the constructor to pass in JSZip and PDFMake from external requires.
    // Otherwise, use globally defined variables, if they are available.
    function _jsZip() {
        return jszip || window.JSZip;
    }
    function _pdfMake() {
        return pdfmake || window.pdfMake;
    }


    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * FileSaver.js dependency
     */

    /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

    var _saveAs = (function (view) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = view.document
            // only get URL when necessary in case Blob.js hasn't overridden it yet
            , get_URL = function () {
                return view.URL || view.webkitURL || view;
            }
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = "download" in save_link
            , click = function (node) {
                var event = new MouseEvent("click");
                node.dispatchEvent(event);
            }
            , is_safari = /constructor/i.test(view.HTMLElement) || view.safari
            , is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
            , throw_outside = function (ex) {
                (view.setImmediate || view.setTimeout)(function () {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
            , arbitrary_revoke_timeout = 1000 * 40 // in ms
            , revoke = function (file) {
                var revoker = function () {
                    if (typeof file === "string") { // file is an object URL
                        get_URL().revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                };
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
            , dispatch = function (filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , auto_bom = function (blob) {
                // prepend BOM for UTF-8 XML and text/* types (including HTML)
                // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                    return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type });
                }
                return blob;
            }
            , FileSaver = function (blob, name, no_auto_bom) {
                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , force = type === force_saveable_type
                    , object_url
                    , dispatch_all = function () {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                    // on any filesys errors revert to saving with object URLs
                    , fs_error = function () {
                        if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                            // Safari doesn't allow downloading of blob urls
                            var reader = new FileReader();
                            reader.onloadend = function () {
                                var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                var popup = view.open(url, '_blank');
                                if (!popup) view.location.href = url;
                                url = undefined; // release reference before dispatching
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                            };
                            reader.readAsDataURL(blob);
                            filesaver.readyState = filesaver.INIT;
                            return;
                        }
                        // don't create more object URLs than needed
                        if (!object_url) {
                            object_url = get_URL().createObjectURL(blob);
                        }
                        if (force) {
                            view.location.href = object_url;
                        } else {
                            var opened = view.open(object_url, "_blank");
                            if (!opened) {
                                // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                view.location.href = object_url;
                            }
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                        revoke(object_url);
                    }
                    ;
                filesaver.readyState = filesaver.INIT;

                if (can_use_save_link) {
                    object_url = get_URL().createObjectURL(blob);
                    setTimeout(function () {
                        save_link.href = object_url;
                        save_link.download = name;
                        click(save_link);
                        dispatch_all();
                        revoke(object_url);
                        filesaver.readyState = filesaver.DONE;
                    });
                    return;
                }

                fs_error();
            }
            , FS_proto = FileSaver.prototype
            , saveAs = function (blob, name, no_auto_bom) {
                return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
            }
            ;
        // IE 10+ (native saveAs)
        if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
            return function (blob, name, no_auto_bom) {
                name = name || blob.name || "download";

                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                return navigator.msSaveOrOpenBlob(blob, name);
            };
        }

        FS_proto.abort = function () { };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
            FS_proto.onwritestart =
            FS_proto.onprogress =
            FS_proto.onwrite =
            FS_proto.onabort =
            FS_proto.onerror =
            FS_proto.onwriteend =
            null;

        return saveAs;
    }(
        typeof self !== "undefined" && self
        || typeof window !== "undefined" && window
        || this.content
    ));


    // Expose file saver on the DataTables API. Can't attach to `DataTables.Buttons`
    // since this file can be loaded before Button's core!
    DataTable.fileSave = _saveAs;


    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Local (private) functions
     */

    /**
     * Get the sheet name for Excel exports.
     *
     * @param {object}	config Button configuration
     */
    var _sheetname = function (config) {
        var sheetName = 'Sheet1';

        if (config.sheetName) {
            sheetName = config.sheetName.replace(/[\[\]\*\/\\\?\:]/g, '');
        }

        return sheetName;
    };

    /**
     * Get the newline character(s)
     *
     * @param {object}	config Button configuration
     * @return {string}				Newline character
     */
    var _newLine = function (config) {
        return config.newline ?
            config.newline :
            navigator.userAgent.match(/Windows/) ?
                '\r\n' :
                '\n';
    };

    /**
     * Combine the data from the `buttons.exportData` method into a string that
     * will be used in the export file.
     *
     * @param	{DataTable.Api} dt		 DataTables API instance
     * @param	{object}				config Button configuration
     * @return {object}							 The data to export
     */
    var _exportData = function (dt, config) {
        var newLine = _newLine(config);
        var data = dt.buttons.exportData(config.exportOptions);
        var boundary = config.fieldBoundary;
        var separator = config.fieldSeparator;
        var reBoundary = new RegExp(boundary, 'g');
        var escapeChar = config.escapeChar !== undefined ?
            config.escapeChar :
            '\\';
        var join = function (a) {
            var s = '';

            // If there is a field boundary, then we might need to escape it in
            // the source data
            for (var i = 0, ien = a.length; i < ien; i++) {
                if (i > 0) {
                    s += separator;
                }

                s += boundary ?
                    boundary + ('' + a[i]).replace(reBoundary, escapeChar + boundary) + boundary :
                    a[i];
            }

            return s;
        };

        var header = config.header ? join(data.header) + newLine : '';
        var footer = config.footer && data.footer ? newLine + join(data.footer) : '';
        var body = [];

        for (var i = 0, ien = data.body.length; i < ien; i++) {
            body.push(join(data.body[i]));
        }

        return {
            str: header + body.join(newLine) + footer,
            rows: body.length
        };
    };

    /**
     * Older versions of Safari (prior to tech preview 18) don't support the
     * download option required.
     *
     * @return {Boolean} `true` if old Safari
     */
    var _isDuffSafari = function () {
        var safari = navigator.userAgent.indexOf('Safari') !== -1 &&
            navigator.userAgent.indexOf('Chrome') === -1 &&
            navigator.userAgent.indexOf('Opera') === -1;

        if (!safari) {
            return false;
        }

        var version = navigator.userAgent.match(/AppleWebKit\/(\d+\.\d+)/);
        if (version && version.length > 1 && version[1] * 1 < 603.1) {
            return true;
        }

        return false;
    };

    /**
     * Convert from numeric position to letter for column names in Excel
     * @param  {int} n Column number
     * @return {string} Column letter(s) name
     */
    function createCellPos(n) {
        var ordA = 'A'.charCodeAt(0);
        var ordZ = 'Z'.charCodeAt(0);
        var len = ordZ - ordA + 1;
        var s = "";

        while (n >= 0) {
            s = String.fromCharCode(n % len + ordA) + s;
            n = Math.floor(n / len) - 1;
        }

        return s;
    }

    try {
        var _serialiser = new XMLSerializer();
        var _ieExcel;
    }
    catch (t) { }

    /**
     * Recursively add XML files from an object's structure to a ZIP file. This
     * allows the XSLX file to be easily defined with an object's structure matching
     * the files structure.
     *
     * @param {JSZip} zip ZIP package
     * @param {object} obj Object to add (recursive)
     */
    function _addToZip(zip, obj) {
        if (_ieExcel === undefined) {
            // Detect if we are dealing with IE's _awful_ serialiser by seeing if it
            // drop attributes
            _ieExcel = _serialiser
                .serializeToString(
                    $.parseXML(excelStrings['xl/worksheets/sheet1.xml'])
                )
                .indexOf('xmlns:r') === -1;
        }

        $.each(obj, function (name, val) {
            if ($.isPlainObject(val)) {
                var newDir = zip.folder(name);
                _addToZip(newDir, val);
            }
            else {
                if (_ieExcel) {
                    // IE's XML serialiser will drop some name space attributes from
                    // from the root node, so we need to save them. Do this by
                    // replacing the namespace nodes with a regular attribute that
                    // we convert back when serialised. Edge does not have this
                    // issue
                    var worksheet = val.childNodes[0];
                    var i, ien;
                    var attrs = [];

                    for (i = worksheet.attributes.length - 1; i >= 0; i--) {
                        var attrName = worksheet.attributes[i].nodeName;
                        var attrValue = worksheet.attributes[i].nodeValue;

                        if (attrName.indexOf(':') !== -1) {
                            attrs.push({ name: attrName, value: attrValue });

                            worksheet.removeAttribute(attrName);
                        }
                    }

                    for (i = 0, ien = attrs.length; i < ien; i++) {
                        var attr = val.createAttribute(attrs[i].name.replace(':', '_dt_b_namespace_token_'));
                        attr.value = attrs[i].value;
                        worksheet.setAttributeNode(attr);
                    }
                }

                var str = _serialiser.serializeToString(val);

                // Fix IE's XML
                if (_ieExcel) {
                    // IE doesn't include the XML declaration
                    if (str.indexOf('<?xml') === -1) {
                        str = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + str;
                    }

                    // Return namespace attributes to being as such
                    str = str.replace(/_dt_b_namespace_token_/g, ':');
                }

                // Safari, IE and Edge will put empty name space attributes onto
                // various elements making them useless. This strips them out
                str = str.replace(/<([^<>]*?) xmlns=""([^<>]*?)>/g, '<$1 $2>');

                zip.file(name, str);
            }
        });
    }

    /**
     * Create an XML node and add any children, attributes, etc without needing to
     * be verbose in the DOM.
     *
     * @param  {object} doc      XML document
     * @param  {string} nodeName Node name
     * @param  {object} opts     Options - can be `attr` (attributes), `children`
     *   (child nodes) and `text` (text content)
     * @return {node}            Created node
     */
    function _createNode(doc, nodeName, opts) {
        var tempNode = doc.createElement(nodeName);

        if (opts) {
            if (opts.attr) {
                $(tempNode).attr(opts.attr);
            }

            if (opts.children) {
                $.each(opts.children, function (key, value) {
                    tempNode.appendChild(value);
                });
            }

            if (opts.text !== null && opts.text !== undefined) {
                tempNode.appendChild(doc.createTextNode(opts.text));
            }
        }

        return tempNode;
    }

    /**
     * Get the width for an Excel column based on the contents of that column
     * @param  {object} data Data for export
     * @param  {int}    col  Column index
     * @return {int}         Column width
     */
    function _excelColWidth(data, col) {
        var max = data.header[col].length;
        var len, lineSplit, str;

        if (data.footer && data.footer[col].length > max) {
            max = data.footer[col].length;
        }

        for (var i = 0, ien = data.body.length; i < ien; i++) {
            var point = data.body[i][col];
            str = point !== null && point !== undefined ?
                point.toString() :
                '';

            // If there is a newline character, workout the width of the column
            // based on the longest line in the string
            if (str.indexOf('\n') !== -1) {
                lineSplit = str.split('\n');
                lineSplit.sort(function (a, b) {
                    return b.length - a.length;
                });

                len = lineSplit[0].length;
            }
            else {
                len = str.length;
            }

            if (len > max) {
                max = len;
            }

            // Max width rather than having potentially massive column widths
            if (max > 40) {
                return 52; // 40 * 1.3
            }
        }

        max *= 1.3;

        // And a min width
        return max > 6 ? max : 6;
    }

    // Excel - Pre-defined strings to build a basic XLSX file
    var excelStrings = {
        "_rels/.rels":
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
            '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
            '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>' +
            '</Relationships>',

        "xl/_rels/workbook.xml.rels":
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
            '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
            '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>' +
            '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>' +
            '</Relationships>',

        "[Content_Types].xml":
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
            '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">' +
            '<Default Extension="xml" ContentType="application/xml" />' +
            '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />' +
            '<Default Extension="jpeg" ContentType="image/jpeg" />' +
            '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />' +
            '<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />' +
            '<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" />' +
            '</Types>',

        "xl/workbook.xml":
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
            '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">' +
            '<fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="24816"/>' +
            '<workbookPr showInkAnnotation="0" autoCompressPictures="0"/>' +
            '<bookViews>' +
            '<workbookView xWindow="0" yWindow="0" windowWidth="25600" windowHeight="19020" tabRatio="500"/>' +
            '</bookViews>' +
            '<sheets>' +
            '<sheet name="" sheetId="1" r:id="rId1"/>' +
            '</sheets>' +
            '</workbook>',

        "xl/worksheets/sheet1.xml":
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
            '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">' +
            '<sheetData/>' +
            '<mergeCells count="0"/>' +
            '</worksheet>',

        "xl/styles.xml":
            '<?xml version="1.0" encoding="UTF-8"?>' +
            '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">' +
            '<numFmts count="6">' +
            '<numFmt numFmtId="164" formatCode="#,##0.00_-\ [$$-45C]"/>' +
            '<numFmt numFmtId="165" formatCode="&quot;Â£&quot;#,##0.00"/>' +
            '<numFmt numFmtId="166" formatCode="[$â¬-2]\ #,##0.00"/>' +
            '<numFmt numFmtId="167" formatCode="0.0%"/>' +
            '<numFmt numFmtId="168" formatCode="#,##0;(#,##0)"/>' +
            '<numFmt numFmtId="169" formatCode="#,##0.00;(#,##0.00)"/>' +
            '</numFmts>' +
            '<fonts count="5" x14ac:knownFonts="1">' +
            '<font>' +
            '<sz val="11" />' +
            '<name val="Calibri" />' +
            '</font>' +
            '<font>' +
            '<sz val="11" />' +
            '<name val="Calibri" />' +
            '<color rgb="FFFFFFFF" />' +
            '</font>' +
            '<font>' +
            '<sz val="11" />' +
            '<name val="Calibri" />' +
            '<b />' +
            '</font>' +
            '<font>' +
            '<sz val="11" />' +
            '<name val="Calibri" />' +
            '<i />' +
            '</font>' +
            '<font>' +
            '<sz val="11" />' +
            '<name val="Calibri" />' +
            '<u />' +
            '</font>' +
            '</fonts>' +
            '<fills count="6">' +
            '<fill>' +
            '<patternFill patternType="none" />' +
            '</fill>' +
            '<fill>' + // Excel appears to use this as a dotted background regardless of values but
            '<patternFill patternType="none" />' + // to be valid to the schema, use a patternFill
            '</fill>' +
            '<fill>' +
            '<patternFill patternType="solid">' +
            '<fgColor rgb="FFD9D9D9" />' +
            '<bgColor indexed="64" />' +
            '</patternFill>' +
            '</fill>' +
            '<fill>' +
            '<patternFill patternType="solid">' +
            '<fgColor rgb="FFD99795" />' +
            '<bgColor indexed="64" />' +
            '</patternFill>' +
            '</fill>' +
            '<fill>' +
            '<patternFill patternType="solid">' +
            '<fgColor rgb="ffc6efce" />' +
            '<bgColor indexed="64" />' +
            '</patternFill>' +
            '</fill>' +
            '<fill>' +
            '<patternFill patternType="solid">' +
            '<fgColor rgb="ffc6cfef" />' +
            '<bgColor indexed="64" />' +
            '</patternFill>' +
            '</fill>' +
            '</fills>' +
            '<borders count="2">' +
            '<border>' +
            '<left />' +
            '<right />' +
            '<top />' +
            '<bottom />' +
            '<diagonal />' +
            '</border>' +
            '<border diagonalUp="false" diagonalDown="false">' +
            '<left style="thin">' +
            '<color auto="1" />' +
            '</left>' +
            '<right style="thin">' +
            '<color auto="1" />' +
            '</right>' +
            '<top style="thin">' +
            '<color auto="1" />' +
            '</top>' +
            '<bottom style="thin">' +
            '<color auto="1" />' +
            '</bottom>' +
            '<diagonal />' +
            '</border>' +
            '</borders>' +
            '<cellStyleXfs count="1">' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" />' +
            '</cellStyleXfs>' +
            '<cellXfs count="67">' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="1" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="2" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="3" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="4" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment horizontal="left"/>' +
            '</xf>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment horizontal="center"/>' +
            '</xf>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment horizontal="right"/>' +
            '</xf>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment horizontal="fill"/>' +
            '</xf>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment textRotation="90"/>' +
            '</xf>' +
            '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">' +
            '<alignment wrapText="1"/>' +
            '</xf>' +
            '<xf numFmtId="9"   fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="164" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="165" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="166" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="167" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="168" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="169" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="3" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="4" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="1" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '<xf numFmtId="2" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/>' +
            '</cellXfs>' +
            '<cellStyles count="1">' +
            '<cellStyle name="Normal" xfId="0" builtinId="0" />' +
            '</cellStyles>' +
            '<dxfs count="0" />' +
            '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4" />' +
            '</styleSheet>'
    };
    // Note we could use 3 `for` loops for the styles, but when gzipped there is
    // virtually no difference in size, since the above can be easily compressed

    // Pattern matching for special number formats. Perhaps this should be exposed
    // via an API in future?
    // Ref: section 3.8.30 - built in formatters in open spreadsheet
    //   https://www.ecma-international.org/news/TC45_current_work/Office%20Open%20XML%20Part%204%20-%20Markup%20Language%20Reference.pdf
    var _excelSpecials = [
        { match: /^\-?\d+\.\d%$/, style: 60, fmt: function (d) { return d / 100; } }, // Precent with d.p.
        { match: /^\-?\d+\.?\d*%$/, style: 56, fmt: function (d) { return d / 100; } }, // Percent
        { match: /^\-?\$[\d,]+.?\d*$/, style: 57 }, // Dollars
        { match: /^\-?Â£[\d,]+.?\d*$/, style: 58 }, // Pounds
        { match: /^\-?â¬[\d,]+.?\d*$/, style: 59 }, // Euros
        { match: /^\-?\d+$/, style: 65 }, // Numbers without thousand separators
        { match: /^\-?\d+\.\d{2}$/, style: 66 }, // Numbers 2 d.p. without thousands separators
        { match: /^\([\d,]+\)$/, style: 61, fmt: function (d) { return -1 * d.replace(/[\(\)]/g, ''); } },  // Negative numbers indicated by brackets
        { match: /^\([\d,]+\.\d{2}\)$/, style: 62, fmt: function (d) { return -1 * d.replace(/[\(\)]/g, ''); } },  // Negative numbers indicated by brackets - 2d.p.
        { match: /^\-?[\d,]+$/, style: 63 }, // Numbers with thousand separators
        { match: /^\-?[\d,]+\.\d{2}$/, style: 64 }  // Numbers with 2 d.p. and thousands separators
    ];



    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Buttons
     */

    //
    // Copy to clipboard
    //
    DataTable.ext.buttons.copyHtml5 = {
        className: 'buttons-copy buttons-html5',

        text: function (dt) {
            return dt.i18n('buttons.copy', 'Copy');
        },

        action: function (e, dt, button, config) {
            this.processing(true);

            var that = this;
            var exportData = _exportData(dt, config);
            var info = dt.buttons.exportInfo(config);
            var newline = _newLine(config);
            var output = exportData.str;
            var hiddenDiv = $('<div/>')
                .css({
                    height: 1,
                    width: 1,
                    overflow: 'hidden',
                    position: 'fixed',
                    top: 0,
                    left: 0
                });

            if (info.title) {
                output = info.title + newline + newline + output;
            }

            if (info.messageTop) {
                output = info.messageTop + newline + newline + output;
            }

            if (info.messageBottom) {
                output = output + newline + newline + info.messageBottom;
            }

            if (config.customize) {
                output = config.customize(output, config);
            }

            var textarea = $('<textarea readonly/>')
                .val(output)
                .appendTo(hiddenDiv);

            // For browsers that support the copy execCommand, try to use it
            if (document.queryCommandSupported('copy')) {
                hiddenDiv.appendTo(dt.table().container());
                textarea[0].focus();
                textarea[0].select();

                try {
                    var successful = document.execCommand('copy');
                    hiddenDiv.remove();

                    if (successful) {
                        dt.buttons.info(
                            dt.i18n('buttons.copyTitle', 'Copy to clipboard'),
                            dt.i18n('buttons.copySuccess', {
                                1: 'Copied one row to clipboard',
                                _: 'Copied %d rows to clipboard'
                            }, exportData.rows),
                            2000
                        );

                        this.processing(false);
                        return;
                    }
                }
                catch (t) { }
            }

            // Otherwise we show the text box and instruct the user to use it
            var message = $('<span>' + dt.i18n('buttons.copyKeys',
                'Press <i>ctrl</i> or <i>\u2318</i> + <i>C</i> to copy the table data<br>to your system clipboard.<br><br>' +
                'To cancel, click this message or press escape.') + '</span>'
            )
                .append(hiddenDiv);

            dt.buttons.info(dt.i18n('buttons.copyTitle', 'Copy to clipboard'), message, 0);

            // Select the text so when the user activates their system clipboard
            // it will copy that text
            textarea[0].focus();
            textarea[0].select();

            // Event to hide the message when the user is done
            var container = $(message).closest('.dt-button-info');
            var close = function () {
                container.off('click.buttons-copy');
                $(document).off('.buttons-copy');
                dt.buttons.info(false);
            };

            container.on('click.buttons-copy', close);
            $(document)
                .on('keydown.buttons-copy', function (e) {
                    if (e.keyCode === 27) { // esc
                        close();
                        that.processing(false);
                    }
                })
                .on('copy.buttons-copy cut.buttons-copy', function () {
                    close();
                    that.processing(false);
                });
        },

        exportOptions: {},

        fieldSeparator: '\t',

        fieldBoundary: '',

        header: true,

        footer: false,

        title: '*',

        messageTop: '*',

        messageBottom: '*'
    };

    //
    // CSV export
    //
    DataTable.ext.buttons.csvHtml5 = {
        bom: false,

        className: 'buttons-csv buttons-html5',

        available: function () {
            return window.FileReader !== undefined && window.Blob;
        },

        text: function (dt) {
            return dt.i18n('buttons.csv', 'CSV');
        },

        action: function (e, dt, button, config) {
            this.processing(true);

            // Set the text
            var output = _exportData(dt, config).str;
            var info = dt.buttons.exportInfo(config);
            var charset = config.charset;

            if (config.customize) {
                output = config.customize(output, config);
            }

            if (charset !== false) {
                if (!charset) {
                    charset = document.characterSet || document.charset;
                }

                if (charset) {
                    charset = ';charset=' + charset;
                }
            }
            else {
                charset = '';
            }

            if (config.bom) {
                output = '\ufeff' + output;
            }

            _saveAs(
                new Blob([output], { type: 'text/csv' + charset }),
                info.filename,
                true
            );

            this.processing(false);
        },

        filename: '*',

        extension: '.csv',

        exportOptions: {},

        fieldSeparator: ',',

        fieldBoundary: '"',

        escapeChar: '"',

        charset: null,

        header: true,

        footer: false
    };

    //
    // Excel (xlsx) export
    //
    DataTable.ext.buttons.excelHtml5 = {
        className: 'buttons-excel buttons-html5',

        available: function () {
            return window.FileReader !== undefined && _jsZip() !== undefined && !_isDuffSafari() && _serialiser;
        },

        text: function (dt) {
            return dt.i18n('buttons.excel', 'Excel');
        },

        action: function (e, dt, button, config) {
            this.processing(true);

            var that = this;
            var rowPos = 0;
            var getXml = function (type) {
                var str = excelStrings[type];

                //str = str.replace( /xmlns:/g, 'xmlns_' ).replace( /mc:/g, 'mc_' );

                return $.parseXML(str);
            };
            var rels = getXml('xl/worksheets/sheet1.xml');
            var relsGet = rels.getElementsByTagName("sheetData")[0];

            var xlsx = {
                _rels: {
                    ".rels": getXml('_rels/.rels')
                },
                xl: {
                    _rels: {
                        "workbook.xml.rels": getXml('xl/_rels/workbook.xml.rels')
                    },
                    "workbook.xml": getXml('xl/workbook.xml'),
                    "styles.xml": getXml('xl/styles.xml'),
                    "worksheets": {
                        "sheet1.xml": rels
                    }

                },
                "[Content_Types].xml": getXml('[Content_Types].xml')
            };

            var data = dt.buttons.exportData(config.exportOptions);
            var currentRow, rowNode;
            var addRow = function (row) {
                currentRow = rowPos + 1;
                rowNode = _createNode(rels, "row", { attr: { r: currentRow } });

                for (var i = 0, ien = row.length; i < ien; i++) {
                    // Concat both the Cell Columns as a letter and the Row of the cell.
                    var cellId = createCellPos(i) + '' + currentRow;
                    var cell = null;

                    // For null, undefined of blank cell, continue so it doesn't create the _createNode
                    if (row[i] === null || row[i] === undefined || row[i] === '') {
                        if (config.createEmptyCells === true) {
                            row[i] = '';
                        }
                        else {
                            continue;
                        }
                    }

                    row[i] = $.trim(row[i]);

                    // Special number formatting options
                    for (var j = 0, jen = _excelSpecials.length; j < jen; j++) {
                        var special = _excelSpecials[j];

                        // TODO Need to provide the ability for the specials to say
                        // if they are returning a string, since at the moment it is
                        // assumed to be a number
                        if (row[i].match && !row[i].match(/^0\d+/) && row[i].match(special.match)) {
                            var val = row[i].replace(/[^\d\.\-]/g, '');

                            if (special.fmt) {
                                val = special.fmt(val);
                            }

                            cell = _createNode(rels, 'c', {
                                attr: {
                                    r: cellId,
                                    s: special.style
                                },
                                children: [
                                    _createNode(rels, 'v', { text: val })
                                ]
                            });

                            break;
                        }
                    }

                    if (!cell) {
                        if (typeof row[i] === 'number' || (
                            row[i].match &&
                            row[i].match(/^-?\d+(\.\d+)?$/) &&
                            !row[i].match(/^0\d+/))
                        ) {
                            // Detect numbers - don't match numbers with leading zeros
                            // or a negative anywhere but the start
                            cell = _createNode(rels, 'c', {
                                attr: {
                                    t: 'n',
                                    r: cellId
                                },
                                children: [
                                    _createNode(rels, 'v', { text: row[i] })
                                ]
                            });
                        }
                        else {
                            // String output - replace non standard characters for text output
                            var text = !row[i].replace ?
                                row[i] :
                                row[i].replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');

                            cell = _createNode(rels, 'c', {
                                attr: {
                                    t: 'inlineStr',
                                    r: cellId
                                },
                                children: {
                                    row: _createNode(rels, 'is', {
                                        children: {
                                            row: _createNode(rels, 't', {
                                                text: text
                                            })
                                        }
                                    })
                                }
                            });
                        }
                    }

                    rowNode.appendChild(cell);
                }

                relsGet.appendChild(rowNode);
                rowPos++;
            };

            $('sheets sheet', xlsx.xl['workbook.xml']).attr('name', _sheetname(config));

            if (config.customizeData) {
                config.customizeData(data);
            }

            var mergeCells = function (row, colspan) {
                var mergeCells = $('mergeCells', rels);

                mergeCells[0].appendChild(_createNode(rels, 'mergeCell', {
                    attr: {
                        ref: 'A' + row + ':' + createCellPos(colspan) + row
                    }
                }));
                mergeCells.attr('count', parseFloat(mergeCells.attr('count')) + 1);
                $('row:eq(' + (row - 1) + ') c', rels).attr('s', '51'); // centre
            };

            // Title and top messages
            var exportInfo = dt.buttons.exportInfo(config);
            if (exportInfo.title) {
                addRow([exportInfo.title], rowPos);
                mergeCells(rowPos, data.header.length - 1);
            }

            if (exportInfo.messageTop) {
                addRow([exportInfo.messageTop], rowPos);
                mergeCells(rowPos, data.header.length - 1);
            }

            // Table itself
            if (config.header) {
                addRow(data.header, rowPos);
                $('row:last c', rels).attr('s', '2'); // bold
            }

            for (var n = 0, ie = data.body.length; n < ie; n++) {
                addRow(data.body[n], rowPos);
            }

            if (config.footer && data.footer) {
                addRow(data.footer, rowPos);
                $('row:last c', rels).attr('s', '2'); // bold
            }

            // Below the table
            if (exportInfo.messageBottom) {
                addRow([exportInfo.messageBottom], rowPos);
                mergeCells(rowPos, data.header.length - 1);
            }

            // Set column widths
            var cols = _createNode(rels, 'cols');
            $('worksheet', rels).prepend(cols);

            for (var i = 0, ien = data.header.length; i < ien; i++) {
                cols.appendChild(_createNode(rels, 'col', {
                    attr: {
                        min: i + 1,
                        max: i + 1,
                        width: _excelColWidth(data, i),
                        customWidth: 1
                    }
                }));
            }

            // Let the developer customise the document if they want to
            if (config.customize) {
                config.customize(xlsx);
            }

            // Excel doesn't like an empty mergeCells tag
            if ($('mergeCells', rels).children().length === 0) {
                $('mergeCells', rels).remove();
            }

            var jszip = _jsZip();
            var zip = new jszip();
            var zipConfig = {
                type: 'blob',
                mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            };

            _addToZip(zip, xlsx);

            if (zip.generateAsync) {
                // JSZip 3+
                zip
                    .generateAsync(zipConfig)
                    .then(function (blob) {
                        _saveAs(blob, exportInfo.filename);
                        that.processing(false);
                    });
            }
            else {
                // JSZip 2.5
                _saveAs(
                    zip.generate(zipConfig),
                    exportInfo.filename
                );
                this.processing(false);
            }
        },

        filename: '*',

        extension: '.xlsx',

        exportOptions: {},

        header: true,

        footer: false,

        title: '*',

        messageTop: '*',

        messageBottom: '*',

        createEmptyCells: false
    };

    //
    // PDF export - using pdfMake - http://pdfmake.org
    //
    DataTable.ext.buttons.pdfHtml5 = {
        className: 'buttons-pdf buttons-html5',

        available: function () {
            return window.FileReader !== undefined && _pdfMake();
        },

        text: function (dt) {
            return dt.i18n('buttons.pdf', 'PDF');
        },

        action: function (e, dt, button, config) {
            this.processing(true);

            var that = this;
            var data = dt.buttons.exportData(config.exportOptions);
            var info = dt.buttons.exportInfo(config);
            var rows = [];

            if (config.header) {
                rows.push($.map(data.header, function (d) {
                    return {
                        text: typeof d === 'string' ? d : d + '',
                        style: 'tableHeader'
                    };
                }));
            }

            for (var i = 0, ien = data.body.length; i < ien; i++) {
                rows.push($.map(data.body[i], function (d) {
                    return {
                        text: typeof d === 'string' ? d : d + '',
                        style: i % 2 ? 'tableBodyEven' : 'tableBodyOdd'
                    };
                }));
            }

            if (config.footer && data.footer) {
                rows.push($.map(data.footer, function (d) {
                    return {
                        text: typeof d === 'string' ? d : d + '',
                        style: 'tableFooter'
                    };
                }));
            }

            var doc = {
                pageSize: config.pageSize,
                pageOrientation: config.orientation,
                content: [
                    {
                        table: {
                            headerRows: 1,
                            body: rows
                        },
                        layout: 'noBorders'
                    }
                ],
                styles: {
                    tableHeader: {
                        bold: true,
                        fontSize: 11,
                        color: 'white',
                        fillColor: '#2d4154',
                        alignment: 'center'
                    },
                    tableBodyEven: {},
                    tableBodyOdd: {
                        fillColor: '#f3f3f3'
                    },
                    tableFooter: {
                        bold: true,
                        fontSize: 11,
                        color: 'white',
                        fillColor: '#2d4154'
                    },
                    title: {
                        alignment: 'center',
                        fontSize: 15
                    },
                    message: {}
                },
                defaultStyle: {
                    fontSize: 10
                }
            };

            if (info.messageTop) {
                doc.content.unshift({
                    text: info.messageTop,
                    style: 'message',
                    margin: [0, 0, 0, 12]
                });
            }

            if (info.messageBottom) {
                doc.content.push({
                    text: info.messageBottom,
                    style: 'message',
                    margin: [0, 0, 0, 12]
                });
            }

            if (info.title) {
                doc.content.unshift({
                    text: info.title,
                    style: 'title',
                    margin: [0, 0, 0, 12]
                });
            }

            if (config.customize) {
                config.customize(doc, config);
            }

            var pdf = _pdfMake().createPdf(doc);

            if (config.download === 'open' && !_isDuffSafari()) {
                pdf.open();
            }
            else {
                pdf.download(info.filename);
            }

            this.processing(false);
        },

        title: '*',

        filename: '*',

        extension: '.pdf',

        exportOptions: {},

        orientation: 'portrait',

        pageSize: 'A4',

        header: true,

        footer: false,

        messageTop: '*',

        messageBottom: '*',

        customize: null,

        download: 'download'
    };


    return DataTable.Buttons;
}));
/*! Responsive 2.2.1
 * 2014-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     Responsive
 * @description Responsive tables plug-in for DataTables
 * @version     2.2.1
 * @file        dataTables.responsive.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2014-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                root = window;
            }

            if (!$ || !$.fn.dataTable) {
                $ = require('datatables.net')(root, $).$;
            }

            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document, undefined) {
    'use strict';
    var DataTable = $.fn.dataTable;


    /**
     * Responsive is a plug-in for the DataTables library that makes use of
     * DataTables' ability to change the visibility of columns, changing the
     * visibility of columns so the displayed columns fit into the table container.
     * The end result is that complex tables will be dynamically adjusted to fit
     * into the viewport, be it on a desktop, tablet or mobile browser.
     *
     * Responsive for DataTables has two modes of operation, which can used
     * individually or combined:
     *
     * * Class name based control - columns assigned class names that match the
     *   breakpoint logic can be shown / hidden as required for each breakpoint.
     * * Automatic control - columns are automatically hidden when there is no
     *   room left to display them. Columns removed from the right.
     *
     * In additional to column visibility control, Responsive also has built into
     * options to use DataTables' child row display to show / hide the information
     * from the table that has been hidden. There are also two modes of operation
     * for this child row display:
     *
     * * Inline - when the control element that the user can use to show / hide
     *   child rows is displayed inside the first column of the table.
     * * Column - where a whole column is dedicated to be the show / hide control.
     *
     * Initialisation of Responsive is performed by:
     *
     * * Adding the class `responsive` or `dt-responsive` to the table. In this case
     *   Responsive will automatically be initialised with the default configuration
     *   options when the DataTable is created.
     * * Using the `responsive` option in the DataTables configuration options. This
     *   can also be used to specify the configuration options, or simply set to
     *   `true` to use the defaults.
     *
     *  @class
     *  @param {object} settings DataTables settings object for the host table
     *  @param {object} [opts] Configuration options
     *  @requires jQuery 1.7+
     *  @requires DataTables 1.10.3+
     *
     *  @example
     *      $('#example').DataTable( {
     *        responsive: true
     *      } );
     *    } );
     */
    var Responsive = function (settings, opts) {
        // Sanity check that we are using DataTables 1.10 or newer
        if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.10')) {
            throw 'DataTables Responsive requires DataTables 1.10.10 or newer';
        }

        this.s = {
            dt: new DataTable.Api(settings),
            columns: [],
            current: []
        };

        // Check if responsive has already been initialised on this table
        if (this.s.dt.settings()[0].responsive) {
            return;
        }

        // details is an object, but for simplicity the user can give it as a string
        // or a boolean
        if (opts && typeof opts.details === 'string') {
            opts.details = { type: opts.details };
        }
        else if (opts && opts.details === false) {
            opts.details = { type: false };
        }
        else if (opts && opts.details === true) {
            opts.details = { type: 'inline' };
        }

        this.c = $.extend(true, {}, Responsive.defaults, DataTable.defaults.responsive, opts);
        settings.responsive = this;
        this._constructor();
    };

    $.extend(Responsive.prototype, {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Constructor
         */

        /**
         * Initialise the Responsive instance
         *
         * @private
         */
        _constructor: function () {
            var that = this;
            var dt = this.s.dt;
            var dtPrivateSettings = dt.settings()[0];
            var oldWindowWidth = $(window).width();

            dt.settings()[0]._responsive = this;

            // Use DataTables' throttle function to avoid processor thrashing on
            // resize
            $(window).on('resize.dtr orientationchange.dtr', DataTable.util.throttle(function () {
                // iOS has a bug whereby resize can fire when only scrolling
                // See: http://stackoverflow.com/questions/8898412
                var width = $(window).width();

                if (width !== oldWindowWidth) {
                    that._resize();
                    oldWindowWidth = width;
                }
            }));

            // DataTables doesn't currently trigger an event when a row is added, so
            // we need to hook into its private API to enforce the hidden rows when
            // new data is added
            dtPrivateSettings.oApi._fnCallbackReg(dtPrivateSettings, 'aoRowCreatedCallback', function (tr, data, idx) {
                if ($.inArray(false, that.s.current) !== -1) {
                    $('>td, >th', tr).each(function (i) {
                        var idx = dt.column.index('toData', i);

                        if (that.s.current[idx] === false) {
                            $(this).css('display', 'none');
                        }
                    });
                }
            });

            // Destroy event handler
            dt.on('destroy.dtr', function () {
                dt.off('.dtr');
                $(dt.table().body()).off('.dtr');
                $(window).off('resize.dtr orientationchange.dtr');

                // Restore the columns that we've hidden
                $.each(that.s.current, function (i, val) {
                    if (val === false) {
                        that._setColumnVis(i, true);
                    }
                });
            });

            // Reorder the breakpoints array here in case they have been added out
            // of order
            this.c.breakpoints.sort(function (a, b) {
                return a.width < b.width ? 1 :
                    a.width > b.width ? -1 : 0;
            });

            this._classLogic();
            this._resizeAuto();

            // Details handler
            var details = this.c.details;

            if (details.type !== false) {
                that._detailsInit();

                // DataTables will trigger this event on every column it shows and
                // hides individually
                dt.on('column-visibility.dtr', function (e, ctx, col, vis, recalc) {
                    if (recalc) {
                        that._classLogic();
                        that._resizeAuto();
                        that._resize();
                    }
                });

                // Redraw the details box on each draw which will happen if the data
                // has changed. This is used until DataTables implements a native
                // `updated` event for rows
                dt.on('draw.dtr', function () {
                    that._redrawChildren();
                });

                $(dt.table().node()).addClass('dtr-' + details.type);
            }

            dt.on('column-reorder.dtr', function (e, settings, details) {
                that._classLogic();
                that._resizeAuto();
                that._resize();
            });

            // Change in column sizes means we need to calc
            dt.on('column-sizing.dtr', function () {
                that._resizeAuto();
                that._resize();
            });

            // On Ajax reload we want to reopen any child rows which are displayed
            // by responsive
            dt.on('preXhr.dtr', function () {
                var rowIds = [];
                dt.rows().every(function () {
                    if (this.child.isShown()) {
                        rowIds.push(this.id(true));
                    }
                });

                dt.one('draw.dtr', function () {
                    that._resizeAuto();
                    that._resize();

                    dt.rows(rowIds).every(function () {
                        that._detailsDisplay(this, false);
                    });
                });
            });

            dt.on('init.dtr', function (e, settings, details) {
                that._resizeAuto();
                that._resize();

                // If columns were hidden, then DataTables needs to adjust the
                // column sizing
                if ($.inArray(false, that.s.current)) {
                    dt.columns.adjust();
                }
            });

            // First pass - draw the table for the current viewport size
            this._resize();
        },


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Private methods
         */

        /**
         * Calculate the visibility for the columns in a table for a given
         * breakpoint. The result is pre-determined based on the class logic if
         * class names are used to control all columns, but the width of the table
         * is also used if there are columns which are to be automatically shown
         * and hidden.
         *
         * @param  {string} breakpoint Breakpoint name to use for the calculation
         * @return {array} Array of boolean values initiating the visibility of each
         *   column.
         *  @private
         */
        _columnsVisiblity: function (breakpoint) {
            var dt = this.s.dt;
            var columns = this.s.columns;
            var i, ien;

            // Create an array that defines the column ordering based first on the
            // column's priority, and secondly the column index. This allows the
            // columns to be removed from the right if the priority matches
            var order = columns
                .map(function (col, idx) {
                    return {
                        columnIdx: idx,
                        priority: col.priority
                    };
                })
                .sort(function (a, b) {
                    if (a.priority !== b.priority) {
                        return a.priority - b.priority;
                    }
                    return a.columnIdx - b.columnIdx;
                });

            // Class logic - determine which columns are in this breakpoint based
            // on the classes. If no class control (i.e. `auto`) then `-` is used
            // to indicate this to the rest of the function
            var display = $.map(columns, function (col) {
                return col.auto && col.minWidth === null ?
                    false :
                    col.auto === true ?
                        '-' :
                        $.inArray(breakpoint, col.includeIn) !== -1;
            });

            // Auto column control - first pass: how much width is taken by the
            // ones that must be included from the non-auto columns
            var requiredWidth = 0;
            for (i = 0, ien = display.length; i < ien; i++) {
                if (display[i] === true) {
                    requiredWidth += columns[i].minWidth;
                }
            }

            // Second pass, use up any remaining width for other columns. For
            // scrolling tables we need to subtract the width of the scrollbar. It
            // may not be requires which makes this sub-optimal, but it would
            // require another full redraw to make complete use of those extra few
            // pixels
            var scrolling = dt.settings()[0].oScroll;
            var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
            var widthAvailable = dt.table().container().offsetWidth - bar;
            var usedWidth = widthAvailable - requiredWidth;

            // Control column needs to always be included. This makes it sub-
            // optimal in terms of using the available with, but to stop layout
            // thrashing or overflow. Also we need to account for the control column
            // width first so we know how much width is available for the other
            // columns, since the control column might not be the first one shown
            for (i = 0, ien = display.length; i < ien; i++) {
                if (columns[i].control) {
                    usedWidth -= columns[i].minWidth;
                }
            }

            // Allow columns to be shown (counting by priority and then right to
            // left) until we run out of room
            var empty = false;
            for (i = 0, ien = order.length; i < ien; i++) {
                var colIdx = order[i].columnIdx;

                if (display[colIdx] === '-' && !columns[colIdx].control && columns[colIdx].minWidth) {
                    // Once we've found a column that won't fit we don't let any
                    // others display either, or columns might disappear in the
                    // middle of the table
                    if (empty || usedWidth - columns[colIdx].minWidth < 0) {
                        empty = true;
                        display[colIdx] = false;
                    }
                    else {
                        display[colIdx] = true;
                    }

                    usedWidth -= columns[colIdx].minWidth;
                }
            }

            // Determine if the 'control' column should be shown (if there is one).
            // This is the case when there is a hidden column (that is not the
            // control column). The two loops look inefficient here, but they are
            // trivial and will fly through. We need to know the outcome from the
            // first , before the action in the second can be taken
            var showControl = false;

            for (i = 0, ien = columns.length; i < ien; i++) {
                if (!columns[i].control && !columns[i].never && !display[i]) {
                    showControl = true;
                    break;
                }
            }

            for (i = 0, ien = columns.length; i < ien; i++) {
                if (columns[i].control) {
                    display[i] = showControl;
                }
            }

            // Finally we need to make sure that there is at least one column that
            // is visible
            if ($.inArray(true, display) === -1) {
                display[0] = true;
            }

            return display;
        },


        /**
         * Create the internal `columns` array with information about the columns
         * for the table. This includes determining which breakpoints the column
         * will appear in, based upon class names in the column, which makes up the
         * vast majority of this method.
         *
         * @private
         */
        _classLogic: function () {
            var that = this;
            var calc = {};
            var breakpoints = this.c.breakpoints;
            var dt = this.s.dt;
            var columns = dt.columns().eq(0).map(function (i) {
                var column = this.column(i);
                var className = column.header().className;
                var priority = dt.settings()[0].aoColumns[i].responsivePriority;

                if (priority === undefined) {
                    var dataPriority = $(column.header()).data('priority');

                    priority = dataPriority !== undefined ?
                        dataPriority * 1 :
                        10000;
                }

                return {
                    className: className,
                    includeIn: [],
                    auto: false,
                    control: false,
                    never: className.match(/\bnever\b/) ? true : false,
                    priority: priority
                };
            });

            // Simply add a breakpoint to `includeIn` array, ensuring that there are
            // no duplicates
            var add = function (colIdx, name) {
                var includeIn = columns[colIdx].includeIn;

                if ($.inArray(name, includeIn) === -1) {
                    includeIn.push(name);
                }
            };

            var column = function (colIdx, name, operator, matched) {
                var size, i, ien;

                if (!operator) {
                    columns[colIdx].includeIn.push(name);
                }
                else if (operator === 'max-') {
                    // Add this breakpoint and all smaller
                    size = that._find(name).width;

                    for (i = 0, ien = breakpoints.length; i < ien; i++) {
                        if (breakpoints[i].width <= size) {
                            add(colIdx, breakpoints[i].name);
                        }
                    }
                }
                else if (operator === 'min-') {
                    // Add this breakpoint and all larger
                    size = that._find(name).width;

                    for (i = 0, ien = breakpoints.length; i < ien; i++) {
                        if (breakpoints[i].width >= size) {
                            add(colIdx, breakpoints[i].name);
                        }
                    }
                }
                else if (operator === 'not-') {
                    // Add all but this breakpoint
                    for (i = 0, ien = breakpoints.length; i < ien; i++) {
                        if (breakpoints[i].name.indexOf(matched) === -1) {
                            add(colIdx, breakpoints[i].name);
                        }
                    }
                }
            };

            // Loop over each column and determine if it has a responsive control
            // class
            columns.each(function (col, i) {
                var classNames = col.className.split(' ');
                var hasClass = false;

                // Split the class name up so multiple rules can be applied if needed
                for (var k = 0, ken = classNames.length; k < ken; k++) {
                    var className = $.trim(classNames[k]);

                    if (className === 'all') {
                        // Include in all
                        hasClass = true;
                        col.includeIn = $.map(breakpoints, function (a) {
                            return a.name;
                        });
                        return;
                    }
                    else if (className === 'none' || col.never) {
                        // Include in none (default) and no auto
                        hasClass = true;
                        return;
                    }
                    else if (className === 'control') {
                        // Special column that is only visible, when one of the other
                        // columns is hidden. This is used for the details control
                        hasClass = true;
                        col.control = true;
                        return;
                    }

                    $.each(breakpoints, function (j, breakpoint) {
                        // Does this column have a class that matches this breakpoint?
                        var brokenPoint = breakpoint.name.split('-');
                        var re = new RegExp('(min\\-|max\\-|not\\-)?(' + brokenPoint[0] + ')(\\-[_a-zA-Z0-9])?');
                        var match = className.match(re);

                        if (match) {
                            hasClass = true;

                            if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {
                                // Class name matches breakpoint name fully
                                column(i, breakpoint.name, match[1], match[2] + match[3]);
                            }
                            else if (match[2] === brokenPoint[0] && !match[3]) {
                                // Class name matched primary breakpoint name with no qualifier
                                column(i, breakpoint.name, match[1], match[2]);
                            }
                        }
                    });
                }

                // If there was no control class, then automatic sizing is used
                if (!hasClass) {
                    col.auto = true;
                }
            });

            this.s.columns = columns;
        },


        /**
         * Show the details for the child row
         *
         * @param  {DataTables.Api} row    API instance for the row
         * @param  {boolean}        update Update flag
         * @private
         */
        _detailsDisplay: function (row, update) {
            var that = this;
            var dt = this.s.dt;
            var details = this.c.details;

            if (details && details.type !== false) {
                var res = details.display(row, update, function () {
                    return details.renderer(
                        dt, row[0], that._detailsObj(row[0])
                    );
                });

                if (res === true || res === false) {
                    $(dt.table().node()).triggerHandler('responsive-display.dt', [dt, row, res, update]);
                }
            }
        },


        /**
         * Initialisation for the details handler
         *
         * @private
         */
        _detailsInit: function () {
            var that = this;
            var dt = this.s.dt;
            var details = this.c.details;

            // The inline type always uses the first child as the target
            if (details.type === 'inline') {
                details.target = 'td:first-child, th:first-child';
            }

            // Keyboard accessibility
            dt.on('draw.dtr', function () {
                that._tabIndexes();
            });
            that._tabIndexes(); // Initial draw has already happened

            $(dt.table().body()).on('keyup.dtr', 'td, th', function (e) {
                if (e.keyCode === 13 && $(this).data('dtr-keyboard')) {
                    $(this).click();
                }
            });

            // type.target can be a string jQuery selector or a column index
            var target = details.target;
            var selector = typeof target === 'string' ? target : 'td, th';

            // Click handler to show / hide the details rows when they are available
            $(dt.table().body())
                .on('click.dtr mousedown.dtr mouseup.dtr', selector, function (e) {
                    // If the table is not collapsed (i.e. there is no hidden columns)
                    // then take no action
                    if (!$(dt.table().node()).hasClass('collapsed')) {
                        return;
                    }

                    // Check that the row is actually a DataTable's controlled node
                    if ($.inArray($(this).closest('tr').get(0), dt.rows().nodes().toArray()) === -1) {
                        return;
                    }

                    // For column index, we determine if we should act or not in the
                    // handler - otherwise it is already okay
                    if (typeof target === 'number') {
                        var targetIdx = target < 0 ?
                            dt.columns().eq(0).length + target :
                            target;

                        if (dt.cell(this).index().column !== targetIdx) {
                            return;
                        }
                    }

                    // $().closest() includes itself in its check
                    var row = dt.row($(this).closest('tr'));

                    // Check event type to do an action
                    if (e.type === 'click') {
                        // The renderer is given as a function so the caller can execute it
                        // only when they need (i.e. if hiding there is no point is running
                        // the renderer)
                        that._detailsDisplay(row, false);
                    }
                    else if (e.type === 'mousedown') {
                        // For mouse users, prevent the focus ring from showing
                        $(this).css('outline', 'none');
                    }
                    else if (e.type === 'mouseup') {
                        // And then re-allow at the end of the click
                        $(this).blur().css('outline', '');
                    }
                });
        },


        /**
         * Get the details to pass to a renderer for a row
         * @param  {int} rowIdx Row index
         * @private
         */
        _detailsObj: function (rowIdx) {
            var that = this;
            var dt = this.s.dt;

            return $.map(this.s.columns, function (col, i) {
                // Never and control columns should not be passed to the renderer
                if (col.never || col.control) {
                    return;
                }

                return {
                    title: dt.settings()[0].aoColumns[i].sTitle,
                    data: dt.cell(rowIdx, i).render(that.c.orthogonal),
                    hidden: dt.column(i).visible() && !that.s.current[i],
                    columnIndex: i,
                    rowIndex: rowIdx
                };
            });
        },


        /**
         * Find a breakpoint object from a name
         *
         * @param  {string} name Breakpoint name to find
         * @return {object}      Breakpoint description object
         * @private
         */
        _find: function (name) {
            var breakpoints = this.c.breakpoints;

            for (var i = 0, ien = breakpoints.length; i < ien; i++) {
                if (breakpoints[i].name === name) {
                    return breakpoints[i];
                }
            }
        },


        /**
         * Re-create the contents of the child rows as the display has changed in
         * some way.
         *
         * @private
         */
        _redrawChildren: function () {
            var that = this;
            var dt = this.s.dt;

            dt.rows({ page: 'current' }).iterator('row', function (settings, idx) {
                var row = dt.row(idx);

                that._detailsDisplay(dt.row(idx), true);
            });
        },


        /**
         * Alter the table display for a resized viewport. This involves first
         * determining what breakpoint the window currently is in, getting the
         * column visibilities to apply and then setting them.
         *
         * @private
         */
        _resize: function () {
            var that = this;
            var dt = this.s.dt;
            var width = $(window).width();
            var breakpoints = this.c.breakpoints;
            var breakpoint = breakpoints[0].name;
            var columns = this.s.columns;
            var i, ien;
            var oldVis = this.s.current.slice();

            // Determine what breakpoint we are currently at
            for (i = breakpoints.length - 1; i >= 0; i--) {
                if (width <= breakpoints[i].width) {
                    breakpoint = breakpoints[i].name;
                    break;
                }
            }

            // Show the columns for that break point
            var columnsVis = this._columnsVisiblity(breakpoint);
            this.s.current = columnsVis;

            // Set the class before the column visibility is changed so event
            // listeners know what the state is. Need to determine if there are
            // any columns that are not visible but can be shown
            var collapsedClass = false;
            for (i = 0, ien = columns.length; i < ien; i++) {
                if (columnsVis[i] === false && !columns[i].never && !columns[i].control) {
                    collapsedClass = true;
                    break;
                }
            }

            $(dt.table().node()).toggleClass('collapsed', collapsedClass);

            var changed = false;
            var visible = 0;

            dt.columns().eq(0).each(function (colIdx, i) {
                if (columnsVis[i] === true) {
                    visible++;
                }

                if (columnsVis[i] !== oldVis[i]) {
                    changed = true;
                    that._setColumnVis(colIdx, columnsVis[i]);
                }
            });

            if (changed) {
                this._redrawChildren();

                // Inform listeners of the change
                $(dt.table().node()).trigger('responsive-resize.dt', [dt, this.s.current]);

                // If no records, update the "No records" display element
                if (dt.page.info().recordsDisplay === 0) {
                    $('td', dt.table().body()).eq(0).attr('colspan', visible);
                }
            }
        },


        /**
         * Determine the width of each column in the table so the auto column hiding
         * has that information to work with. This method is never going to be 100%
         * perfect since column widths can change slightly per page, but without
         * seriously compromising performance this is quite effective.
         *
         * @private
         */
        _resizeAuto: function () {
            var dt = this.s.dt;
            var columns = this.s.columns;

            // Are we allowed to do auto sizing?
            if (!this.c.auto) {
                return;
            }

            // Are there any columns that actually need auto-sizing, or do they all
            // have classes defined
            if ($.inArray(true, $.map(columns, function (c) { return c.auto; })) === -1) {
                return;
            }

            // Need to restore all children. They will be reinstated by a re-render
            if (!$.isEmptyObject(_childNodeStore)) {
                $.each(_childNodeStore, function (key) {
                    var idx = key.split('-');

                    _childNodesRestore(dt, idx[0] * 1, idx[1] * 1);
                });
            }

            // Clone the table with the current data in it
            var tableWidth = dt.table().node().offsetWidth;
            var columnWidths = dt.columns;
            var clonedTable = dt.table().node().cloneNode(false);
            var clonedHeader = $(dt.table().header().cloneNode(false)).appendTo(clonedTable);
            var clonedBody = $(dt.table().body()).clone(false, false).empty().appendTo(clonedTable); // use jQuery because of IE8

            // Header
            var headerCells = dt.columns()
                .header()
                .filter(function (idx) {
                    return dt.column(idx).visible();
                })
                .to$()
                .clone(false)
                .css('display', 'table-cell')
                .css('min-width', 0);

            // Body rows - we don't need to take account of DataTables' column
            // visibility since we implement our own here (hence the `display` set)
            $(clonedBody)
                .append($(dt.rows({ page: 'current' }).nodes()).clone(false))
                .find('th, td').css('display', '');

            // Footer
            var footer = dt.table().footer();
            if (footer) {
                var clonedFooter = $(footer.cloneNode(false)).appendTo(clonedTable);
                var footerCells = dt.columns()
                    .footer()
                    .filter(function (idx) {
                        return dt.column(idx).visible();
                    })
                    .to$()
                    .clone(false)
                    .css('display', 'table-cell');

                $('<tr/>')
                    .append(footerCells)
                    .appendTo(clonedFooter);
            }

            $('<tr/>')
                .append(headerCells)
                .appendTo(clonedHeader);

            // In the inline case extra padding is applied to the first column to
            // give space for the show / hide icon. We need to use this in the
            // calculation
            if (this.c.details.type === 'inline') {
                $(clonedTable).addClass('dtr-inline collapsed');
            }

            // It is unsafe to insert elements with the same name into the DOM
            // multiple times. For example, cloning and inserting a checked radio
            // clears the chcecked state of the original radio.
            $(clonedTable).find('[name]').removeAttr('name');

            var inserted = $('<div/>')
                .css({
                    width: 1,
                    height: 1,
                    overflow: 'hidden',
                    clear: 'both'
                })
                .append(clonedTable);

            inserted.insertBefore(dt.table().node());

            // The cloned header now contains the smallest that each column can be
            headerCells.each(function (i) {
                var idx = dt.column.index('fromVisible', i);
                columns[idx].minWidth = this.offsetWidth || 0;
            });

            inserted.remove();
        },

        /**
         * Set a column's visibility.
         *
         * We don't use DataTables' column visibility controls in order to ensure
         * that column visibility can Responsive can no-exist. Since only IE8+ is
         * supported (and all evergreen browsers of course) the control of the
         * display attribute works well.
         *
         * @param {integer} col      Column index
         * @param {boolean} showHide Show or hide (true or false)
         * @private
         */
        _setColumnVis: function (col, showHide) {
            var dt = this.s.dt;
            var display = showHide ? '' : 'none'; // empty string will remove the attr

            $(dt.column(col).header()).css('display', display);
            $(dt.column(col).footer()).css('display', display);
            dt.column(col).nodes().to$().css('display', display);

            // If the are child nodes stored, we might need to reinsert them
            if (!$.isEmptyObject(_childNodeStore)) {
                dt.cells(null, col).indexes().each(function (idx) {
                    _childNodesRestore(dt, idx.row, idx.column);
                });
            }
        },


        /**
         * Update the cell tab indexes for keyboard accessibility. This is called on
         * every table draw - that is potentially inefficient, but also the least
         * complex option given that column visibility can change on the fly. Its a
         * shame user-focus was removed from CSS 3 UI, as it would have solved this
         * issue with a single CSS statement.
         *
         * @private
         */
        _tabIndexes: function () {
            var dt = this.s.dt;
            var cells = dt.cells({ page: 'current' }).nodes().to$();
            var ctx = dt.settings()[0];
            var target = this.c.details.target;

            cells.filter('[data-dtr-keyboard]').removeData('[data-dtr-keyboard]');

            var selector = typeof target === 'number' ?
                ':eq(' + target + ')' :
                target;

            // This is a bit of a hack - we need to limit the selected nodes to just
            // those of this table
            if (selector === 'td:first-child, th:first-child') {
                selector = '>td:first-child, >th:first-child';
            }

            $(selector, dt.rows({ page: 'current' }).nodes())
                .attr('tabIndex', ctx.iTabIndex)
                .data('dtr-keyboard', 1);
        }
    });


    /**
     * List of default breakpoints. Each item in the array is an object with two
     * properties:
     *
     * * `name` - the breakpoint name.
     * * `width` - the breakpoint width
     *
     * @name Responsive.breakpoints
     * @static
     */
    Responsive.breakpoints = [
        { name: 'desktop', width: Infinity },
        { name: 'tablet-l', width: 1024 },
        { name: 'tablet-p', width: 768 },
        { name: 'mobile-l', width: 480 },
        { name: 'mobile-p', width: 320 }
    ];


    /**
     * Display methods - functions which define how the hidden data should be shown
     * in the table.
     *
     * @namespace
     * @name Responsive.defaults
     * @static
     */
    Responsive.display = {
        childRow: function (row, update, render) {
            if (update) {
                if ($(row.node()).hasClass('parent')) {
                    row.child(render(), 'child').show();

                    return true;
                }
            }
            else {
                if (!row.child.isShown()) {
                    row.child(render(), 'child').show();
                    $(row.node()).addClass('parent');

                    return true;
                }
                else {
                    row.child(false);
                    $(row.node()).removeClass('parent');

                    return false;
                }
            }
        },

        childRowImmediate: function (row, update, render) {
            if ((!update && row.child.isShown()) || !row.responsive.hasHidden()) {
                // User interaction and the row is show, or nothing to show
                row.child(false);
                $(row.node()).removeClass('parent');

                return false;
            }
            else {
                // Display
                row.child(render(), 'child').show();
                $(row.node()).addClass('parent');

                return true;
            }
        },

        // This is a wrapper so the modal options for Bootstrap and jQuery UI can
        // have options passed into them. This specific one doesn't need to be a
        // function but it is for consistency in the `modal` name
        modal: function (options) {
            return function (row, update, render) {
                if (!update) {
                    // Show a modal
                    var close = function () {
                        modal.remove(); // will tidy events for us
                        $(document).off('keypress.dtr');
                    };

                    var modal = $('<div class="dtr-modal"/>')
                        .append($('<div class="dtr-modal-display"/>')
                            .append($('<div class="dtr-modal-content"/>')
                                .append(render())
                            )
                            .append($('<div class="dtr-modal-close">&times;</div>')
                                .click(function () {
                                    close();
                                })
                            )
                        )
                        .append($('<div class="dtr-modal-background"/>')
                            .click(function () {
                                close();
                            })
                        )
                        .appendTo('body');

                    $(document).on('keyup.dtr', function (e) {
                        if (e.keyCode === 27) {
                            e.stopPropagation();

                            close();
                        }
                    });
                }
                else {
                    $('div.dtr-modal-content')
                        .empty()
                        .append(render());
                }

                if (options && options.header) {
                    $('div.dtr-modal-content').prepend(
                        '<h2>' + options.header(row) + '</h2>'
                    );
                }
            };
        }
    };


    var _childNodeStore = {};

    function _childNodes(dt, row, col) {
        var name = row + '-' + col;

        if (_childNodeStore[name]) {
            return _childNodeStore[name];
        }

        // https://jsperf.com/childnodes-array-slice-vs-loop
        var nodes = [];
        var children = dt.cell(row, col).node().childNodes;
        for (var i = 0, ien = children.length; i < ien; i++) {
            nodes.push(children[i]);
        }

        _childNodeStore[name] = nodes;

        return nodes;
    }

    function _childNodesRestore(dt, row, col) {
        var name = row + '-' + col;

        if (!_childNodeStore[name]) {
            return;
        }

        var node = dt.cell(row, col).node();
        var store = _childNodeStore[name];
        var parent = store[0].parentNode;
        var parentChildren = parent.childNodes;
        var a = [];

        for (var i = 0, ien = parentChildren.length; i < ien; i++) {
            a.push(parentChildren[i]);
        }

        for (var j = 0, jen = a.length; j < jen; j++) {
            node.appendChild(a[j]);
        }

        _childNodeStore[name] = undefined;
    }


    /**
     * Display methods - functions which define how the hidden data should be shown
     * in the table.
     *
     * @namespace
     * @name Responsive.defaults
     * @static
     */
    Responsive.renderer = {
        listHiddenNodes: function () {
            return function (api, rowIdx, columns) {
                var ul = $('<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>');
                var found = false;

                var data = $.each(columns, function (i, col) {
                    if (col.hidden) {
                        $(
                            '<li data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '">' +
                            '<span class="dtr-title">' +
                            col.title +
                            '</span> ' +
                            '</li>'
                        )
                            .append($('<span class="dtr-data"/>').append(_childNodes(api, col.rowIndex, col.columnIndex)))// api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )
                            .appendTo(ul);

                        found = true;
                    }
                });

                return found ?
                    ul :
                    false;
            };
        },

        listHidden: function () {
            return function (api, rowIdx, columns) {
                var data = $.map(columns, function (col) {
                    return col.hidden ?
                        '<li data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '">' +
                        '<span class="dtr-title">' +
                        col.title +
                        '</span> ' +
                        '<span class="dtr-data">' +
                        col.data +
                        '</span>' +
                        '</li>' :
                        '';
                }).join('');

                return data ?
                    $('<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>').append(data) :
                    false;
            }
        },

        tableAll: function (options) {
            options = $.extend({
                tableClass: ''
            }, options);

            return function (api, rowIdx, columns) {
                var data = $.map(columns, function (col) {
                    return '<tr data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '">' +
                        '<td>' + col.title + ':' + '</td> ' +
                        '<td>' + col.data + '</td>' +
                        '</tr>';
                }).join('');

                return $('<table class="' + options.tableClass + ' dtr-details" width="100%"/>').append(data);
            }
        }
    };

    /**
     * Responsive default settings for initialisation
     *
     * @namespace
     * @name Responsive.defaults
     * @static
     */
    Responsive.defaults = {
        /**
         * List of breakpoints for the instance. Note that this means that each
         * instance can have its own breakpoints. Additionally, the breakpoints
         * cannot be changed once an instance has been creased.
         *
         * @type {Array}
         * @default Takes the value of `Responsive.breakpoints`
         */
        breakpoints: Responsive.breakpoints,

        /**
         * Enable / disable auto hiding calculations. It can help to increase
         * performance slightly if you disable this option, but all columns would
         * need to have breakpoint classes assigned to them
         *
         * @type {Boolean}
         * @default  `true`
         */
        auto: true,

        /**
         * Details control. If given as a string value, the `type` property of the
         * default object is set to that value, and the defaults used for the rest
         * of the object - this is for ease of implementation.
         *
         * The object consists of the following properties:
         *
         * * `display` - A function that is used to show and hide the hidden details
         * * `renderer` - function that is called for display of the child row data.
         *   The default function will show the data from the hidden columns
         * * `target` - Used as the selector for what objects to attach the child
         *   open / close to
         * * `type` - `false` to disable the details display, `inline` or `column`
         *   for the two control types
         *
         * @type {Object|string}
         */
        details: {
            display: Responsive.display.childRow,

            renderer: Responsive.renderer.listHidden(),

            target: 0,

            type: 'inline'
        },

        /**
         * Orthogonal data request option. This is used to define the data type
         * requested when Responsive gets the data to show in the child row.
         *
         * @type {String}
         */
        orthogonal: 'display'
    };


    /*
     * API
     */
    var Api = $.fn.dataTable.Api;

    // Doesn't do anything - work around for a bug in DT... Not documented
    Api.register('responsive()', function () {
        return this;
    });

    Api.register('responsive.index()', function (li) {
        li = $(li);

        return {
            column: li.data('dtr-index'),
            row: li.parent().data('dtr-index')
        };
    });

    Api.register('responsive.rebuild()', function () {
        return this.iterator('table', function (ctx) {
            if (ctx._responsive) {
                ctx._responsive._classLogic();
            }
        });
    });

    Api.register('responsive.recalc()', function () {
        return this.iterator('table', function (ctx) {
            if (ctx._responsive) {
                ctx._responsive._resizeAuto();
                ctx._responsive._resize();
            }
        });
    });

    Api.register('responsive.hasHidden()', function () {
        var ctx = this.context[0];

        return ctx._responsive ?
            $.inArray(false, ctx._responsive.s.current) !== -1 :
            false;
    });

    Api.registerPlural('columns().responsiveHidden()', 'column().responsiveHidden()', function () {
        return this.iterator('column', function (settings, column) {
            return settings._responsive ?
                settings._responsive.s.current[column] :
                false;
        }, 1);
    });


    /**
     * Version information
     *
     * @name Responsive.version
     * @static
     */
    Responsive.version = '2.2.1';


    $.fn.dataTable.Responsive = Responsive;
    $.fn.DataTable.Responsive = Responsive;

    // Attach a listener to the document which listens for DataTables initialisation
    // events so we can automatically initialise
    $(document).on('preInit.dt.dtr', function (e, settings, json) {
        if (e.namespace !== 'dt') {
            return;
        }

        if ($(settings.nTable).hasClass('responsive') ||
            $(settings.nTable).hasClass('dt-responsive') ||
            settings.oInit.responsive ||
            DataTable.defaults.responsive
        ) {
            var init = settings.oInit.responsive;

            if (init !== false) {
                new Responsive(settings, $.isPlainObject(init) ? init : {});
            }
        }
    });


    return Responsive;
}));
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGF0YWJsZXMuanMiLCJidXR0b25zLmpzIiwianN6aXAubWluLmpzIiwiYnV0dG9ucy5odG1sNS5qcyIsInJlc3BvbnNpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeHlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0M0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImRhdGF0YWJsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgRGF0YVRhYmxlcyAxLjEwLjE2XHJcbiAqIMKpMjAwOC0yMDE3IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBzdW1tYXJ5ICAgICBEYXRhVGFibGVzXHJcbiAqIEBkZXNjcmlwdGlvbiBQYWdpbmF0ZSwgc2VhcmNoIGFuZCBvcmRlciBIVE1MIHRhYmxlc1xyXG4gKiBAdmVyc2lvbiAgICAgMS4xMC4xNlxyXG4gKiBAZmlsZSAgICAgICAganF1ZXJ5LmRhdGFUYWJsZXMuanNcclxuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcclxuICogQGNvbnRhY3QgICAgIHd3dy5kYXRhdGFibGVzLm5ldFxyXG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMDgtMjAxNyBTcHJ5TWVkaWEgTHRkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XHJcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxyXG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxyXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcclxuICovXHJcblxyXG4vKmpzbGludCBldmlsOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xyXG4vKmdsb2JhbHMgJCxyZXF1aXJlLGpRdWVyeSxkZWZpbmUsX3NlbGVjdG9yX3J1bixfc2VsZWN0b3Jfb3B0cyxfc2VsZWN0b3JfZmlyc3QsX3NlbGVjdG9yX3Jvd19pbmRleGVzLF9leHQsX0FwaSxfYXBpX3JlZ2lzdGVyLF9hcGlfcmVnaXN0ZXJQbHVyYWwsX3JlX25ld19saW5lcyxfcmVfaHRtbCxfcmVfZm9ybWF0dGVkX251bWVyaWMsX3JlX2VzY2FwZV9yZWdleCxfZW1wdHksX2ludFZhbCxfbnVtVG9EZWNpbWFsLF9pc051bWJlcixfaXNIdG1sLF9odG1sTnVtZXJpYyxfcGx1Y2ssX3BsdWNrX29yZGVyLF9yYW5nZSxfc3RyaXBIdG1sLF91bmlxdWUsX2ZuQnVpbGRBamF4LF9mbkFqYXhVcGRhdGUsX2ZuQWpheFBhcmFtZXRlcnMsX2ZuQWpheFVwZGF0ZURyYXcsX2ZuQWpheERhdGFTcmMsX2ZuQWRkQ29sdW1uLF9mbkNvbHVtbk9wdGlvbnMsX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLF9mblZpc2libGVUb0NvbHVtbkluZGV4LF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLF9mblZpc2JsZUNvbHVtbnMsX2ZuR2V0Q29sdW1ucyxfZm5Db2x1bW5UeXBlcyxfZm5BcHBseUNvbHVtbkRlZnMsX2ZuSHVuZ2FyaWFuTWFwLF9mbkNhbWVsVG9IdW5nYXJpYW4sX2ZuTGFuZ3VhZ2VDb21wYXQsX2ZuQnJvd3NlckRldGVjdCxfZm5BZGREYXRhLF9mbkFkZFRyLF9mbk5vZGVUb0RhdGFJbmRleCxfZm5Ob2RlVG9Db2x1bW5JbmRleCxfZm5HZXRDZWxsRGF0YSxfZm5TZXRDZWxsRGF0YSxfZm5TcGxpdE9iak5vdGF0aW9uLF9mbkdldE9iamVjdERhdGFGbixfZm5TZXRPYmplY3REYXRhRm4sX2ZuR2V0RGF0YU1hc3RlcixfZm5DbGVhclRhYmxlLF9mbkRlbGV0ZUluZGV4LF9mbkludmFsaWRhdGUsX2ZuR2V0Um93RWxlbWVudHMsX2ZuQ3JlYXRlVHIsX2ZuQnVpbGRIZWFkLF9mbkRyYXdIZWFkLF9mbkRyYXcsX2ZuUmVEcmF3LF9mbkFkZE9wdGlvbnNIdG1sLF9mbkRldGVjdEhlYWRlcixfZm5HZXRVbmlxdWVUaHMsX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsX2ZuRmlsdGVyQ29tcGxldGUsX2ZuRmlsdGVyQ3VzdG9tLF9mbkZpbHRlckNvbHVtbixfZm5GaWx0ZXIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLF9mbkVzY2FwZVJlZ2V4LF9mbkZpbHRlckRhdGEsX2ZuRmVhdHVyZUh0bWxJbmZvLF9mblVwZGF0ZUluZm8sX2ZuSW5mb01hY3JvcyxfZm5Jbml0aWFsaXNlLF9mbkluaXRDb21wbGV0ZSxfZm5MZW5ndGhDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxMZW5ndGgsX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxfZm5QYWdlQ2hhbmdlLF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxfZm5Qcm9jZXNzaW5nRGlzcGxheSxfZm5GZWF0dXJlSHRtbFRhYmxlLF9mblNjcm9sbERyYXcsX2ZuQXBwbHlUb0NoaWxkcmVuLF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxfZm5UaHJvdHRsZSxfZm5Db252ZXJ0VG9XaWR0aCxfZm5HZXRXaWRlc3ROb2RlLF9mbkdldE1heExlblN0cmluZyxfZm5TdHJpbmdUb0NzcyxfZm5Tb3J0RmxhdHRlbixfZm5Tb3J0LF9mblNvcnRBcmlhLF9mblNvcnRMaXN0ZW5lcixfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsX2ZuU29ydGluZ0NsYXNzZXMsX2ZuU29ydERhdGEsX2ZuU2F2ZVN0YXRlLF9mbkxvYWRTdGF0ZSxfZm5TZXR0aW5nc0Zyb21Ob2RlLF9mbkxvZyxfZm5NYXAsX2ZuQmluZEFjdGlvbixfZm5DYWxsYmFja1JlZyxfZm5DYWxsYmFja0ZpcmUsX2ZuTGVuZ3RoT3ZlcmZsb3csX2ZuUmVuZGVyZXIsX2ZuRGF0YVNvdXJjZSxfZm5Sb3dBdHRyaWJ1dGVzKi9cclxuXHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRFxyXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmdW5jdGlvbiAoJCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCB3aW5kb3csIGRvY3VtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIENvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xyXG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbW1vbkpTIGVudmlyb25tZW50cyB3aXRob3V0IGEgd2luZG93IGdsb2JhbCBtdXN0IHBhc3MgYVxyXG4gICAgICAgICAgICAgICAgLy8gcm9vdC4gVGhpcyB3aWxsIGdpdmUgYW4gZXJyb3Igb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICByb290ID0gd2luZG93O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoISQpIHtcclxuICAgICAgICAgICAgICAgICQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IC8vIGpRdWVyeSdzIGZhY3RvcnkgY2hlY2tzIGZvciBhIGdsb2JhbCB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCdqcXVlcnknKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnanF1ZXJ5Jykocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQsIHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyXHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG59XHJcbiAgICAoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEYXRhVGFibGVzIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIGpRdWVyeSBKYXZhc2NyaXB0IGxpYnJhcnkuIEl0IGlzIGEgaGlnaGx5XHJcbiAgICAgICAgICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXHJcbiAgICAgICAgICogd2hpY2ggd2lsbCBhZGQgYWR2YW5jZWQgaW50ZXJhY3Rpb24gY29udHJvbHMgdG8gYW55IEhUTUwgdGFibGUuIEZvciBhXHJcbiAgICAgICAgICogZnVsbCBsaXN0IG9mIGZlYXR1cmVzIHBsZWFzZSByZWZlciB0b1xyXG4gICAgICAgICAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGVgIG9iamVjdCBpcyBub3QgYSBnbG9iYWwgdmFyaWFibGUgYnV0IGlzIGFsaWFzZWRcclxuICAgICAgICAgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxyXG4gICAgICAgICAqIGJlICBhY2Nlc3NlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAY2xhc3NcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IFtpbml0PXt9XSBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgRGF0YVRhYmxlcy4gT3B0aW9uc1xyXG4gICAgICAgICAqICAgIGFyZSBkZWZpbmVkIGJ5IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9XHJcbiAgICAgICAgICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cclxuICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xyXG4gICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxyXG4gICAgICAgICAqICAgIC8vIHBhZ2luYXRpb24gYW5kIHNvcnRpbmcuXHJcbiAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcclxuICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXHJcbiAgICAgICAgICogICAgICAgIFwic29ydFwiOiBmYWxzZVxyXG4gICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXHJcbiAgICAgICAgICAgICAqIHJldHVybiB0aGUgcmVzdWx0aW5nIGpRdWVyeSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBUUiBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXHJcbiAgICAgICAgICAgICAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBUUiBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cclxuICAgICAgICAgICAgICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3JcclxuICAgICAgICAgICAgICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXHJcbiAgICAgICAgICAgICAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcclxuICAgICAgICAgICAgICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cclxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBIaWdobGlnaHQgZXZlcnkgc2Vjb25kIHJvd1xyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIC8vIEZpbHRlciB0byByb3dzIHdpdGggJ1dlYmtpdCcgaW4gdGhlbSwgYWRkIGEgYmFja2dyb3VuZCBjb2xvdXIgYW5kIHRoZW5cclxuICAgICAgICAgICAgICogICAgICAvLyByZW1vdmUgdGhlIGZpbHRlciwgdGh1cyBoaWdobGlnaHRpbmcgdGhlICdXZWJraXQnIHJvd3Mgb25seS5cclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cicsIHtcInNlYXJjaFwiOiBcImFwcGxpZWRcIn0pLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoJycpO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLiQgPSBmdW5jdGlvbiAoc1NlbGVjdG9yLCBvT3B0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpLiQoc1NlbGVjdG9yLCBvT3B0cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbW9zdCBpZGVudGljYWwgdG8gJCBpbiBvcGVyYXRpb24sIGJ1dCBpbiB0aGlzIGNhc2UgcmV0dXJucyB0aGUgZGF0YSBmb3IgdGhlIG1hdGNoZWRcclxuICAgICAgICAgICAgICogcm93cyAtIGFzIHN1Y2gsIHRoZSBqUXVlcnkgc2VsZWN0b3IgdXNlZCBzaG91bGQgbWF0Y2ggVFIgcm93IG5vZGVzIG9yIFREL1RIIGNlbGwgbm9kZXNcclxuICAgICAgICAgICAgICogcmF0aGVyIHRoYW4gYW55IGRlc2NlbmRhbnRzLCBzbyB0aGUgZGF0YSBjYW4gYmUgb2J0YWluZWQgZm9yIHRoZSByb3cvY2VsbC4gSWYgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICogcm93cyBhcmUgZm91bmQsIHRoZSBkYXRhIHJldHVybmVkIGlzIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5L29iamVjdCB0aGF0IHdhcyB1c2VkIHRvXHJcbiAgICAgICAgICAgICAqIGNyZWF0ZSB0aGUgcm93IChvciBhIGdlbmVyYXRlZCBhcnJheSBpZiBmcm9tIGEgRE9NIHNvdXJjZSkuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG9mdGVuIHVzZWZ1bCBpbi1jb21iaW5hdGlvbiB3aXRoICQgd2hlcmUgYm90aCBmdW5jdGlvbnMgYXJlIGdpdmVuIHRoZVxyXG4gICAgICAgICAgICAgKiBzYW1lIHBhcmFtZXRlcnMgYW5kIHRoZSBhcnJheSBpbmRleGVzIHdpbGwgbWF0Y2ggaWRlbnRpY2FsbHkuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXHJcbiAgICAgICAgICAgICAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgZGF0YSBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxyXG4gICAgICAgICAgICAgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxyXG4gICAgICAgICAgICAgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2VcclxuICAgICAgICAgICAgICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxyXG4gICAgICAgICAgICAgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBEYXRhIGZvciB0aGUgbWF0Y2hlZCBlbGVtZW50cy4gSWYgYW55IGVsZW1lbnRzLCBhcyBhIHJlc3VsdCBvZiB0aGVcclxuICAgICAgICAgICAgICogICAgc2VsZWN0b3IsIHdlcmUgbm90IFRSLCBURCBvciBUSCBlbGVtZW50cyBpbiB0aGUgRGF0YVRhYmxlLCB0aGV5IHdpbGwgaGF2ZSBhIG51bGxcclxuICAgICAgICAgICAgICogICAgZW50cnkgaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBmaXJzdCByb3cgaW4gdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHI6Zmlyc3QnKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgdXNlZnVsIHdpdGggdGhlIGRhdGFcclxuICAgICAgICAgICAgICogICAgICBhbGVydCggXCJGaXJzdCBjZWxsIGlzOiBcIitkYXRhWzBdICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIC8vIEZpbHRlciB0byAnV2Via2l0JyBhbmQgZ2V0IGFsbCBkYXRhIGZvclxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgKiAgICAgIGFsZXJ0KCBkYXRhLmxlbmd0aCtcIiByb3dzIG1hdGNoZWQgdGhlIHNlYXJjaFwiICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuXyA9IGZ1bmN0aW9uIChzU2VsZWN0b3IsIG9PcHRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkodHJ1ZSkucm93cyhzU2VsZWN0b3IsIG9PcHRzKS5kYXRhKCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZSBhIERhdGFUYWJsZXMgQXBpIGluc3RhbmNlLCB3aXRoIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFibGVzIGZvclxyXG4gICAgICAgICAgICAgKiB0aGUgQXBpJ3MgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbdHJhZGl0aW9uYWw9ZmFsc2VdIFNldCB0aGUgQVBJIGluc3RhbmNlJ3MgY29udGV4dCB0byBiZVxyXG4gICAgICAgICAgICAgKiAgIG9ubHkgdGhlIHRhYmxlIHJlZmVycmVkIHRvIGJ5IHRoZSBgRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhgIG9wdGlvbiwgYXMgd2FzXHJcbiAgICAgICAgICAgICAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxyXG4gICAgICAgICAgICAgKiAgIG9yIGlmIGFsbCB0YWJsZXMgY2FwdHVyZWQgaW4gdGhlIGpRdWVyeSBvYmplY3Qgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0RhdGFUYWJsZXMuQXBpfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5hcGkgPSBmdW5jdGlvbiAodHJhZGl0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFkaXRpb25hbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mblNldHRpbmdzRnJvbU5vZGUodGhpc1tfZXh0LmlBcGlJbmRleF0pXHJcbiAgICAgICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXHJcbiAgICAgICAgICAgICAqIHRoYXQgdGhpcyBpcyBzdWl0YWJsZSBmb3IgY2xpZW50LXNpZGUgcHJvY2Vzc2luZyBvbmx5IC0gaWYgeW91IGFyZSB1c2luZ1xyXG4gICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIChpLmUuIFwiYlNlcnZlclNpZGVcIjogdHJ1ZSksIHRoZW4gdG8gYWRkIGRhdGEsIHlvdVxyXG4gICAgICAgICAgICAgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGJlIGFkZGVkIHRvIHRoZSB0YWJsZS4gVGhpcyBjYW4gYmU6XHJcbiAgICAgICAgICAgICAqICAgIDx1bD5cclxuICAgICAgICAgICAgICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgPGxpPjJEIGFycmF5IG9mIGFycmF5cyAtIGFkZCBtdWx0aXBsZSByb3dzIGluIGEgc2luZ2xlIGNhbGw8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgIDxsaT5vYmplY3QgLSBkYXRhIG9iamVjdCB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxyXG4gICAgICAgICAgICAgKiAgICA8L3VsPlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxyXG4gICAgICAgICAgICAgKiAgICA8aT5hb0RhdGE8L2k+ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9KSB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0b1xyXG4gICAgICAgICAgICAgKiAgICB0aGUgdGFibGUuXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gR2xvYmFsIHZhciBmb3IgY291bnRlclxyXG4gICAgICAgICAgICAgKiAgICB2YXIgZ2lDb3VudCA9IDI7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgZnVuY3Rpb24gZm5DbGlja0FkZFJvdygpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgZ2lDb3VudCtcIi4xXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjJcIixcclxuICAgICAgICAgICAgICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgZ2lDb3VudCtcIi40XCIgXVxyXG4gICAgICAgICAgICAgKiAgICAgICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgZ2lDb3VudCsrO1xyXG4gICAgICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuQWRkRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCByZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSAkLmlzQXJyYXkoZGF0YSkgJiYgKCQuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkpID9cclxuICAgICAgICAgICAgICAgICAgICBhcGkucm93cy5hZGQoZGF0YSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5yb3cuYWRkKGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByb3dzLmZsYXR0ZW4oKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcclxuICAgICAgICAgICAgICogY29udGFpbmVkIGluIHRoZSB0YWJsZSBhbmQgdGhlIHNpemVzIGFwcGxpZWQgdG8gdGhlIGNvbHVtbnMgKGluIHRoZSBET00sIENTUyBvclxyXG4gICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBzV2lkdGggcGFyYW1ldGVyKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSdzXHJcbiAgICAgICAgICAgICAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90LCB5b3Ugd2lsbCB0eXBpY2FsbHkgd2FudCB0b1xyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzU2Nyb2xsWVwiOiBcIjIwMHB4XCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgIG9UYWJsZS5mbkFkanVzdENvbHVtblNpemluZygpO1xyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbkFkanVzdENvbHVtblNpemluZyA9IGZ1bmN0aW9uIChiUmVkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkuY29sdW1ucy5hZGp1c3QoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IGFwaS5zZXR0aW5ncygpWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIG5vdCByZWRyYXdpbmcsIGJ1dCBzY3JvbGxpbmcsIHdlIHdhbnQgdG8gYXBwbHkgdGhlIG5ldyBjb2x1bW4gc2l6ZXMgYW55d2F5ICovXHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5DbGVhclRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5DbGVhclRhYmxlID0gZnVuY3Rpb24gKGJSZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBleGFjdCBvcHBvc2l0ZSBvZiAnb3BlbmluZycgYSByb3csIHRoaXMgZnVuY3Rpb24gd2lsbCBjbG9zZSBhbnkgcm93cyB3aGljaFxyXG4gICAgICAgICAgICAgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gJ2Nsb3NlJ1xyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCBvciAxIGlmIGZhaWxlZCAoY2FuJ3QgZmluZCB0aGUgcm93KVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcclxuICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5DbG9zZSA9IGZ1bmN0aW9uIChuVHIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLnJvdyhuVHIpLmNoaWxkLmhpZGUoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlIGEgcm93IGZvciB0aGUgdGFibGVcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxyXG4gICAgICAgICAgICAgKiAgICB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudCB0byBkZWxldGVcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gW2NhbGxCYWNrXSBDYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IFRoZSByb3cgdGhhdCB3YXMgZGVsZXRlZFxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRGVsZXRlUm93KCAwICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5EZWxldGVSb3cgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYWxsYmFjaywgcmVkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IGFwaS5yb3dzKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSByb3dzLnNldHRpbmdzKClbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dzWzBdWzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICByb3dzLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc2V0dGluZ3MsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXN0b3JlIHRoZSB0YWJsZSB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIGluIHRoZSBET00gYnkgcmVtb3ZpbmcgYWxsIG9mIERhdGFUYWJsZXNcclxuICAgICAgICAgICAgICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZT1mYWxzZV0gQ29tcGxldGVseSByZW1vdmUgdGhlIHRhYmxlIGZyb20gdGhlIERPTVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIC8vIFRoaXMgZXhhbXBsZSBpcyBmYWlybHkgcG9pbnRsZXNzIGluIHJlYWxpdHksIGJ1dCBzaG93cyBob3cgZm5EZXN0cm95IGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLmRlc3Ryb3kocmVtb3ZlKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVkcmF3IHRoZSB0YWJsZVxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbY29tcGxldGU9dHJ1ZV0gUmUtZmlsdGVyIGFuZCByZXNvcnQgKGlmIGVuYWJsZWQpIHRoZSB0YWJsZSBiZWZvcmUgdGhlIGRyYXcuXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gUmUtZHJhdyB0aGUgdGFibGUgLSB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyBpdCBoZXJlLCBidXQgaXQncyBhbiBleGFtcGxlIDotKVxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkRyYXcoKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbkRyYXcgPSBmdW5jdGlvbiAoY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGFuIGV4YWN0IG1hdGNoIHRvIHRoZSBvbGQgY2FsbCB0byBfZm5EcmF3IC0gaXQgdGFrZXNcclxuICAgICAgICAgICAgICAgIC8vIGludG8gYWNjb3VudCB0aGUgbmV3IGRhdGEsIGJ1dCBjYW4gaG9sZCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLmRyYXcoY29tcGxldGUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXIgdGhlIGlucHV0IGJhc2VkIG9uIGRhdGFcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fG51bGx9IFtpQ29sdW1uXSBDb2x1bW4gdG8gbGltaXQgZmlsdGVyaW5nIHRvXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVnZXg9ZmFsc2VdIFRyZWF0IGFzIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JTaG93R2xvYmFsPXRydWVdIFNob3cgdGhlIGlucHV0IGdsb2JhbCBmaWx0ZXIgaW4gaXQncyBpbnB1dCBib3goZXMpXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiQ2FzZUluc2Vuc2l0aXZlPXRydWVdIERvIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gU29tZXRpbWUgbGF0ZXIgLSBmaWx0ZXIuLi5cclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoICd0ZXN0IHN0cmluZycgKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbkZpbHRlciA9IGZ1bmN0aW9uIChzSW5wdXQsIGlDb2x1bW4sIGJSZWdleCwgYlNtYXJ0LCBiU2hvd0dsb2JhbCwgYkNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zZWFyY2goc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuY29sdW1uKGlDb2x1bW4pLnNlYXJjaChzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxyXG4gICAgICAgICAgICAgKiBwcm92aWRlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXHJcbiAgICAgICAgICAgICAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXHJcbiAgICAgICAgICAgICAqICAgIFREL1RIIGNlbGwgbm9kZSB0aGVuIGlDb2wgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYW5kIHRoZSBkYXRhIGZvciB0aGVcclxuICAgICAgICAgICAgICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxyXG4gICAgICAgICAgICAgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IFtjb2xdIE9wdGlvbmFsIGNvbHVtbiBpbmRleCB0aGF0IHlvdSB3YW50IHRoZSBkYXRhIG9mLlxyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xyXG4gICAgICAgICAgICAgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xyXG4gICAgICAgICAgICAgKiAgICBkZWZpbmVkLCBvbmx5IGRhdGEgZm9yIHRoZSBkZXNpZ25hdGVkIGNlbGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gUm93IGRhdGFcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuJCgndHInKS5jbGljayggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgIHZhciBzRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIHRoaXMgKTtcclxuICAgICAgICAgICAgICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24gKHNyYywgY29sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNyYyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzcmMubm9kZU5hbWUgPyBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sICE9PSB1bmRlZmluZWQgfHwgdHlwZSA9PSAndGQnIHx8IHR5cGUgPT0gJ3RoJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jZWxsKHNyYywgY29sKS5kYXRhKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93KHNyYykuZGF0YSgpIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5kYXRhKCkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIFRSIG5vZGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlJ3MgYm9keS4gTm90ZSB0aGF0IHlvdSB3aWxsXHJcbiAgICAgICAgICAgICAqIHR5cGljYWxseSB3YW50IHRvIHVzZSB0aGUgJyQnIEFQSSBtZXRob2QgaW4gcHJlZmVyZW5jZSB0byB0aGlzIGFzIGl0IGlzIG1vcmVcclxuICAgICAgICAgICAgICogZmxleGlibGUuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2lSb3ddIE9wdGlvbmFsIHJvdyBpbmRleCBmb3IgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnRcclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheXxub2RlfSBJZiBpUm93IGlzIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgVFIgZWxlbWVudHNcclxuICAgICAgICAgICAgICogICAgaW4gdGhlIHRhYmxlJ3MgYm9keSwgb3IgaVJvdyBpcyBkZWZpbmVkLCBqdXN0IHRoZSBUUiBlbGVtZW50IHJlcXVlc3RlZC5cclxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBHZXQgdGhlIG5vZGVzIGZyb20gdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG5Ob2RlcyA9IG9UYWJsZS5mbkdldE5vZGVzKCApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuR2V0Tm9kZXMgPSBmdW5jdGlvbiAoaVJvdykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBpUm93ICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5yb3coaVJvdykubm9kZSgpIDpcclxuICAgICAgICAgICAgICAgICAgICBhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBhcnJheSBpbmRleGVzIG9mIGEgcGFydGljdWxhciBjZWxsIGZyb20gaXQncyBET00gZWxlbWVudFxyXG4gICAgICAgICAgICAgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBub2RlIHRoaXMgY2FuIGVpdGhlciBiZSBhIFRSLCBURCBvciBUSCBpbiB0aGUgdGFibGUncyBib2R5XHJcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBJZiBuTm9kZSBpcyBnaXZlbiBhcyBhIFRSLCB0aGVuIGEgc2luZ2xlIGluZGV4IGlzIHJldHVybmVkLCBvclxyXG4gICAgICAgICAgICAgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXHJcbiAgICAgICAgICAgICAqICAgIGNvbHVtbiBpbmRleCAoYWxsKV0gaXMgZ2l2ZW4uXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdGQnKS5jbGljayggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRhIGZyb20gdGhlIG5vZGVcclxuICAgICAgICAgICAgICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAgIC8vIEdldCB0aGUgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcclxuICAgICAgICAgICAgICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBhcnJheSBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcclxuICAgICAgICAgICAgICogICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJ2NsaWNrZWQnO1xyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBJbml0IERhdGFUYWJsZXNcclxuICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSAnVFInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5yb3cobm9kZSkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09ICdURCcgfHwgbm9kZU5hbWUgPT0gJ1RIJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gYXBpLmNlbGwobm9kZSkuaW5kZXgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29sdW1uVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2x1bW5cclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrIHRvIHNlZSBpZiBhIHJvdyBpcyAnb3Blbicgb3Igbm90LlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uIChuVHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaSh0cnVlKS5yb3coblRyKS5jaGlsZC5pc1Nob3duKCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XHJcbiAgICAgICAgICAgICAqIG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UsIHdpdGggdGhlIEhUTUwgY29udGVudHMgdGhhdCBpcyBwYXNzZWQgaW50byB0aGVcclxuICAgICAgICAgICAgICogZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBhc2sgZm9yIGNvbmZpcm1hdGlvbiB0aGF0IGFcclxuICAgICAgICAgICAgICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5UciBUaGUgdGFibGUgcm93IHRvICdvcGVuJ1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IG1IdG1sIFRoZSBIVE1MIHRvIHB1dCBpbnRvIHRoZSByb3dcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBUaGUgcm93IG9wZW5lZC4gTm90ZSB0aGF0IGlmIHRoZSB0YWJsZSByb3cgcGFzc2VkIGluIGFzIHRoZVxyXG4gICAgICAgICAgICAgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIGlzIG5vdCBmb3VuZCBpbiB0aGUgdGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgc2lsZW50bHlcclxuICAgICAgICAgICAgICogICAgcmV0dXJuLlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcclxuICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5PcGVuID0gZnVuY3Rpb24gKG5UciwgbUh0bWwsIHNDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJvdyhuVHIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNoaWxkKG1IdG1sLCBzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNob3coKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZCgpWzBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGFuZ2UgdGhlIHBhZ2luYXRpb24gLSBwcm92aWRlcyB0aGUgaW50ZXJuYWwgbG9naWMgZm9yIHBhZ2luYXRpb24gaW4gYSBzaW1wbGUgQVBJXHJcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBoYXZlIGEgRGF0YVRhYmxlcyB0YWJsZSBnbyB0byB0aGUgbmV4dCxcclxuICAgICAgICAgICAgICogcHJldmlvdXMsIGZpcnN0IG9yIGxhc3QgcGFnZXMuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IG1BY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIiwgXCJuZXh0XCIgb3IgXCJsYXN0XCJcclxuICAgICAgICAgICAgICogICAgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlciksIG5vdGUgdGhhdCBwYWdlIDAgaXMgdGhlIGZpcnN0IHBhZ2UuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuUGFnZUNoYW5nZSggJ25leHQnICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5QYWdlQ2hhbmdlID0gZnVuY3Rpb24gKG1BY3Rpb24sIGJSZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKS5wYWdlKG1BY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2hvdyBhIHBhcnRpY3VsYXIgY29sdW1uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaUNvbCBUaGUgY29sdW1uIHdob3NlIGRpc3BsYXkgc2hvdWxkIGJlIGNoYW5nZWRcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlNob3cgU2hvdyAodHJ1ZSkgb3IgaGlkZSAoZmFsc2UpIHRoZSBjb2x1bW5cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3RcclxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBIaWRlIHRoZSBzZWNvbmQgY29sdW1uIGFmdGVyIGluaXRpYWxpc2F0aW9uXHJcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuU2V0Q29sdW1uVmlzKCAxLCBmYWxzZSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuU2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKGlDb2wsIGJTaG93LCBiUmVkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkuY29sdW1uKGlDb2wpLnZpc2libGUoYlNob3cpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5jb2x1bW5zLmFkanVzdCgpLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBzZXR0aW5ncyBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBTZWVcclxuICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvU2V0dGluZ3MgPSBvVGFibGUuZm5TZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgIC8vIFNob3cgYW4gZXhhbXBsZSBwYXJhbWV0ZXIgZnJvbSB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgICogICAgICBhbGVydCggb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZm5TZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5TZXR0aW5nc0Zyb21Ob2RlKHRoaXNbX2V4dC5pQXBpSW5kZXhdKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU29ydCB0aGUgdGFibGUgYnkgYSBwYXJ0aWN1bGFyIGNvbHVtblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXHJcbiAgICAgICAgICAgICAqICAgICdkaXNwbGF5IGluZGV4JyBpZiB5b3UgaGF2ZSBoaWRkZW4gZGF0YSBlbnRyaWVzXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblNvcnQoIFsgWzAsJ2FzYyddLCBbMSwnYXNjJ10gXSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuU29ydCA9IGZ1bmN0aW9uIChhYVNvcnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLm9yZGVyKGFhU29ydCkuZHJhdygpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5Ob2RlIHRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc29ydCBsaXN0ZW5lciB0b1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2ZuQ2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cclxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAvLyBTb3J0IG9uIGNvbHVtbiAxLCB3aGVuICdzb3J0ZXInIGlzIGNsaWNrZWQgb25cclxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5Tb3J0TGlzdGVuZXIoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzb3J0ZXInKSwgMSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZuU29ydExpc3RlbmVyID0gZnVuY3Rpb24gKG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwaSh0cnVlKS5vcmRlci5saXN0ZW5lcihuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVwZGF0ZSBhIHRhYmxlIGNlbGwgb3Igcm93IC0gdGhpcyBtZXRob2Qgd2lsbCBhY2NlcHQgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIHRvXHJcbiAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgY2VsbCB3aXRoLCBhbiBhcnJheSBvZiB2YWx1ZXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBjb2x1bW4gb3JcclxuICAgICAgICAgICAgICogYW4gb2JqZWN0IGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UuIFRoZSBmdW5jdGlvbiBpc1xyXG4gICAgICAgICAgICAgKiBzZWxmLXJlZmVyZW5jaW5nIGluIG9yZGVyIHRvIG1ha2UgdGhlIG11bHRpIGNvbHVtbiB1cGRhdGVzIGVhc2llci5cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ30gbURhdGEgRGF0YSB0byB1cGRhdGUgdGhlIGNlbGwvcm93IHdpdGhcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZXxpbnR9IG1Sb3cgVFIgZWxlbWVudCB5b3Ugd2FudCB0byB1cGRhdGUgb3IgdGhlIGFvRGF0YSBpbmRleFxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IFtpQ29sdW1uXSBUaGUgY29sdW1uIHRvIHVwZGF0ZSwgZ2l2ZSBhcyBudWxsIG9yIHVuZGVmaW5lZCB0b1xyXG4gICAgICAgICAgICAgKiAgICB1cGRhdGUgYSB3aG9sZSByb3cuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiQWN0aW9uPXRydWVdIFBlcmZvcm0gcHJlLWRyYXcgYWN0aW9ucyBvciBub3RcclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2VzcywgMSBvbiBlcnJvclxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggJ0V4YW1wbGUgdXBkYXRlJywgMCwgMCApOyAvLyBTaW5nbGUgY2VsbFxyXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgJCgndGJvZHkgdHInKVswXSApOyAvLyBSb3dcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mblVwZGF0ZSA9IGZ1bmN0aW9uIChtRGF0YSwgbVJvdywgaUNvbHVtbiwgYlJlZHJhdywgYkFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpQ29sdW1uID09PSB1bmRlZmluZWQgfHwgaUNvbHVtbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5yb3cobVJvdykuZGF0YShtRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuY2VsbChtUm93LCBpQ29sdW1uKS5kYXRhKG1EYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYkFjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGJBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuY29sdW1ucy5hZGp1c3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nIHVzZWQsIGluIG9yZGVyXHJcbiAgICAgICAgICAgICAqIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNWZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuIE5vdGUgdGhhdCB0aGVcclxuICAgICAgICAgICAgICogICAgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWRcclxuICAgICAgICAgICAgICogICAgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Qgc3VpdGFibGVcclxuICAgICAgICAgICAgICogIEBtZXRob2RcclxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuICAgICAgICAgICAgICogICAgICBhbGVydCggb1RhYmxlLmZuVmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mblZlcnNpb25DaGVjayA9IF9leHQuZm5WZXJzaW9uQ2hlY2s7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIF90aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVtcHR5SW5pdCA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVtcHR5SW5pdCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZCB3aXRoIG9sZCBzdHlsZSBwbHVnLWluIEFQSSBtZXRob2RzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGZuIGluIERhdGFUYWJsZS5leHQuaW50ZXJuYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbZm5dID0gX2ZuRXh0ZXJuQXBpRnVuYyhmbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQgY2FuIGJlIGJhc2hlZCBhcm91bmRcclxuICAgICAgICAgICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIF9mbkV4dGVuZChvLCBvcHRpb25zLCB0cnVlKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucztcclxuXHJcbiAgICAgICAgICAgICAgICAvKmdsb2JhbCBvSW5pdCxfdGhhdCxlbXB0eUluaXQqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJJbml0SGFuZGVkT2ZmID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKiBTYW5pdHkgY2hlY2sgKi9cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkxvZyhudWxsLCAwLCAnTm9uLXRhYmxlIG5vZGUgaW5pdGlhbGlzYXRpb24gKCcgKyB0aGlzLm5vZGVOYW1lICsgJyknLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xyXG4gICAgICAgICAgICAgICAgX2ZuQ29tcGF0T3B0cyhkZWZhdWx0cyk7XHJcbiAgICAgICAgICAgICAgICBfZm5Db21wYXRDb2xzKGRlZmF1bHRzLmNvbHVtbik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cclxuICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oZGVmYXVsdHMsIGRlZmF1bHRzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFNldHRpbmcgdXAgdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdCAqL1xyXG4gICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cywgJC5leHRlbmQob0luaXQsICR0aGlzLmRhdGEoKSkpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsbFNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFsbFNldHRpbmdzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gYWxsU2V0dGluZ3NbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEJhc2UgY2hlY2sgb24gdGFibGUgbm9kZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm5UYWJsZSA9PSB0aGlzIHx8IHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcyB8fCAocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiRGVzdHJveSA9IG9Jbml0LmJEZXN0cm95ICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iRGVzdHJveSA6IGRlZmF1bHRzLmJEZXN0cm95O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5SW5pdCB8fCBiUmV0cmlldmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLm9JbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiRGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vSW5zdGFuY2UuZm5EZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2VkLCBidXQgdGhlIHRhYmxlIG5vZGVzIGRvbid0IG1hdGNoIChmcm9tIGJlZm9yZSkgdGhlbiB3ZSBkZXN0cm95IHRoZSBvbGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW5jZSBieSBzaW1wbHkgZGVsZXRpbmcgaXQuIFRoaXMgaXMgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgdGFibGUgaGFzIGJlZW5cclxuICAgICAgICAgICAgICAgICAgICAgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zVGFibGVJZCA9PSB0aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNldHRpbmdzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cclxuICAgICAgICAgICAgICAgIGlmIChzSWQgPT09IG51bGwgfHwgc0lkID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc0lkID0gXCJEYXRhVGFibGVzX1RhYmxlX1wiICsgKERhdGFUYWJsZS5leHQuX3VuaXF1ZSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gc0lkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGlzIHRhYmxlIGFuZCBzZXQgc29tZSBvZiB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzICovXHJcbiAgICAgICAgICAgICAgICB2YXIgb1NldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic0luc3RhbmNlXCI6IHNJZCxcclxuICAgICAgICAgICAgICAgICAgICBcInNUYWJsZUlkXCI6IHNJZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRhYmxlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5vQXBpID0gX3RoYXQuaW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub0luaXQgPSBvSW5pdDtcclxuXHJcbiAgICAgICAgICAgICAgICBhbGxTZXR0aW5ncy5wdXNoKG9TZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhZGQgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgc2V0dGluZ3MgYXJyYXksIHNvIHdlIGNhbiBzZWxmIHJlZmVyZW5jZSB0aGUgdGFibGUgaW5zdGFuY2UgaWYgbW9yZSB0aGFuIG9uZVxyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLm9JbnN0YW5jZSA9IChfdGhhdC5sZW5ndGggPT09IDEpID8gX3RoYXQgOiAkdGhpcy5kYXRhVGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcclxuICAgICAgICAgICAgICAgIF9mbkNvbXBhdE9wdHMob0luaXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5vTGFuZ3VhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZm5MYW5ndWFnZUNvbXBhdChvSW5pdC5vTGFuZ3VhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxyXG4gICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFMZW5ndGhNZW51ICYmICFvSW5pdC5pRGlzcGxheUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gJC5pc0FycmF5KG9Jbml0LmFMZW5ndGhNZW51WzBdKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9Jbml0LmFMZW5ndGhNZW51WzBdWzBdIDogb0luaXQuYUxlbmd0aE1lbnVbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRlZmF1bHRzIGFuZCBpbml0IG9wdGlvbnMgdG8gbWFrZSBhIHNpbmdsZSBpbml0IG9iamVjdCB3aWxsIGFsbFxyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBkZWZpbmVkIGZyb20gZGVmYXVsdHMgYW5kIGluc3RhbmNlIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICBvSW5pdCA9IF9mbkV4dGVuZCgkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMpLCBvSW5pdCk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBvbnRvIHRoZSBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICAgIF9mbk1hcChvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYlBhZ2luYXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiTGVuZ3RoQ2hhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiRmlsdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiU29ydFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYkluZm9cIixcclxuICAgICAgICAgICAgICAgICAgICBcImJQcm9jZXNzaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiU29ydENsYXNzZXNcIixcclxuICAgICAgICAgICAgICAgICAgICBcImJTZXJ2ZXJTaWRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiRGVmZXJSZW5kZXJcIlxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLCBvSW5pdCwgW1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYXNTdHJpcGVDbGFzc2VzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhamF4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIixcclxuICAgICAgICAgICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzU2VydmVyTWV0aG9kXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhYVNvcnRpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhTGVuZ3RoTWVudVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic1BhZ2luYXRpb25UeXBlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzQWpheFNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic0FqYXhEYXRhUHJvcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaVN0YXRlRHVyYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICBcInNEb21cIixcclxuICAgICAgICAgICAgICAgICAgICBcImJTb3J0Q2VsbHNUb3BcIixcclxuICAgICAgICAgICAgICAgICAgICBcImlUYWJJbmRleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicmVuZGVyZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBcInNlYXJjaERlbGF5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyb3dJZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFtcImlDb29raWVEdXJhdGlvblwiLCBcImlTdGF0ZUR1cmF0aW9uXCJdLCAvLyBiYWNrd2FyZHMgY29tcGF0XHJcbiAgICAgICAgICAgICAgICAgICAgW1wib1NlYXJjaFwiLCBcIm9QcmV2aW91c1NlYXJjaFwiXSxcclxuICAgICAgICAgICAgICAgICAgICBbXCJhb1NlYXJjaENvbHNcIiwgXCJhb1ByZVNlYXJjaENvbHNcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wiaURpc3BsYXlMZW5ndGhcIiwgXCJfaURpc3BsYXlMZW5ndGhcIl1cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgX2ZuTWFwKG9TZXR0aW5ncy5vU2Nyb2xsLCBvSW5pdCwgW1xyXG4gICAgICAgICAgICAgICAgICAgIFtcInNTY3JvbGxYXCIsIFwic1hcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wic1Njcm9sbFhJbm5lclwiLCBcInNYSW5uZXJcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wic1Njcm9sbFlcIiwgXCJzWVwiXSxcclxuICAgICAgICAgICAgICAgICAgICBbXCJiU2Nyb2xsQ29sbGFwc2VcIiwgXCJiQ29sbGFwc2VcIl1cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgX2ZuTWFwKG9TZXR0aW5ncy5vTGFuZ3VhZ2UsIG9Jbml0LCBcImZuSW5mb0NhbGxiYWNrXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIG9Jbml0LmZuRHJhd0NhbGxiYWNrLCAndXNlcicpO1xyXG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TZXJ2ZXJQYXJhbXMnLCBvSW5pdC5mblNlcnZlclBhcmFtcywgJ3VzZXInKTtcclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICd1c2VyJyk7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsIG9Jbml0LmZuU3RhdGVMb2FkUGFyYW1zLCAndXNlcicpO1xyXG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsIG9Jbml0LmZuU3RhdGVMb2FkZWQsICd1c2VyJyk7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgb0luaXQuZm5Sb3dDYWxsYmFjaywgJ3VzZXInKTtcclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgb0luaXQuZm5DcmVhdGVkUm93LCAndXNlcicpO1xyXG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICd1c2VyJyk7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgJ3VzZXInKTtcclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgb0luaXQuZm5Jbml0Q29tcGxldGUsICd1c2VyJyk7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAndXNlcicpO1xyXG5cclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5yb3dJZEZuID0gX2ZuR2V0T2JqZWN0RGF0YUZuKG9Jbml0LnJvd0lkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXHJcbiAgICAgICAgICAgICAgICBfZm5Ccm93c2VyRGV0ZWN0KG9TZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xyXG5cclxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKG9DbGFzc2VzLnNUYWJsZSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXHJcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5pRGVmZXJMb2FkaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSAkLmlzQXJyYXkob0luaXQuaURlZmVyTG9hZGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcclxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzFdIDogb0luaXQuaURlZmVyTG9hZGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKiBMYW5ndWFnZSBkZWZpbml0aW9ucyAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIG9MYW5ndWFnZSA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XHJcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9MYW5ndWFnZS5zVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogR2V0IHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyBmcm9tIGEgZmlsZSAtIGJlY2F1c2UgdGhpcyBBamF4IGNhbGwgbWFrZXMgdGhlIGxhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogZ2V0IGFzeW5jIHRvIHRoZSByZW1haW5kZXIgb2YgdGhpcyBmdW5jdGlvbiB3ZSB1c2UgYkluaXRIYW5kZWRPZmYgdG8gaW5kaWNhdGUgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIF9mbkluaXRpYWxpc2Ugd2lsbCBiZSBmaXJlZCBieSB0aGUgcmV0dXJuZWQgQWpheCBoYW5kbGVyLCByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IG9MYW5ndWFnZS5zVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoanNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQoanNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvTGFuZ3VhZ2UsIGpzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYkluaXRIYW5kZWRPZmYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBTdHJpcGVzXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5hc1N0cmlwZUNsYXNzZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvQ2xhc3Nlcy5zU3RyaXBlT2RkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvQ2xhc3Nlcy5zU3RyaXBlRXZlblxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogUmVtb3ZlIHJvdyBzdHJpcGUgY2xhc3NlcyBpZiB0aGV5IGFyZSBhbHJlYWR5IG9uIHRoZSB0YWJsZSByb3cgKi9cclxuICAgICAgICAgICAgICAgIHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgIHZhciByb3dPbmUgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKS5maW5kKCd0cicpLmVxKDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheSh0cnVlLCAkLm1hcChzdHJpcGVDbGFzc2VzLCBmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcclxuICAgICAgICAgICAgICAgIH0pKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKCd0Ym9keSB0cicsIHRoaXMpLnJlbW92ZUNsYXNzKHN0cmlwZUNsYXNzZXMuam9pbignICcpKTtcclxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcyA9IHN0cmlwZUNsYXNzZXMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogQ29sdW1uc1xyXG4gICAgICAgICAgICAgICAgICogU2VlIGlmIHdlIHNob3VsZCBsb2FkIGNvbHVtbnMgYXV0b21hdGljYWxseSBvciB1c2UgZGVmaW5lZCBvbmVzXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBhblRocyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFvQ29sdW1uc0luaXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgblRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChuVGhlYWQubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyKG9TZXR0aW5ncy5hb0hlYWRlciwgblRoZWFkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBhblRocyA9IF9mbkdldFVuaXF1ZVRocyhvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIElmIG5vdCBnaXZlbiBhIGNvbHVtbiBhcnJheSwgZ2VuZXJhdGUgb25lIHdpdGggbnVsbHMgKi9cclxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5hb0NvbHVtbnMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBhb0NvbHVtbnNJbml0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFuVGhzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhb0NvbHVtbnNJbml0LnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKiBBZGQgdGhlIGNvbHVtbnMgKi9cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0NvbHVtbnNJbml0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkFkZENvbHVtbihvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKiBBcHBseSB0aGUgY29sdW1uIGRlZmluaXRpb25zICovXHJcbiAgICAgICAgICAgICAgICBfZm5BcHBseUNvbHVtbkRlZnMob1NldHRpbmdzLCBvSW5pdC5hb0NvbHVtbkRlZnMsIGFvQ29sdW1uc0luaXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsIG9EZWYpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxyXG4gICAgICAgICAgICAgICAgICogYXR0cmlidXRlcyBhcmUgZm91bmRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvd09uZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uIChjZWxsLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkKHJvd09uZVswXSkuY2hpbGRyZW4oJ3RoLCB0ZCcpLmVhY2goZnVuY3Rpb24gKGksIGNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sLm1EYXRhID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IGEoY2VsbCwgJ3NvcnQnKSB8fCBhKGNlbGwsICdvcmRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGEoY2VsbCwgJ2ZpbHRlcicpIHx8IGEoY2VsbCwgJ3NlYXJjaCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ICE9PSBudWxsIHx8IGZpbHRlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5tRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXzogaSArICcuZGlzcGxheScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQgIT09IG51bGwgPyBpICsgJy5AZGF0YS0nICsgc29ydCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ydCAhPT0gbnVsbCA/IGkgKyAnLkBkYXRhLScgKyBzb3J0IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlciAhPT0gbnVsbCA/IGkgKyAnLkBkYXRhLScgKyBmaWx0ZXIgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5PcHRpb25zKG9TZXR0aW5ncywgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZEluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgKiBTb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRvZG8gRm9yIG1vZHVsYXJpc2F0aW9uICgxLjExKSB0aGlzIG5lZWRzIHRvIGRvIGludG8gYSBzb3J0IHN0YXJ0IHVwIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWFTb3J0aW5nIGlzIG5vdCBkZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaW5kaWNhdG9yIGluIGFzU29ydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhhdCBoYXMgYmVlbiBhbHRlcmVkLCBzbyB0aGUgZGVmYXVsdCBzb3J0IHJlZmxlY3RzIHRoYXQgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0aW5nID0gb1NldHRpbmdzLmFhU29ydGluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IHNvcnRpbmcubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXS5hc1NvcnRpbmdbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIERvIGEgZmlyc3QgcGFzcyBvbiB0aGUgc29ydGluZyBjbGFzc2VzIChhbGxvd3MgYW55IHNpemUgY2hhbmdlcyB0byBiZSB0YWtlbiBpbnRvXHJcbiAgICAgICAgICAgICAgICAgICAgICogYWNjb3VudCwgYW5kIGFsc28gd2lsbCBhcHBseSBzb3J0aW5nIGRpc2FibGVkIGNsYXNzZXMgaWYgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0aW5nQ2xhc3NlcyhvU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmJTb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbihvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRDb2x1bW5zID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChhU29ydCwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRDb2x1bW5zW3ZhbC5zcmNdID0gdmFsLmRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ29yZGVyJywgW29TZXR0aW5ncywgYVNvcnQsIHNvcnRlZENvbHVtbnNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXJpYShvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmJTb3J0ZWQgfHwgX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRpbmdDbGFzc2VzKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCAnc2MnKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICogRmluYWwgaW5pdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXB0aW9ucyA9ICR0aGlzLmNoaWxkcmVuKCdjYXB0aW9uJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhcHRpb25TaWRlID0gJCh0aGlzKS5jc3MoJ2NhcHRpb24tc2lkZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlYWQgPSAkdGhpcy5jaGlsZHJlbigndGhlYWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhlYWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbygkdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRib2R5ID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRib2R5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0Ym9keSA9ICQoJzx0Ym9keS8+JykuYXBwZW5kVG8oJHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0Zm9vdCA9ICR0aGlzLmNoaWxkcmVuKCd0Zm9vdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgJiYgY2FwdGlvbnMubGVuZ3RoID4gMCAmJiAob1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhIHNjcm9sbGluZyB0YWJsZSwgYW5kIG5vIGZvb3RlciBoYXMgYmVlbiBnaXZlbiwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGZvb3QgPSAkKCc8dGZvb3QvPicpLmFwcGVuZFRvKCR0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Mob0NsYXNzZXMuc05vRm9vdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGZvb3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihvU2V0dGluZ3MuYW9Gb290ZXIsIG9TZXR0aW5ncy5uVEZvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFhRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb0luaXQuYWFEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhKG9TZXR0aW5ncywgb0luaXQuYWFEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyB8fCBfZm5EYXRhU291cmNlKG9TZXR0aW5ncykgPT0gJ2RvbScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhYiB0aGUgZGF0YSBmcm9tIHRoZSBwYWdlIC0gb25seSBkbyB0aGlzIHdoZW4gZGVmZXJyZWQgbG9hZGluZyBvciBubyBBamF4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZSBzaW5jZSB0aGVyZSBpcyBubyBwb2ludCBpbiByZWFkaW5nIHRoZSBET00gZGF0YSBpZiB3ZSBhcmUgdGhlbiBnb2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0byByZXBsYWNlIGl0IHdpdGggQWpheCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGRUcihvU2V0dGluZ3MsICQob1NldHRpbmdzLm5UQm9keSkuY2hpbGRyZW4oJ3RyJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEluaXRpYWxpc2F0aW9uIGNvbXBsZXRlIC0gdGFibGUgY2FuIGJlIGRyYXduICovXHJcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJJbml0aWFsaXNlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIGlmIHdlIG5lZWQgdG8gaW5pdGlhbGlzZSB0aGUgdGFibGUgKGl0IG1pZ2h0IG5vdCBoYXZlIGJlZW4gaGFuZGVkIG9mZiB0byB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgKiBsYW5ndWFnZSBwcm9jZXNzb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJJbml0SGFuZGVkT2ZmID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5Jbml0aWFsaXNlKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBNdXN0IGJlIGRvbmUgYWZ0ZXIgZXZlcnl0aGluZyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3RhdGUgc2F2aW5nISAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKG9Jbml0LmJTdGF0ZVNhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5iU3RhdGVTYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnKTtcclxuICAgICAgICAgICAgICAgICAgICBfZm5Mb2FkU3RhdGUob1NldHRpbmdzLCBvSW5pdCwgbG9hZGVkSW5pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRJbml0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoYXQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyBmdW5jdGlvbnMgY2FuIGFjY2VzcyB0aGVtIGFuZCB0aGV5IGRvbid0IGxlYWsgaW50byBnbG9iYWwgc3BhY2UuXHJcbiAgICAgICAgICogQXQgdGhlIHNhbWUgdGltZSB0aGVzZSBmdW5jdGlvbnMgYXJlIG9mdGVuIHVzZWZ1bCBvdmVyIG11bHRpcGxlIGZpbGVzIGluIHRoZVxyXG4gICAgICAgICAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcclxuICAgICAgICAgKiBieSBEYXRhVGFibGVzIGFzIHByaXZhdGUgdmFyaWFibGVzIGhlcmUuIFRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm9cclxuICAgICAgICAgKiBjbGFzaGluZyBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdGhhdCB0aGV5IGNhbiBlYXNpbHkgcmVmZXJlbmNlZCBmb3IgcmV1c2UuXHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAvLyBEZWZpbmVkIGVsc2Ugd2hlcmVcclxuICAgICAgICAvLyAgX3NlbGVjdG9yX3J1blxyXG4gICAgICAgIC8vICBfc2VsZWN0b3Jfb3B0c1xyXG4gICAgICAgIC8vICBfc2VsZWN0b3JfZmlyc3RcclxuICAgICAgICAvLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXHJcblxyXG4gICAgICAgIHZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XHJcbiAgICAgICAgdmFyIF9BcGk7IC8vIERhdGFUYWJsZS5BcGlcclxuICAgICAgICB2YXIgX2FwaV9yZWdpc3RlcjsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclxyXG4gICAgICAgIHZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXHJcblxyXG4gICAgICAgIHZhciBfcmVfZGljID0ge307XHJcbiAgICAgICAgdmFyIF9yZV9uZXdfbGluZXMgPSAvW1xcclxcbl0vZztcclxuICAgICAgICB2YXIgX3JlX2h0bWwgPSAvPC4qPz4vZztcclxuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBub3Qgc3RyaWN0IElTTzg2MDEgLSBEYXRlLnBhcnNlKCkgaXMgcXVpdGUgbGF4LCBhbHRob3VnaFxyXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cclxuICAgICAgICB2YXIgX3JlX2RhdGUgPSAvXlxcZHsyLDR9W1xcLlxcL1xcLV1cXGR7MSwyfVtcXC5cXC9cXC1dXFxkezEsMn0oW1QgXXsxfVxcZHsxLDJ9WzpcXC5dXFxkezJ9KFtcXC46XVxcZHsyfSk/KT8kLztcclxuXHJcbiAgICAgICAgLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnNcclxuICAgICAgICB2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIFsnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLCAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCcsICckJywgJ14nLCAnLSddLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm9yZWlnbl9leGNoYW5nZV9tYXJrZXRcclxuICAgICAgICAvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxyXG4gICAgICAgIC8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cclxuICAgICAgICAvLyAtIFxcdTIwQkEgLSBUdXJraXNoIExpcmFcclxuICAgICAgICAvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcclxuICAgICAgICAvLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXHJcbiAgICAgICAgLy8gLSBmciAtIFN3aXNzIEZyYW5jXHJcbiAgICAgICAgLy8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXHJcbiAgICAgICAgLy8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxyXG4gICAgICAgIC8vICAgc3RhbmRhcmRzIGFzIHRob3VzYW5kcyBzZXBhcmF0b3JzLlxyXG4gICAgICAgIHZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWycsJMKj4oKswqUlXFx1MjAwOVxcdTIwMkZcXHUyMEJEXFx1MjBhOVxcdTIwQkFyZmtdL2dpO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9lbXB0eSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhZCB8fCBkID09PSB0cnVlIHx8IGQgPT09ICctJyA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9pbnRWYWwgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICB2YXIgaW50ZWdlciA9IHBhcnNlSW50KHMsIDEwKTtcclxuICAgICAgICAgICAgcmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBhIGZvcm1hdHRlZCBudW1iZXIgd2l0aCBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gYC5gIGFzIHRoZVxyXG4gICAgICAgIC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcclxuICAgICAgICB2YXIgX251bVRvRGVjaW1hbCA9IGZ1bmN0aW9uIChudW0sIGRlY2ltYWxQb2ludCkge1xyXG4gICAgICAgICAgICAvLyBDYWNoZSBjcmVhdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHNwZWVkIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9mdGVuXHJcbiAgICAgICAgICAgIGlmICghX3JlX2RpY1tkZWNpbWFsUG9pbnRdKSB7XHJcbiAgICAgICAgICAgICAgICBfcmVfZGljW2RlY2ltYWxQb2ludF0gPSBuZXcgUmVnRXhwKF9mbkVzY2FwZVJlZ2V4KGRlY2ltYWxQb2ludCksICdnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIGRlY2ltYWxQb2ludCAhPT0gJy4nID9cclxuICAgICAgICAgICAgICAgIG51bS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoX3JlX2RpY1tkZWNpbWFsUG9pbnRdLCAnLicpIDpcclxuICAgICAgICAgICAgICAgIG51bTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9pc051bWJlciA9IGZ1bmN0aW9uIChkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyVHlwZSA9IHR5cGVvZiBkID09PSAnc3RyaW5nJztcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcclxuICAgICAgICAgICAgLy8gZm9ybWF0dGVkIHN0cmluZyAodGhpcyBzdG9wcyB0aGUgc3RyaW5nIFwia1wiLCBvciBcImtyXCIsIGV0YyBiZWluZyBkZXRlY3RlZFxyXG4gICAgICAgICAgICAvLyBhcyBhIGZvcm1hdHRlZCBudW1iZXIgZm9yIGN1cnJlbmN5XHJcbiAgICAgICAgICAgIGlmIChfZW1wdHkoZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBvaW50ICYmIHN0clR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGQgPSBfbnVtVG9EZWNpbWFsKGQsIGRlY2ltYWxQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgJiYgc3RyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGQpKSAmJiBpc0Zpbml0ZShkKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLy8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcclxuICAgICAgICB2YXIgX2lzSHRtbCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZCkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICB2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChfZW1wdHkoZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaHRtbCA9IF9pc0h0bWwoZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAhaHRtbCA/XHJcbiAgICAgICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgICAgIF9pc051bWJlcihfc3RyaXBIdG1sKGQpLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRydWUgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfcGx1Y2sgPSBmdW5jdGlvbiAoYSwgcHJvcCwgcHJvcDIpIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGllbiA9IGEubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcclxuICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcclxuICAgICAgICAgICAgaWYgKHByb3AyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSAmJiBhW2ldW3Byb3BdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbaV1bcHJvcF1bcHJvcDJdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtpXVtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvLyBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgX3BsdWNrLCBidXQgcmF0aGVyIHRoYW4gbG9vcGluZyBvdmVyIGBhYCB3ZSB1c2UgYG9yZGVyYFxyXG4gICAgICAgIC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcclxuICAgICAgICB2YXIgX3BsdWNrX29yZGVyID0gZnVuY3Rpb24gKGEsIG9yZGVyLCBwcm9wLCBwcm9wMikge1xyXG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgaWVuID0gb3JkZXIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcclxuICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcclxuICAgICAgICAgICAgaWYgKHByb3AyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVtvcmRlcltpXV1bcHJvcF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtvcmRlcltpXV1bcHJvcF1bcHJvcDJdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtvcmRlcltpXV1bcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICB2YXIgX3JhbmdlID0gZnVuY3Rpb24gKGxlbiwgc3RhcnQpIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZW5kO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBsZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSkgeyAvLyBjYXJlZnVsIC0gd2lsbCByZW1vdmUgYWxsIGZhbHN5IHZhbHVlcyFcclxuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9zdHJpcEh0bWwgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5yZXBsYWNlKF9yZV9odG1sLCAnJyk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSBpZiBhbGwgdmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdW5pcXVlLiBUaGlzIG1lYW5zIHdlIGNhbiBzaG9ydFxyXG4gICAgICAgICAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxyXG4gICAgICAgICAqIHRvIGVhc2lseSBjaGVjayB0aGUgdmFsdWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFsbCB1bmlxdWUsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICAgICAqIEBpZ25vcmVcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgX2FyZUFsbFVuaXF1ZSA9IGZ1bmN0aW9uIChzcmMpIHtcclxuICAgICAgICAgICAgaWYgKHNyYy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNvcnRlZCA9IHNyYy5zbGljZSgpLnNvcnQoKTtcclxuICAgICAgICAgICAgdmFyIGxhc3QgPSBzb3J0ZWRbMF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgaWVuID0gc29ydGVkLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkW2ldID09PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3QgPSBzb3J0ZWRbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gc3JjIFNvdXJjZSBhcnJheVxyXG4gICAgICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcclxuICAgICAgICAgKiBAaWdub3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoc3JjKSB7XHJcbiAgICAgICAgICAgIGlmIChfYXJlQWxsVW5pcXVlKHNyYykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzcmMuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQSBmYXN0ZXIgdW5pcXVlIG1ldGhvZCBpcyB0byB1c2Ugb2JqZWN0IGtleXMgdG8gaWRlbnRpZnkgdXNlZCB2YWx1ZXMsXHJcbiAgICAgICAgICAgIC8vIGJ1dCB0aGlzIGRvZXNuJ3Qgd29yayB3aXRoIGFycmF5cyBvciBvYmplY3RzLCB3aGljaCB3ZSBtdXN0IGFsc29cclxuICAgICAgICAgICAgLy8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcclxuICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgb3V0ID0gW10sXHJcbiAgICAgICAgICAgICAgICB2YWwsXHJcbiAgICAgICAgICAgICAgICBpLCBpZW4gPSBzcmMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaiwgayA9IDA7XHJcblxyXG4gICAgICAgICAgICBhZ2FpbjogZm9yIChpID0gMDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBzcmNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGs7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbal0gPT09IHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhZ2FpbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBUaGlzIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgbWV0aG9kcyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbnRlcm5hbGx5IHRvXHJcbiAgICAgICAgICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXHJcbiAgICAgICAgICogVGhlc2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBieSBleHRlbnNpb24gYXV0aG9ycyB0byBzYXZlIHRoZSBkdXBsaWNhdGlvbiBvZlxyXG4gICAgICAgICAqIGNvZGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERhdGFUYWJsZS51dGlsID0ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZFxyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gV3JhcHBlZCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmbiwgZnJlcSkge1xyXG4gICAgICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5ID0gZnJlcSAhPT0gdW5kZWZpbmVkID8gZnJlcSA6IDIwMCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3cgPSArbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnJlcXVlbmN5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgc3RyaW5nIHRvIGVzY2FwZVxyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGVzY2FwZVJlZ2V4OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoX3JlX2VzY2FwZV9yZWdleCwgJ1xcXFwkMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYSBtYXBwaW5nIG9iamVjdCB0aGF0IGFsbG93cyBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gYmUgbG9va2VkIHVwXHJcbiAgICAgICAgICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcclxuICAgICAgICAgKiBwYXJhbWV0ZXIgY2FsbGVkIGBfaHVuZ2FyaWFuTWFwYCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkh1bmdhcmlhbk1hcChvKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgaHVuZ2FyaWFuID0gJ2EgYWEgYWkgYW8gYXMgYiBmbiBpIG0gbyBzICcsXHJcbiAgICAgICAgICAgICAgICBtYXRjaCxcclxuICAgICAgICAgICAgICAgIG5ld0tleSxcclxuICAgICAgICAgICAgICAgIG1hcCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKG8sIGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBodW5nYXJpYW4uaW5kZXhPZihtYXRjaFsxXSArICcgJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3S2V5ID0ga2V5LnJlcGxhY2UobWF0Y2hbMF0sIG1hdGNoWzJdLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcFtuZXdLZXldID0ga2V5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5IdW5nYXJpYW5NYXAob1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgby5faHVuZ2FyaWFuTWFwID0gbWFwO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcclxuICAgICAgICAgKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXHJcbiAgICAgICAgICogICAgbWFwcGVkLlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcclxuICAgICAgICAgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcclxuICAgICAgICAgKiAgICB3b24ndCBiZS5cclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbihzcmMsIHVzZXIsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3JjLl9odW5nYXJpYW5NYXApIHtcclxuICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcChzcmMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaHVuZ2FyaWFuS2V5O1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBba2V5XTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaHVuZ2FyaWFuS2V5ICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IHVzZXJbaHVuZ2FyaWFuS2V5XSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBjYW1lbENhc2Ugb3B0aW9ucyBvdmVyIHRvIHRoZSBodW5nYXJpYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyW2h1bmdhcmlhbktleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHVzZXJbaHVuZ2FyaWFuS2V5XSwgdXNlcltrZXldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oc3JjW2h1bmdhcmlhbktleV0sIHVzZXJbaHVuZ2FyaWFuS2V5XSwgZm9yY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcltodW5nYXJpYW5LZXldID0gdXNlcltrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSAtIHdoZW4gY2VydGFpbiBvcHRpb25zIGFyZSBnaXZlbiwgYW5kIG90aGVycyBhcmVuJ3QsIHdlXHJcbiAgICAgICAgICogbmVlZCB0byBkdXBsaWNhdGUgdGhlIHZhbHVlcyBvdmVyLCBpbiBvcmRlciB0byBwcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICogd2l0aCBvbGRlciBsYW5ndWFnZSBmaWxlcy5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5MYW5ndWFnZUNvbXBhdChsYW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2U7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvUmVjb3JkcyA9IGxhbmcuc1plcm9SZWNvcmRzO1xyXG5cclxuICAgICAgICAgICAgLyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSBpZiB0aGVyZSBpcyBubyBzRW1wdHlUYWJsZSBnaXZlbiwgdGhlbiB1c2UgdGhlIHNhbWUgYXNcclxuICAgICAgICAgICAgICogc1plcm9SZWNvcmRzIC0gYXNzdW1pbmcgdGhhdCBpcyBnaXZlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICghbGFuZy5zRW1wdHlUYWJsZSAmJiB6ZXJvUmVjb3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHMuc0VtcHR5VGFibGUgPT09IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIikge1xyXG4gICAgICAgICAgICAgICAgX2ZuTWFwKGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogTGlrZXdpc2Ugd2l0aCBsb2FkaW5nIHJlY29yZHMgKi9cclxuICAgICAgICAgICAgaWYgKCFsYW5nLnNMb2FkaW5nUmVjb3JkcyAmJiB6ZXJvUmVjb3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHMuc0xvYWRpbmdSZWNvcmRzID09PSBcIkxvYWRpbmcuLi5cIikge1xyXG4gICAgICAgICAgICAgICAgX2ZuTWFwKGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0xvYWRpbmdSZWNvcmRzJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9sZCBwYXJhbWV0ZXIgbmFtZSBvZiB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciBtYXBwZWQgb250byB0aGUgbmV3XHJcbiAgICAgICAgICAgIGlmIChsYW5nLnNJbmZvVGhvdXNhbmRzKSB7XHJcbiAgICAgICAgICAgICAgICBsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbCA9IGxhbmcuc0RlY2ltYWw7XHJcbiAgICAgICAgICAgIGlmIChkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICBfYWRkTnVtZXJpY1NvcnQoZGVjaW1hbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gT2JqZWN0IHRvIG1hcFxyXG4gICAgICAgICAqICBAcGFyYW0geyp9IGtuZXcgVGhlIG5ldyBwYXJhbWV0ZXIgbmFtZVxyXG4gICAgICAgICAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIF9mbkNvbXBhdE1hcCA9IGZ1bmN0aW9uIChvLCBrbmV3LCBvbGQpIHtcclxuICAgICAgICAgICAgaWYgKG9ba25ld10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb1tvbGRdID0gb1trbmV3XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgbWFpbiBEVCBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ld1xyXG4gICAgICAgICAqIG9wdGlvbnMgYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2VcclxuICAgICAgICAgKiBjaGFuZ2Ugb25seS5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMoaW5pdCkge1xyXG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyaW5nJywgJ2JTb3J0Jyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJNdWx0aScsICdiU29ydE11bHRpJyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJDbGFzc2VzJywgJ2JTb3J0Q2xhc3NlcycpO1xyXG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyQ2VsbHNUb3AnLCAnYlNvcnRDZWxsc1RvcCcpO1xyXG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyJywgJ2FhU29ydGluZycpO1xyXG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyRml4ZWQnLCAnYWFTb3J0aW5nRml4ZWQnKTtcclxuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdpbmcnLCAnYlBhZ2luYXRlJyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAncGFnaW5nVHlwZScsICdzUGFnaW5hdGlvblR5cGUnKTtcclxuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdlTGVuZ3RoJywgJ2lEaXNwbGF5TGVuZ3RoJyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnc2VhcmNoaW5nJywgJ2JGaWx0ZXInKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIGluaXQuc1Njcm9sbFggPSBpbml0LnNTY3JvbGxYID8gJzEwMCUnIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgaW5pdC5zY3JvbGxYID0gaW5pdC5zY3JvbGxYID8gJzEwMCUnIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbHVtbiBzZWFyY2ggb2JqZWN0cyBhcmUgaW4gYW4gYXJyYXksIHNvIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxyXG4gICAgICAgICAgICAvLyBlbGVtZW50IGJ5IGVsZW1lbnRcclxuICAgICAgICAgICAgdmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hDb2xzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gc2VhcmNoQ29scy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hDb2xzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xyXG4gICAgICAgICAqIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlIGNoYW5nZVxyXG4gICAgICAgICAqIG9ubHkuXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Db21wYXRDb2xzKGluaXQpIHtcclxuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlcmFibGUnLCAnYlNvcnRhYmxlJyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJEYXRhJywgJ2FEYXRhU29ydCcpO1xyXG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyk7XHJcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJEYXRhVHlwZScsICdzb3J0RGF0YVR5cGUnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG9yZGVyRGF0YSBjYW4gYmUgZ2l2ZW4gYXMgYW4gaW50ZWdlclxyXG4gICAgICAgICAgICB2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISQuaXNBcnJheShkYXRhU29ydCkpIHtcclxuICAgICAgICAgICAgICAgIGluaXQuYURhdGFTb3J0ID0gW2RhdGFTb3J0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gdGhpcyBldmVyeSB0aW1lIERhdGFUYWJsZXMgaXMgY29uc3RydWN0ZWQsIHRoZSB2YWx1ZXNcclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBhcmUgc3BlY2lmaWMgdG8gdGhlIGJyb3dzZXIgYW5kIE9TIGNvbmZpZ3VyYXRpb24gd2hpY2ggd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xyXG4gICAgICAgICAgICBpZiAoIURhdGFUYWJsZS5fX2Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBicm93c2VyID0ge307XHJcbiAgICAgICAgICAgICAgICBEYXRhVGFibGUuX19icm93c2VyID0gYnJvd3NlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgZmVhdHVyZSAvIHF1aXJrcyBkZXRlY3Rpb25cclxuICAgICAgICAgICAgICAgIHZhciBuID0gJCgnPGRpdi8+JylcclxuICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJCh3aW5kb3cpLnNjcm9sbExlZnQoKSAqIC0xLCAvLyBhbGxvdyBmb3Igc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGRpdi8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdzY3JvbGwnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2Lz4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvdXRlciA9IG4uY2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbm5lciA9IG91dGVyLmNoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTnVtYmVycyBiZWxvdywgaW4gb3JkZXIsIGFyZTpcclxuICAgICAgICAgICAgICAgIC8vIGlubmVyLm9mZnNldFdpZHRoLCBpbm5lci5jbGllbnRXaWR0aCwgb3V0ZXIub2Zmc2V0V2lkdGgsIG91dGVyLmNsaWVudFdpZHRoXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gSUU2IFhQOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMCAxMDAgMTAwICA4M1xyXG4gICAgICAgICAgICAgICAgLy8gSUU3IFZpc3RhOiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCAxMDAgMTAwICA4M1xyXG4gICAgICAgICAgICAgICAgLy8gSUUgOCsgV2luZG93czogICAgICAgICAgICAgICAgICAgICA4MyAgODMgMTAwICA4M1xyXG4gICAgICAgICAgICAgICAgLy8gRXZlcmdyZWVuIFdpbmRvd3M6ICAgICAgICAgICAgICAgICA4MyAgODMgMTAwICA4M1xyXG4gICAgICAgICAgICAgICAgLy8gRXZlcmdyZWVuIE1hYyB3aXRoIHNjcm9sbGJhcnM6ICAgICA4NSAgODUgMTAwICA4NVxyXG4gICAgICAgICAgICAgICAgLy8gRXZlcmdyZWVuIE1hYyB3aXRob3V0IHNjcm9sbGJhcnM6IDEwMCAxMDAgMTAwIDEwMFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBzY3JvbGxiYXIgd2lkdGhcclxuICAgICAgICAgICAgICAgIGJyb3dzZXIuYmFyV2lkdGggPSBvdXRlclswXS5vZmZzZXRXaWR0aCAtIG91dGVyWzBdLmNsaWVudFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElFNi83IHdpbGwgb3ZlcnNpemUgYSB3aWR0aCAxMDAlIGVsZW1lbnQgaW5zaWRlIGEgc2Nyb2xsaW5nIGVsZW1lbnQsIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLCB3aGlsZSBvdGhlciBicm93c2VycyBlbnN1cmUgdGhlIGlubmVyXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRob3V0IGZvcmNpbmcgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICBicm93c2VyLmJTY3JvbGxPdmVyc2l6ZSA9IGlubmVyWzBdLm9mZnNldFdpZHRoID09PSAxMDAgJiYgb3V0ZXJbMF0uY2xpZW50V2lkdGggIT09IDEwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBydGwgdGV4dCBsYXlvdXQsIHNvbWUgYnJvd3NlcnMgKG1vc3QsIGJ1dCBub3QgYWxsKSB3aWxsIHBsYWNlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0LCByYXRoZXIgdGhhbiB0aGUgcmlnaHQuXHJcbiAgICAgICAgICAgICAgICBicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID0gTWF0aC5yb3VuZChpbm5lci5vZmZzZXQoKS5sZWZ0KSAhPT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJRTgtIGRvbid0IHByb3ZpZGUgaGVpZ2h0IGFuZCB3aWR0aCBmb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XHJcbiAgICAgICAgICAgICAgICBicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgbi5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJC5leHRlbmQoc2V0dGluZ3Mub0Jyb3dzZXIsIERhdGFUYWJsZS5fX2Jyb3dzZXIpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5vU2Nyb2xsLmlCYXJXaWR0aCA9IERhdGFUYWJsZS5fX2Jyb3dzZXIuYmFyV2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkucHJvdG90eXBlIHJlZHVjZVtSaWdodF0gbWV0aG9kLCB1c2VkIGZvciBicm93c2VycyB3aGljaCBkb24ndCBzdXBwb3J0XHJcbiAgICAgICAgICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuUmVkdWNlKHRoYXQsIGZuLCBpbml0LCBzdGFydCwgZW5kLCBpbmMpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBpID0gc3RhcnQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGlzU2V0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluaXQ7XHJcbiAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gaXNTZXQgP1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKHZhbHVlLCB0aGF0W2ldLCBpLCB0aGF0KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpICs9IGluYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgY29sdW1uIHRvIHRoZSBsaXN0IHVzZWQgZm9yIHRoZSB0YWJsZSB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVGggVGhlIHRoIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFkZENvbHVtbihvU2V0dGluZ3MsIG5UaCkge1xyXG4gICAgICAgICAgICAvLyBBZGQgY29sdW1uIHRvIGFvQ29sdW1ucyBhcnJheVxyXG4gICAgICAgICAgICB2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcclxuICAgICAgICAgICAgdmFyIGlDb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG9Db2wgPSAkLmV4dGVuZCh7fSwgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uLCBvRGVmYXVsdHMsIHtcclxuICAgICAgICAgICAgICAgIFwiblRoXCI6IG5UaCA/IG5UaCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyksXHJcbiAgICAgICAgICAgICAgICBcInNUaXRsZVwiOiBvRGVmYXVsdHMuc1RpdGxlID8gb0RlZmF1bHRzLnNUaXRsZSA6IG5UaCA/IG5UaC5pbm5lckhUTUwgOiAnJyxcclxuICAgICAgICAgICAgICAgIFwiYURhdGFTb3J0XCI6IG9EZWZhdWx0cy5hRGF0YVNvcnQgPyBvRGVmYXVsdHMuYURhdGFTb3J0IDogW2lDb2xdLFxyXG4gICAgICAgICAgICAgICAgXCJtRGF0YVwiOiBvRGVmYXVsdHMubURhdGEgPyBvRGVmYXVsdHMubURhdGEgOiBpQ29sLFxyXG4gICAgICAgICAgICAgICAgaWR4OiBpQ29sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2gob0NvbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgc2VhcmNoIG9iamVjdCBmb3IgY29sdW1uIHNwZWNpZmljIHNlYXJjaC4gTm90ZSB0aGF0IHRoZSBgc2VhcmNoQ29sc1sgaUNvbCBdYFxyXG4gICAgICAgICAgICAvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcclxuICAgICAgICAgICAgLy8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHZhciBzZWFyY2hDb2xzID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcclxuICAgICAgICAgICAgc2VhcmNoQ29sc1tpQ29sXSA9ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaUNvbF0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcclxuICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGx5IG9wdGlvbnMgZm9yIGEgY29sdW1uXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvT3B0aW9ucyBvYmplY3Qgd2l0aCBzVHlwZSwgYlZpc2libGUgYW5kIGJTZWFyY2hhYmxlIGV0Y1xyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Db2x1bW5PcHRpb25zKG9TZXR0aW5ncywgaUNvbCwgb09wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2lDb2xdO1xyXG4gICAgICAgICAgICB2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XHJcbiAgICAgICAgICAgIHZhciB0aCA9ICQob0NvbC5uVGgpO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCB3aWR0aCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBET00uIFdlIGNhbid0IGdldCBpdCBmcm9tIENTU1xyXG4gICAgICAgICAgICAvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcclxuICAgICAgICAgICAgaWYgKCFvQ29sLnNXaWR0aE9yaWcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdpZHRoIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgb0NvbC5zV2lkdGhPcmlnID0gdGguYXR0cignd2lkdGgnKSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0eWxlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSAodGguYXR0cignc3R5bGUnKSB8fCAnJykubWF0Y2goL3dpZHRoOlxccyooXFxkK1tweGVtJV0rKS8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvQ29sLnNXaWR0aE9yaWcgPSB0WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xyXG4gICAgICAgICAgICBpZiAob09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgICAgIF9mbkNvbXBhdENvbHMob09wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcCBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0c1xyXG4gICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIG1EYXRhUHJvcCAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLm1EYXRhUHJvcCAhPT0gdW5kZWZpbmVkICYmICFvT3B0aW9ucy5tRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9PcHRpb25zLm1EYXRhID0gb09wdGlvbnMubURhdGFQcm9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5zVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxyXG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLmNsYXNzTmFtZSAmJiAhb09wdGlvbnMuc0NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb09wdGlvbnMuc0NsYXNzID0gb09wdGlvbnMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLnNDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoLmFkZENsYXNzKG9PcHRpb25zLnNDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgJC5leHRlbmQob0NvbCwgb09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgX2ZuTWFwKG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogaURhdGFTb3J0IHRvIGJlIGFwcGxpZWQgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSwgYnV0IGFEYXRhU29ydCB3aWxsIHRha2VcclxuICAgICAgICAgICAgICAgICAqIHByaW9yaXR5IGlmIGRlZmluZWRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLmlEYXRhU29ydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb0NvbC5hRGF0YVNvcnQgPSBbb09wdGlvbnMuaURhdGFTb3J0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9mbk1hcChvQ29sLCBvT3B0aW9ucywgXCJhRGF0YVNvcnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIENhY2hlIHRoZSBkYXRhIGdldCBhbmQgc2V0IGZ1bmN0aW9ucyBmb3Igc3BlZWQgKi9cclxuICAgICAgICAgICAgdmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcclxuICAgICAgICAgICAgdmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKG1EYXRhU3JjKTtcclxuICAgICAgICAgICAgdmFyIG1SZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4ob0NvbC5tUmVuZGVyKSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0clRlc3QgPSBmdW5jdGlvbiAoc3JjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLmluZGV4T2YoJ0AnKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KG1EYXRhU3JjKSAmJiAoXHJcbiAgICAgICAgICAgICAgICBhdHRyVGVzdChtRGF0YVNyYy5zb3J0KSB8fCBhdHRyVGVzdChtRGF0YVNyYy50eXBlKSB8fCBhdHRyVGVzdChtRGF0YVNyYy5maWx0ZXIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG9Db2wuX3NldHRlciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBvQ29sLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB0eXBlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJEYXRhID0gbURhdGEocm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbVJlbmRlciAmJiB0eXBlID9cclxuICAgICAgICAgICAgICAgICAgICBtUmVuZGVyKGlubmVyRGF0YSwgdHlwZSwgcm93RGF0YSwgbWV0YSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRGF0YTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgb0NvbC5mblNldERhdGEgPSBmdW5jdGlvbiAocm93RGF0YSwgdmFsLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKG1EYXRhU3JjKShyb3dEYXRhLCB2YWwsIG1ldGEpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gSW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBzaG91bGQgcmVhZCBET00gZGF0YSBhcyBhbiBvYmplY3Qgb3IgYXJyYXlcclxuICAgICAgICAgICAgLy8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLl9yb3dSZWFkT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cclxuICAgICAgICAgICAgaWYgKCFvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGguYWRkQ2xhc3Mob0NsYXNzZXMuc1NvcnRhYmxlTm9uZSk7IC8vIEhhdmUgdG8gYWRkIGNsYXNzIGhlcmUgYXMgb3JkZXIgZXZlbnQgaXNuJ3QgY2FsbGVkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIENoZWNrIHRoYXQgdGhlIGNsYXNzIGFzc2lnbm1lbnQgaXMgY29ycmVjdCBmb3Igc29ydGluZyAqL1xyXG4gICAgICAgICAgICB2YXIgYkFzYyA9ICQuaW5BcnJheSgnYXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcclxuICAgICAgICAgICAgdmFyIGJEZXNjID0gJC5pbkFycmF5KCdkZXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcclxuICAgICAgICAgICAgaWYgKCFvQ29sLmJTb3J0YWJsZSB8fCAoIWJBc2MgJiYgIWJEZXNjKSkge1xyXG4gICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlTm9uZTtcclxuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYkFzYyAmJiAhYkRlc2MpIHtcclxuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZUFzYztcclxuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghYkFzYyAmJiBiRGVzYykge1xyXG4gICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlRGVzYztcclxuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJRGVzY0FsbG93ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGU7XHJcbiAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXHJcbiAgICAgICAgICogZG8gYSByZWRyYXcgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIC8qIE5vdCBpbnRlcmVzdGVkIGluIGRvaW5nIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbiBpZiBhdXRvLXdpZHRoIGlzIGRpc2FibGVkICovXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vRmVhdHVyZXMuYkF1dG9XaWR0aCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cclxuICAgICAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5uVGguc3R5bGUud2lkdGggPSBjb2x1bW5zW2ldLnNXaWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIF9mblNjcm9sbERyYXcoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XHJcbiAgICAgICAgICogb2YgaGlkZGVuIGNvbHVtbnMpXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcclxuICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChvU2V0dGluZ3MsIGlNYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgIGFpVmlzW2lNYXRjaF0gOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGFuIGluZGV4IGluIHRoZSBkYXRhIGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSB2aXNpYmxlXHJcbiAgICAgICAgICogICBjb2x1bW4gaW5kZXggKHRha2UgYWNjb3VudCBvZiBoaWRkZW4gY29sdW1ucylcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShvU2V0dGluZ3MsIGlNYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyk7XHJcbiAgICAgICAgICAgIHZhciBpUG9zID0gJC5pbkFycmF5KGlNYXRjaCwgYWlWaXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlQb3MgIT09IC0xID8gaVBvcyA6IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgdmlzaWJsZSBjb2x1bW5zXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgdmlzID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vIHJlZHVjZSBpbiBJRTgsIHVzZSBhIGxvb3AgZm9yIG5vd1xyXG4gICAgICAgICAgICAkLmVhY2gob1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKGksIGNvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbC5iVmlzaWJsZSAmJiAkKGNvbC5uVGgpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmlzO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJvcGVydHlcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1BhcmFtIFBhcmFtZXRlciBpbiBhb0NvbHVtbnMgdG8gbG9vayBmb3IgLSB0eXBpY2FsbHlcclxuICAgICAgICAgKiAgICBiVmlzaWJsZSBvciBiU2VhcmNoYWJsZVxyXG4gICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyhvU2V0dGluZ3MsIHNQYXJhbSkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgJC5tYXAob1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKHZhbCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbFtzUGFyYW1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgJ3R5cGUnIG9mIGEgY29sdW1uXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Db2x1bW5UeXBlcyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3Q7XHJcbiAgICAgICAgICAgIHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xyXG4gICAgICAgICAgICB2YXIgY29sLCBjZWxsLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggY29sdW1uLCBzcGluIG92ZXIgdGhlIFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb2wgPSBjb2x1bW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb2wuc1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSB0eXBlcy5sZW5ndGg7IGogPCBqZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBrZW4gPSBkYXRhLmxlbmd0aDsgayA8IGtlbjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBjYWNoZSBhcnJheSBzbyB3ZSBvbmx5IG5lZWQgdG8gZ2V0IHRoZSB0eXBlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIGZvcm1hdHRlciBvbmNlICh3aGVuIHVzaW5nIG11bHRpcGxlIGRldGVjdG9ycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVtrXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVba10gPSBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaywgaSwgJ3R5cGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZFR5cGUgPSB0eXBlc1tqXShjYWNoZVtrXSwgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGV0ZWN0ZWRUeXBlICYmIGogIT09IHR5cGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIG1hdGNoIGlzIG5lZWRlZCBmb3IgaHRtbCB0eXBlIHNpbmNlIGl0IGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gb2YgdGhlIHBpbGUgYW5kIHZlcnkgc2ltaWxhciB0byBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXRlY3RlZFR5cGUgPT09ICdodG1sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sLnNUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XHJcbiAgICAgICAgICogdGhleSByZWxhdGUgdG8gY29sdW1uIGluZGV4ZXMuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIHRoZW4gYXBwbHkgdGhlXHJcbiAgICAgICAgICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhb0NvbERlZnMgVGhlIGFvQ29sdW1uRGVmcyBhcnJheSB0aGF0IGlzIHRvIGJlIGFwcGxpZWRcclxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXHJcbiAgICAgICAgICogICAgY29sdW1uIGluZGV4IGFuZCB0aGUgZGVmaW5pdGlvbiBmb3IgdGhhdCBjb2x1bW4uXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFwcGx5Q29sdW1uRGVmcyhvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbikge1xyXG4gICAgICAgICAgICB2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XHJcblxyXG4gICAgICAgICAgICAvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xyXG4gICAgICAgICAgICBpZiAoYW9Db2xEZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gYW9Db2xEZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gYW9Db2xEZWZzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiBFYWNoIGRlZmluaXRpb24gY2FuIHRhcmdldCBtdWx0aXBsZSBjb2x1bW5zLCBhcyBpdCBpcyBhbiBhcnJheSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYudGFyZ2V0cyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5hVGFyZ2V0cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkoYVRhcmdldHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFUYXJnZXRzID0gW2FUYXJnZXRzXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpMZW4gPSBhVGFyZ2V0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbHVtbnMubGVuZ3RoIDw9IGFUYXJnZXRzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkQ29sdW1uKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSW50ZWdlciwgYmFzaWMgaW5kZXggKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGFUYXJnZXRzW2pdLCBkZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oY29sdW1ucy5sZW5ndGggKyBhVGFyZ2V0c1tqXSwgZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBDbGFzcyBuYW1lIG1hdGNoaW5nIG9uIFRIIGVsZW1lbnQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGtMZW4gPSBjb2x1bW5zLmxlbmd0aDsgayA8IGtMZW47IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhVGFyZ2V0c1tqXSA9PSBcIl9hbGxcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGNvbHVtbnNba10ublRoKS5oYXNDbGFzcyhhVGFyZ2V0c1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oaywgZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXRpY2FsbHkgZGVmaW5lZCBjb2x1bW5zIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChhb0NvbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0NvbHMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4oaSwgYW9Db2xzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgZGF0YSBhcnJheSB0byB0aGUgdGFibGUsIGNyZWF0aW5nIERPTSBub2RlIGV0Yy4gVGhpcyBpcyB0aGUgcGFyYWxsZWwgdG9cclxuICAgICAgICAgKiBfZm5HYXRoZXJEYXRhLCBidXQgZm9yIGFkZGluZyByb3dzIGZyb20gYSBKYXZhc2NyaXB0IHNvdXJjZSwgcmF0aGVyIHRoYW4gYVxyXG4gICAgICAgICAqIERPTSBzb3VyY2UuXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYURhdGEgZGF0YSBhcnJheSB0byBiZSBhZGRlZFxyXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IFtuVHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXHJcbiAgICAgICAgICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXHJcbiAgICAgICAgICogICAgaWYgblRyIGlzLlxyXG4gICAgICAgICAqICBAcmV0dXJucyB7aW50fSA+PTAgaWYgc3VjY2Vzc2Z1bCAoaW5kZXggb2YgbmV3IGFvRGF0YSBlbnRyeSksIC0xIGlmIGZhaWxlZFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5BZGREYXRhKG9TZXR0aW5ncywgYURhdGFJbiwgblRyLCBhblRkcykge1xyXG4gICAgICAgICAgICAvKiBDcmVhdGUgdGhlIG9iamVjdCBmb3Igc3RvcmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG5ldyByb3cgKi9cclxuICAgICAgICAgICAgdmFyIGlSb3cgPSBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG9EYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xyXG4gICAgICAgICAgICAgICAgc3JjOiBuVHIgPyAnZG9tJyA6ICdkYXRhJyxcclxuICAgICAgICAgICAgICAgIGlkeDogaVJvd1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG9EYXRhLl9hRGF0YSA9IGFEYXRhSW47XHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5hb0RhdGEucHVzaChvRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvKiBDcmVhdGUgdGhlIGNlbGxzICovXHJcbiAgICAgICAgICAgIHZhciBuVGQsIHNUaGlzVHlwZTtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cclxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgY29sdW1uIHR5cGVzIGFzIHRoZSBuZXcgZGF0YSBuZWVkcyB0byBiZSByZXZhbGlkYXRlZFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2ldLnNUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIucHVzaChpUm93KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpZCA9IG9TZXR0aW5ncy5yb3dJZEZuKGFEYXRhSW4pO1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmFJZHNbaWRdID0gb0RhdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cclxuICAgICAgICAgICAgaWYgKG5UciB8fCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIF9mbkNyZWF0ZVRyKG9TZXR0aW5ncywgaVJvdywgblRyLCBhblRkcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpUm93O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBvbmUgb3IgbW9yZSBUUiBlbGVtZW50cyB0byB0aGUgdGFibGUuIEdlbmVyYWxseSB3ZSdkIGV4cGVjdCB0b1xyXG4gICAgICAgICAqIHVzZSB0aGlzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBhIERPTSBzb3VyY2VkIHRhYmxlLCBidXQgaXQgY291bGQgYmVcclxuICAgICAgICAgKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxyXG4gICAgICAgICAqIGl0IGlzIG5vdCBjbG9uZWQpLlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcclxuICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIGZvciB0aGUgYWRkZWQgcm93c1xyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5BZGRUcihzZXR0aW5ncywgdHJzKSB7XHJcbiAgICAgICAgICAgIHZhciByb3c7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBhbiBpbmRpdmlkdWFsIG5vZGUgdG8gYmUgcGFzc2VkIGluXHJcbiAgICAgICAgICAgIGlmICghKHRycyBpbnN0YW5jZW9mICQpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnMgPSAkKHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgICAgICAgICAgcm93ID0gX2ZuR2V0Um93RWxlbWVudHMoc2V0dGluZ3MsIGVsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5BZGREYXRhKHNldHRpbmdzLCByb3cuZGF0YSwgZWwsIHJvdy5jZWxscyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2UgYSBUUiBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IHRvIGFuIGluZGV4IGluIGFvRGF0YVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXHJcbiAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCBudWxsIGlmIG5vdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Ob2RlVG9EYXRhSW5kZXgob1NldHRpbmdzLCBuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobi5fRFRfUm93SW5kZXggIT09IHVuZGVmaW5lZCkgPyBuLl9EVF9Sb3dJbmRleCA6IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZSBhIFREIGVsZW1lbnQgYW5kIGNvbnZlcnQgaXQgaW50byBhIGNvbHVtbiBkYXRhIGluZGV4IChub3QgdGhlIHZpc2libGUgaW5kZXgpXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBudW1iZXIgdGhlIFREL1RIIGNhbiBiZSBmb3VuZCBpblxyXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IG4gVGhlIFREL1RIIGVsZW1lbnQgdG8gZmluZFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgLTEgaWYgbm90XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbk5vZGVUb0NvbHVtbkluZGV4KG9TZXR0aW5ncywgaVJvdywgbikge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KG4sIG9TZXR0aW5ncy5hb0RhdGFbaVJvd10uYW5DZWxscyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIGNlbGwgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGUsIHRha2luZyBpbnRvIGFjY291bnQgZGF0YSBtYXBwaW5nXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnKVxyXG4gICAgICAgICAqICBAcmV0dXJucyB7Kn0gQ2VsbCBkYXRhXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhdyA9IHNldHRpbmdzLmlEcmF3O1xyXG4gICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcbiAgICAgICAgICAgIHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xyXG4gICAgICAgICAgICB2YXIgY2VsbERhdGEgPSBjb2wuZm5HZXREYXRhKHJvd0RhdGEsIHR5cGUsIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgIHJvdzogcm93SWR4LFxyXG4gICAgICAgICAgICAgICAgY29sOiBjb2xJZHhcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2VsbERhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkxvZyhzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNvbC5tRGF0YSA9PSAnZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIgKyBjb2wubURhdGEgKyBcIidcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBmb3Igcm93IFwiICsgcm93SWR4ICsgXCIsIGNvbHVtbiBcIiArIGNvbElkeCwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaURyYXdFcnJvciA9IGRyYXc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdENvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwgYW5kIGEgc3BlY2lmaWMgZGF0YSB0eXBlIGlzIHJlcXVlc3RlZCAoaS5lLlxyXG4gICAgICAgICAgICAvLyBub3QgdGhlIG9yaWdpbmFsIGRhdGEpLCB3ZSBjYW4gdXNlIGRlZmF1bHQgY29sdW1uIGRhdGFcclxuICAgICAgICAgICAgaWYgKChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGRlZmF1bHRDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgc291cmNlIGlzIGEgZnVuY3Rpb24sIHRoZW4gd2UgcnVuIGl0IGFuZCB1c2UgdGhlIHJldHVybixcclxuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxEYXRhLmNhbGwocm93RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09ICdkaXNwbGF5Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjZWxsRGF0YTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxyXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxyXG4gICAgICAgICAqICBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB2YWwpIHtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xyXG4gICAgICAgICAgICB2YXIgcm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGNvbC5mblNldERhdGEocm93RGF0YSwgdmFsLCB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgICByb3c6IHJvd0lkeCxcclxuICAgICAgICAgICAgICAgIGNvbDogY29sSWR4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XHJcbiAgICAgICAgdmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcclxuICAgICAgICB2YXIgX19yZUZuID0gL1xcKFxcKSQvO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdCBzdHJpbmcgb24gcGVyaW9kcywgdGFraW5nIGludG8gYWNjb3VudCBlc2NhcGVkIHBlcmlvZHNcclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcclxuICAgICAgICAgKiBAcmV0dXJuIHthcnJheX0gU3BsaXQgc3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQubWFwKHN0ci5tYXRjaCgvKFxcXFwufFteXFwuXSkrL2cpIHx8IFsnJ10sIGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xyXG4gICAgICAgICAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldE9iamVjdERhdGFGbihtU291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QobVNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIC8qIEJ1aWxkIGFuIG9iamVjdCBvZiBnZXQgZnVuY3Rpb25zLCBhbmQgd3JhcCB0aGVtIGluIGEgc2luZ2xlIGNhbGwgKi9cclxuICAgICAgICAgICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgICAgICAgICAkLmVhY2gobVNvdXJjZSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBfZm5HZXRPYmplY3REYXRhRm4odmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1Tb3VyY2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8qIEdpdmUgYW4gZW1wdHkgc3RyaW5nIGZvciByZW5kZXJpbmcgLyBzb3J0aW5nIGV0YyAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtU291cmNlKGRhdGEsIHR5cGUsIHJvdywgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XHJcbiAgICAgICAgICAgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgYSAuIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZW4gdGhlIGRhdGEgc291cmNlIGlzIGluIGFcclxuICAgICAgICAgICAgICAgICAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgKiByZXR1cm4uIFRoaXMgYWxsb3dzIGVudGlyZSBvYmplY3RzIHRvIGJlIG1pc3NpbmcgYW5kIHNEZWZhdWx0Q29udGVudCB0b1xyXG4gICAgICAgICAgICAgICAgICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHNyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmMgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKHNyYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGEubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Tm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBub3RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5zcGxpY2UoMCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyU3JjID0gYS5qb2luKCcuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IGdldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChmZXRjaERhdGEoZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQgdG8gam9pbiB0aGUgc3RyaW5ncyB0b2dldGhlciwgb3RoZXJ3aXNlIGFuIGFycmF5IGlzIHJldHVybmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW4gPSBhcnJheU5vdGF0aW9uWzBdLnN1YnN0cmluZygxLCBhcnJheU5vdGF0aW9uWzBdLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoam9pbiA9PT0gXCJcIikgPyBvdXQgOiBvdXQuam9pbihqb2luKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHJlcXVlc3RlZCwgc28gd2UgZXhpdCBmcm9tIHRoZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jTm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGFbYVtpXV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaERhdGEoZGF0YSwgdHlwZSwgbVNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZyAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbbVNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXHJcbiAgICAgICAgICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UpIHtcclxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChtU291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgLyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXHJcbiAgICAgICAgICAgICAgICAgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3RcclxuICAgICAgICAgICAgICAgICAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xyXG4gICAgICAgICAgICAgICAgICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4obVNvdXJjZS5fKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtU291cmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBOb3RoaW5nIHRvIGRvIHdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1Tb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbVNvdXJjZShkYXRhLCAnc2V0JywgdmFsLCBtZXRhKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcclxuICAgICAgICAgICAgICAgIG1Tb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBtU291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBMaWtlIHRoZSBnZXQsIHdlIG5lZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIG5lc3RlZCBvYmplY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciBzZXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHZhbCwgc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKHNyYyksIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFMYXN0ID0gYVthLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG8sIGlubmVyU3JjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGEubGVuZ3RoIC0gMTsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Tm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2FbaV1dID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gc2V0IHNvIHdlIGNhbiByZWN1cnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5zcGxpY2UoMCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJTcmMgPSBiLmpvaW4oJy4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSB2YWwubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGF0YShvLCB2YWxbal0sIGlubmVyU3JjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthW2ldXS5wdXNoKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGJlZW4gYXNrZWQgdG8gc2F2ZSBkYXRhIHRvIGFuIGFycmF5LCBidXQgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpc24ndCBhcnJheSBkYXRhIHRvIGJlIHNhdmVkLiBCZXN0IHRoYXQgY2FuIGJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYVtpXV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jTm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmVzdGVkIG9iamVjdCBkb2Vzbid0IGN1cnJlbnRseSBleGlzdCAtIHNpbmNlIHdlIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVthW2ldXSA9PT0gbnVsbCB8fCBkYXRhW2FbaV1dID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYVtpXV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFMYXN0Lm1hdGNoKF9fcmVGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpXSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGFzc2lnbiB0aGUgdmFsdWUuIElmIGl0IGlzbid0IHVzZWQsIHRoZW4gd2UgZ2V0IHRoZSByZXN1bHQgd2Ugd2FudCBhbnl3YXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthTGFzdC5yZXBsYWNlKF9fcmVBcnJheSwgJycpXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXREYXRhKGRhdGEsIHZhbCwgbVNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZyAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVttU291cmNlXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgZnVsbCB0YWJsZSBkYXRhXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVrZSB0aGUgdGFibGVcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5DbGVhclRhYmxlKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmFJZHMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRha2UgYW4gYXJyYXkgb2YgaW50ZWdlcnMgKGluZGV4IGFycmF5KSBhbmQgcmVtb3ZlIGEgdGFyZ2V0IGludGVnZXIgKHZhbHVlIC0gbm90XHJcbiAgICAgICAgKiB0aGUga2V5ISlcclxuICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxyXG4gICAgICAgICogIEBwYXJhbSB7aW50fSBpVGFyZ2V0IHZhbHVlIHRvIGZpbmRcclxuICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkRlbGV0ZUluZGV4KGEsIGlUYXJnZXQsIHNwbGljZSkge1xyXG4gICAgICAgICAgICB2YXIgaVRhcmdldEluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGEubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSA9PSBpVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaVRhcmdldEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFbaV0gPiBpVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYVtpXS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaVRhcmdldEluZGV4ICE9IC0xICYmIHNwbGljZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhLnNwbGljZShpVGFyZ2V0SW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXHJcbiAgICAgICAgICogdGhlIGNhY2hlZCBkYXRhIGlzIG5leHQgcmVxdWVzdGVkLiBBbHNvIHVwZGF0ZSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gICAgcm93SWR4ICAgUm93IGluZGV4IHRvIGludmFsaWRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gICAgU291cmNlIHRvIGludmFsaWRhdGUgZnJvbTogdW5kZWZpbmVkLCAnYXV0bycsICdkb20nXHJcbiAgICAgICAgICogICAgIG9yICdkYXRhJ1xyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSAgICBbY29sSWR4XSBDb2x1bW4gaW5kZXggdG8gaW52YWxpZGF0ZS4gSWYgdW5kZWZpbmVkIHRoZSB3aG9sZVxyXG4gICAgICAgICAqICAgICByb3cgd2lsbCBiZSBpbnZhbGlkYXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHRvZG8gRm9yIHRoZSBtb2R1bGFyaXNhdGlvbiBvZiB2MS4xMSB0aGlzIHdpbGwgbmVlZCB0byBiZWNvbWUgYSBjYWxsYmFjaywgc29cclxuICAgICAgICAgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcclxuICAgICAgICAgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMgZm9yIHNvcnRpbmcsIHdoaWNoIGlzIHdoeSBpdCBpcyBub3QgYWxyZWFkeSBiYWtlZCBpblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvd0lkeCwgc3JjLCBjb2xJZHgpIHtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdO1xyXG4gICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG4gICAgICAgICAgICB2YXIgY2VsbFdyaXRlID0gZnVuY3Rpb24gKGNlbGwsIGNvbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjZWxsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5yZW1vdmVDaGlsZChjZWxsLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNlbGwuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gQXJlIHdlIHJlYWRpbmcgbGFzdCBkYXRhIGZyb20gRE9NIG9yIHRoZSBkYXRhIG9iamVjdD9cclxuICAgICAgICAgICAgaWYgKHNyYyA9PT0gJ2RvbScgfHwgKCghc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXHJcbiAgICAgICAgICAgICAgICByb3cuX2FEYXRhID0gX2ZuR2V0Um93RWxlbWVudHMoXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsIHJvdywgY29sSWR4LCBjb2xJZHggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJvdy5fYURhdGFcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlYWRpbmcgZnJvbSBkYXRhIG9iamVjdCwgdXBkYXRlIHRoZSBET01cclxuICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHJvdy5hbkNlbGxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjZWxscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xJZHggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV3JpdGUoY2VsbHNbY29sSWR4XSwgY29sSWR4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNlbGxzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsV3JpdGUoY2VsbHNbaV0sIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgYm90aCByb3cgYW5kIGNlbGwgaW52YWxpZGF0aW9uLCB0aGUgY2FjaGVkIGRhdGEgZm9yIHNvcnRpbmcgYW5kXHJcbiAgICAgICAgICAgIC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XHJcbiAgICAgICAgICAgIHJvdy5fYVNvcnREYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgcm93Ll9hRmlsdGVyRGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIG1pZ2h0IGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICB2YXIgY29scyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuICAgICAgICAgICAgaWYgKGNvbElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xzW2NvbElkeF0uc1R5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29scy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHNbaV0uc1R5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBEYXRhVGFibGVzIHNwZWNpYWwgYERUXypgIGF0dHJpYnV0ZXMgZm9yIHRoZSByb3dcclxuICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXMoc2V0dGluZ3MsIHJvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZCBhIGRhdGEgc291cmNlIG9iamVjdCBmcm9tIGFuIEhUTUwgcm93LCByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGVcclxuICAgICAgICAgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcclxuICAgICAgICAgKiAgIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlLXJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgY2VsbHNcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gW2NvbElkeF0gT3B0aW9uYWwgY29sdW1uIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xyXG4gICAgICAgICAqICAgcGFyYW1ldGVyIHNob3VsZCBhbHNvIGJlIGdpdmVuIGFuZCB3aWxsIGJlIHVzZWQgdG8gd3JpdGUgdGhlIGRhdGEgaW50by5cclxuICAgICAgICAgKiAgIE9ubHkgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiB3aWxsIGJlIHdyaXR0ZW5cclxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXHJcbiAgICAgICAgICogICBkb2N1bWVudCBvcmRlciwgYW5kIGBjZWxsc2AgYW5kIGFycmF5IG9mIG5vZGVzICh0aGV5IGNhbiBiZSB1c2VmdWwgdG8gdGhlXHJcbiAgICAgICAgICogICBjYWxsZXIsIHNvIHJhdGhlciB0aGFuIG5lZWRpbmcgYSBzZWNvbmQgdHJhdmVyc2FsIHRvIGdldCB0aGVtLCBqdXN0IHJldHVyblxyXG4gICAgICAgICAqICAgdGhlbSBmcm9tIGhlcmUpLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKHNldHRpbmdzLCByb3csIGNvbElkeCwgZCkge1xyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIHRkcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgdGQgPSByb3cuZmlyc3RDaGlsZCxcclxuICAgICAgICAgICAgICAgIG5hbWUsIGNvbCwgbywgaSA9IDAsIGNvbnRlbnRzLFxyXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcclxuICAgICAgICAgICAgICAgIG9iamVjdFJlYWQgPSBzZXR0aW5ncy5fcm93UmVhZE9iamVjdDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgaW4sIG9yIGNvbnN0cnVjdFxyXG4gICAgICAgICAgICBkID0gZCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIGQgOlxyXG4gICAgICAgICAgICAgICAgb2JqZWN0UmVhZCA/XHJcbiAgICAgICAgICAgICAgICAgICAge30gOlxyXG4gICAgICAgICAgICAgICAgICAgIFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHIgPSBmdW5jdGlvbiAoc3RyLCB0ZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKCdAJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyhpZHggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbihzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoZCwgdGQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XHJcbiAgICAgICAgICAgIHZhciBjZWxsUHJvY2VzcyA9IGZ1bmN0aW9uIChjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sID0gY29sdW1uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9ICQudHJpbShjZWxsLmlubmVySFRNTCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wgJiYgY29sLl9iQXR0clNyYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKGNvbC5tRGF0YS5fKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKGQsIGNvbnRlbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIoY29sLm1EYXRhLnNvcnQsIGNlbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyKGNvbC5tRGF0YS50eXBlLCBjZWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cihjb2wubURhdGEuZmlsdGVyLCBjZWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHJlYWQgdG8gZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdFJlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sLl9zZXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLl9zZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oY29sLm1EYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5fc2V0dGVyKGQsIGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaV0gPSBjb250ZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxQcm9jZXNzKHRkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGRzLnB1c2godGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSB0ZC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXHJcbiAgICAgICAgICAgICAgICB0ZHMgPSByb3cuYW5DZWxscztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamVuID0gdGRzLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFByb2Nlc3ModGRzW2pdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgSUQgZnJvbSB0aGUgRE9NIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgdmFyIHJvd05vZGUgPSByb3cuZmlyc3RDaGlsZCA/IHJvdyA6IHJvdy5uVHI7XHJcblxyXG4gICAgICAgICAgICBpZiAocm93Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gcm93Tm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuU2V0T2JqZWN0RGF0YUZuKHNldHRpbmdzLnJvd0lkKShkLCBpZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxyXG4gICAgICAgICAgICAgICAgY2VsbHM6IHRkc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgVFIgZWxlbWVudCAoYW5kIGl0J3MgVEQgY2hpbGRyZW4pIGZvciBhIHJvd1xyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxyXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IFtuVHJJbl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcclxuICAgICAgICAgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cclxuICAgICAgICAgKiAgICBpZiBuVHIgaXMuXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNyZWF0ZVRyKG9TZXR0aW5ncywgaVJvdywgblRySW4sIGFuVGRzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgcm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcclxuICAgICAgICAgICAgICAgIHJvd0RhdGEgPSByb3cuX2FEYXRhLFxyXG4gICAgICAgICAgICAgICAgY2VsbHMgPSBbXSxcclxuICAgICAgICAgICAgICAgIG5UciwgblRkLCBvQ29sLFxyXG4gICAgICAgICAgICAgICAgaSwgaUxlbjtcclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cublRyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJvdy5uVHIgPSBuVHI7XHJcbiAgICAgICAgICAgICAgICByb3cuYW5DZWxscyA9IGNlbGxzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgICAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cclxuICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXMob1NldHRpbmdzLCByb3cpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFByb2Nlc3MgZWFjaCBjb2x1bW4gKi9cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBuVGQgPSBuVHJJbiA/IGFuVGRzW2ldIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvQ29sLnNDZWxsVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgblRkLl9EVF9DZWxsSW5kZXggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogaVJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChuVGQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgSFRNTCBpZiBuZXcsIG9yIGlmIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFuVHJJbiB8fCBvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCEkLmlzUGxhaW5PYmplY3Qob0NvbC5tRGF0YSkgfHwgb0NvbC5tRGF0YS5fICE9PSBpICsgJy5kaXNwbGF5JylcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgblRkLmlubmVySFRNTCA9IF9mbkdldENlbGxEYXRhKG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEFkZCB1c2VyIGRlZmluZWQgY2xhc3MgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAob0NvbC5zQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgblRkLmNsYXNzTmFtZSArPSAnICcgKyBvQ29sLnNDbGFzcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZpc2liaWxpdHkgLSBhZGQgb3IgcmVtb3ZlIGFzIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9Db2wuYlZpc2libGUgJiYgIW5UckluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5Uci5hcHBlbmRDaGlsZChuVGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb0NvbC5iVmlzaWJsZSAmJiBuVHJJbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuVGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuVGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9Db2wuZm5DcmVhdGVkQ2VsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvQ29sLmZuQ3JlYXRlZENlbGwuY2FsbChvU2V0dGluZ3Mub0luc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkLCBfZm5HZXRDZWxsRGF0YShvU2V0dGluZ3MsIGlSb3csIGkpLCByb3dEYXRhLCBpUm93LCBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG51bGwsIFtuVHIsIHJvd0RhdGEsIGlSb3ddKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9uY2Ugd2Via2l0IGJ1ZyAxMzE4MTkgYW5kIENocm9taXVtIGJ1ZyAzNjU2MTkgaGF2ZSBiZWVuIHJlc29sdmVkXHJcbiAgICAgICAgICAgIC8vIGFuZCBkZXBsb3llZFxyXG4gICAgICAgICAgICByb3cublRyLnNldEF0dHJpYnV0ZSgncm9sZScsICdyb3cnKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYXR0cmlidXRlcyB0byBhIHJvdyBiYXNlZCBvbiB0aGUgc3BlY2lhbCBgRFRfKmAgcGFyYW1ldGVycyBpbiBhIGRhdGFcclxuICAgICAgICAgKiBzb3VyY2Ugb2JqZWN0LlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IERhdGFUYWJsZXMgcm93IG9iamVjdCBmb3IgdGhlIHJvdyB0byBiZSBtb2RpZmllZFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Sb3dBdHRyaWJ1dGVzKHNldHRpbmdzLCByb3cpIHtcclxuICAgICAgICAgICAgdmFyIHRyID0gcm93Lm5UcjtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSByb3cuX2FEYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmlkID0gaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93Q2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9fcm93YyA9IHJvdy5fX3Jvd2MgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdW5pcXVlKHJvdy5fX3Jvd2MuY29uY2F0KGEpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICQodHIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhyb3cuX19yb3djLmpvaW4oJyAnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGRhdGEuRFRfUm93Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLkRUX1Jvd0F0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKHRyKS5hdHRyKGRhdGEuRFRfUm93QXR0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICQodHIpLmRhdGEoZGF0YS5EVF9Sb3dEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkJ1aWxkSGVhZChvU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGksIGllbiwgY2VsbCwgcm93LCBjb2x1bW47XHJcbiAgICAgICAgICAgIHZhciB0aGVhZCA9IG9TZXR0aW5ncy5uVEhlYWQ7XHJcbiAgICAgICAgICAgIHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVIZWFkZXIgPSAkKCd0aCwgdGQnLCB0aGVhZCkubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3NlcztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNyZWF0ZUhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0aGVhZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XHJcbiAgICAgICAgICAgICAgICBjZWxsID0gJChjb2x1bW4ublRoKS5hZGRDbGFzcyhjb2x1bW4uc0NsYXNzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRUbyhyb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIDEuMTEgbW92ZSBpbnRvIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5hZGRDbGFzcyhjb2x1bW4uc1NvcnRpbmdDbGFzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGFiaW5kZXgnLCBvU2V0dGluZ3MuaVRhYkluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydEF0dGFjaExpc3RlbmVyKG9TZXR0aW5ncywgY29sdW1uLm5UaCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc1RpdGxlICE9IGNlbGxbMF0uaW5uZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5odG1sKGNvbHVtbi5zVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIF9mblJlbmRlcmVyKG9TZXR0aW5ncywgJ2hlYWRlcicpKFxyXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXIob1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIEFSSUEgcm9sZSBmb3IgdGhlIHJvd3MgKi9cclxuICAgICAgICAgICAgJCh0aGVhZCkuZmluZCgnPnRyJykuYXR0cigncm9sZScsICdyb3cnKTtcclxuXHJcbiAgICAgICAgICAgIC8qIERlYWwgd2l0aCB0aGUgZm9vdGVyIC0gYWRkIGNsYXNzZXMgaWYgcmVxdWlyZWQgKi9cclxuICAgICAgICAgICAgJCh0aGVhZCkuZmluZCgnPnRyPnRoLCA+dHI+dGQnKS5hZGRDbGFzcyhjbGFzc2VzLnNIZWFkZXJUSCk7XHJcbiAgICAgICAgICAgICQodGZvb3QpLmZpbmQoJz50cj50aCwgPnRyPnRkJykuYWRkQ2xhc3MoY2xhc3Nlcy5zRm9vdGVyVEgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGZvb3RlciBjZWxscy4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGUgY2VsbHMgZnJvbSB0aGUgZmlyc3RcclxuICAgICAgICAgICAgLy8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXHJcbiAgICAgICAgICAgIC8vIGludGVyYWN0IHdpdGgsIHRoZXkgbmVlZCB0byB1c2UgdGhlIHRhYmxlKCkuZm9vdCgpIG1ldGhvZC4gTm90ZSBhbHNvIHRoaXNcclxuICAgICAgICAgICAgLy8gYWxsb3dzIGNlbGxzIHRvIGJlIHVzZWQgZm9yIG11bHRpcGxlIGNvbHVtbnMgdXNpbmcgY29sc3BhblxyXG4gICAgICAgICAgICBpZiAodGZvb3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IG9TZXR0aW5ncy5hb0Zvb3RlclswXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjZWxscy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLm5UZiA9IGNlbGxzW2ldLmNlbGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc0NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoY29sdW1uLm5UZikuYWRkQ2xhc3MoY29sdW1uLnNDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy4gVGhlXHJcbiAgICAgICAgICogbWV0aG9kb2xvZ3kgaGVyZSBpcyB0byB1c2UgdGhlIGxheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlciwgbW9kaWZpZWQgZm9yXHJcbiAgICAgICAgICogdGhlIGluc3RhbnRhbmVvdXMgY29sdW1uIHZpc2liaWxpdHksIHRvIGNvbnN0cnVjdCB0aGUgbmV3IGxheW91dC4gVGhlIGdyaWQgaXNcclxuICAgICAgICAgKiB0cmF2ZXJzZWQgb3ZlciBjZWxsIGF0IGEgdGltZSBpbiBhIHJvd3MgeCBjb2x1bW5zIGdyaWQgZmFzaGlvbiwgYWx0aG91Z2ggZWFjaFxyXG4gICAgICAgICAqIGNlbGwgaW5zZXJ0IGNhbiBjb3ZlciBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgZ3JpZCAtIHdoaWNoIGlzIHRyYWNrcyB1c2luZyB0aGVcclxuICAgICAgICAgKiBhQXBwbGllZCBhcnJheS4gQ2VsbCBpbnNlcnRzIGluIHRoZSBncmlkIHdpbGwgb25seSBvY2N1ciB3aGVyZSB0aGVyZSBpc24ndFxyXG4gICAgICAgICAqIGFscmVhZHkgYSBjZWxsIGluIHRoYXQgcG9zaXRpb24uXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIGFycmF5IHtvYmplY3RzfSBhb1NvdXJjZSBMYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXJcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbYkluY2x1ZGVIaWRkZW49ZmFsc2VdIElmIHRydWUgdGhlbiBpbmNsdWRlIHRoZSBoaWRkZW4gY29sdW1ucyBpbiB0aGUgY2FsYyxcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRHJhd0hlYWQob1NldHRpbmdzLCBhb1NvdXJjZSwgYkluY2x1ZGVIaWRkZW4pIHtcclxuICAgICAgICAgICAgdmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIG4sIG5Mb2NhbFRyO1xyXG4gICAgICAgICAgICB2YXIgYW9Mb2NhbCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYUFwcGxpZWQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGlDb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBpUm93c3BhbiwgaUNvbHNwYW47XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFvU291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiSW5jbHVkZUhpZGRlbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBiSW5jbHVkZUhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBNYWtlIGEgY29weSBvZiB0aGUgbWFzdGVyIGxheW91dCBhcnJheSwgYnV0IHdpdGhvdXQgdGhlIHZpc2libGUgY29sdW1ucyBpbiBpdCAqL1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW9Tb3VyY2UubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhb0xvY2FsW2ldID0gYW9Tb3VyY2VbaV0uc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIGFvTG9jYWxbaV0ublRyID0gYW9Tb3VyY2VbaV0ublRyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFJlbW92ZSBhbnkgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGhpZGRlbiAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaUNvbHVtbnMgLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb1NldHRpbmdzLmFvQ29sdW1uc1tqXS5iVmlzaWJsZSAmJiAhYkluY2x1ZGVIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW9Mb2NhbFtpXS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIFByZXAgdGhlIGFwcGxpZWQgYXJyYXkgLSBpdCBuZWVkcyBhbiBlbGVtZW50IGZvciBlYWNoIHJvdyAqL1xyXG4gICAgICAgICAgICAgICAgYUFwcGxpZWQucHVzaChbXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0xvY2FsLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbkxvY2FsVHIgPSBhb0xvY2FsW2ldLm5UcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvdyAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKG5Mb2NhbFRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkxvY2FsVHIucmVtb3ZlQ2hpbGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpMZW4gPSBhb0xvY2FsW2ldLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlSb3dzcGFuID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2VsbCAocm93L2NvbHNwYW4pIGNvdmVyaW5nIG91ciB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkxvY2FsVHIuYXBwZW5kQ2hpbGQoYW9Mb2NhbFtpXVtqXS5jZWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYUFwcGxpZWRbaV1bal0gPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFvTG9jYWxbaSArIGlSb3dzcGFuXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpICsgaVJvd3NwYW5dW2pdLmNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2kgKyBpUm93c3Bhbl1bal0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgY29sdW1ucyBhcyBuZWVkZWQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFvTG9jYWxbaV1baiArIGlDb2xzcGFuXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpXVtqICsgaUNvbHNwYW5dLmNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaVJvd3NwYW47IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2kgKyBrXVtqICsgaUNvbHNwYW5dID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDb2xzcGFuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIERvIHRoZSBhY3R1YWwgZXhwYW5zaW9uIGluIHRoZSBET00gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJChhb0xvY2FsW2ldW2pdLmNlbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncm93c3BhbicsIGlSb3dzcGFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NvbHNwYW4nLCBpQ29sc3Bhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0IHRoZSByZXF1aXJlZCBUUiBub2RlcyBpbnRvIHRoZSB0YWJsZSBmb3IgZGlzcGxheVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkRyYXcob1NldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXHJcbiAgICAgICAgICAgIHZhciBhUHJlRHJhdyA9IF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10pO1xyXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KGZhbHNlLCBhUHJlRHJhdykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGksIGlMZW4sIG47XHJcbiAgICAgICAgICAgIHZhciBhblJvd3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGlSb3dDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xyXG4gICAgICAgICAgICB2YXIgaVN0cmlwZXMgPSBhc1N0cmlwZUNsYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaU9wZW5Sb3dzID0gb1NldHRpbmdzLmFvT3BlblJvd3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xyXG4gICAgICAgICAgICB2YXIgaUluaXREaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnc3NwJztcclxuICAgICAgICAgICAgdmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XHJcblxyXG4gICAgICAgICAgICBvU2V0dGluZ3MuYkRyYXdpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xyXG4gICAgICAgICAgICBpZiAoaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cclxuICAgICAgICAgICAgICAgICAgICBpSW5pdERpc3BsYXlTdGFydCA6XHJcbiAgICAgICAgICAgICAgICAgICAgaUluaXREaXNwbGF5U3RhcnQgPj0gb1NldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpSW5pdERpc3BsYXlTdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGlEaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcclxuXHJcbiAgICAgICAgICAgIC8qIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZHJhdyBpbnRlcmNlcHQgKi9cclxuICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmlEcmF3Kys7XHJcbiAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghYlNlcnZlclNpZGUpIHtcclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5pRHJhdysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvU2V0dGluZ3MuYkRlc3Ryb3lpbmcgJiYgIV9mbkFqYXhVcGRhdGUob1NldHRpbmdzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaVN0YXJ0OyBqIDwgaUVuZDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlEYXRhSW5kZXggPSBhaURpc3BsYXlbal07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbaURhdGFJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFvRGF0YS5uVHIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ3JlYXRlVHIob1NldHRpbmdzLCBpRGF0YUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuUm93ID0gYW9EYXRhLm5UcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogUmVtb3ZlIHRoZSBvbGQgc3RyaXBpbmcgY2xhc3NlcyBhbmQgdGhlbiBhZGQgdGhlIG5ldyBvbmUgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaVN0cmlwZXMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNTdHJpcGUgPSBhc1N0cmlwZUNsYXNzZXNbaVJvd0NvdW50ICUgaVN0cmlwZXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW9EYXRhLl9zUm93U3RyaXBlICE9IHNTdHJpcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoblJvdykucmVtb3ZlQ2xhc3MoYW9EYXRhLl9zUm93U3RyaXBlKS5hZGRDbGFzcyhzU3RyaXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvRGF0YS5fc1Jvd1N0cmlwZSA9IHNTdHJpcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlSb3dDb3VudCBhbmQgaiBhcmUgbm90IGN1cnJlbnRseSBkb2N1bWVudGVkLiBBcmUgdGhleSBhdCBhbGxcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2VmdWw/XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFuUm93cy5wdXNoKG5Sb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlSb3dDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogVGFibGUgaXMgZW1wdHkgLSBjcmVhdGUgYSByb3cgd2l0aCBhbiBlbXB0eSBtZXNzYWdlIGluIGl0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgc1plcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XHJcbiAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmlEcmF3ID09IDEgJiYgX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpID09ICdhamF4Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNaZXJvID0gb0xhbmcuc0xvYWRpbmdSZWNvcmRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob0xhbmcuc0VtcHR5VGFibGUgJiYgb1NldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzWmVybyA9IG9MYW5nLnNFbXB0eVRhYmxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFuUm93c1swXSA9ICQoJzx0ci8+JywgeyAnY2xhc3MnOiBpU3RyaXBlcyA/IGFzU3RyaXBlQ2xhc3Nlc1swXSA6ICcnIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8dGQgLz4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWxpZ24nOiAndG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcclxuICAgICAgICAgICAgICAgICAgICB9KS5odG1sKHNaZXJvKSlbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIEhlYWRlciBhbmQgZm9vdGVyIGNhbGxiYWNrcyAqL1xyXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICdoZWFkZXInLCBbJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcclxuICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcihvU2V0dGluZ3MpLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5XSk7XHJcblxyXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICdmb290ZXInLCBbJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcclxuICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcihvU2V0dGluZ3MpLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5XSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9keSA9ICQob1NldHRpbmdzLm5UQm9keSk7XHJcblxyXG4gICAgICAgICAgICBib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XHJcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kKCQoYW5Sb3dzKSk7XHJcblxyXG4gICAgICAgICAgICAvKiBDYWxsIGFsbCByZXF1aXJlZCBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBlbmQgb2YgYSBkcmF3ICovXHJcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10pO1xyXG5cclxuICAgICAgICAgICAgLyogRHJhdyBpcyBjb21wbGV0ZSwgc29ydGluZyBhbmQgZmlsdGVyaW5nIG11c3QgYmUgYXMgd2VsbCAqL1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MuYlNvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MuYkZpbHRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5iRHJhd2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGUgLSB0YWtpbmcgYWNjb3VudCBvZiB0aGUgdmFyaW91cyBmZWF0dXJlcyB3aGljaCBhcmUgZW5hYmxlZFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW2hvbGRQb3NpdGlvbl0gS2VlcCB0aGUgY3VycmVudCBwYWdpbmcgcG9zaXRpb24uIEJ5IGRlZmF1bHRcclxuICAgICAgICAgKiAgICB0aGUgcGFnaW5nIGlzIHJlc2V0IHRvIHRoZSBmaXJzdCBwYWdlXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mblJlRHJhdyhzZXR0aW5ncywgaG9sZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICBzb3J0ID0gZmVhdHVyZXMuYlNvcnQsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmZWF0dXJlcy5iRmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvcnQpIHtcclxuICAgICAgICAgICAgICAgIF9mblNvcnQoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb21wbGV0ZShzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGZpbHRlcmluZywgc28gd2Ugd2FudCB0byBqdXN0IHVzZSB0aGUgZGlzcGxheSBtYXN0ZXJcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaG9sZFBvc2l0aW9uICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExldCBhbnkgbW9kdWxlcyBrbm93IGFib3V0IHRoZSBkcmF3IGhvbGQgcG9zaXRpb24gc3RhdGUgKHVzZWQgYnlcclxuICAgICAgICAgICAgLy8gc2Nyb2xsaW5nIGludGVybmFsbHkpXHJcbiAgICAgICAgICAgIHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MuX2RyYXdIb2xkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFkZE9wdGlvbnNIdG1sKG9TZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3NlcztcclxuICAgICAgICAgICAgdmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcclxuICAgICAgICAgICAgdmFyIGhvbGRpbmcgPSAkKCc8ZGl2Lz4nKS5pbnNlcnRCZWZvcmUodGFibGUpOyAvLyBIb2xkaW5nIGVsZW1lbnQgZm9yIHNwZWVkXHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGwgRGF0YVRhYmxlcyBhcmUgd3JhcHBlZCBpbiBhIGRpdlxyXG4gICAgICAgICAgICB2YXIgaW5zZXJ0ID0gJCgnPGRpdi8+Jywge1xyXG4gICAgICAgICAgICAgICAgaWQ6IG9TZXR0aW5ncy5zVGFibGVJZCArICdfd3JhcHBlcicsXHJcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc2VzLnNXcmFwcGVyICsgKG9TZXR0aW5ncy5uVEZvb3QgPyAnJyA6ICcgJyArIGNsYXNzZXMuc05vRm9vdGVyKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5uSG9sZGluZyA9IGhvbGRpbmdbMF07XHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MublRhYmxlUmVpbnNlcnRCZWZvcmUgPSBvU2V0dGluZ3MublRhYmxlLm5leHRTaWJsaW5nO1xyXG5cclxuICAgICAgICAgICAgLyogTG9vcCBvdmVyIHRoZSB1c2VyIHNldCBwb3NpdGlvbmluZyBhbmQgcGxhY2UgdGhlIGVsZW1lbnRzIGFzIG5lZWRlZCAqL1xyXG4gICAgICAgICAgICB2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcclxuICAgICAgICAgICAgdmFyIGZlYXR1cmVOb2RlLCBjT3B0aW9uLCBuTmV3Tm9kZSwgY05leHQsIHNBdHRyLCBqO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFEb20ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNPcHRpb24gPSBhRG9tW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjT3B0aW9uID09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIE5ldyBjb250YWluZXIgZGl2ICovXHJcbiAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUgPSAkKCc8ZGl2Lz4nKVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyICovXHJcbiAgICAgICAgICAgICAgICAgICAgY05leHQgPSBhRG9tW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY05leHQgPT0gXCInXCIgfHwgY05leHQgPT0gJ1wiJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYURvbVtpICsgal0gIT0gY05leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNBdHRyICs9IGFEb21baSArIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZXBsYWNlIGpRdWVyeSBVSSBjb25zdGFudHMgQHRvZG8gZGVwcmVjaWF0ZWQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNBdHRyID09IFwiSFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciA9IGNsYXNzZXMuc0pVSUhlYWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzQXR0ciA9PSBcIkZcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0F0dHIgPSBjbGFzc2VzLnNKVUlGb290ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBicmVha3MgdGhlIHN0cmluZyBpbnRvIHBhcnRzIGFuZCBhcHBsaWVzIHRoZW0gYXMgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0F0dHIuaW5kZXhPZignLicpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVNwbGl0ID0gc0F0dHIuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmlkID0gYVNwbGl0WzBdLnN1YnN0cigxLCBhU3BsaXRbMF0ubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZS5jbGFzc05hbWUgPSBhU3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc0F0dHIuY2hhckF0KDApID09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZS5pZCA9IHNBdHRyLnN1YnN0cigxLCBzQXR0ci5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmNsYXNzTmFtZSA9IHNBdHRyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQuYXBwZW5kKG5OZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSAkKG5OZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJz4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogRW5kIGNvbnRhaW5lciBkaXYgKi9cclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBpbnNlcnQucGFyZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBAdG9kbyBNb3ZlIG9wdGlvbnMgaW50byB0aGVpciBvd24gcGx1Z2lucz9cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ2wnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSAmJiBmZWF0dXJlcy5iTGVuZ3RoQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogTGVuZ3RoICovXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbExlbmd0aChvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnZicgJiYgZmVhdHVyZXMuYkZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIEZpbHRlciAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIob1NldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ3InICYmIGZlYXR1cmVzLmJQcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogcFJvY2Vzc2luZyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICd0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRhYmxlICovXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICdpJyAmJiBmZWF0dXJlcy5iSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIEluZm8gKi9cclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sSW5mbyhvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAncCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogUGFnaW5hdGlvbiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZShvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIFBsdWctaW4gZmVhdHVyZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW9GZWF0dXJlcyA9IERhdGFUYWJsZS5leHQuZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGFvRmVhdHVyZXMubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gYW9GZWF0dXJlc1trXS5mbkluaXQob1NldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIEFkZCB0byB0aGUgMkQgZmVhdHVyZXMgYXJyYXkgKi9cclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYW5GZWF0dXJlcyA9IG9TZXR0aW5ncy5hYW5GZWF0dXJlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhYW5GZWF0dXJlc1tjT3B0aW9uXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWFuRmVhdHVyZXNbY09wdGlvbl0ucHVzaChmZWF0dXJlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmFwcGVuZChmZWF0dXJlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIEJ1aWx0IG91ciBET00gc3RydWN0dXJlIC0gcmVwbGFjZSB0aGUgaG9sZGluZyBkaXYgd2l0aCB3aGF0IHdlIHdhbnQgKi9cclxuICAgICAgICAgICAgaG9sZGluZy5yZXBsYWNlV2l0aChpbnNlcnQpO1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MubkhvbGRpbmcgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZSB0aGUgRE9NIHNvdXJjZSB0byBjcmVhdGUgdXAgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGxzLiBUaGUgaWRlYSBoZXJlIGlzIHRvXHJcbiAgICAgICAgICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2VcclxuICAgICAgICAgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcclxuICAgICAgICAgKiBhbnkgY29sdW1uIC8gcm93IGNvdWxkIGJlIHJlbW92ZWQgYW5kIHRoZSBuZXcgZ3JpZCBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAqICBAcGFyYW0gYXJyYXkge29iamVjdH0gYUxheW91dCBBcnJheSB0byBzdG9yZSB0aGUgY2FsY3VsYXRlZCBsYXlvdXQgaW5cclxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuVGhlYWQpIHtcclxuICAgICAgICAgICAgdmFyIG5UcnMgPSAkKG5UaGVhZCkuY2hpbGRyZW4oJ3RyJyk7XHJcbiAgICAgICAgICAgIHZhciBuVHIsIG5DZWxsO1xyXG4gICAgICAgICAgICB2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3BhbjtcclxuICAgICAgICAgICAgdmFyIGJVbmlxdWU7XHJcbiAgICAgICAgICAgIHZhciBmblNoaWZ0Q29sID0gZnVuY3Rpb24gKGEsIGksIGopIHtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gYVtpXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGo7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBhTGF5b3V0LnNwbGljZSgwLCBhTGF5b3V0Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBuVHJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYUxheW91dC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogQ2FsY3VsYXRlIGEgbGF5b3V0IGFycmF5ICovXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBuVHJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgblRyID0gblRyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlDb2x1bW4gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLi4gKi9cclxuICAgICAgICAgICAgICAgIG5DZWxsID0gblRyLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobkNlbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlREXCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlRIXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW0gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaUNvbHNwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlSb3dzcGFuID0gbkNlbGwuZ2V0QXR0cmlidXRlKCdyb3dzcGFuJykgKiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9ICghaUNvbHNwYW4gfHwgaUNvbHNwYW4gPT09IDAgfHwgaUNvbHNwYW4gPT09IDEpID8gMSA6IGlDb2xzcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUm93c3BhbiA9ICghaVJvd3NwYW4gfHwgaVJvd3NwYW4gPT09IDAgfHwgaVJvd3NwYW4gPT09IDEpID8gMSA6IGlSb3dzcGFuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woYUxheW91dCwgaSwgaUNvbHVtbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnMgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgYlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgY29sIC8gcm93c3BhbiwgY29weSB0aGUgaW5mb3JtYXRpb24gaW50byB0aGUgbGF5b3V0IGdyaWQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGlDb2xzcGFuOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBpUm93c3BhbjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUxheW91dFtpICsga11baUNvbFNoaWZ0ZWQgKyBsXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjZWxsXCI6IG5DZWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVuaXF1ZVwiOiBiVW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0W2kgKyBrXS5uVHIgPSBuVHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBhcnJheSBvZiB1bmlxdWUgdGggZWxlbWVudHMsIG9uZSBmb3IgZWFjaCBjb2x1bW5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5IZWFkZXIgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGxheW91dCBmcm9tIHRoaXMgbm9kZSAtIG9wdGlvbmFsXHJcbiAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFMYXlvdXQgdGhlYWQvdGZvb3QgbGF5b3V0IGZyb20gX2ZuRGV0ZWN0SGVhZGVyIC0gb3B0aW9uYWxcclxuICAgICAgICAgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMob1NldHRpbmdzLCBuSGVhZGVyLCBhTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHZhciBhUmV0dXJuID0gW107XHJcbiAgICAgICAgICAgIGlmICghYUxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgYUxheW91dCA9IG9TZXR0aW5ncy5hb0hlYWRlcjtcclxuICAgICAgICAgICAgICAgIGlmIChuSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYUxheW91dCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuSGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBhTGF5b3V0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBhTGF5b3V0W2ldLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhTGF5b3V0W2ldW2pdLnVuaXF1ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWFSZXR1cm5bal0gfHwgIW9TZXR0aW5ncy5iU29ydENlbGxzVG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhUmV0dXJuW2pdID0gYUxheW91dFtpXVtqXS5jZWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFSZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcclxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGNhbiBoYXZlIG11bHRpcGxlIGZvcm1zLCBhbmQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlciwgcmVxdWlyZWQgYnlcclxuICAgICAgICAgKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5CdWlsZEFqYXgob1NldHRpbmdzLCBkYXRhLCBmbikge1xyXG4gICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LSwgYWxsb3cgZm5TZXJ2ZXJEYXRhIGFuZCBldmVudCB0byBtYW5pcHVsYXRlXHJcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBvYmplY3QgYmFzZWQgZm9yIDEuMTArIGlmIHVzaW5nIHRoZSBvbGQgYXJyYXkgc2NoZW1lIHdoaWNoIGNhblxyXG4gICAgICAgICAgICAvLyBjb21lIGZyb20gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBvciBzZXJ2ZXJQYXJhbXNcclxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgJC5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgcmJyYWNrZXQgPSAvKC4qPylcXFtcXF0kLztcclxuXHJcbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsLm5hbWUubWF0Y2gocmJyYWNrZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRtcFtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wW25hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wW25hbWVdLnB1c2godmFsLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFt2YWwubmFtZV0gPSB2YWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYWpheERhdGE7XHJcbiAgICAgICAgICAgIHZhciBhamF4ID0gb1NldHRpbmdzLmFqYXg7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywganNvbiwgb1NldHRpbmdzLmpxWEhSXSk7XHJcbiAgICAgICAgICAgICAgICBmbihqc29uKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoYWpheCkgJiYgYWpheC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBhamF4RGF0YSA9IGFqYXguZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9ICQuaXNGdW5jdGlvbihhamF4RGF0YSkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGFqYXhEYXRhKGRhdGEsIG9TZXR0aW5ncykgOiAgLy8gZm4gY2FuIG1hbmlwdWxhdGUgZGF0YSBvciByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXHJcbiAgICAgICAgICAgICAgICBkYXRhID0gJC5pc0Z1bmN0aW9uKGFqYXhEYXRhKSAmJiBuZXdEYXRhID9cclxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhIDpcclxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBkYXRhLCBuZXdEYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGRhdGEgcHJvcGVydHkgYXMgd2UndmUgcmVzb2x2ZWQgaXQgYWxyZWFkeSBhbmQgZG9uJ3Qgd2FudFxyXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhamF4LmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlQWpheCA9IHtcclxuICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG9TZXR0aW5ncywgMCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmpzb24gPSBqc29uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGpzb24pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXHJcbiAgICAgICAgICAgICAgICBcImNhY2hlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvciwgdGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBudWxsLCBvU2V0dGluZ3MuanFYSFJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheSh0cnVlLCByZXQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cob1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhvU2V0dGluZ3MsIDAsICdBamF4IGVycm9yJywgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KG9TZXR0aW5ncywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgc3VibWl0dGVkIGZvciB0aGUgQVBJXHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5vQWpheERhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3ByZVhocicsIFtvU2V0dGluZ3MsIGRhdGFdKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmZuU2VydmVyRGF0YS5jYWxsKGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zQWpheFNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAkLm1hcChkYXRhLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gTmVlZCB0byBjb252ZXJ0IGJhY2sgdG8gMS45IHRyYWQgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdmFsdWU6IHZhbCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvU2V0dGluZ3Muc0FqYXhTb3VyY2UgfHwgdHlwZW9mIGFqYXggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCQuZXh0ZW5kKGJhc2VBamF4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhamF4IHx8IG9TZXR0aW5ncy5zQWpheFNvdXJjZVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihhamF4KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXMgYSBmdW5jdGlvbiAtIGxldCB0aGUgY2FsbGVyIGRlZmluZSB3aGF0IG5lZWRzIHRvIGJlIGRvbmVcclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbChpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoJC5leHRlbmQoYmFzZUFqYXgsIGFqYXgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICBhamF4LmRhdGEgPSBhamF4RGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgdGFibGUgdXNpbmcgYW4gQWpheCBjYWxsXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmJBamF4RGF0YUdldCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaURyYXcrKztcclxuICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZm5CdWlsZEFqYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFBhcmFtZXRlcnMoc2V0dGluZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhVcGRhdGVEcmF3KHNldHRpbmdzLCBqc29uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZCB1cCB0aGUgcGFyYW1ldGVycyBpbiBhbiBvYmplY3QgbmVlZGVkIGZvciBhIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcclxuICAgICAgICAgKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxyXG4gICAgICAgICAqIG1ldGhvZCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQgaW4gRGF0YVRhYmxlcyAxLjEwIHdoaWNoIHVzZXMgb2JqZWN0cyBhbmRcclxuICAgICAgICAgKiBhcnJheXMsIG9yIHRoZSAxLjktIG1ldGhvZCB3aXRoIGlzIG5hbWUgLyB2YWx1ZSBwYWlycy4gMS45IG1ldGhvZCBpcyB1c2VkIGlmXHJcbiAgICAgICAgICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcclxuICAgICAgICAgKiBvcHRpb24gaXMgc2V0LlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgcHJlU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLFxyXG4gICAgICAgICAgICAgICAgcHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxyXG4gICAgICAgICAgICAgICAgaSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXHJcbiAgICAgICAgICAgICAgICBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oc2V0dGluZ3MpLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheVN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGVuZ3RoID0gZmVhdHVyZXMuYlBhZ2luYXRlICE9PSBmYWxzZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcclxuICAgICAgICAgICAgICAgICAgICAtMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHsgJ25hbWUnOiBuYW1lLCAndmFsdWUnOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmxlIG1ldGhvZFxyXG4gICAgICAgICAgICBwYXJhbSgnc0VjaG8nLCBzZXR0aW5ncy5pRHJhdyk7XHJcbiAgICAgICAgICAgIHBhcmFtKCdpQ29sdW1ucycsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgcGFyYW0oJ3NDb2x1bW5zJywgX3BsdWNrKGNvbHVtbnMsICdzTmFtZScpLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgIHBhcmFtKCdpRGlzcGxheVN0YXJ0JywgZGlzcGxheVN0YXJ0KTtcclxuICAgICAgICAgICAgcGFyYW0oJ2lEaXNwbGF5TGVuZ3RoJywgZGlzcGxheUxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxyXG4gICAgICAgICAgICB2YXIgZCA9IHtcclxuICAgICAgICAgICAgICAgIGRyYXc6IHNldHRpbmdzLmlEcmF3LFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW10sXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogW10sXHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGlzcGxheVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBkaXNwbGF5TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBwcmVTZWFyY2guYlJlZ2V4XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbHVtblNlYXJjaCA9IHByZUNvbFNlYXJjaFtpXTtcclxuICAgICAgICAgICAgICAgIGRhdGFQcm9wID0gdHlwZW9mIGNvbHVtbi5tRGF0YSA9PSBcImZ1bmN0aW9uXCIgPyAnZnVuY3Rpb24nIDogY29sdW1uLm1EYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIGQuY29sdW1ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhUHJvcCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW4uc05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoYWJsZTogY29sdW1uLmJTZWFyY2hhYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyYWJsZTogY29sdW1uLmJTb3J0YWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbHVtblNlYXJjaC5zU2VhcmNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogY29sdW1uU2VhcmNoLmJSZWdleFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtKFwibURhdGFQcm9wX1wiICsgaSwgZGF0YVByb3ApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTZWFyY2hfJyArIGksIGNvbHVtblNlYXJjaC5zU2VhcmNoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbSgnYlJlZ2V4XycgKyBpLCBjb2x1bW5TZWFyY2guYlJlZ2V4KTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbSgnYlNlYXJjaGFibGVfJyArIGksIGNvbHVtbi5iU2VhcmNoYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JTb3J0YWJsZV8nICsgaSwgY29sdW1uLmJTb3J0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbSgnc1NlYXJjaCcsIHByZVNlYXJjaC5zU2VhcmNoKTtcclxuICAgICAgICAgICAgICAgIHBhcmFtKCdiUmVnZXgnLCBwcmVTZWFyY2guYlJlZ2V4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc29ydCwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQub3JkZXIucHVzaCh7IGNvbHVtbjogdmFsLmNvbCwgZGlyOiB2YWwuZGlyIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXJhbSgnaVNvcnRDb2xfJyArIGksIHZhbC5jb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtKCdzU29ydERpcl8nICsgaSwgdmFsLmRpcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbSgnaVNvcnRpbmdDb2xzJywgc29ydC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGVnYWN5LmFqYXggcGFyYW1ldGVyIGlzIG51bGwsIHRoZW4gd2UgYXV0b21hdGljYWxseSBkZWNpZGUgd2hpY2hcclxuICAgICAgICAgICAgLy8gZm9ybSB0byB1c2UsIGJhc2VkIG9uIHNBamF4U291cmNlXHJcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSBEYXRhVGFibGUuZXh0LmxlZ2FjeS5hamF4O1xyXG4gICAgICAgICAgICBpZiAobGVnYWN5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc0FqYXhTb3VyY2UgPyBkYXRhIDogZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxyXG4gICAgICAgICAgICAvLyBmb3JtXHJcbiAgICAgICAgICAgIHJldHVybiBsZWdhY3kgPyBkYXRhIDogZDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEYXRhIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciAobnVraW5nIHRoZSBvbGQpIGFuZCByZWRyYXcgdGhlIHRhYmxlXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBqc29uLnNFY2hvIFRyYWNraW5nIGZsYWcgZm9yIERhdGFUYWJsZXMgdG8gbWF0Y2ggcmVxdWVzdHNcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcclxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0ganNvbi5hYURhdGEgVGhlIGRhdGEgdG8gZGlzcGxheSBvbiB0aGlzIHBhZ2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3KHNldHRpbmdzLCBqc29uKSB7XHJcbiAgICAgICAgICAgIC8vIHYxLjEwIHVzZXMgY2FtZWxDYXNlIHZhcmlhYmxlcywgd2hpbGUgMS45IHVzZXMgSHVuZ2FyaWFuIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGJvdGhcclxuICAgICAgICAgICAgdmFyIGNvbXBhdCA9IGZ1bmN0aW9uIChvbGQsIG1vZGVybikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25bb2xkXSAhPT0gdW5kZWZpbmVkID8ganNvbltvbGRdIDoganNvblttb2Rlcm5dO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyhzZXR0aW5ncywganNvbik7XHJcbiAgICAgICAgICAgIHZhciBkcmF3ID0gY29tcGF0KCdzRWNobycsICdkcmF3Jyk7XHJcbiAgICAgICAgICAgIHZhciByZWNvcmRzVG90YWwgPSBjb21wYXQoJ2lUb3RhbFJlY29yZHMnLCAncmVjb3Jkc1RvdGFsJyk7XHJcbiAgICAgICAgICAgIHZhciByZWNvcmRzRmlsdGVyZWQgPSBjb21wYXQoJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRyYXcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBvdXQgb2Ygc2VxdWVuY2UgcmV0dXJuc1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYXcgKiAxIDwgc2V0dGluZ3MuaURyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhdyA9IGRyYXcgKiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZm5DbGVhclRhYmxlKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHBhcnNlSW50KHJlY29yZHNGaWx0ZXJlZCwgMTApO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF9mbkFkZERhdGEoc2V0dGluZ3MsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgSlNPTiBkYXRhIHNvdXJjZSB0byB1c2UgZm9yIGRyYXdpbmcgYSB0YWJsZS4gVXNpbmdcclxuICAgICAgICAgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXHJcbiAgICAgICAgICogc291cmNlIG9iamVjdCwgb3IgZnJvbSBhIHByb2Nlc3NpbmcgZnVuY3Rpb24uXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxyXG4gICAgICAgICAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5BamF4RGF0YVNyYyhvU2V0dGluZ3MsIGpzb24pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3Qob1NldHRpbmdzLmFqYXgpICYmIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYWpheC5kYXRhU3JjIDpcclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zQWpheERhdGFQcm9wOyAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS5cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLiBJbiBvcmRlciB0byByZWFkIGZyb20gYWFEYXRhLCBjaGVjayBpZiB0aGVcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBoYXMgYmVlbiBjaGFuZ2VkLCBpZiBub3QsIGNoZWNrIGZvciBhYURhdGFcclxuICAgICAgICAgICAgaWYgKGRhdGFTcmMgPT09ICdkYXRhJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhU3JjICE9PSBcIlwiID9cclxuICAgICAgICAgICAgICAgIF9mbkdldE9iamVjdERhdGFGbihkYXRhU3JjKShqc29uKSA6XHJcbiAgICAgICAgICAgICAgICBqc29uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIGZpbHRlcmluZyB0ZXh0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBGaWx0ZXIgY29udHJvbCBlbGVtZW50XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcclxuICAgICAgICAgICAgdmFyIHRhYmxlSWQgPSBzZXR0aW5ncy5zVGFibGVJZDtcclxuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gc2V0dGluZ3Mub0xhbmd1YWdlO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cIicgKyBjbGFzc2VzLnNGaWx0ZXJJbnB1dCArICdcIi8+JztcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBsYW5ndWFnZS5zU2VhcmNoO1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL19JTlBVVF8vKSA/XHJcbiAgICAgICAgICAgICAgICBzdHIucmVwbGFjZSgnX0lOUFVUXycsIGlucHV0KSA6XHJcbiAgICAgICAgICAgICAgICBzdHIgKyBpbnB1dDtcclxuXHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICAgICAgICAgICAnaWQnOiAhZmVhdHVyZXMuZiA/IHRhYmxlSWQgKyAnX2ZpbHRlcicgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zRmlsdGVyXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxsYWJlbC8+JykuYXBwZW5kKHN0cikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlYXJjaEZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBmZWF0dXJlcy5mO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxyXG5cclxuICAgICAgICAgICAgICAgIC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb21wbGV0ZShzZXR0aW5ncywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogdmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJSZWdleFwiOiBwcmV2aW91c1NlYXJjaC5iUmVnZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNtYXJ0XCI6IHByZXZpb3VzU2VhcmNoLmJTbWFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHByZXZpb3VzU2VhcmNoLmJDYXNlSW5zZW5zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byByZWRyYXcsIHdpdGhvdXQgcmVzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2VhcmNoRGVsYXkgOlxyXG4gICAgICAgICAgICAgICAgX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT09ICdzc3AnID9cclxuICAgICAgICAgICAgICAgICAgICA0MDAgOlxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcblxyXG4gICAgICAgICAgICB2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcclxuICAgICAgICAgICAgICAgIC52YWwocHJldmlvdXNTZWFyY2guc1NlYXJjaClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdwbGFjZWhvbGRlcicsIGxhbmd1YWdlLnNTZWFyY2hQbGFjZWhvbGRlcilcclxuICAgICAgICAgICAgICAgIC5vbihcclxuICAgICAgICAgICAgICAgICAgICAna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoRGVsYXkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5UaHJvdHRsZShzZWFyY2hGbiwgc2VhcmNoRGVsYXkpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRm5cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5vbigna2V5cHJlc3MuRFQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIFByZXZlbnQgZm9ybSBzdWJtaXNzaW9uICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGFibGVJZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGVsZW1lbnRzIHdoZW5ldmVyIHRoZSB0YWJsZSBpcyBmaWx0ZXJlZFxyXG4gICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkub24oJ3NlYXJjaC5kdC5EVCcsIGZ1bmN0aW9uIChldiwgcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4uLlxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqcUZpbHRlclswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFGaWx0ZXIudmFsKHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2VhcmNoIHNlYXJjaCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZShvU2V0dGluZ3MsIG9JbnB1dCwgaUZvcmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XHJcbiAgICAgICAgICAgIHZhciBhb1ByZXZTZWFyY2ggPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xyXG4gICAgICAgICAgICB2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKG9GaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cclxuICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLnNTZWFyY2ggPSBvRmlsdGVyLnNTZWFyY2g7XHJcbiAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5iUmVnZXggPSBvRmlsdGVyLmJSZWdleDtcclxuICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xyXG4gICAgICAgICAgICAgICAgb1ByZXZTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZSA9IG9GaWx0ZXIuYkNhc2VJbnNlbnNpdGl2ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGZuUmVnZXggPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYkVzY2FwZVJlZ2V4IG9wdGlvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG8uYkVzY2FwZVJlZ2V4ICE9PSB1bmRlZmluZWQgPyAhby5iRXNjYXBlUmVnZXggOiBvLmJSZWdleDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cclxuICAgICAgICAgICAgLy8gQHRvZG8gQXMgcGVyIHNvcnQgLSBjYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGFuIGV2ZW50IGhhbmRsZXI/XHJcbiAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzKG9TZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvKiBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGFsbCBmaWx0ZXJpbmcgaXMgZG9uZSBieSB0aGUgc2VydmVyLCBzbyBubyBwb2ludCBoYW5naW5nIGFyb3VuZCBoZXJlICovXHJcbiAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKG9TZXR0aW5ncykgIT0gJ3NzcCcpIHtcclxuICAgICAgICAgICAgICAgIC8qIEdsb2JhbCBmaWx0ZXIgKi9cclxuICAgICAgICAgICAgICAgIF9mbkZpbHRlcihvU2V0dGluZ3MsIG9JbnB1dC5zU2VhcmNoLCBpRm9yY2UsIGZuUmVnZXgob0lucHV0KSwgb0lucHV0LmJTbWFydCwgb0lucHV0LmJDYXNlSW5zZW5zaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgZm5TYXZlRmlsdGVyKG9JbnB1dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogTm93IGRvIHRoZSBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXIgKi9cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW9QcmV2U2VhcmNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29sdW1uKG9TZXR0aW5ncywgYW9QcmV2U2VhcmNoW2ldLnNTZWFyY2gsIGksIGZuUmVnZXgoYW9QcmV2U2VhcmNoW2ldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW9QcmV2U2VhcmNoW2ldLmJTbWFydCwgYW9QcmV2U2VhcmNoW2ldLmJDYXNlSW5zZW5zaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIEN1c3RvbSBmaWx0ZXJpbmcgKi9cclxuICAgICAgICAgICAgICAgIF9mbkZpbHRlckN1c3RvbShvU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm5TYXZlRmlsdGVyKG9JbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gd2UgaGF2ZSBiZWVuIGZpbHRlcmluZyAqL1xyXG4gICAgICAgICAgICBvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBseSBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9uc1xyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckN1c3RvbShzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xyXG4gICAgICAgICAgICB2YXIgZGlzcGxheVJvd3MgPSBzZXR0aW5ncy5haURpc3BsYXk7XHJcbiAgICAgICAgICAgIHZhciByb3csIHJvd0lkeDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvb3Agb3ZlciBlYWNoIHJvdyBhbmQgc2VlIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IGRpc3BsYXlSb3dzLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93SWR4ID0gZGlzcGxheVJvd3Nbal07XHJcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldKHNldHRpbmdzLCByb3cuX2FGaWx0ZXJEYXRhLCByb3dJZHgsIHJvdy5fYURhdGEsIGopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3dJZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBhcnJheVxyXG4gICAgICAgICAgICAgICAgZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICQubWVyZ2UoZGlzcGxheVJvd3MsIHJvd3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlsdGVyIHRoZSB0YWJsZSBvbiBhIHBlci1jb2x1bW4gYmFzaXNcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gY29sdW1uIHRvIGZpbHRlclxyXG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBzZWFyY2ggc3RyaW5nIGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxyXG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxyXG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDb2x1bW4oc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoc2VhcmNoU3RyID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcclxuICAgICAgICAgICAgdmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKHNlYXJjaFN0ciwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW2Rpc3BsYXlbaV1dLl9hRmlsdGVyRGF0YVtjb2xJZHhdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChycFNlYXJjaC50ZXN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goZGlzcGxheVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IG91dDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaWx0ZXIgdGhlIGRhdGEgdGFibGUgYmFzZWQgb24gdXNlciBpbnB1dCBhbmQgZHJhdyB0aGUgdGFibGVcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBmb3JjZSBvcHRpb25hbCAtIGZvcmNlIGEgcmVzZWFyY2ggb2YgdGhlIG1hc3RlciBhcnJheSAoMSkgb3Igbm90ICh1bmRlZmluZWQgb3IgMClcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBzbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBjYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXIoc2V0dGluZ3MsIGlucHV0LCBmb3JjZSwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgdmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSk7XHJcbiAgICAgICAgICAgIHZhciBwcmV2U2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2g7XHJcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xyXG4gICAgICAgICAgICB2YXIgZGlzcGxheSwgaW52YWxpZGF0ZWQsIGk7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byB0YWtlIGFjY291bnQgb2YgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnMgLSBhbHdheXMgZmlsdGVyXHJcbiAgICAgICAgICAgIGlmIChEYXRhVGFibGUuZXh0LnNlYXJjaC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcclxuICAgICAgICAgICAgaW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBibGFuayAtIHdlIGp1c3Qgd2FudCB0aGUgZnVsbCBkYXRhIHNldFxyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5ldyBzZWFyY2ggLSBzdGFydCBmcm9tIHRoZSBtYXN0ZXIgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkYXRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlNlYXJjaC5sZW5ndGggPiBpbnB1dC5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5pbmRleE9mKHByZXZTZWFyY2gpICE9PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYlNvcnRlZCAvLyBPbiByZXNvcnQsIHRoZSBkaXNwbGF5IG1hc3RlciBuZWVkcyB0byBiZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWZpbHRlcmVkIHNpbmNlIGluZGV4ZXMgd2lsbCBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhlIGRpc3BsYXkgYXJyYXlcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpc3BsYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnBTZWFyY2gudGVzdChzZXR0aW5ncy5hb0RhdGFbZGlzcGxheVtpXV0uX3NGaWx0ZXJSb3cpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goZGlzcGxheVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGZpbHRlcmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1NlYXJjaCBzdHJpbmcgdG8gc2VhcmNoIGZvclxyXG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XHJcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7UmVnRXhwfSBjb25zdHJ1Y3RlZCBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKHNlYXJjaCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgc2VhcmNoID0gcmVnZXggP1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoIDpcclxuICAgICAgICAgICAgICAgIF9mbkVzY2FwZVJlZ2V4KHNlYXJjaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc21hcnQpIHtcclxuICAgICAgICAgICAgICAgIC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxyXG4gICAgICAgICAgICAgICAgICogd29yZCBvcmRlci4gV2UgYWxzbyB3YW50IGRvdWJsZSBxdW90ZWQgdGV4dCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdvcmRcclxuICAgICAgICAgICAgICAgICAqIG9yZGVyIGlzIGltcG9ydGFudCAtIGEgbGEgZ29vZ2xlLiBTbyB0aGlzIGlzIHdoYXQgd2Ugd2FudCB0b1xyXG4gICAgICAgICAgICAgICAgICogZ2VuZXJhdGU6XHJcbiAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAqIF4oPz0uKj9cXGJvbmVcXGIpKD89Lio/XFxidHdvIHRocmVlXFxiKSg/PS4qP1xcYmZvdXJcXGIpLiokXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBhID0gJC5tYXAoc2VhcmNoLm1hdGNoKC9cIlteXCJdK1wifFteIF0rL2cpIHx8IFsnJ10sIGZ1bmN0aW9uICh3b3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQuY2hhckF0KDApID09PSAnXCInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gd29yZC5tYXRjaCgvXlwiKC4qKVwiJC8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmQucmVwbGFjZSgnXCInLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSAnXig/PS4qPycgKyBhLmpvaW4oJykoPz0uKj8nKSArICcpLiokJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoLCBjYXNlSW5zZW5zaXRpdmUgPyAnaScgOiAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXHJcbiAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xyXG5cclxuICAgICAgICB2YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcclxuICAgICAgICB2YXIgX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID0gX19maWx0ZXJfZGl2LnRleHRDb250ZW50ICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlsdGVyaW5nIGRhdGEgZm9yIGVhY2ggcm93IGlmIG5lZWRlZCAoYnkgaW52YWxpZGF0aW9uIG9yIGZpcnN0IHJ1bilcclxuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uO1xyXG4gICAgICAgICAgICB2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XHJcbiAgICAgICAgICAgIHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xyXG4gICAgICAgICAgICB2YXIgd2FzSW52YWxpZGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcm93Ll9hRmlsdGVyRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGEgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gY29sdW1ucy5sZW5ndGg7IGogPCBqZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5iU2VhcmNoYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaSwgaiwgJ2ZpbHRlcicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb21hdHRlcnNbY29sdW1uLnNUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gZm9tYXR0ZXJzW2NvbHVtbi5zVHlwZV0oY2VsbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIDEuMTAgaXMgc3RyaW5nIGJhc2VkLiBJbiAxLjExIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbERhdGEgIT09ICdzdHJpbmcnICYmIGNlbGxEYXRhLnRvU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGVyZSBpcyBhbiBIVE1MIGVudGl0eSBpbiB0aGUgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGRlY29kZSBpdCBzbyBzb3J0aW5nIHdvcmtzIGFzIGV4cGVjdGVkLiBOb3RlIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ldGhvZCB1c2VkIGhlcmUgaXMgbXVjaCBmYXN0ZXIgaHR0cDovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19maWx0ZXJfZGl2LmlubmVyVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gY2VsbERhdGEucmVwbGFjZSgvW1xcclxcbl0vZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhLnB1c2goY2VsbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9zRmlsdGVyUm93ID0gZmlsdGVyRGF0YS5qb2luKCcgICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHdhc0ludmFsaWRhdGVkO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnQgZnJvbSB0aGUgaW50ZXJuYWwgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsQ2FzZSBmb3IgZXh0ZXJuYWxcclxuICAgICAgICAgKiBpbnRlcmFjdGlvblxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IEludmVydGVkIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5TZWFyY2hUb0NhbWVsKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBvYmouc1NlYXJjaCxcclxuICAgICAgICAgICAgICAgIHNtYXJ0OiBvYmouYlNtYXJ0LFxyXG4gICAgICAgICAgICAgICAgcmVnZXg6IG9iai5iUmVnZXgsXHJcbiAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IG9iai5iQ2FzZUluc2Vuc2l0aXZlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnQgZnJvbSBjYW1lbENhc2Ugbm90YXRpb24gdG8gdGhlIGludGVybmFsIEh1bmdhcmlhbi4gV2UgY291bGQgdXNlIHRoZVxyXG4gICAgICAgICAqIEh1bmdhcmlhbiBjb252ZXJ0IGZ1bmN0aW9uIGhlcmUsIGJ1dCB0aGlzIGlzIGNsZWFuZXJcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU2VhcmNoVG9IdW5nKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc1NlYXJjaDogb2JqLnNlYXJjaCxcclxuICAgICAgICAgICAgICAgIGJTbWFydDogb2JqLnNtYXJ0LFxyXG4gICAgICAgICAgICAgICAgYlJlZ2V4OiBvYmoucmVnZXgsXHJcbiAgICAgICAgICAgICAgICBiQ2FzZUluc2Vuc2l0aXZlOiBvYmouY2FzZUluc2Vuc2l0aXZlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIGluZm8gZGlzcGxheVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIHRpZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxyXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pLFxyXG4gICAgICAgICAgICAgICAgbiA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcclxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAhbm9kZXMgPyB0aWQgKyAnX2luZm8nIDogbnVsbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZm5cIjogX2ZuVXBkYXRlSW5mbyxcclxuICAgICAgICAgICAgICAgICAgICBcInNOYW1lXCI6IFwiaW5mb3JtYXRpb25cIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgblxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyb2xlJywgJ3N0YXR1cycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XHJcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRpZCArICdfaW5mbycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gblswXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnRzIGluIHRoZSBkaXNwbGF5XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5VcGRhdGVJbmZvKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIC8qIFNob3cgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlICovXHJcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmk7XHJcbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCArIDEsXHJcbiAgICAgICAgICAgICAgICBlbmQgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuICAgICAgICAgICAgICAgIG1heCA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXHJcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcclxuICAgICAgICAgICAgICAgIG91dCA9IHRvdGFsID9cclxuICAgICAgICAgICAgICAgICAgICBsYW5nLnNJbmZvIDpcclxuICAgICAgICAgICAgICAgICAgICBsYW5nLnNJbmZvRW1wdHk7XHJcblxyXG4gICAgICAgICAgICBpZiAodG90YWwgIT09IG1heCkge1xyXG4gICAgICAgICAgICAgICAgLyogUmVjb3JkIHNldCBhZnRlciBmaWx0ZXJpbmcgKi9cclxuICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyBsYW5nLnNJbmZvRmlsdGVyZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xyXG4gICAgICAgICAgICBvdXQgKz0gbGFuZy5zSW5mb1Bvc3RGaXg7XHJcbiAgICAgICAgICAgIG91dCA9IF9mbkluZm9NYWNyb3Moc2V0dGluZ3MsIG91dCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBsYW5nLmZuSW5mb0NhbGxiYWNrO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG91dCA9IGNhbGxiYWNrLmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBvdXRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICQobm9kZXMpLmh0bWwob3V0KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZm5JbmZvTWFjcm9zKHNldHRpbmdzLCBzdHIpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXMgdXNlZCBvbmx5XHJcbiAgICAgICAgICAgIC8vIGludGVybmFsbHlcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcixcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKyAxLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdmlzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxyXG4gICAgICAgICAgICAgICAgYWxsID0gbGVuID09PSAtMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHIuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fU1RBUlRfL2csIGZvcm1hdHRlci5jYWxsKHNldHRpbmdzLCBzdGFydCkpLlxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvX0VORF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpKSkuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fTUFYXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSkpLlxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvX1RPVEFMXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgdmlzKSkuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fUEFHRV8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoc3RhcnQgLyBsZW4pKSkuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fUEFHRVNfL2csIGZvcm1hdHRlci5jYWxsKHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKHZpcyAvIGxlbikpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Jbml0aWFsaXNlKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBpTGVuLCBpQWpheFN0YXJ0ID0gc2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLCBjb2x1bW47XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcclxuICAgICAgICAgICAgdmFyIGRlZmVyTG9hZGluZyA9IHNldHRpbmdzLmJEZWZlckxvYWRpbmc7IC8vIHZhbHVlIG1vZGlmaWVkIGJ5IHRoZSBkcmF3XHJcblxyXG4gICAgICAgICAgICAvKiBFbnN1cmUgdGhhdCB0aGUgdGFibGUgZGF0YSBpcyBmdWxseSBpbml0aWFsaXNlZCAqL1xyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmJJbml0aWFsaXNlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF9mbkluaXRpYWxpc2Uoc2V0dGluZ3MpOyB9LCAyMDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBTaG93IHRoZSBkaXNwbGF5IEhUTUwgb3B0aW9ucyAqL1xyXG4gICAgICAgICAgICBfZm5BZGRPcHRpb25zSHRtbChzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvKiBCdWlsZCBhbmQgZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGUgKi9cclxuICAgICAgICAgICAgX2ZuQnVpbGRIZWFkKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyKTtcclxuICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cclxuICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLyogQ2FsY3VsYXRlIHNpemVzIGZvciBjb2x1bW5zICovXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iQXV0b1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ublRoLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29sdW1uLnNXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ3ByZUluaXQnLCBbc2V0dGluZ3NdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRlZmF1bHQgc29ydGluZyByZXF1aXJlZCAtIGxldCdzIGRvIGl0LiBUaGUgc29ydCBmdW5jdGlvblxyXG4gICAgICAgICAgICAvLyB3aWxsIGRvIHRoZSBkcmF3aW5nIGZvciB1cy4gT3RoZXJ3aXNlIHdlIGRyYXcgdGhlIHRhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIEFqYXggc291cmNlIC0gdGhpcyBhbGxvd3MgdGhlIHRhYmxlIHRvIGxvb2sgaW5pdGlhbGlzZWQgZm9yIEFqYXggc291cmNpbmdcclxuICAgICAgICAgICAgLy8gZGF0YSAoc2hvdyAnbG9hZGluZycgbWVzc2FnZSBwb3NzaWJseSlcclxuICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaW5pdCBjb21wbGV0ZSBpcyBkb25lIGJ5IF9mbkFqYXhVcGRhdGVEcmF3XHJcbiAgICAgICAgICAgIHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZShzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhU3JjICE9ICdzc3AnIHx8IGRlZmVyTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWpheCBzb3VyY2UgbG9hZCB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTcmMgPT0gJ2FqYXgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4KHNldHRpbmdzLCBbXSwgZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR290IHRoZSBkYXRhIC0gYWRkIGl0IHRvIHRoZSB0YWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYURhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGEoc2V0dGluZ3MsIGFEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGluaXQgZGlzcGxheSBmb3IgY29va2llIHNhdmluZy4gV2UndmUgYWxyZWFkeSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZmlsdGVyLCBhbmQgdGhlcmVmb3JlIGNsZWFyZWQgaXQgYmVmb3JlLiBTbyB3ZSBuZWVkIHRvIG1ha2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYXBwZWFyICdmcmVzaCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBpQWpheFN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRDb21wbGV0ZShzZXR0aW5ncywganNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBfZm5Jbml0Q29tcGxldGUoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IFtqc29uXSBKU09OIGZyb20gdGhlIHNlcnZlciB0aGF0IGNvbXBsZXRlZCB0aGUgdGFibGUsIGlmIHVzaW5nIEFqYXggc291cmNlXHJcbiAgICAgICAgICogICAgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIChvcHRpb25hbClcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzLCBqc29uKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gZGF0YSB3YXMgYWRkZWQgYWZ0ZXIgdGhlIGluaXRpYWxpc2F0aW9uIChkYXRhIG9yIEFqYXgpIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6aW5nXHJcbiAgICAgICAgICAgIGlmIChqc29uIHx8IHNldHRpbmdzLm9Jbml0LmFhRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncGx1Z2luLWluaXQnLCBbc2V0dGluZ3MsIGpzb25dKTtcclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIFtzZXR0aW5ncywganNvbl0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkxlbmd0aENoYW5nZShzZXR0aW5ncywgdmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoID0gbGVuO1xyXG5cclxuICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XHJcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2xlbmd0aCcsIFtzZXR0aW5ncywgbGVuXSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHVzZXIgZGlzcGxheSBsZW5ndGggY2hhbmdpbmdcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBEaXNwbGF5IGxlbmd0aCBmZWF0dXJlIG5vZGVcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxMZW5ndGgoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMsXHJcbiAgICAgICAgICAgICAgICB0YWJsZUlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXHJcbiAgICAgICAgICAgICAgICBtZW51ID0gc2V0dGluZ3MuYUxlbmd0aE1lbnUsXHJcbiAgICAgICAgICAgICAgICBkMiA9ICQuaXNBcnJheShtZW51WzBdKSxcclxuICAgICAgICAgICAgICAgIGxlbmd0aHMgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxyXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlbGVjdCA9ICQoJzxzZWxlY3QvPicsIHtcclxuICAgICAgICAgICAgICAgICduYW1lJzogdGFibGVJZCArICdfbGVuZ3RoJyxcclxuICAgICAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcclxuICAgICAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzZXMuc0xlbmd0aFNlbGVjdFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBsZW5ndGhzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RbMF1baV0gPSBuZXcgT3B0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYW5ndWFnZVtpXSA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcihsYW5ndWFnZVtpXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVtpXSxcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGhzW2ldXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGl2ID0gJCgnPGRpdj48bGFiZWwvPjwvZGl2PicpLmFkZENsYXNzKGNsYXNzZXMuc0xlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWFuRmVhdHVyZXMubCkge1xyXG4gICAgICAgICAgICAgICAgZGl2WzBdLmlkID0gdGFibGVJZCArICdfbGVuZ3RoJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGl2LmNoaWxkcmVuKCkuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub0xhbmd1YWdlLnNMZW5ndGhNZW51LnJlcGxhY2UoJ19NRU5VXycsIHNlbGVjdFswXS5vdXRlckhUTUwpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYW4ndCB1c2UgYHNlbGVjdGAgdmFyaWFibGUgYXMgdXNlciBtaWdodCBwcm92aWRlIHRoZWlyIG93biBhbmQgdGhlXHJcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcclxuICAgICAgICAgICAgJCgnc2VsZWN0JywgZGl2KVxyXG4gICAgICAgICAgICAgICAgLnZhbChzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAub24oJ2NoYW5nZS5EVCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIG5vZGUgdmFsdWUgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcyB0aGUgdGFibGUncyBsZW5ndGhcclxuICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLm9uKCdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKCdzZWxlY3QnLCBkaXYpLnZhbChsZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaXZbMF07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcbiAgICAgICAgICogTm90ZSB0aGF0IG1vc3Qgb2YgdGhlIHBhZ2luZyBsb2dpYyBpcyBkb25lIGluXHJcbiAgICAgICAgICogRGF0YVRhYmxlLmV4dC5wYWdlclxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZGVmYXVsdCBwYWdpbmF0aW9uXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IFBhZ2luYXRpb24gZmVhdHVyZSBub2RlXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luID0gRGF0YVRhYmxlLmV4dC5wYWdlclt0eXBlXSxcclxuICAgICAgICAgICAgICAgIG1vZGVybiA9IHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicsXHJcbiAgICAgICAgICAgICAgICByZWRyYXcgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBub2RlID0gJCgnPGRpdi8+JykuYWRkQ2xhc3Moc2V0dGluZ3Mub0NsYXNzZXMuc1BhZ2luZyArIHR5cGUpWzBdLFxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcztcclxuXHJcbiAgICAgICAgICAgIGlmICghbW9kZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW4uZm5Jbml0KHNldHRpbmdzLCBub2RlLCByZWRyYXcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBBZGQgYSBkcmF3IGNhbGxiYWNrIGZvciB0aGUgcGFnaW5hdGlvbiBvbiBmaXJzdCBpbnN0YW5jZSwgdG8gdXBkYXRlIHRoZSBwYWdpbmcgZGlzcGxheSAqL1xyXG4gICAgICAgICAgICBpZiAoIWZlYXR1cmVzLnApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuaWQgPSBzZXR0aW5ncy5zVGFibGVJZCArICdfcGFnaW5hdGUnO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZm5cIjogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2Rlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsID0gbGVuID09PSAtMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlID0gYWxsID8gMCA6IE1hdGguY2VpbChzdGFydCAvIGxlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXMgPSBhbGwgPyAxIDogTWF0aC5jZWlsKHZpc1JlY29yZHMgLyBsZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBwbHVnaW4ocGFnZSwgcGFnZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBmZWF0dXJlcy5wLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVuZGVyZXIoc2V0dGluZ3MsICdwYWdlQnV0dG9uJykoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLCBmZWF0dXJlcy5wW2ldLCBpLCBidXR0b25zLCBwYWdlLCBwYWdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4uZm5VcGRhdGUoc2V0dGluZ3MsIHJlZHJhdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJwYWdpbmF0aW9uXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludH0gYWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsXHJcbiAgICAgICAgICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcclxuICAgICAgICAgKiAgQHBhcmFtIFtib29sXSByZWRyYXcgQXV0b21hdGljYWxseSBkcmF3IHRoZSB1cGRhdGUgb3Igbm90XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtib29sfSB0cnVlIHBhZ2UgaGFzIGNoYW5nZWQsIGZhbHNlIC0gbm8gY2hhbmdlXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3KSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVjb3JkcyA9PT0gMCB8fCBsZW4gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBhY3Rpb24gKiBsZW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcmVjb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJmaXJzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwicHJldmlvdXNcIikge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBsZW4gPj0gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgLSBsZW4gOlxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJuZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIGxlbiA8IHJlY29yZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwibGFzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3IoKHJlY29yZHMgLSAxKSAvIGxlbikgKiBsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfZm5Mb2coc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIiArIGFjdGlvbiwgNSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ3BhZ2UnLCBbc2V0dGluZ3NdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IFByb2Nlc3NpbmcgZWxlbWVudFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmcoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQoJzxkaXYvPicsIHtcclxuICAgICAgICAgICAgICAgICdpZCc6ICFzZXR0aW5ncy5hYW5GZWF0dXJlcy5yID8gc2V0dGluZ3Muc1RhYmxlSWQgKyAnX3Byb2Nlc3NpbmcnIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNQcm9jZXNzaW5nXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuaHRtbChzZXR0aW5ncy5vTGFuZ3VhZ2Uuc1Byb2Nlc3NpbmcpXHJcbiAgICAgICAgICAgICAgICAuaW5zZXJ0QmVmb3JlKHNldHRpbmdzLm5UYWJsZSlbMF07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzcGxheSBvciBoaWRlIHRoZSBwcm9jZXNzaW5nIGluZGljYXRvclxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgc2hvdykge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLmFhbkZlYXR1cmVzLnIpLmNzcygnZGlzcGxheScsIHNob3cgPyAnYmxvY2snIDogJ25vbmUnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncHJvY2Vzc2luZycsIFtzZXR0aW5ncywgc2hvd10pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gTm9kZSB0byBhZGQgdG8gdGhlIERPTVxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFRhYmxlKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgQVJJQSBncmlkIHJvbGUgdG8gdGhlIHRhYmxlXHJcbiAgICAgICAgICAgIHRhYmxlLmF0dHIoJ3JvbGUnLCAnZ3JpZCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzY3JvbGwuc1ggPT09ICcnICYmIHNjcm9sbC5zWSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5uVGFibGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxYID0gc2Nyb2xsLnNYO1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcclxuICAgICAgICAgICAgdmFyIGNhcHRpb24gPSB0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGhlYWRlckNsb25lID0gJCh0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpKTtcclxuICAgICAgICAgICAgdmFyIGZvb3RlckNsb25lID0gJCh0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpKTtcclxuICAgICAgICAgICAgdmFyIGZvb3RlciA9IHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpO1xyXG4gICAgICAgICAgICB2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXMgPyBudWxsIDogX2ZuU3RyaW5nVG9Dc3Mocyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvb3Rlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvb3RlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcclxuICAgICAgICAgICAgICogIGRpdiAtIHNjcm9sbGVyXHJcbiAgICAgICAgICAgICAqICAgIGRpdiAtIHNjcm9sbCBoZWFkXHJcbiAgICAgICAgICAgICAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcclxuICAgICAgICAgICAgICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcclxuICAgICAgICAgICAgICogICAgICAgICAgdGhlYWQgLSB0aGVhZFxyXG4gICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxyXG4gICAgICAgICAgICAgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcclxuICAgICAgICAgICAgICogICAgICAgIHRoZWFkIC0gdGhlYWQgY2xvbmUgZm9yIHNpemluZ1xyXG4gICAgICAgICAgICAgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxyXG4gICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxyXG4gICAgICAgICAgICAgKiAgICAgIGRpdiAtIHNjcm9sbCBmb290IGlubmVyXHJcbiAgICAgICAgICAgICAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHRmb290IC0gdGZvb3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxlciA9ICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxXcmFwcGVyIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxIZWFkIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxIZWFkSW5uZXIgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsLnNYSW5uZXIgfHwgJzEwMCUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoY2FwdGlvblNpZGUgPT09ICd0b3AnID8gY2FwdGlvbiA6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxCb2R5IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNpemUoc2Nyb2xsWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0YWJsZSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlci5hcHBlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEZvb3QgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290SW5uZXIgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb290ZXJDbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoY2FwdGlvblNpZGUgPT09ICdib3R0b20nID8gY2FwdGlvbiA6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGJvZHkgaXMgc2Nyb2xsZWQsIHRoZW4gd2UgYWxzbyB3YW50IHRvIHNjcm9sbCB0aGUgaGVhZGVyc1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsWCkge1xyXG4gICAgICAgICAgICAgICAgJChzY3JvbGxCb2R5KS5vbignc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGVhZC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxGb290LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkKHNjcm9sbEJvZHkpLmNzcyhcclxuICAgICAgICAgICAgICAgIHNjcm9sbFkgJiYgc2Nyb2xsLmJDb2xsYXBzZSA/ICdtYXgtaGVpZ2h0JyA6ICdoZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsWVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MublNjcm9sbEhlYWQgPSBzY3JvbGxIZWFkO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5uU2Nyb2xsQm9keSA9IHNjcm9sbEJvZHk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uIHJlZHJhdyAtIGFsaWduIGNvbHVtbnNcclxuICAgICAgICAgICAgc2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBcImZuXCI6IF9mblNjcm9sbERyYXcsXHJcbiAgICAgICAgICAgICAgICBcInNOYW1lXCI6IFwic2Nyb2xsaW5nXCJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsZXJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaGVhZGVyLCBmb290ZXIgYW5kIGJvZHkgdGFibGVzIGZvciByZXNpemluZyAtIGkuZS4gY29sdW1uXHJcbiAgICAgICAgICogYWxpZ25tZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2VsY29tZSB0byB0aGUgbW9zdCBob3JyaWJsZSBmdW5jdGlvbiBEYXRhVGFibGVzLiBUaGUgcHJvY2VzcyB0aGF0IHRoaXNcclxuICAgICAgICAgKiBmdW5jdGlvbiBmb2xsb3dzIGlzIGJhc2ljYWxseTpcclxuICAgICAgICAgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XHJcbiAgICAgICAgICogICAyLiBUYWtlIGxpdmUgbWVhc3VyZW1lbnRzIGZyb20gdGhlIERPTVxyXG4gICAgICAgICAqICAgMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50cyB0byBhbGlnbiB0aGUgY29sdW1uc1xyXG4gICAgICAgICAqICAgNC4gQ2xlYW4gdXBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAvLyBHaXZlbiB0aGF0IHRoaXMgaXMgc3VjaCBhIG1vbnN0ZXIgZnVuY3Rpb24sIGEgbG90IG9mIHZhcmlhYmxlcyBhcmUgdXNlXHJcbiAgICAgICAgICAgIC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbC5zWCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbC5zWSxcclxuICAgICAgICAgICAgICAgIGJhcldpZHRoID0gc2Nyb2xsLmlCYXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIGRpdkhlYWRlciA9ICQoc2V0dGluZ3MublNjcm9sbEhlYWQpLFxyXG4gICAgICAgICAgICAgICAgZGl2SGVhZGVyU3R5bGUgPSBkaXZIZWFkZXJbMF0uc3R5bGUsXHJcbiAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lciA9IGRpdkhlYWRlci5jaGlsZHJlbignZGl2JyksXHJcbiAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlID0gZGl2SGVhZGVySW5uZXJbMF0uc3R5bGUsXHJcbiAgICAgICAgICAgICAgICBkaXZIZWFkZXJUYWJsZSA9IGRpdkhlYWRlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgZGl2Qm9keUVsID0gc2V0dGluZ3MublNjcm9sbEJvZHksXHJcbiAgICAgICAgICAgICAgICBkaXZCb2R5ID0gJChkaXZCb2R5RWwpLFxyXG4gICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlID0gZGl2Qm9keUVsLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgZGl2Rm9vdGVyID0gJChzZXR0aW5ncy5uU2Nyb2xsRm9vdCksXHJcbiAgICAgICAgICAgICAgICBkaXZGb290ZXJJbm5lciA9IGRpdkZvb3Rlci5jaGlsZHJlbignZGl2JyksXHJcbiAgICAgICAgICAgICAgICBkaXZGb290ZXJUYWJsZSA9IGRpdkZvb3RlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyID0gJChzZXR0aW5ncy5uVEhlYWQpLFxyXG4gICAgICAgICAgICAgICAgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSksXHJcbiAgICAgICAgICAgICAgICB0YWJsZUVsID0gdGFibGVbMF0sXHJcbiAgICAgICAgICAgICAgICB0YWJsZVN0eWxlID0gdGFibGVFbC5zdHlsZSxcclxuICAgICAgICAgICAgICAgIGZvb3RlciA9IHNldHRpbmdzLm5URm9vdCA/ICQoc2V0dGluZ3MublRGb290KSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBicm93c2VyID0gc2V0dGluZ3Mub0Jyb3dzZXIsXHJcbiAgICAgICAgICAgICAgICBpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUsXHJcbiAgICAgICAgICAgICAgICBkdEhlYWRlckNlbGxzID0gX3BsdWNrKHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcpLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyVHJnRWxzLCBmb290ZXJUcmdFbHMsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJTcmNFbHMsIGZvb3RlclNyY0VscyxcclxuICAgICAgICAgICAgICAgIGhlYWRlckNvcHksIGZvb3RlckNvcHksXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJXaWR0aHMgPSBbXSwgZm9vdGVyV2lkdGhzID0gW10sXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJDb250ZW50ID0gW10sIGZvb3RlckNvbnRlbnQgPSBbXSxcclxuICAgICAgICAgICAgICAgIGlkeCwgY29ycmVjdGlvbiwgc2FuaXR5V2lkdGgsXHJcbiAgICAgICAgICAgICAgICB6ZXJvT3V0ID0gZnVuY3Rpb24gKG5TaXplcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IG5TaXplci5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmJvcmRlclRvcFdpZHRoID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBjb2x1bW4gc2l6ZXMgYXMgdGhlIHRhYmxlIHdpZHRoIHdpbGwgaGF2ZSBjaGFuZ2VkIHRvIGFjY291bnRcclxuICAgICAgICAgICAgLy8gZm9yIHRoZSBzY3JvbGxiYXJcclxuICAgICAgICAgICAgdmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjcm9sbEJhclZpcyAhPT0gc2Nyb2xsQmFyVmlzICYmIHNldHRpbmdzLnNjcm9sbEJhclZpcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XHJcbiAgICAgICAgICAgICAgICBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhZGp1c3QgY29sdW1uIHNpemluZyB3aWxsIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIG1pbmltaXNlZCB0aGVhZCBhbmQgdGZvb3QgZWxlbWVudHMgaW4gdGhlIGlubmVyIHRhYmxlXHJcbiAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8odGFibGUpO1xyXG4gICAgICAgICAgICAgICAgZm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXHJcbiAgICAgICAgICAgICAgICBmb290ZXJTcmNFbHMgPSBmb290ZXJDb3B5LmZpbmQoJ3RyJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBjdXJyZW50IGhlYWRlciBhbmQgZm9vdGVyIGVsZW1lbnRzIGFuZCB0aGVuIHBsYWNlIGl0IGludG8gdGhlIGlubmVyIHRhYmxlXHJcbiAgICAgICAgICAgIGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8odGFibGUpO1xyXG4gICAgICAgICAgICBoZWFkZXJUcmdFbHMgPSBoZWFkZXIuZmluZCgndHInKTsgLy8gb3JpZ2luYWwgaGVhZGVyIGlzIGluIGl0cyBvd24gdGFibGVcclxuICAgICAgICAgICAgaGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xyXG4gICAgICAgICAgICBoZWFkZXJDb3B5LmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XHJcblxyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBzaXppbmcgYW5kIGFwcGx5IHRoZSBjYWxjdWxhdGVkIGNvbHVtbiB3aWR0aHNcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGVkIHNpemVzIHRvIHRoaXMgaGVhZGVyXHJcbiAgICAgICAgICAgIGlmICghc2Nyb2xsWCkge1xyXG4gICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgICAgICAgICAgZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goX2ZuR2V0VW5pcXVlVGhzKHNldHRpbmdzLCBoZWFkZXJDb3B5KSwgZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChzZXR0aW5ncywgaSk7XHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHNldHRpbmdzLmFvQ29sdW1uc1tpZHhdLnNXaWR0aDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnN0eWxlLndpZHRoID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH0sIGZvb3RlclNyY0Vscyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNpemUgdGhlIHRhYmxlIGFzIGEgd2hvbGVcclxuICAgICAgICAgICAgc2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxYID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyB4IHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXHJcbiAgICAgICAgICAgICAgICAvLyAtIHdoaWNoIGlzIHNob3VsZG4ndC4gV2hlbiB0aGVyZSBpcyBhIHNjcm9sbGJhciB3ZSBuZWVkIHRvIHRha2UgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gaW50byBhY2NvdW50LlxyXG4gICAgICAgICAgICAgICAgaWYgKGllNjcgJiYgKHRhYmxlLmZpbmQoJ3Rib2R5JykuaGVpZ2h0KCkgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlLm91dGVyV2lkdGgoKSAtIGJhcldpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB0aGUgc2FuaXR5IHdpZHRoXHJcbiAgICAgICAgICAgICAgICBzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxYSW5uZXIgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGxlZ2FjeSB4IHNjcm9sbCBpbm5lciBoYXMgYmVlbiBnaXZlbiAtIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFhJbm5lcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxyXG4gICAgICAgICAgICAgICAgc2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhpZGRlbiBoZWFkZXIgc2hvdWxkIGhhdmUgemVybyBoZWlnaHQsIHNvIHJlbW92ZSBwYWRkaW5nIGFuZCBib3JkZXJzLiBUaGVuXHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgd2lkdGggYmFzZWQgb24gdGhlIHJlYWwgaGVhZGVyc1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xyXG4gICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oemVyb091dCwgaGVhZGVyU3JjRWxzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3NcclxuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlckNvbnRlbnQucHVzaChuU2l6ZXIuaW5uZXJIVE1MKTtcclxuICAgICAgICAgICAgICAgIGhlYWRlcldpZHRocy5wdXNoKF9mblN0cmluZ1RvQ3NzKCQoblNpemVyKS5jc3MoJ3dpZHRoJykpKTtcclxuICAgICAgICAgICAgfSwgaGVhZGVyU3JjRWxzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGFsbCB3aWR0aHMgaW4gZmluYWwgcGFzc1xyXG4gICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5Ub1NpemUsIGkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgd2lkdGhzIHRvIHRoZSBEYXRhVGFibGVzIGRldGVjdGVkIGhlYWRlciBjZWxscyAtIHRoaXNcclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnRzIGNvbXBsZXggaGVhZGVycyBmcm9tIGhhdmluZyBjb250cmFkaWN0b3J5IHNpemVzIGFwcGxpZWRcclxuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoblRvU2l6ZSwgZHRIZWFkZXJDZWxscykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgblRvU2l6ZS5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgaGVhZGVyVHJnRWxzKTtcclxuXHJcbiAgICAgICAgICAgICQoaGVhZGVyU3JjRWxzKS5oZWlnaHQoMCk7XHJcblxyXG4gICAgICAgICAgICAvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xyXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oemVyb091dCwgZm9vdGVyU3JjRWxzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RlckNvbnRlbnQucHVzaChuU2l6ZXIuaW5uZXJIVE1MKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXJXaWR0aHMucHVzaChfZm5TdHJpbmdUb0NzcygkKG5TaXplcikuY3NzKCd3aWR0aCcpKSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAoblRvU2l6ZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XHJcbiAgICAgICAgICAgICAgICB9LCBmb290ZXJUcmdFbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgLy8gXCJIaWRlXCIgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRoYXQgd2UgdXNlZCBmb3IgdGhlIHNpemluZy4gV2UgbmVlZCB0byBrZWVwXHJcbiAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxyXG4gICAgICAgICAgICAvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcclxuICAgICAgICAgICAgLy8gd2lkdGggdG8gd2hhdCB0aGV5IGN1cnJlbnRseSBhcmVcclxuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIsIGkpIHtcclxuICAgICAgICAgICAgICAgIG5TaXplci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfc2l6aW5nXCIgc3R5bGU9XCJoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47XCI+JyArIGhlYWRlckNvbnRlbnRbaV0gKyAnPC9kaXY+JztcclxuICAgICAgICAgICAgICAgIG5TaXplci5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoc1tpXTtcclxuICAgICAgICAgICAgfSwgaGVhZGVyU3JjRWxzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAoblNpemVyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgblNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIiBzdHlsZT1cImhlaWdodDowO292ZXJmbG93OmhpZGRlbjtcIj4nICsgZm9vdGVyQ29udGVudFtpXSArICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcclxuICAgICAgICAgICAgICAgIH0sIGZvb3RlclNyY0Vscyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayB0aGF0IHRoZSB0YWJsZSBpcyBvZiBhIHNlbnNpYmxlIHdpZHRoLiBJZiBub3QgdGhlbiB3ZSBhcmUgZ29pbmcgdG8gZ2V0XHJcbiAgICAgICAgICAgIC8vIG1pc2FsaWdubWVudCAtIHRyeSB0byBwcmV2ZW50IHRoaXMgYnkgbm90IGFsbG93aW5nIHRoZSB0YWJsZSB0byBzaHJpbmsgYmVsb3cgaXRzIG1pbiB3aWR0aFxyXG4gICAgICAgICAgICBpZiAodGFibGUub3V0ZXJXaWR0aCgpIDwgc2FuaXR5V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaW4gd2lkdGggZGVwZW5kcyB1cG9uIGlmIHdlIGhhdmUgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgdmlzaWJsZSBvciBub3QgKi9cclxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb24gPSAoKGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKSkgP1xyXG4gICAgICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoICsgYmFyV2lkdGggOlxyXG4gICAgICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cclxuICAgICAgICAgICAgICAgIGlmIChpZTY3ICYmIChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID5cclxuICAgICAgICAgICAgICAgICAgICBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uIC0gYmFyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCA9PT0gXCJcIiB8fCBzY3JvbGxYSW5uZXIgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZm5Mb2coc2V0dGluZ3MsIDEsICdQb3NzaWJsZSBjb2x1bW4gbWlzYWxpZ25tZW50JywgNik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0aW9uID0gJzEwMCUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGRpdkJvZHlTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIDQuIENsZWFuIHVwXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoIXNjcm9sbFkpIHtcclxuICAgICAgICAgICAgICAgIC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xyXG4gICAgICAgICAgICAgICAgICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChpZTY3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlRWwub2Zmc2V0SGVpZ2h0ICsgYmFyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBGaW5hbGx5IHNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzICovXHJcbiAgICAgICAgICAgIHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgZGl2SGVhZGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcbiAgICAgICAgICAgIGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZXJlIGFyZSBzY3JvbGxiYXIgcHJlc2VudCAtIGlmIHNvIHRoZW4gd2UgbmVlZCBhIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0b1xyXG4gICAgICAgICAgICAvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXHJcbiAgICAgICAgICAgIHZhciBiU2Nyb2xsaW5nID0gdGFibGUuaGVpZ2h0KCkgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIjtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAncGFkZGluZycgKyAoYnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA/ICdMZWZ0JyA6ICdSaWdodCcpO1xyXG4gICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlW3BhZGRpbmddID0gYlNjcm9sbGluZyA/IGJhcldpZHRoICsgXCJweFwiIDogXCIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuICAgICAgICAgICAgICAgIGRpdkZvb3RlclRhYmxlWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaU91dGVyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgZGl2Rm9vdGVySW5uZXJbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICBkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCArIFwicHhcIiA6IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvcnJlY3QgRE9NIG9yZGVyaW5nIGZvciBjb2xncm91cCAtIGNvbWVzIGJlZm9yZSB0aGUgdGhlYWRcclxuICAgICAgICAgICAgdGFibGUuY2hpbGRyZW4oJ2NvbGdyb3VwJykuaW5zZXJ0QmVmb3JlKHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpKTtcclxuXHJcbiAgICAgICAgICAgIC8qIEFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIGhlYWRlciBpbiBjYXNlIHdlIGxvb3NlIHRoZSB5LXNjcm9sbGJhciAqL1xyXG4gICAgICAgICAgICBkaXZCb2R5LnNjcm9sbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXHJcbiAgICAgICAgICAgIC8vIG9ubHkgaWYgd2UgYXJlbid0IGhvbGRpbmcgdGhlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYlNvcnRlZCB8fCBzZXR0aW5ncy5iRmlsdGVyZWQpICYmICFzZXR0aW5ncy5fZHJhd0hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGRpdkJvZHlFbC5zY3JvbGxUb3AgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XHJcbiAgICAgICAgICogVEQgY2hpbGRyZW4gb2YgVFIgcm93c1xyXG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBNZXRob2QgdG8gYXBwbHkgdG8gdGhlIG9iamVjdHNcclxuICAgICAgICAgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXHJcbiAgICAgICAgICogIEBwYXJhbSBhcnJheSB7bm9kZXN9IGFuMiBBbm90aGVyIGxpc3QgKGlkZW50aWNhbCBzdHJ1Y3R1cmUgdG8gdGhlIGZpcnN0KSAtIG9wdGlvbmFsXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFwcGx5VG9DaGlsZHJlbihmbiwgYW4xLCBhbjIpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMCwgaSA9IDAsIGlMZW4gPSBhbjEubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbk5vZGUxLCBuTm9kZTI7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGlMZW4pIHtcclxuICAgICAgICAgICAgICAgIG5Ob2RlMSA9IGFuMVtpXS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgbk5vZGUyID0gYW4yID8gYW4yW2ldLmZpcnN0Q2hpbGQgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChuTm9kZTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobk5vZGUxLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKG5Ob2RlMSwgbk5vZGUyLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihuTm9kZTEsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5Ob2RlMSA9IG5Ob2RlMS5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBuTm9kZTIgPSBhbjIgPyBuTm9kZTIubmV4dFNpYmxpbmcgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiBjb2x1bW5zIGZvciB0aGUgdGFibGVcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMob1NldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgdGFibGUgPSBvU2V0dGluZ3MublRhYmxlLFxyXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGwgPSBvU2V0dGluZ3Mub1Njcm9sbCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbFkgPSBzY3JvbGwuc1ksXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxYID0gc2Nyb2xsLnNYLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsWElubmVyID0gc2Nyb2xsLnNYSW5uZXIsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyksXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxscyA9ICQoJ3RoJywgb1NldHRpbmdzLm5USGVhZCksXHJcbiAgICAgICAgICAgICAgICB0YWJsZVdpZHRoQXR0ciA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgLy8gZnJvbSBET00gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgdGFibGVDb250YWluZXIgPSB0YWJsZS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgdXNlcklucHV0cyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaSwgY29sdW1uLCBjb2x1bW5JZHgsIHdpZHRoLCBvdXRlcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgYnJvd3NlciA9IG9TZXR0aW5ncy5vQnJvd3NlcixcclxuICAgICAgICAgICAgICAgIGllNjcgPSBicm93c2VyLmJTY3JvbGxPdmVyc2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGFibGVXaWR0aEF0dHIgPSBzdHlsZVdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBDb252ZXJ0IGFueSB1c2VyIGlucHV0IHNpemVzIGludG8gcGl4ZWwgc2l6ZXMgKi9cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNXaWR0aCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aChjb2x1bW4uc1dpZHRoT3JpZywgdGFibGVDb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1c2VySW5wdXRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogSWYgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBET00gZXF1YWxzIHRoZSBudW1iZXIgdGhhdCB3ZSBoYXZlIHRvXHJcbiAgICAgICAgICAgICAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcclxuICAgICAgICAgICAgICogdGhlIHdlYi0gYnJvd3Nlci4gTm8gY3VzdG9tIHNpemVzIGNhbiBiZSBzZXQgaW4gb3JkZXIgZm9yIHRoaXMgdG8gaGFwcGVuLFxyXG4gICAgICAgICAgICAgKiBub3Igc2Nyb2xsaW5nIHVzZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChpZTY3IHx8ICF1c2VySW5wdXRzICYmICFzY3JvbGxYICYmICFzY3JvbGxZICYmXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncykgJiZcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ID09IGhlYWRlckNlbGxzLmxlbmd0aFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IF9mblZpc2libGVUb0NvbHVtbkluZGV4KG9TZXR0aW5ncywgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xJZHggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tjb2xJZHhdLnNXaWR0aCA9IF9mblN0cmluZ1RvQ3NzKGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjb25zdHJ1Y3QgYSBzaW5nbGUgcm93LCB3b3JzdCBjYXNlLCB0YWJsZSB3aXRoIHRoZSB3aWRlc3RcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgaW4gdGhlIGRhdGEsIGFzc2lnbiBhbnkgdXNlciBkZWZpbmVkIHdpZHRocywgdGhlbiBpbnNlcnQgaXQgaW50b1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIERPTSBhbmQgYWxsb3cgdGhlIGJyb3dzZXIgdG8gZG8gYWxsIHRoZSBoYXJkIHdvcmsgb2YgY2FsY3VsYXRpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRhYmxlIHdpZHRoc1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcFRhYmxlID0gJCh0YWJsZSkuY2xvbmUoKSAvLyBkb24ndCB1c2UgY2xvbmVOb2RlIC0gSUU4IHdpbGwgcmVtb3ZlIGV2ZW50cyBvbiB0aGUgbWFpbiB0YWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignaWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdGFibGUgYm9keVxyXG4gICAgICAgICAgICAgICAgdG1wVGFibGUuZmluZCgndGJvZHkgdHInKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ciA9ICQoJzx0ci8+JykuYXBwZW5kVG8odG1wVGFibGUuZmluZCgndGJvZHknKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIHRhYmxlIGhlYWRlciBhbmQgZm9vdGVyIC0gd2UgY2FuJ3QgdXNlIHRoZSBoZWFkZXIgLyBmb290ZXJcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIGNsb25lZCB0YWJsZSwgc2luY2UgaWYgc2Nyb2xsaW5nIGlzIGFjdGl2ZSwgdGhlIHRhYmxlJ3NcclxuICAgICAgICAgICAgICAgIC8vIHJlYWwgaGVhZGVyIGFuZCBmb290ZXIgYXJlIGNvbnRhaW5lZCBpbiBkaWZmZXJlbnQgdGFibGUgdGFnc1xyXG4gICAgICAgICAgICAgICAgdG1wVGFibGUuZmluZCgndGhlYWQsIHRmb290JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB0bXBUYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGFzc2lnbmVkIHdpZHRocyBmcm9tIHRoZSBmb290ZXIgKGZyb20gc2Nyb2xsaW5nKVxyXG4gICAgICAgICAgICAgICAgdG1wVGFibGUuZmluZCgndGZvb3QgdGgsIHRmb290IHRkJykuY3NzKCd3aWR0aCcsICcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxscyA9IF9mbkdldFVuaXF1ZVRocyhvU2V0dGluZ3MsIHRtcFRhYmxlLmZpbmQoJ3RoZWFkJylbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbdmlzaWJsZUNvbHVtbnNbaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxsc1tpXS5zdHlsZS53aWR0aCA9IGNvbHVtbi5zV2lkdGhPcmlnICE9PSBudWxsICYmIGNvbHVtbi5zV2lkdGhPcmlnICE9PSAnJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mblN0cmluZ1RvQ3NzKGNvbHVtbi5zV2lkdGhPcmlnKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2Nyb2xsWCB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBjb2x1bW4gd2lkdGggb3RoZXJ3aXNlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggdGhlIGNvbHVtbiByZXF1aXJlcywgdGhlbiBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChoZWFkZXJDZWxsc1tpXSkuYXBwZW5kKCQoJzxkaXYvPicpLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uLnNXaWR0aE9yaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JZHggPSB2aXNpYmxlQ29sdW1uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tjb2x1bW5JZHhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJChfZm5HZXRXaWRlc3ROb2RlKG9TZXR0aW5ncywgY29sdW1uSWR4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9uZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoY29sdW1uLnNDb250ZW50UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRpZHkgdGhlIHRlbXBvcmFyeSB0YWJsZSAtIHJlbW92ZSBuYW1lIGF0dHJpYnV0ZXMgc28gdGhlcmUgYXJlbid0XHJcbiAgICAgICAgICAgICAgICAvLyBkdXBsaWNhdGVkIGluIHRoZSBkb20gKHJhZGlvIGVsZW1lbnRzIGZvciBleGFtcGxlKVxyXG4gICAgICAgICAgICAgICAgJCgnW25hbWVdJywgdG1wVGFibGUpLnJlbW92ZUF0dHIoJ25hbWUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBoYXMgYmVlbiBidWlsdCwgYXR0YWNoIHRvIHRoZSBkb2N1bWVudCBzbyB3ZSBjYW4gd29yayB3aXRoIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gQSBob2xkaW5nIGVsZW1lbnQgaXMgdXNlZCwgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggbWluaW1hbCBoZWlnaHQsIHNvIGl0IGhhcyBubyBlZmZlY3Qgb24gaWYgdGhlIGNvbnRhaW5lciBzY3JvbGxzXHJcbiAgICAgICAgICAgICAgICAvLyBvciBub3QuIE90aGVyd2lzZSBpdCBtaWdodCB0cmlnZ2VyIHNjcm9sbGluZyB3aGVuIGl0IGFjdHVhbGx5IGlzbid0XHJcbiAgICAgICAgICAgICAgICAvLyBuZWVkZWRcclxuICAgICAgICAgICAgICAgIHZhciBob2xkZXIgPSAkKCc8ZGl2Lz4nKS5jc3Moc2Nyb2xsWCB8fCBzY3JvbGxZID9cclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHt9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0bXBUYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGFibGVDb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIChYIG9yIFkpIHdlIHdhbnQgdG8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgYXMgXHJcbiAgICAgICAgICAgICAgICAvLyBhcHByb3ByaWF0ZS4gSG93ZXZlciwgd2hlbiBub3Qgc2Nyb2xsaW5nIGxlYXZlIHRoZSB0YWJsZSB3aWR0aCBhcyBpdFxyXG4gICAgICAgICAgICAgICAgLy8gaXMuIFRoaXMgcmVzdWx0cyBpbiBzbGlnaHRseSBkaWZmZXJlbnQsIGJ1dCBJIHRoaW5rIGNvcnJlY3QgYmVoYXZpb3VyXHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCAmJiBzY3JvbGxYSW5uZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aChzY3JvbGxYSW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmNzcygnd2lkdGgnLCAnYXV0bycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHdpZHRoIGF0dHJpYnV0ZSBvciBzdHlsZSwgdGhlbiBhbGxvdyB0aGUgdGFibGUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXBUYWJsZS53aWR0aCgpIDwgdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggJiYgdGFibGVXaWR0aEF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVDb250YWluZXIuY2xpZW50V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aCh0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWJsZVdpZHRoQXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLndpZHRoKHRhYmxlV2lkdGhBdHRyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggY29sdW1uIGluIHRoZSBjb25zdHJ1Y3RlZCB0YWJsZSAtIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGtub3cgdGhlIGlubmVyIHdpZHRoIChzbyBpdCBjYW4gYmUgYXNzaWduZWQgdG8gdGhlIG90aGVyIHRhYmxlJ3NcclxuICAgICAgICAgICAgICAgIC8vIGNlbGxzKSBhbmQgdGhlIG91dGVyIHdpZHRoIHNvIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGZ1bGwgd2lkdGggb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0YWJsZS4gVGhpcyBpcyBzYWZlIHNpbmNlIERhdGFUYWJsZXMgcmVxdWlyZXMgYSB1bmlxdWUgY2VsbCBmb3IgZWFjaFxyXG4gICAgICAgICAgICAgICAgLy8gY29sdW1uLCBidXQgaWYgZXZlciBhIGhlYWRlciBjYW4gc3BhbiBtdWx0aXBsZSBjb2x1bW5zLCB0aGlzIHdpbGxcclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgbW9kaWZpZWQuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyID0gY2VsbC5vdXRlcldpZHRoKCkgLSBjZWxsLndpZHRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBnZXRCb3VuZGluZy4uLiB3aGVyZSBwb3NzaWJsZSAobm90IElFOC0pIGJlY2F1c2UgaXQgY2FuIGdpdmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmcgPSBicm93c2VyLmJCb3VuZGluZyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChoZWFkZXJDZWxsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLm91dGVyV2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgaXMgdHJhY2tlZCB0byByZW1vdmUgYW55IHN1Yi1waXhlbCBlcnJvcnMgYXMgdGhlIG91dGVyV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGJvdW5kaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaWR0aCBmb3IgZWFjaCBjb2x1bW4gdG8gdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uc1t2aXNpYmxlQ29sdW1uc1tpXV0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoYm91bmRpbmcgLSBib3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3ModG90YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcclxuICAgICAgICAgICAgICAgIGhvbGRlci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB3aWR0aCBhdHRyLCB3ZSB3YW50IHRvIGF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB3aGljaFxyXG4gICAgICAgICAgICAvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcclxuICAgICAgICAgICAgLy8gcmVzaXplZC4gVXNlIHRoZSB3aWR0aCBhdHRyIHJhdGhlciB0aGFuIENTUywgc2luY2Ugd2UgY2FuJ3Qga25vdyBpZiB0aGVcclxuICAgICAgICAgICAgLy8gQ1NTIGlzIGEgcmVsYXRpdmUgdmFsdWUgb3IgYWJzb2x1dGUgLSBET00gcmVhZCBpcyBhbHdheXMgcHguXHJcbiAgICAgICAgICAgIGlmICh0YWJsZVdpZHRoQXR0cikge1xyXG4gICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0YWJsZVdpZHRoQXR0cik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgIW9TZXR0aW5ncy5fcmVzekV2dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJyArIG9TZXR0aW5ncy5zSW5zdGFuY2UsIF9mblRocm90dGxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKG9TZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgaWYgKGllNjcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGJpbmRSZXNpemUsIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZFJlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkIGZvclxyXG4gICAgICAgICAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cclxuICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBbZnJlcT0yMDBdIGNhbGwgZnJlcXVlbmN5IGluIG1TXHJcbiAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnQgYSBDU1MgdW5pdCB3aWR0aCB0byBwaXhlbHMgKGUuZy4gMmVtKVxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXHJcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcGFyZW50IHBhcmVudCB0byBnZXQgdGhlIHdpdGggZm9yIChyZXF1aXJlZCBmb3IgcmVsYXRpdmUgd2lkdGhzKSAtIG9wdGlvbmFsXHJcbiAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IHdpZHRoIGluIHBpeGVsc1xyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Db252ZXJ0VG9XaWR0aCh3aWR0aCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbiA9ICQoJzxkaXYvPicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKHdpZHRoKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhwYXJlbnQgfHwgZG9jdW1lbnQuYm9keSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsID0gblswXS5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgbi5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSB3aWRlc3Qgbm9kZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcclxuICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IHdpZGVzdCB0YWJsZSBub2RlXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldFdpZGVzdE5vZGUoc2V0dGluZ3MsIGNvbElkeCkge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKHNldHRpbmdzLCBjb2xJZHgpO1xyXG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW2lkeF07XHJcbiAgICAgICAgICAgIHJldHVybiAhZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgICQoJzx0ZC8+JykuaHRtbChfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaWR4LCBjb2xJZHgsICdkaXNwbGF5JykpWzBdIDpcclxuICAgICAgICAgICAgICAgIGRhdGEuYW5DZWxsc1tjb2xJZHhdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XHJcbiAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoc2V0dGluZ3MsIGNvbElkeCkge1xyXG4gICAgICAgICAgICB2YXIgcywgbWF4ID0gLTEsIG1heElkeCA9IC0xO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JykgKyAnJztcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoX19yZV9odG1sX3JlbW92ZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvJm5ic3A7L2csICcgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4SWR4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1heElkeDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBlbmQgYSBDU1MgdW5pdCAob25seSBpZiByZXF1aXJlZCkgdG8gYSBzdHJpbmdcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcclxuICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gdmFsdWUgd2l0aCBjc3MgdW5pdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5TdHJpbmdUb0NzcyhzKSB7XHJcbiAgICAgICAgICAgIGlmIChzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzBweCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgPCAwID9cclxuICAgICAgICAgICAgICAgICAgICAnMHB4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgcyArICdweCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGl0IGhhcyBhIHVuaXQgY2hhcmFjdGVyIGFscmVhZHlcclxuICAgICAgICAgICAgcmV0dXJuIHMubWF0Y2goL1xcZCQvKSA/XHJcbiAgICAgICAgICAgICAgICBzICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICBzO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIGksIGlMZW4sIGssIGtMZW4sXHJcbiAgICAgICAgICAgICAgICBhU29ydCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgYWlPcmlnID0gW10sXHJcbiAgICAgICAgICAgICAgICBhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICBhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXHJcbiAgICAgICAgICAgICAgICBmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxyXG4gICAgICAgICAgICAgICAgZml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoZml4ZWQpLFxyXG4gICAgICAgICAgICAgICAgbmVzdGVkU29ydCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggJiYgISQuaXNBcnJheShhWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxRCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTb3J0LnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyRCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLm1lcmdlKG5lc3RlZFNvcnQsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXHJcbiAgICAgICAgICAgIC8vIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KGZpeGVkKSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGZpeGVkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZpeGVkT2JqICYmIGZpeGVkLnByZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGZpeGVkLnByZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFkZChzZXR0aW5ncy5hYVNvcnRpbmcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeGVkT2JqICYmIGZpeGVkLnBvc3QpIHtcclxuICAgICAgICAgICAgICAgIGFkZChmaXhlZC5wb3N0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5lc3RlZFNvcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNyY0NvbCA9IG5lc3RlZFNvcnRbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBhRGF0YVNvcnQgPSBhb0NvbHVtbnNbc3JjQ29sXS5hRGF0YVNvcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMCwga0xlbiA9IGFEYXRhU29ydC5sZW5ndGg7IGsgPCBrTGVuOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpQ29sID0gYURhdGFTb3J0W2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNUeXBlID0gYW9Db2x1bW5zW2lDb2xdLnNUeXBlIHx8ICdzdHJpbmcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkU29ydFtpXS5faWR4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydFtpXS5faWR4ID0gJC5pbkFycmF5KG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYVNvcnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogc3JjQ29sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGlDb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogbmVzdGVkU29ydFtpXVsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG5lc3RlZFNvcnRbaV0uX2lkeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyW3NUeXBlICsgXCItcHJlXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhU29ydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICogIEB0b2RvIFRoaXMgcmVhbGx5IG5lZWRzIHNwbGl0IHVwIVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mblNvcnQob1NldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgaSwgaWVuLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLFxyXG4gICAgICAgICAgICAgICAgc0RhdGFUeXBlLCBuVGgsXHJcbiAgICAgICAgICAgICAgICBhaU9yaWcgPSBbXSxcclxuICAgICAgICAgICAgICAgIG9FeHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YSxcclxuICAgICAgICAgICAgICAgIGFvQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICBhRGF0YVNvcnQsIGRhdGEsIGlDb2wsIHNUeXBlLCBvU29ydCxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcnMgPSAwLFxyXG4gICAgICAgICAgICAgICAgc29ydENvbCxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxyXG4gICAgICAgICAgICAgICAgYVNvcnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXHJcbiAgICAgICAgICAgIC8vIEB0b2RvIENhbiB0aGlzIGJlIG1vdmVkIGludG8gYSAnZGF0YS1yZWFkeScgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlblxyXG4gICAgICAgICAgICAvLyAgIGRhdGEgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbiB0aGUgdGFibGU/XHJcbiAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzKG9TZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICBhU29ydCA9IF9mblNvcnRGbGF0dGVuKG9TZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBhU29ydC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc29ydENvbCA9IGFTb3J0W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZhc3Qgc29ydCBhbGdvcml0aG1cclxuICAgICAgICAgICAgICAgIGlmIChzb3J0Q29sLmZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcnMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIHNvcnQsIGZvciBlYWNoIGNlbGxcclxuICAgICAgICAgICAgICAgIF9mblNvcnREYXRhKG9TZXR0aW5ncywgc29ydENvbC5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBObyBzb3J0aW5nIHJlcXVpcmVkIGlmIHNlcnZlci1zaWRlIG9yIG5vIHNvcnRpbmcgYXJyYXkgKi9cclxuICAgICAgICAgICAgaWYgKF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHZhbHVlIC0ga2V5IGFycmF5IG9mIHRoZSBjdXJyZW50IHJvdyBwb3NpdGlvbnMgc3VjaCB0aGF0IHdlIGNhbiB1c2UgdGhlaXJcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBkaXNwbGF5TWFzdGVyLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFpT3JpZ1tkaXNwbGF5TWFzdGVyW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogRG8gdGhlIHNvcnQgLSBoZXJlIHdlIHdhbnQgbXVsdGktY29sdW1uIHNvcnRpbmcgYmFzZWQgb24gYSBnaXZlbiBkYXRhIHNvdXJjZSAoY29sdW1uKVxyXG4gICAgICAgICAgICAgICAgICogYW5kIHNvcnRpbmcgZnVuY3Rpb24gKGZyb20gb1NvcnQpIGluIGEgY2VydGFpbiBkaXJlY3Rpb24uIEl0J3MgcmVhc29uYWJseSBjb21wbGV4IHRvXHJcbiAgICAgICAgICAgICAgICAgKiBmb2xsb3cgb24gaXQncyBvd24sIGJ1dCB0aGlzIGlzIHdoYXQgd2Ugd2FudCAoZXhhbXBsZSB0d28gY29sdW1uIHNvcnRpbmcpOlxyXG4gICAgICAgICAgICAgICAgICogIGZuTG9jYWxTb3J0aW5nID0gZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICAgICAqICAgIHZhciBpVGVzdDtcclxuICAgICAgICAgICAgICAgICAqICAgIGlUZXN0ID0gb1NvcnRbJ3N0cmluZy1hc2MnXSgnZGF0YTExJywgJ2RhdGExMicpO1xyXG4gICAgICAgICAgICAgICAgICogICAgICBpZiAoaVRlc3QgIT09IDApXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIGlUZXN0O1xyXG4gICAgICAgICAgICAgICAgICogICAgaVRlc3QgPSBvU29ydFsnbnVtZXJpYy1kZXNjJ10oJ2RhdGEyMScsICdkYXRhMjInKTtcclxuICAgICAgICAgICAgICAgICAqICAgIGlmIChpVGVzdCAhPT0gMClcclxuICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuIGlUZXN0O1xyXG4gICAgICAgICAgICAgICAgICogICAgcmV0dXJuIG9Tb3J0WydudW1lcmljLWFzYyddKCBhaU9yaWdbYV0sIGFpT3JpZ1tiXSApO1xyXG4gICAgICAgICAgICAgICAgICogIH1cclxuICAgICAgICAgICAgICAgICAqIEJhc2ljYWxseSB3ZSBoYXZlIGEgdGVzdCBmb3IgZWFjaCBzb3J0aW5nIGNvbHVtbiwgaWYgdGhlIGRhdGEgaW4gdGhhdCBjb2x1bW4gaXMgZXF1YWwsXHJcbiAgICAgICAgICAgICAgICAgKiB0ZXN0IHRoZSBuZXh0IGNvbHVtbi4gSWYgYWxsIGNvbHVtbnMgbWF0Y2gsIHRoZW4gd2UgdXNlIGEgbnVtZXJpYyBzb3J0IG9uIHRoZSByb3dcclxuICAgICAgICAgICAgICAgICAqIHBvc2l0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSB0byBwcm92aWRlIGEgc3RhYmxlIHNvcnQuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSAtIEkga25vdyBpdCBzZWVtcyBleGNlc3NpdmUgdG8gaGF2ZSB0d28gc29ydGluZyBtZXRob2RzLCBidXQgdGhlIGZpcnN0IGlzIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICogMTUlIGZhc3Rlciwgc28gdGhlIHNlY29uZCBpcyBvbmx5IG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggc29ydGluZ1xyXG4gICAgICAgICAgICAgICAgICogbWV0aG9kcyB3aGljaCBkbyBub3QgaGF2ZSBhIHByZS1zb3J0IGZvcm1hdHRpbmcgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZXJzID09PSBhU29ydC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgc29ydCB0eXBlcyBoYXZlIGZvcm1hdHRpbmcgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgaywgdGVzdCwgc29ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGFTb3J0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ID0gYVNvcnRba107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRhdGFBW3NvcnQuY29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkYXRhQltzb3J0LmNvbF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3QgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydC5kaXIgPT09ICdhc2MnID8gdGVzdCA6IC10ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYWlPcmlnW2FdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYWlPcmlnW2JdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXByZWNpYXRlZCAtIHJlbW92ZSBpbiAxLjExIChwcm92aWRpbmcgYSBwbHVnLWluIG9wdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kcy5cclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TWFzdGVyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCBrLCBsLCB0ZXN0LCBzb3J0LCBmbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGFTb3J0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ID0gYVNvcnRba107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRhdGFBW3NvcnQuY29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkYXRhQltzb3J0LmNvbF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBvRXh0U29ydFtzb3J0LnR5cGUgKyBcIi1cIiArIHNvcnQuZGlyXSB8fCBvRXh0U29ydFtcInN0cmluZy1cIiArIHNvcnQuZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSBmbih4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBhaU9yaWdbYV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBhaU9yaWdbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4IDwgeSA/IC0xIDogeCA+IHkgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB0aGF0IHdlIGhhdmUgc29ydGVkIHRoZSBkYXRhICovXHJcbiAgICAgICAgICAgIG9TZXR0aW5ncy5iU29ydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0QXJpYShzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWw7XHJcbiAgICAgICAgICAgIHZhciBuZXh0U29ydDtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XHJcbiAgICAgICAgICAgIHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdmFyIG9BcmlhID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9BcmlhO1xyXG5cclxuICAgICAgICAgICAgLy8gQVJJQSBhdHRyaWJ1dGVzIC0gbmVlZCB0byBsb29wIGFsbCBjb2x1bW5zLCB0byB1cGRhdGUgYWxsIChyZW1vdmluZyBvbGRcclxuICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBhcyBuZWVkZWQpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb2x1bW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1RpdGxlID0gY29sLnNUaXRsZS5yZXBsYWNlKC88Lio/Pi9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aCA9IGNvbC5uVGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUU3IGlzIHRocm93aW5nIGFuIGVycm9yIHdoZW4gc2V0dGluZyB0aGVzZSBwcm9wZXJ0aWVzIHdpdGggalF1ZXJ5J3NcclxuICAgICAgICAgICAgICAgIC8vIGF0dHIoKSBhbmQgcmVtb3ZlQXR0cigpIG1ldGhvZHMuLi5cclxuICAgICAgICAgICAgICAgIHRoLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zb3J0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogSW4gQVJJQSBvbmx5IHRoZSBmaXJzdCBzb3J0aW5nIGNvbHVtbiBjYW4gYmUgbWFya2VkIGFzIHNvcnRpbmcgLSBubyBtdWx0aS1zb3J0IG9wdGlvbiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbC5iU29ydGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc29ydCcsIGFTb3J0WzBdLmRpciA9PSBcImFzY1wiID8gXCJhc2NlbmRpbmdcIiA6IFwiZGVzY2VuZGluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnQgPSBhc1NvcnRpbmdbYVNvcnRbMF0uaW5kZXggKyAxXSB8fCBhc1NvcnRpbmdbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydCA9IGFzU29ydGluZ1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gc1RpdGxlICsgKG5leHRTb3J0ID09PSBcImFzY1wiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgb0FyaWEuc1NvcnRBc2NlbmRpbmcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvQXJpYS5zU29ydERlc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBzVGl0bGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGguc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gdG8gcnVuIG9uIHVzZXIgc29ydCByZXF1ZXN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbYXBwZW5kPWZhbHNlXSBBcHBlbmQgdGhlIHJlcXVlc3RlZCBzb3J0IHRvIHRoZSBleGlzdGluZ1xyXG4gICAgICAgICAqICAgIHNvcnQgaWYgdHJ1ZSAoaS5lLiBtdWx0aS1jb2x1bW4gc29ydClcclxuICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0TGlzdGVuZXIoc2V0dGluZ3MsIGNvbElkeCwgYXBwZW5kLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcbiAgICAgICAgICAgIHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xyXG4gICAgICAgICAgICB2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcclxuICAgICAgICAgICAgdmFyIG5leHRTb3J0SWR4O1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChhLCBvdmVyZmxvdykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGEuX2lkeDtcclxuICAgICAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9ICQuaW5BcnJheShhWzFdLCBhc1NvcnRpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBpZHggKyAxIDwgYXNTb3J0aW5nLmxlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4ICsgMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gMkQgYXJyYXkgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbc29ydGluZ107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGFwcGVuZGluZyB0aGUgc29ydCB0aGVuIHdlIGFyZSBtdWx0aS1jb2x1bW4gc29ydGluZ1xyXG4gICAgICAgICAgICBpZiAoYXBwZW5kICYmIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydE11bHRpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cclxuICAgICAgICAgICAgICAgIHZhciBzb3J0SWR4ID0gJC5pbkFycmF5KGNvbElkeCwgX3BsdWNrKHNvcnRpbmcsICcwJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzb3J0SWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFllcywgbW9kaWZ5IHRoZSBzb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnRJZHggPSBuZXh0KHNvcnRpbmdbc29ydElkeF0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNvcnRJZHggPT09IG51bGwgJiYgc29ydGluZy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnRJZHggPSAwOyAvLyBjYW4ndCByZW1vdmUgc29ydGluZyBjb21wbGV0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNvcnRJZHggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZy5zcGxpY2Uoc29ydElkeCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nW25leHRTb3J0SWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1tzb3J0SWR4XS5faWR4ID0gbmV4dFNvcnRJZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc29ydCBvbiB0aGlzIGNvbHVtbiB5ZXRcclxuICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLnB1c2goW2NvbElkeCwgYXNTb3J0aW5nWzBdLCAwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGluZ1tzb3J0aW5nLmxlbmd0aCAtIDFdLl9pZHggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNvcnRpbmcubGVuZ3RoICYmIHNvcnRpbmdbMF1bMF0gPT0gY29sSWR4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgY29sdW1uIC0gYWxyZWFkeSBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLCBtb2RpZnkgdGhlIHNvcnRcclxuICAgICAgICAgICAgICAgIG5leHRTb3J0SWR4ID0gbmV4dChzb3J0aW5nWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzb3J0aW5nLmxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICBzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nW25leHRTb3J0SWR4XTtcclxuICAgICAgICAgICAgICAgIHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlIGNvbHVtbiAtIHNvcnQgb25seSBvbiB0aGlzIGNvbHVtblxyXG4gICAgICAgICAgICAgICAgc29ydGluZy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgc29ydGluZy5wdXNoKFtjb2xJZHgsIGFzU29ydGluZ1swXV0pO1xyXG4gICAgICAgICAgICAgICAgc29ydGluZ1swXS5faWR4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUnVuIHRoZSBzb3J0IGJ5IGNhbGxpbmcgYSBmdWxsIHJlZHJhd1xyXG4gICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgdXNlZCBmb3IgYXN5bmMgdXNlciBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF0dGFjaCBhIHNvcnQgaGFuZGxlciAoY2xpY2spIHRvIGEgbm9kZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xyXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBhdHRhY2hUbywgY29sSWR4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcblxyXG4gICAgICAgICAgICBfZm5CaW5kQWN0aW9uKGF0dGFjaFRvLCB7fSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBjb2x1bW4gaXMgbm90IHNvcnRhYmxlIC0gZG9uJ3QgdG8gYW55dGhpbmcgKi9cclxuICAgICAgICAgICAgICAgIGlmIChjb2wuYlNvcnRhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9jZXNzaW5nIGlzIGVuYWJsZWQgdXNlIGEgdGltZW91dCB0byBhbGxvdyB0aGUgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzcGxheSB0byBiZSBzaG93biAtIG90aGVyd2lzZSB0byBpdCBzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydExpc3RlbmVyKHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgcmVtb3ZlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIGRpc3BsYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mbkRhdGFTb3VyY2Uoc2V0dGluZ3MpICE9PSAnc3NwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuU29ydExpc3RlbmVyKHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgICAqIHdoZW4gYlNvcnQgYW5kIGJTb3J0Q2xhc3NlcyBhcmUgZmFsc2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0aW5nQ2xhc3NlcyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcclxuICAgICAgICAgICAgdmFyIHNvcnRDbGFzcyA9IHNldHRpbmdzLm9DbGFzc2VzLnNTb3J0Q29sdW1uO1xyXG4gICAgICAgICAgICB2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xyXG4gICAgICAgICAgICB2YXIgaSwgaWVuLCBjb2xJZHg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHNvcnRpbmcgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gb2xkU29ydC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbElkeCA9IG9sZFNvcnRbaV0uc3JjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29sdW1uIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNvcnRDbGFzcyArIChpIDwgMiA/IGkgKyAxIDogMykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNvcnQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xJZHggPSBzb3J0W2ldLnNyYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJChfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhzb3J0Q2xhc3MgKyAoaSA8IDIgPyBpICsgMSA6IDMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MuYUxhc3RTb3J0ID0gc29ydDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGRhdGEgdG8gc29ydCBhIGNvbHVtbiwgYmUgaXQgZnJvbSBjYWNoZSwgZnJlc2ggKHBvcHVsYXRpbmcgdGhlXHJcbiAgICAgICAgLy8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcclxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0RGF0YShzZXR0aW5ncywgaWR4KSB7XHJcbiAgICAgICAgICAgIC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXHJcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XTtcclxuICAgICAgICAgICAgdmFyIGN1c3RvbVNvcnQgPSBEYXRhVGFibGUuZXh0Lm9yZGVyW2NvbHVtbi5zU29ydERhdGFUeXBlXTtcclxuICAgICAgICAgICAgdmFyIGN1c3RvbURhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VzdG9tU29ydCkge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRGF0YSA9IGN1c3RvbVNvcnQuY2FsbChzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBpZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoc2V0dGluZ3MsIGlkeClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXHJcbiAgICAgICAgICAgIHZhciByb3csIGNlbGxEYXRhO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyW2NvbHVtbi5zVHlwZSArIFwiLXByZVwiXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYVNvcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9hU29ydERhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gY3VzdG9tU29ydCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGFbaV0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaSwgaWR4LCAnc29ydCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByb3cuX2FTb3J0RGF0YVtpZHhdID0gZm9ybWF0dGVyID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyKGNlbGxEYXRhKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmUgdGhlIHN0YXRlIG9mIGEgdGFibGVcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5TYXZlU3RhdGUoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSB8fCBzZXR0aW5ncy5iRGVzdHJveWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRpbWU6ICtuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogJC5leHRlbmQodHJ1ZSwgW10sIHNldHRpbmdzLmFhU29ydGluZyksXHJcbiAgICAgICAgICAgICAgICBzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoKSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnM6ICQubWFwKHNldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKGNvbCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGNvbC5iVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiBfZm5TZWFyY2hUb0NhbWVsKHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0pO1xyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3Mub1NhdmVkU3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgc2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvSW5pdCBEYXRhVGFibGVzIGluaXQgb2JqZWN0IHNvIHdlIGNhbiBvdmVycmlkZSBzZXR0aW5nc1xyXG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5Mb2FkU3RhdGUoc2V0dGluZ3MsIG9Jbml0LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXMgfHwgIXMudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBhbmQgcGx1Zy1pbiBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGFsdGVyIHRoZSBzYXZlZCBkYXRhIHNldCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2VcclxuICAgICAgICAgICAgICAgIHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShmYWxzZSwgYWJTdGF0ZUxvYWQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlamVjdCBvbGQgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gc2V0dGluZ3MuaVN0YXRlRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwICYmIHMudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uICogMTAwMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgY29sdW1ucyBoYXZlIGNoYW5nZWQgLSBhbGwgYmV0cyBhcmUgb2ZmLCBubyByZXN0b3JlIG9mIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICBpZiAocy5jb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoICE9PSBzLmNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHNhdmVkIHN0YXRlIHNvIGl0IG1pZ2h0IGJlIGFjY2Vzc2VkIGF0IGFueSB0aW1lXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBrZXkgZmVhdHVyZXMgLSB0b2RvIC0gZm9yIDEuMTEgdGhpcyBuZWVkcyB0byBiZSBkb25lIGJ5XHJcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmVkIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gcy5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHMuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9yZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAocy5vcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHMub3JkZXIsIGZ1bmN0aW9uIChpLCBjb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nLnB1c2goY29sWzBdID49IGNvbHVtbnMubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCBjb2xbMV1dIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaFxyXG4gICAgICAgICAgICAgICAgaWYgKHMuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyhzLnNlYXJjaCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbHVtbnNcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBpZiAocy5jb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gcy5jb2x1bW5zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzLmNvbHVtbnNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWaXNpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wudmlzaWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zW2ldLmJWaXNpYmxlID0gY29sLnZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIF9mblNlYXJjaFRvSHVuZyhjb2wuc2VhcmNoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsICdzdGF0ZUxvYWRlZCcsIFtzZXR0aW5ncywgc10pO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gc2V0dGluZ3MuZm5TdGF0ZUxvYWRDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGxvYWRlZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkKHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHdhaXQgZm9yIHRoZSBsb2FkZWQgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlXHJcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gdGFibGUgdGFibGUgd2UgYXJlIHVzaW5nIGFzIGEgZGF0YVRhYmxlXHJcbiAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IFNldHRpbmdzIG9iamVjdCAtIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mblNldHRpbmdzRnJvbU5vZGUodGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHRhYmxlLCBfcGx1Y2soc2V0dGluZ3MsICduVGFibGUnKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaWR4ICE9PSAtMSA/XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1tpZHhdIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBsZXZlbCBsb2cgZXJyb3IgbWVzc2FnZXMsIG9yIGRpc3BsYXkgdGhlbSB0byB0aGUgdXNlclxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuTG9nKHNldHRpbmdzLCBsZXZlbCwgbXNnLCB0bikge1xyXG4gICAgICAgICAgICBtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnICtcclxuICAgICAgICAgICAgICAgIChzZXR0aW5ncyA/ICd0YWJsZSBpZD0nICsgc2V0dGluZ3Muc1RhYmxlSWQgKyAnIC0gJyA6ICcnKSArIG1zZztcclxuXHJcbiAgICAgICAgICAgIGlmICh0bikge1xyXG4gICAgICAgICAgICAgICAgbXNnICs9ICcuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3IsIHBsZWFzZSBzZWUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi8nICsgdG47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSAxLjEwXHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2Vycm9yJywgW3NldHRpbmdzLCB0biwgbXNnXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2FsZXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09ICd0aHJvdycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlKHNldHRpbmdzLCB0biwgbXNnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHJldCB0YXJnZXQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW21hcHBlZE5hbWVdIG5hbWUgdG8gbWFwIHRvbyAtIG9wdGlvbmFsLCBuYW1lIHVzZWQgaWYgbm90IGdpdmVuXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbk1hcChyZXQsIHNyYywgbmFtZSwgbWFwcGVkTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2gobmFtZSwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAocmV0LCBzcmMsIHZhbFswXSwgdmFsWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChyZXQsIHNyYywgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtYXBwZWROYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1hcHBlZE5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3JjW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldFttYXBwZWROYW1lXSA9IHNyY1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXHJcbiAgICAgICAgICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAgICAqIGRlZXAgY29weSBhcnJheSBpbml0IHZhbHVlcyAoc3VjaCBhcyBhYVNvcnRpbmcpIHNpbmNlIHRoZSBkZXYgd291bGRuJ3QgYmVcclxuICAgICAgICAgKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gZXh0ZW5kZXIgT2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnRpZXMgd2lsbCBiZSBhcHBsaWVkIHRvXHJcbiAgICAgICAgICogICAgICBvdXRcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxyXG4gICAgICAgICAqICAgICAgaW5kZXBlbmRlbnQgY29weSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGBkYXRhYCBvciBgYWFEYXRhYCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cclxuICAgICAgICAgKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcclxuICAgICAgICAgKiAgICAgIHJlZmVyZW5jZXNcclxuICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqICBAdG9kbyBUaGlzIGRvZXNuJ3QgdGFrZSBhY2NvdW50IG9mIGFycmF5cyBpbnNpZGUgdGhlIGRlZXAgY29waWVkIG9iamVjdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRXh0ZW5kKG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZXh0ZW5kZXJbcHJvcF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChvdXRbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbcHJvcF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvdXRbcHJvcF0sIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgJC5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3Byb3BdID0gdmFsLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJpbmQgYW4gZXZlbnQgaGFuZGVycyB0byBhbGxvdyBhIGNsaWNrIG9yIHJldHVybiBrZXkgdG8gYWN0aXZhdGUgdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIFRoaXMgaXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSBzaW5jZSBhIHJldHVybiBvbiB0aGUga2V5Ym9hcmQgd2lsbCBoYXZlIHRoZVxyXG4gICAgICAgICAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cclxuICAgICAgICAgKiAgQHBhcmFtIHtlbGVtZW50fSBuIEVsZW1lbnQgdG8gYmluZCB0aGUgYWN0aW9uIHRvXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvRGF0YSBEYXRhIG9iamVjdCB0byBwYXNzIHRvIHRoZSB0cmlnZ2VyZWQgZnVuY3Rpb25cclxuICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxyXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5CaW5kQWN0aW9uKG4sIG9EYXRhLCBmbikge1xyXG4gICAgICAgICAgICAkKG4pXHJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5ibHVyKCk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbigna2V5cHJlc3MuRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdzZWxlY3RzdGFydC5EVCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBUYWtlIHRoZSBicnV0YWwgYXBwcm9hY2ggdG8gY2FuY2VsbGluZyB0ZXh0IHNlbGVjdGlvbiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24uIEVhc2lseSBhbGxvd3MgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBhZGRlZCB0b1xyXG4gICAgICAgICAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNTdG9yZSBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluIG9TZXR0aW5nc1xyXG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYmFja1xyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc05hbWUgSWRlbnRpZnlpbmcgbmFtZSBmb3IgdGhlIGNhbGxiYWNrIChpLmUuIGEgbGFiZWwpXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgc1N0b3JlLCBmbiwgc05hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBcImZuXCI6IGZuLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogc05hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcclxuICAgICAgICAgKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXHJcbiAgICAgICAgICogZmlyZSBvZmYgdHJpZ2dlcnMgaW4gdGltZSBzZW5zaXRpdmUgYXBwbGljYXRpb25zIChmb3IgZXhhbXBsZSBjZWxsIGNyZWF0aW9uKVxyXG4gICAgICAgICAqIGFzIGl0cyBzbG93LlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGNhbGxiYWNrQXJyIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW5cclxuICAgICAgICAgKiAgICAgIG9TZXR0aW5nc1xyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcclxuICAgICAgICAgKiAgICAgIG51bGwgbm8gdHJpZ2dlciBpcyBmaXJlZFxyXG4gICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXHJcbiAgICAgICAgICogICAgICB0cmlnZ2VyXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgY2FsbGJhY2tBcnIsIGV2ZW50TmFtZSwgYXJncykge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tBcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldCA9ICQubWFwKHNldHRpbmdzW2NhbGxiYWNrQXJyXS5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHZhbCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZm4uYXBwbHkoc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9ICQuRXZlbnQoZXZlbnROYW1lICsgJy5kdCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS50cmlnZ2VyKGUsIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGUucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZm5MZW5ndGhPdmVyZmxvdyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgc3BhY2UgdG8gc2hvdyBleHRyYSByb3dzIChiYWNraW5nIHVwIGZyb20gdGhlIGVuZCBwb2ludCAtIHRoZW4gZG8gc28gKi9cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSBsZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHN0YXJ0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXHJcbiAgICAgICAgICAgIHN0YXJ0IC09IChzdGFydCAlIGxlbik7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuID09PSAtMSB8fCBzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZm5SZW5kZXJlcihzZXR0aW5ncywgdHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBzZXR0aW5ncy5yZW5kZXJlcjtcclxuICAgICAgICAgICAgdmFyIGhvc3QgPSBEYXRhVGFibGUuZXh0LnJlbmRlcmVyW3R5cGVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChyZW5kZXJlcikgJiYgcmVuZGVyZXJbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFNwZWNpZmljIHJlbmRlcmVyIGZvciB0aGlzIHR5cGUuIElmIGF2YWlsYWJsZSB1c2UgaXQsIG90aGVyd2lzZSB1c2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RbcmVuZGVyZXJdIHx8IGhvc3QuXztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHJldHVybiBob3N0Ll87XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZWN0IHRoZSBkYXRhIHNvdXJjZSBiZWluZyB1c2VkIGZvciB0aGUgdGFibGUuIFVzZWQgdG8gc2ltcGxpZnkgdGhlIGNvZGVcclxuICAgICAgICAgKiBhIGxpdHRsZSAoYWpheCkgYW5kIHRvIG1ha2UgaXQgY29tcHJlc3MgYSBsaXR0bGUgc21hbGxlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gRGF0YSBzb3VyY2VcclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NzcCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MuYWpheCB8fCBzZXR0aW5ncy5zQWpheFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhamF4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ2RvbSc7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xyXG4gICAgICAgICAqIGBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKClgIHdoZW4gYnVpbGRpbmcgdGhlIEFQSS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXHJcbiAgICAgICAgICogb2JqZWN0cyBzaW5jZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZWZmZWN0aXZlbHkgcHJlLXBhcnNlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcclxuICAgICAgICAgKiBiYXNlIGFycmF5IHJlcHJlc2VudHMgdGhlIEFwaSBwcm90b3R5cGUgYmFzZTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBbXHJcbiAgICAgICAgICogICAgICAge1xyXG4gICAgICAgICAqICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXHJcbiAgICAgICAgICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxyXG4gICAgICAgICAqICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcclxuICAgICAgICAgKiAgICAgICB9LFxyXG4gICAgICAgICAqICAgICAgIHtcclxuICAgICAgICAgKiAgICAgICAgIG5hbWU6ICAgICAncm93J1xyXG4gICAgICAgICAqICAgICAgICAgdmFsOiAgICAgICB7fSxcclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcclxuICAgICAgICAgKiAgICAgICAgIHByb3BFeHQ6ICAgW1xyXG4gICAgICAgICAqICAgICAgICAgICB7XHJcbiAgICAgICAgICogICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcclxuICAgICAgICAgKiAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgICAgICAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcclxuICAgICAgICAgKiAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cclxuICAgICAgICAgKiAgICAgICAgICAgfSxcclxuICAgICAgICAgKiAgICAgICAgICAgLi4uXHJcbiAgICAgICAgICogICAgICAgICBdXHJcbiAgICAgICAgICogICAgICAgfVxyXG4gICAgICAgICAqICAgICBdXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICogQGlnbm9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBfX2FwaVN0cnVjdCA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICogQGlnbm9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBfX2FycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnN0cmFjdGlvbiBmb3IgYGNvbnRleHRgIHBhcmFtZXRlciBvZiB0aGUgYEFwaWAgY29uc3RydWN0b3IgdG8gYWxsb3cgaXQgdG9cclxuICAgICAgICAgKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEVhY2ggb2YgdGhlIGlucHV0IHBhcmFtZXRlciB0eXBlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIERhdGFUYWJsZXMgc2V0dGluZ3NcclxuICAgICAgICAgKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8bm9kZXxqUXVlcnl8b2JqZWN0fSBtaXhlZCBEYXRhVGFibGUgaWRlbnRpZmllci4gQ2FuIGJlIG9uZVxyXG4gICAgICAgICAqICAgb2Y6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3JcclxuICAgICAgICAgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cclxuICAgICAgICAgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXHJcbiAgICAgICAgICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXHJcbiAgICAgICAgICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2FycmF5fG51bGx9IE1hdGNoaW5nIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy4gYG51bGxgIG9yXHJcbiAgICAgICAgICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXHJcbiAgICAgICAgICogQGlnbm9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uIChtaXhlZCkge1xyXG4gICAgICAgICAgICB2YXIgaWR4LCBqcTtcclxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xyXG4gICAgICAgICAgICB2YXIgdGFibGVzID0gJC5tYXAoc2V0dGluZ3MsIGZ1bmN0aW9uIChlbCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5UYWJsZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1peGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQublRhYmxlICYmIG1peGVkLm9BcGkpIHtcclxuICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW21peGVkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtaXhlZC5ub2RlTmFtZSAmJiBtaXhlZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBub2RlXHJcbiAgICAgICAgICAgICAgICBpZHggPSAkLmluQXJyYXkobWl4ZWQsIHRhYmxlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IFtzZXR0aW5nc1tpZHhdXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWl4ZWQuc2V0dGluZ3MoKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICBqcSA9ICQobWl4ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgJCkge1xyXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAganEgPSBtaXhlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGpxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganEubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gJC5pbkFycmF5KHRoaXMsIHRhYmxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBzZXR0aW5nc1tpZHhdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEYXRhVGFibGVzIEFQSSBjbGFzcyAtIHVzZWQgdG8gY29udHJvbCBhbmQgaW50ZXJmYWNlIHdpdGggIG9uZSBvciBtb3JlXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgQVBJIGNsYXNzIGlzIGhlYXZpbHkgYmFzZWQgb24galF1ZXJ5LCBwcmVzZW50aW5nIGEgY2hhaW5hYmxlIGludGVyZmFjZVxyXG4gICAgICAgICAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcclxuICAgICAgICAgKiBhIFwiY29udGV4dFwiIC0gaS5lLiB0aGUgdGFibGVzIHRoYXQgaXQgd2lsbCBvcGVyYXRlIG9uLiBUaGlzIGNvdWxkIGJlIGEgc2luZ2xlXHJcbiAgICAgICAgICogdGFibGUsIGFsbCB0YWJsZXMgb24gYSBwYWdlIG9yIGEgc3ViLXNldCB0aGVyZW9mLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWRkaXRpb25hbGx5IHRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYWxsb3cgeW91IHRvIGVhc2lseSB3b3JrIHdpdGggdGhlIGRhdGEgaW5cclxuICAgICAgICAgKiB0aGUgdGFibGVzLCByZXRyaWV2aW5nIGFuZCBtYW5pcHVsYXRpbmcgaXQgYXMgcmVxdWlyZWQuIFRoaXMgaXMgZG9uZSBieVxyXG4gICAgICAgICAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxyXG4gICAgICAgICAqIGFycmF5IGRlcGVuZCB1cG9uIHRoZSBhY3Rpb25zIHJlcXVlc3RlZCBieSBlYWNoIG1ldGhvZCAoZm9yIGV4YW1wbGVcclxuICAgICAgICAgKiBgcm93cygpLm5vZGVzKClgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG5vZGVzLCB3aGlsZSBgcm93cygpLmRhdGEoKWAgd2lsbFxyXG4gICAgICAgICAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3NcclxuICAgICAgICAgKiBjb25maWd1cmF0aW9uKS4gVGhlIEFQSSBvYmplY3QgaGFzIGEgbnVtYmVyIG9mIGFycmF5IGxpa2UgbWV0aG9kcyAoYHB1c2hgLFxyXG4gICAgICAgICAqIGBwb3BgLCBgcmV2ZXJzZWAgZXRjKSBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgKGBlYWNoYCwgYHBsdWNrYCxcclxuICAgICAgICAgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBNb3N0IG1ldGhvZHMgKHRob3NlIHdoaWNoIHJldHVybiBhbiBBcGkgaW5zdGFuY2UpIGFyZSBjaGFpbmFibGUsIHdoaWNoIG1lYW5zXHJcbiAgICAgICAgICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxyXG4gICAgICAgICAqIHRvcCBsZXZlbCBvYmplY3QgaGFkLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvIGNhbGxzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIE5vdCBjaGFpbmVkXHJcbiAgICAgICAgICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApO1xyXG4gICAgICAgICAqICAgICBhcGkuZHJhdygpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIENoYWluZWRcclxuICAgICAgICAgKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICkuZHJhdygpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGNsYXNzIERhdGFUYWJsZS5BcGlcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fG9iamVjdHxzdHJpbmd8alF1ZXJ5fSBjb250ZXh0IERhdGFUYWJsZSBpZGVudGlmaWVyLiBUaGlzIGlzXHJcbiAgICAgICAgICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXHJcbiAgICAgICAgICogICBDYW4gYmUgb25lIG9mOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXHJcbiAgICAgICAgICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXHJcbiAgICAgICAgICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxyXG4gICAgICAgICAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxyXG4gICAgICAgICAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gW2RhdGFdIERhdGEgdG8gaW5pdGlhbGlzZSB0aGUgQXBpIGluc3RhbmNlIHdpdGguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgLy8gRGlyZWN0IGluaXRpYWxpc2F0aW9uIGR1cmluZyBEYXRhVGFibGVzIGNvbnN0cnVjdGlvblxyXG4gICAgICAgICAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3RcclxuICAgICAgICAgKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmFwaSgpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgIC8vIEluaXRpYWxpc2F0aW9uIGFzIGEgY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgIHZhciBhcGkgPSBuZXcgJC5mbi5EYXRhVGFibGUuQXBpKCAndGFibGUuZGF0YVRhYmxlJyApO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9BcGkgPSBmdW5jdGlvbiAoY29udGV4dCwgZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0FwaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaShjb250ZXh0LCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF90b1NldHRpbmdzKG8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzLmNvbmNhdChhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4U2V0dGluZ3MoY29udGV4dFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdHhTZXR0aW5ncyhjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gX3VuaXF1ZShzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsIGRhdGFcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICQubWVyZ2UodGhpcywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNlbGVjdG9yXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB7XHJcbiAgICAgICAgICAgICAgICByb3dzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY29sczogbnVsbCxcclxuICAgICAgICAgICAgICAgIG9wdHM6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF9BcGkuZXh0ZW5kKHRoaXMsIHRoaXMsIF9fYXBpU3RydWN0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBEYXRhVGFibGUuQXBpID0gX0FwaTtcclxuXHJcbiAgICAgICAgLy8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3NcclxuICAgICAgICAvLyBpc1BsYWluT2JqZWN0LlxyXG4gICAgICAgICQuZXh0ZW5kKF9BcGkucHJvdG90eXBlLCB7XHJcbiAgICAgICAgICAgIGFueTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBjb25jYXQ6IF9fYXJyYXlQcm90by5jb25jYXQsXHJcblxyXG5cclxuICAgICAgICAgICAgY29udGV4dDogW10sIC8vIGFycmF5IG9mIHRhYmxlIHNldHRpbmdzIG9iamVjdHNcclxuXHJcblxyXG4gICAgICAgICAgICBjb3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW2ldLCBpLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBlcTogZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoY3R4W2lkeF0sIHRoaXNbaWR4XSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9fYXJyYXlQcm90by5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKHRoaXMsIGZuLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGksIHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2godGhpc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgYSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgZmxhdHRlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIGEuY29uY2F0LmFwcGx5KGEsIHRoaXMudG9BcnJheSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgam9pbjogX19hcnJheVByb3RvLmpvaW4sXHJcblxyXG5cclxuICAgICAgICAgICAgaW5kZXhPZjogX19hcnJheVByb3RvLmluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAoc3RhcnQgfHwgMCksIGllbiA9IHRoaXMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGl0ZXJhdG9yOiBmdW5jdGlvbiAoZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldykge1xyXG4gICAgICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IFtdLCByZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaSwgaWVuLCBqLCBqZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICByb3dzLCBpdGVtcywgaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXJndW1lbnQgc2hpZnRpbmdcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxhdHRlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbHdheXNOZXcgPSBmbjtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGZsYXR0ZW47XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKGNvbnRleHRbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RhYmxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY29sdW1ucycgfHwgdHlwZSA9PT0gJ3Jvd3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHNhbWUgbGVuZ3RoIGFzIGNvbnRleHQgLSBvbmUgZW50cnkgZm9yIGVhY2ggdGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uY2FsbChhcGlJbnN0LCBjb250ZXh0W2ldLCB0aGlzW2ldLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHJldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2NvbHVtbicgfHwgdHlwZSA9PT0gJ2NvbHVtbi1yb3dzJyB8fCB0eXBlID09PSAncm93JyB8fCB0eXBlID09PSAnY2VsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sdW1ucyBhbmQgcm93cyBzaGFyZSB0aGUgc2FtZSBzdHJ1Y3R1cmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdGhpc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29sdW1uLXJvd3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKGNvbnRleHRbaV0sIHNlbGVjdG9yLm9wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSBpdGVtcy5sZW5ndGg7IGogPCBqZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY2VsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCB8fCBhbHdheXNOZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gbmV3IF9BcGkoY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KFtdLCBhKSA6IGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcGlTZWxlY3RvciA9IGFwaS5zZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcclxuICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcclxuICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5vcHRzID0gc2VsZWN0b3Iub3B0cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgbGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQml0IGNoZWVreS4uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSh0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIGxlbmd0aDogMCxcclxuXHJcblxyXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX19hcnJheVByb3RvLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwodGhpcywgZm4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHRoaXMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGZuLmNhbGwodGhpcywgdGhpc1tpXSwgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCBhKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBwbHVjazogZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHBvcDogX19hcnJheVByb3RvLnBvcCxcclxuXHJcblxyXG4gICAgICAgICAgICBwdXNoOiBfX2FycmF5UHJvdG8ucHVzaCxcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHJlZHVjZTogX19hcnJheVByb3RvLnJlZHVjZSB8fCBmdW5jdGlvbiAoZm4sIGluaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5SZWR1Y2UodGhpcywgZm4sIGluaXQsIDAsIHRoaXMubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICByZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0IHx8IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mblJlZHVjZSh0aGlzLCBmbiwgaW5pdCwgdGhpcy5sZW5ndGggLSAxLCAtMSwgLTEpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIHJldmVyc2U6IF9fYXJyYXlQcm90by5yZXZlcnNlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcclxuICAgICAgICAgICAgc2VsZWN0b3I6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgc2hpZnQ6IF9fYXJyYXlQcm90by5zaGlmdCxcclxuXHJcblxyXG4gICAgICAgICAgICBzbGljZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgc29ydDogX19hcnJheVByb3RvLnNvcnQsIC8vID8gbmFtZSAtIG9yZGVyP1xyXG5cclxuXHJcbiAgICAgICAgICAgIHNwbGljZTogX19hcnJheVByb3RvLnNwbGljZSxcclxuXHJcblxyXG4gICAgICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hcnJheVByb3RvLnNsaWNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgdG8kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICB0b0pRdWVyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcyk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgdW5pcXVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCBfdW5pcXVlKHRoaXMpKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICB1bnNoaWZ0OiBfX2FycmF5UHJvdG8udW5zaGlmdFxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoc2NvcGUsIG9iaiwgZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcclxuICAgICAgICAgICAgaWYgKCFleHQubGVuZ3RoIHx8ICFvYmogfHwgKCEob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgIW9iai5fX2R0X3dyYXBwZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgaSwgaWVuLFxyXG4gICAgICAgICAgICAgICAgaiwgamVuLFxyXG4gICAgICAgICAgICAgICAgc3RydWN0LCBpbm5lcixcclxuICAgICAgICAgICAgICAgIG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoc2NvcGUsIGZuLCBzdHJ1Yykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ldGhvZCBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgX0FwaS5leHRlbmQocmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBleHQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0cnVjdCA9IGV4dFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZVxyXG4gICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXSA9IHR5cGVvZiBzdHJ1Y3QudmFsID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgICAgICAgICBtZXRob2RTY29waW5nKHNjb3BlLCBzdHJ1Y3QudmFsLCBzdHJ1Y3QpIDpcclxuICAgICAgICAgICAgICAgICAgICAkLmlzUGxhaW5PYmplY3Qoc3RydWN0LnZhbCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdC52YWw7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgX0FwaS5leHRlbmQoc2NvcGUsIG9ialtzdHJ1Y3QubmFtZV0sIHN0cnVjdC5wcm9wRXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvLyBAdG9kbyAtIElzIHRoZXJlIG5lZWQgZm9yIGFuIGF1Z21lbnQgZnVuY3Rpb24/XHJcbiAgICAgICAgLy8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gXHQvLyBGaW5kIHNyYyBvYmplY3QgaW4gdGhlIHN0cnVjdHVyZSBmcm9tIHRoZSBuYW1lXHJcbiAgICAgICAgLy8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIC8vIFx0X0FwaS5leHRlbmQoIGluc3QsIG9iaiApO1xyXG4gICAgICAgIC8vIH07XHJcblxyXG5cclxuICAgICAgICAvLyAgICAgW1xyXG4gICAgICAgIC8vICAgICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxyXG4gICAgICAgIC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3RcclxuICAgICAgICAvLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcclxuICAgICAgICAvLyAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgLy8gICAgICAgfSxcclxuICAgICAgICAvLyAgICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBuYW1lOiAgICAgJ3JvdydcclxuICAgICAgICAvLyAgICAgICAgIHZhbDogICAgICAge30sXHJcbiAgICAgICAgLy8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXHJcbiAgICAgICAgLy8gICAgICAgICBwcm9wRXh0OiAgIFtcclxuICAgICAgICAvLyAgICAgICAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcclxuICAgICAgICAvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXHJcbiAgICAgICAgLy8gICAgICAgICAgIH0sXHJcbiAgICAgICAgLy8gICAgICAgICAgIC4uLlxyXG4gICAgICAgIC8vICAgICAgICAgXVxyXG4gICAgICAgIC8vICAgICAgIH1cclxuICAgICAgICAvLyAgICAgXVxyXG5cclxuICAgICAgICBfQXBpLnJlZ2lzdGVyID0gX2FwaV9yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IG5hbWUubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfQXBpLnJlZ2lzdGVyKG5hbWVbal0sIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgaSwgaWVuLFxyXG4gICAgICAgICAgICAgICAgaGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIHN0cnVjdCA9IF9fYXBpU3RydWN0LFxyXG4gICAgICAgICAgICAgICAga2V5LCBtZXRob2Q7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmluZCA9IGZ1bmN0aW9uIChzcmMsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzcmMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjW2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyY1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGhlaXIubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBtZXRob2QgP1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxyXG4gICAgICAgICAgICAgICAgICAgIGhlaXJbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IGZpbmQoc3RydWN0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzcmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcmMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kRXh0OiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEV4dDogW11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdC5wdXNoKHNyYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGllbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcmMudmFsID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0ID0gbWV0aG9kID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjLm1ldGhvZEV4dCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYy5wcm9wRXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIF9BcGkucmVnaXN0ZXJQbHVyYWwgPSBfYXBpX3JlZ2lzdGVyUGx1cmFsID0gZnVuY3Rpb24gKHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsKSB7XHJcbiAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIocGx1cmFsTmFtZSwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIoc2luZ3VsYXJOYW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmV0IGluc3RhbmNlb2YgX0FwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBBUEkgaW5zdGFuY2UgcmV0dXJuZWQsIHdhbnQgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldC5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmlzQXJyYXkocmV0WzBdKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShyZXQuY29udGV4dCwgcmV0WzBdKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFswXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VsZWN0b3IgZm9yIEhUTUwgdGFibGVzLiBBcHBseSB0aGUgZ2l2ZW4gc2VsZWN0b3IgdG8gdGhlIGdpdmUgYXJyYXkgb2ZcclxuICAgICAgICAgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgb3IgaW50ZWdlclxyXG4gICAgICAgICAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcclxuICAgICAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAgICAgKiBAaWdub3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIF9fdGFibGVfc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGEpIHtcclxuICAgICAgICAgICAgLy8gSW50ZWdlciBpcyB1c2VkIHRvIHBpY2sgb3V0IGEgdGFibGUgYnkgaW5kZXhcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbYVtzZWxlY3Rvcl1dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xyXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSAkLm1hcChhLCBmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5uVGFibGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICQobm9kZXMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbGVjdG9yKVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gdHJhbnNsYXRlIGJhY2sgZnJvbSB0aGUgdGFibGUgbm9kZSB0byB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHRoaXMsIG5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtpZHhdO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250ZXh0IHNlbGVjdG9yIGZvciB0aGUgQVBJJ3MgY29udGV4dCAoaS5lLiB0aGUgdGFibGVzIHRoZSBBUEkgaW5zdGFuY2VcclxuICAgICAgICAgKiByZWZlcnMgdG8uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSAgICBEYXRhVGFibGUuQXBpI3RhYmxlc1xyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICogICBzaG91bGQgb3BlcmF0ZSBvbi4gSWYgbm90IGdpdmVuLCBhbGwgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYXJlXHJcbiAgICAgICAgICogICB1c2VkLiBUaGlzIGNhbiBiZSBnaXZlbiBhcyBhIGpRdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgYCc6Z3QoMCknYCkgdG9cclxuICAgICAgICAgKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZS5BcGl9IFJldHVybnMgYSBuZXcgQVBJIGluc3RhbmNlIGlmIGEgc2VsZWN0b3IgaXMgZ2l2ZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcigndGFibGVzKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgLy8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yID9cclxuICAgICAgICAgICAgICAgIG5ldyBfQXBpKF9fdGFibGVfc2VsZWN0b3Ioc2VsZWN0b3IsIHRoaXMuY29udGV4dCkpIDpcclxuICAgICAgICAgICAgICAgIHRoaXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCd0YWJsZSgpJywgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyhzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgIG5ldyBfQXBpKGN0eFswXSkgOlxyXG4gICAgICAgICAgICAgICAgdGFibGVzO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkubm9kZXMoKScsICd0YWJsZSgpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVGFibGU7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkuYm9keSgpJywgJ3RhYmxlKCkuYm9keSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5UQm9keTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5USGVhZDtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5mb290ZXIoKScsICd0YWJsZSgpLmZvb3RlcigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5URm9vdDtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5jb250YWluZXJzKCknLCAndGFibGUoKS5jb250YWluZXIoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2RyYXcoKScsIGZ1bmN0aW9uIChwYWdpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnaW5nID09PSAncGFnZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFnaW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmcgPSBwYWdpbmcgPT09ICdmdWxsLWhvbGQnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MsIHBhZ2luZyA9PT0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZClcclxuICAgICAgICAgKi8vKipcclxuICAgICAgICAqIFNldCB0aGUgY3VycmVudCBwYWdlLlxyXG4gICAgICAgICpcclxuICAgICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXHJcbiAgICAgICAgKiBub3QgdGhyb3cgYW4gZXJyb3IsIGJ1dCByYXRoZXIgcmVzZXQgdGhlIHBhZ2luZy5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxyXG4gICAgICAgICogICogYGludGVnZXJgIC0gVGhlIHBhZ2UgaW5kZXggdG8ganVtcCB0b1xyXG4gICAgICAgICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcclxuICAgICAgICAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cclxuICAgICAgICAqICAgICogYG5leHRgIC0gSnVtcCB0byB0aGUgbmV4dCBwYWdlXHJcbiAgICAgICAgKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2VcclxuICAgICAgICAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxyXG4gICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcbiAgICAgICAgKi9cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdwYWdlKCknLCBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGFjdGlvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElmIHlvdSByZXF1aXJlIHBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgYW5vdGhlciB0YWJsZSwgdXNlIHRoZSBgdGFibGUoKWAgbWV0aG9kXHJcbiAgICAgICAgICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgc2V0OlxyXG4gICAgICAgICAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxyXG4gICAgICAgICAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcclxuICAgICAgICAgKiAgKiBgc3RhcnRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGZpcnN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXHJcbiAgICAgICAgICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxyXG4gICAgICAgICAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcclxuICAgICAgICAgKiAgICArIGxlbmd0aCA9IGVuZGAsIGJ1dCB0aGlzIGlzIG5vdCBhbHdheXMgdHJ1ZSwgZm9yIGV4YW1wbGUgaWYgdGhlcmUgYXJlXHJcbiAgICAgICAgICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cclxuICAgICAgICAgKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXHJcbiAgICAgICAgICogICogYHJlY29yZHNEaXNwbGF5YCAtIERhdGEgc2V0IGxlbmd0aCBvbmNlIHRoZSBjdXJyZW50IGZpbHRlcmluZyBjcml0ZXJpb25cclxuICAgICAgICAgKiAgICBhcmUgYXBwbGllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdwYWdlLmluZm8oKScsIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLmNvbnRleHRbMF0sXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSA/IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6IC0xLFxyXG4gICAgICAgICAgICAgICAgdmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcclxuICAgICAgICAgICAgICAgIGFsbCA9IGxlbiA9PT0gLTE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgXCJwYWdlXCI6IGFsbCA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0IC8gbGVuKSxcclxuICAgICAgICAgICAgICAgIFwicGFnZXNcIjogYWxsID8gMSA6IE1hdGguY2VpbCh2aXNSZWNvcmRzIC8gbGVuKSxcclxuICAgICAgICAgICAgICAgIFwic3RhcnRcIjogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBcImVuZFwiOiBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGxlbixcclxuICAgICAgICAgICAgICAgIFwicmVjb3Jkc1RvdGFsXCI6IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXHJcbiAgICAgICAgICAgICAgICBcInJlY29yZHNEaXNwbGF5XCI6IHZpc1JlY29yZHMsXHJcbiAgICAgICAgICAgICAgICBcInNlcnZlclNpZGVcIjogX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT09ICdzc3AnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgbGVuZ3RoLiBOb3RlIGAtMWAgaW5kaWNhdGVzIHRoYXQgYWxsIHJlY29yZHNcclxuICAgICAgICAgKiAgIGFyZSB0byBiZSBzaG93bi5cclxuICAgICAgICAgKi8vKipcclxuICAgICAgICAqIFNldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cclxuICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcigncGFnZS5sZW4oKScsIGZ1bmN0aW9uIChsZW4pIHtcclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiAnbGVuZ3RoKCknIGJlY2F1c2UgYGxlbmd0aGBcclxuICAgICAgICAgICAgLy8gaXMgYSBKYXZhc2NyaXB0IHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmVzIGhvdyBtYW55IGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZXhwZWN0cy5cclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCBsZW4pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgX19yZWxvYWQgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBkcmF3IGV2ZW50IHRvIHRyaWdnZXIgYSBjYWxsYmFja1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgX0FwaShzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXBpLm9uZSgnZHJhdycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhcGkuYWpheC5qc29uKCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PSAnc3NwJykge1xyXG4gICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzLCBob2xkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gc2V0dGluZ3MuanFYSFI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB4aHJcclxuICAgICAgICAgICAgICAgIF9mbkJ1aWxkQWpheChzZXR0aW5ncywgW10sIGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGEoc2V0dGluZ3MsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzLCBob2xkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgbGFzdCBBamF4IHJlcXVlc3QgdGhhdCBEYXRhVGFibGVzIG1hZGUgdG8gdGhlXHJcbiAgICAgICAgICogc2VydmVyLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBKU09OIGZyb20gdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICogY29udGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gSlNPTiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHhbMF0uanNvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBkYXRhIHN1Ym1pdHRlZCBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdhamF4LnBhcmFtcygpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4WzBdLm9BamF4RGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXHJcbiAgICAgICAgICogYXV0b21hdGljYWxseSByZS1kcmF3IHRoZSB0YWJsZSB3aGVuIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcclxuICAgICAgICAgKiAgIHBvc2l0aW9uLiBBIGZ1bGwgcmUtc29ydCBhbmQgcmUtZmlsdGVyIGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgbWV0aG9kIGlzXHJcbiAgICAgICAgICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uIChjYWxsYmFjaywgcmVzZXRQYWdpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBfX3JlbG9hZChzZXR0aW5ncywgcmVzZXRQYWdpbmcgPT09IGZhbHNlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3RcclxuICAgICAgICAgKiB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxyXG4gICAgICAgICAqLy8qKlxyXG4gICAgICAgICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcclxuICAgICAgICAqIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXHJcbiAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuICAgICAgICAqL1xyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGdldFxyXG4gICAgICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4ID0gY3R4WzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHguYWpheCA/XHJcbiAgICAgICAgICAgICAgICAgICAgJC5pc1BsYWluT2JqZWN0KGN0eC5hamF4KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hamF4LnVybCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hamF4IDpcclxuICAgICAgICAgICAgICAgICAgICBjdHguc0FqYXhTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNldFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qoc2V0dGluZ3MuYWpheCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFqYXggPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnNpZGVyIHNBamF4U291cmNlIGhlcmUgc2luY2UgRGF0YVRhYmxlcyBnaXZlcyBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYGFqYXhgIG92ZXIgYHNBamF4U291cmNlYC4gU28gc2V0dGluZyBgYWpheGAgaGVyZSwgcmVuZGVycyBhbnlcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIG9mIGBzQWpheFNvdXJjZWAgcmVkdW5kYW50LlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XHJcbiAgICAgICAgICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXHJcbiAgICAgICAgICogaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBjYWxsaW5nIGBhamF4LnJlbG9hZCgpYCBidXQgaXMgcHJvdmlkZWQgZm9yXHJcbiAgICAgICAgICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxyXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdhamF4LnVybCgpLmxvYWQoKScsIGZ1bmN0aW9uIChjYWxsYmFjaywgcmVzZXRQYWdpbmcpIHtcclxuICAgICAgICAgICAgLy8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcclxuICAgICAgICAgICAgLy8gdXJsIGNoYW5nZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBfX3JlbG9hZChjdHgsIHJlc2V0UGFnaW5nID09PSBmYWxzZSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgdmFyIF9zZWxlY3Rvcl9ydW4gPSBmdW5jdGlvbiAodHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cykge1xyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIG91dCA9IFtdLCByZXMsXHJcbiAgICAgICAgICAgICAgICBhLCBpLCBpZW4sIGosIGplbixcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yVHlwZSA9IHR5cGVvZiBzZWxlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbid0IGp1c3QgY2hlY2sgZm9yIGlzQXJyYXkgaGVyZSwgYXMgYW4gQVBJIG9yIGpRdWVyeSBpbnN0YW5jZSBtaWdodCBiZVxyXG4gICAgICAgICAgICAvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ3N0cmluZycgfHwgc2VsZWN0b3JUeXBlID09PSAnZnVuY3Rpb24nIHx8IHNlbGVjdG9yLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IFtzZWxlY3Rvcl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNlbGVjdG9yLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNwbGl0IG9uIHNpbXBsZSBzdHJpbmdzIC0gY29tcGxleCBleHByZXNzaW9ucyB3aWxsIGJlIGpRdWVyeSBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIGEgPSBzZWxlY3RvcltpXSAmJiBzZWxlY3RvcltpXS5zcGxpdCAmJiAhc2VsZWN0b3JbaV0ubWF0Y2goL1tcXFtcXCg6XS8pID9cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcclxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0b3JbaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGEubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBzZWxlY3RGbih0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYVtqXSkgOiBhW2pdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQocmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNlbGVjdG9yIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgdmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbdHlwZV07XHJcbiAgICAgICAgICAgIGlmIChleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBleHQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgPSBleHRbaV0oc2V0dGluZ3MsIG9wdHMsIG91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfdW5pcXVlKG91dCk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfc2VsZWN0b3Jfb3B0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0cykge1xyXG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXHJcbiAgICAgICAgICAgIC8vIHRoYW4gc2VhcmNoXHJcbiAgICAgICAgICAgIGlmIChvcHRzLmZpbHRlciAmJiBvcHRzLnNlYXJjaCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogJ2N1cnJlbnQnLFxyXG4gICAgICAgICAgICAgICAgcGFnZTogJ2FsbCdcclxuICAgICAgICAgICAgfSwgb3B0cyk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfc2VsZWN0b3JfZmlyc3QgPSBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgICAgICAvLyBSZWR1Y2UgdGhlIEFQSSBpbnN0YW5jZSB0byB0aGUgZmlyc3QgaXRlbSBmb3VuZFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gaW5zdC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgZmlyc3QgZWxlbWVudCB0byB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdFswXSA9IGluc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdFswXS5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3QubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0LmNvbnRleHQgPSBbaW5zdC5jb250ZXh0W2ldXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdCBmb3VuZCAtIHJldHVybiBhbiBlbXB0eSBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpbnN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICB2YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKHNldHRpbmdzLCBvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgaSwgaWVuLCB0bXAsIGEgPSBbXSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XHJcblxyXG4gICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgIHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBvcHRzLm9yZGVyLCAgIC8vIGFwcGxpZWQsIGN1cnJlbnQsIGluZGV4IChvcmlnaW5hbCAtIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkpXHJcbiAgICAgICAgICAgICAgICBwYWdlID0gb3B0cy5wYWdlOyAgICAvLyBhbGwsIGN1cnJlbnRcclxuXHJcbiAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PSAnc3NwJykge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlLCBtb3N0IG9wdGlvbnMgYXJlIGlycmVsZXZhbnQgc2luY2VcclxuICAgICAgICAgICAgICAgIC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcclxuICAgICAgICAgICAgICAgIC8vIGFycmF5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xyXG4gICAgICAgICAgICAgICAgICAgIFtdIDpcclxuICAgICAgICAgICAgICAgICAgICBfcmFuZ2UoMCwgZGlzcGxheU1hc3Rlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhZ2UgPT0gJ2N1cnJlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpdGxlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gZmFpcmx5IHNlbnNlbGVzcyBvdGhlcndpc2UsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBvcmRlciBhbmQgc2VhcmNoIGFjdHVhbGx5XHJcbiAgICAgICAgICAgICAgICAvLyBhcmVcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LCBpZW4gPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGRpc3BsYXlGaWx0ZXJlZFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJykge1xyXG4gICAgICAgICAgICAgICAgYSA9IHNlYXJjaCA9PSAnbm9uZScgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIuc2xpY2UoKSA6ICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNlYXJjaFxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9PSAnYXBwbGllZCcgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKSA6ICAgICAgICAgICAgICAgIC8vIGFwcGxpZWQgc2VhcmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQubWFwKGRpc3BsYXlNYXN0ZXIsIGZ1bmN0aW9uIChlbCwgaSkgeyAvLyByZW1vdmVkIHNlYXJjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShlbCwgZGlzcGxheUZpbHRlcmVkKSA9PT0gLTEgPyBlbCA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gc2V0dGluZ3MuYW9EYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gJC5pbkFycmF5KGksIGRpc3BsYXlGaWx0ZXJlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0bXAgPj0gMCAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcbiAgICAgICAgICogUm93c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICoge30gICAgICAgICAgLSBubyBzZWxlY3RvciAtIHVzZSBhbGwgYXZhaWxhYmxlIHJvd3NcclxuICAgICAgICAgKiB7aW50ZWdlcn0gICAtIHJvdyBhb0RhdGEgaW5kZXhcclxuICAgICAgICAgKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcclxuICAgICAgICAgKiB7c3RyaW5nfSAgICAtIGpRdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byB0aGUgVFIgZWxlbWVudHNcclxuICAgICAgICAgKiB7YXJyYXl9ICAgICAtIGpRdWVyeSBhcnJheSBvZiBub2Rlcywgb3Igc2ltcGx5IGFuIGFycmF5IG9mIFRSIG5vZGVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIHZhciBfX3Jvd19zZWxlY3RvciA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIHJvd3M7XHJcbiAgICAgICAgICAgIHZhciBydW4gPSBmdW5jdGlvbiAoc2VsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsSW50ID0gX2ludFZhbChzZWwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIGllbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydCBjdXQgLSBzZWxlY3RvciBpcyBhIG51bWJlciBhbmQgbm8gb3B0aW9ucyBwcm92aWRlZCAoZGVmYXVsdCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWxsIHJlY29yZHMsIHNvIG5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGluZGV4IGlzIGluIHRoZXJlLCBzaW5jZSBpdFxyXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ICE9PSBudWxsICYmICFvcHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcm93cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KHNlbEludCwgcm93cykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdW5kZWZpbmVkIHx8IHNlbCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIG5vbmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93cztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChyb3dzLCBmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbaWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbChpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIpID8gaWR4IDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcclxuICAgICAgICAgICAgICAgICAgICBfcGx1Y2tfb3JkZXIoc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnblRyJylcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBub2RlXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5fRFRfUm93SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlbC5fRFRfUm93SW5kZXhdOyAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLl9EVF9DZWxsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWwuX0RUX0NlbGxJbmRleC5yb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3QgPSAkKHNlbCkuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3QubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtob3N0LmRhdGEoJ2R0LXJvdycpXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3IuIFdhbnQgdG8gYWx3YXlzIGJlIGFibGUgdG8gc2VsZWN0IHJvd3MgYnkgaWQsIHJlZ2FyZGxlc3NcclxuICAgICAgICAgICAgICAgIC8vIG9mIGlmIHRoZSB0ciBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3Igbm90LCBzbyBjYW4ndCByZWx5IHVwb25cclxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBoZXJlIC0gaGVuY2UgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uIFRoaXMgZG9lcyBub3QgbWF0Y2hcclxuICAgICAgICAgICAgICAgIC8vIFNpenpsZSdzIGZhc3Qgc2VsZWN0b3Igb3IgSFRNTDQgLSBpbiBIVE1MNSB0aGUgSUQgY2FuIGJlIGFueXRoaW5nLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRvIHNlbGVjdCBpdCB1c2luZyBhIENTUyBzZWxlY3RvciBlbmdpbmUgKGxpa2UgU2l6emxlIG9yXHJcbiAgICAgICAgICAgICAgICAvLyBxdWVyeVNlbGVjdCkgaXQgd291bGQgbmVlZCB0byBuZWVkIHRvIGJlIGVzY2FwZWQgZm9yIHNvbWUgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgc2ltcGxpZmllcyB0aGlzIGZvciByb3cgc2VsZWN0b3JzIHNpbmNlIHlvdSBjYW4gc2VsZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGEgcm93LiBBICMgaW5kaWNhdGVzIGFuIGlkIGFueSBhbnl0aGluZyB0aGF0IGZvbGxvd3MgaXMgdGhlIGlkIC1cclxuICAgICAgICAgICAgICAgIC8vIHVuZXNjYXBlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyAmJiBzZWwuY2hhckF0KDApID09PSAnIycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgcm93IGluZGV4IGZyb20gaWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93T2JqID0gc2V0dGluZ3MuYUlkc1tzZWwucmVwbGFjZSgvXiMvLCAnJyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dPYmogIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jvd09iai5pZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBmYWxsIHRocm91Z2ggdG8galF1ZXJ5IGluIGNhc2UgdGhlcmUgaXMgRE9NIGlkIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nLCBhcnJheSBvZiBub2RlcyBvciBqUXVlcnkgb2JqZWN0L1xyXG4gICAgICAgICAgICAgICAgLy8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgLy8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJChub2RlcylcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfcnVuKCdyb3cnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MoKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xyXG4gICAgICAgICAgICAvLyBhcmd1bWVudCBzaGlmdGluZ1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRzID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRzID0gX3NlbGVjdG9yX29wdHMob3B0cyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19yb3dfc2VsZWN0b3Ioc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzKTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9fcm93X3NlbGVjdG9yP1xyXG4gICAgICAgICAgICBpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3dzKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3JvdycsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9EYXRhW3Jvd10ublRyIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKHRydWUsICdyb3dzJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3dzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ19hRGF0YScpO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzZXR0aW5ncy5hb0RhdGFbcm93XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLmludmFsaWRhdGUoKScsICdyb3coKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoc3JjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xyXG4gICAgICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShzZXR0aW5ncywgcm93LCBzcmMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLmluZGV4ZXMoKScsICdyb3coKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuaWRzKCknLCAncm93KCkuaWQoKScsIGZ1bmN0aW9uIChoYXNoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgLy8gYGl0ZXJhdG9yYCB3aWxsIGRyb3AgdW5kZWZpbmVkIHZhbHVlcywgYnV0IGluIHRoaXMgY2FzZSB3ZSB3YW50IHRoZW1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqZW4gPSB0aGlzW2ldLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKGNvbnRleHRbaV0uYW9EYXRhW3RoaXNbaV1bal1dLl9hRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKChoYXNoID09PSB0cnVlID8gJyMnIDogJycpICsgaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkoY29udGV4dCwgYSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3Jvd3MoKS5yZW1vdmUoKScsICdyb3coKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIHRoYXRJZHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSBkYXRhW3Jvd107XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgaWVuLCBqLCBqZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9vcFJvdywgbG9vcENlbGxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKHJvdywgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjYWNoZWQgaW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3BSb3cgPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3BDZWxscyA9IGxvb3BSb3cuYW5DZWxscztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wUm93Lm5UciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wUm93Lm5Uci5fRFRfUm93SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VsbHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcENlbGxzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGxvb3BDZWxscy5sZW5ndGg7IGogPCBqZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcENlbGxzW2pdLl9EVF9DZWxsSW5kZXgucm93ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcclxuICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlciwgcm93KTtcclxuICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHNldHRpbmdzLmFpRGlzcGxheSwgcm93KTtcclxuICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHRoYXRbdGhhdElkeF0sIHJvdywgZmFsc2UpOyAvLyBtYWludGFpbiBsb2NhbCBpbmRleGVzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzIC0gc3VidHJhY3QgdGhlIGRlbGV0ZWQgcm93IGZyb20gdGhlIGNvdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxyXG4gICAgICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcm93J3MgSUQgcmVmZXJlbmNlIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbihyb3dEYXRhLl9hRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5hSWRzW2lkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFvRGF0YVtpXS5pZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cy5hZGQoKScsIGZ1bmN0aW9uIChyb3dzKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdSb3dzID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3csIGksIGllbjtcclxuICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSByb3dzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChfZm5BZGRUcihzZXR0aW5ncywgcm93KVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChfZm5BZGREYXRhKHNldHRpbmdzLCByb3cpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgc28gcm93cygpLm5vZGVzKCkgZXRjIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICAgIHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKC0xKTtcclxuICAgICAgICAgICAgbW9kUm93cy5wb3AoKTtcclxuICAgICAgICAgICAgJC5tZXJnZShtb2RSb3dzLCBuZXdSb3dzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtb2RSb3dzO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3coKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KHRoaXMucm93cyhzZWxlY3Rvciwgb3B0cykpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93KCkuZGF0YSgpJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2FEYXRhIDpcclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldFxyXG4gICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9hRGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcclxuICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgIGN0eFswXS5hb0RhdGFbdGhpc1swXV0ublRyIHx8IG51bGwgOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvdy5hZGQoKScsIGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgLy8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cclxuICAgICAgICAgICAgLy8gaXQgdGhvdWdoIC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxyXG4gICAgICAgICAgICBpZiAocm93IGluc3RhbmNlb2YgJCAmJiByb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSByb3dbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkVHIoc2V0dGluZ3MsIHJvdylbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkRGF0YShzZXR0aW5ncywgcm93KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgcm93IHNlbGVjdGVkXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdyhyb3dzWzBdKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgX19kZXRhaWxzX2FkZCA9IGZ1bmN0aW9uIChjdHgsIHJvdywgZGF0YSwga2xhc3MpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYWRkUm93ID0gZnVuY3Rpb24gKHIsIGspIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KHIpIHx8IHIgaW5zdGFuY2VvZiAkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHIubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUm93KHJbaV0sIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcclxuICAgICAgICAgICAgICAgIC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcclxuICAgICAgICAgICAgICAgIGlmIChyLm5vZGVOYW1lICYmIHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZCA9ICQoJzx0cj48dGQvPjwvdHI+JykuYWRkQ2xhc3Moayk7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgndGQnLCBjcmVhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwocilcclxuICAgICAgICAgICAgICAgICAgICBbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKGNyZWF0ZWRbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgYWRkUm93KGRhdGEsIGtsYXNzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5kZXRhY2goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93Ll9kZXRhaWxzID0gJChyb3dzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXHJcbiAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHNTaG93KSB7XHJcbiAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIocm93Lm5Ucik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9fZGV0YWlsc19yZW1vdmUgPSBmdW5jdGlvbiAoYXBpLCBpZHgpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IGFwaS5jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBjdHhbMF0uYW9EYXRhW2lkeCAhPT0gdW5kZWZpbmVkID8gaWR4IDogYXBpWzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocm93ICYmIHJvdy5fZGV0YWlscykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKGFwaSwgc2hvdykge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCAmJiBhcGkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVthcGlbMF1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHNTaG93ID0gc2hvdztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmRldGFjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX2V2ZW50cyhjdHhbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfX2RldGFpbHNfZXZlbnRzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgX0FwaShzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xyXG4gICAgICAgICAgICB2YXIgZHJhd0V2ZW50ID0gJ2RyYXcnICsgbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICB2YXIgY29sdmlzRXZlbnQgPSAnY29sdW1uLXZpc2liaWxpdHknICsgbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICB2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3knICsgbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGFwaS5vZmYoZHJhd0V2ZW50ICsgJyAnICsgY29sdmlzRXZlbnQgKyAnICcgKyBkZXN0cm95RXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9wbHVjayhkYXRhLCAnX2RldGFpbHMnKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbiBlYWNoIGRyYXcsIGluc2VydCB0aGUgcmVxdWlyZWQgZWxlbWVudHMgaW50byB0aGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIGFwaS5vbihkcmF3RXZlbnQsIGZ1bmN0aW9uIChlLCBjdHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcGkucm93cyh7IHBhZ2U6ICdjdXJyZW50JyB9KS5lcSgwKS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgZGF0YSBncmFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBkYXRhW2lkeF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzU2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2UgLSB1cGRhdGUgdGhlIGNvbHNwYW5cclxuICAgICAgICAgICAgICAgIGFwaS5vbihjb2x2aXNFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCwgaWR4LCB2aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGNvbHNwYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gZGF0YVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5jaGlsZHJlbigndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXHJcbiAgICAgICAgICAgICAgICBhcGkub24oZGVzdHJveUV2ZW50LCBmdW5jdGlvbiAoZSwgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0uX2RldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUoYXBpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxyXG4gICAgICAgIHZhciBfZW1wID0gJyc7XHJcbiAgICAgICAgdmFyIF9jaGlsZF9vYmogPSBfZW1wICsgJ3JvdygpLmNoaWxkJztcclxuICAgICAgICB2YXIgX2NoaWxkX210aCA9IF9jaGlsZF9vYmogKyAnKCknO1xyXG5cclxuICAgICAgICAvLyBkYXRhIGNhbiBiZTpcclxuICAgICAgICAvLyAgdHJcclxuICAgICAgICAvLyAgc3RyaW5nXHJcbiAgICAgICAgLy8gIGpRdWVyeSBvciBhcnJheSBvZiBhbnkgb2YgdGhlIGFib3ZlXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcihfY2hpbGRfbXRoLCBmdW5jdGlvbiAoZGF0YSwga2xhc3MpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGdldFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2RldGFpbHMgOlxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaG93XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICBfX2RldGFpbHNfcmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldFxyXG4gICAgICAgICAgICAgICAgX19kZXRhaWxzX2FkZChjdHhbMF0sIGN0eFswXS5hb0RhdGFbdGhpc1swXV0sIGRhdGEsIGtsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKFtcclxuICAgICAgICAgICAgX2NoaWxkX29iaiArICcuc2hvdygpJyxcclxuICAgICAgICAgICAgX2NoaWxkX210aCArICcuc2hvdygpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XHJcbiAgICAgICAgXSwgZnVuY3Rpb24gKHNob3cpIHsgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxyXG4gICAgICAgICAgICBfX2RldGFpbHNfZGlzcGxheSh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKFtcclxuICAgICAgICAgICAgX2NoaWxkX29iaiArICcuaGlkZSgpJyxcclxuICAgICAgICAgICAgX2NoaWxkX210aCArICcuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XHJcbiAgICAgICAgXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXHJcbiAgICAgICAgICAgIF9fZGV0YWlsc19kaXNwbGF5KHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKFtcclxuICAgICAgICAgICAgX2NoaWxkX29iaiArICcucmVtb3ZlKCknLFxyXG4gICAgICAgICAgICBfY2hpbGRfbXRoICsgJy5yZW1vdmUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxyXG4gICAgICAgIF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXHJcbiAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcihfY2hpbGRfb2JqICsgJy5pc1Nob3duKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4WzBdLmFvRGF0YVt0aGlzWzBdXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICAgICAqIENvbHVtbnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHtpbnRlZ2VyfSAgICAgICAgICAgLSBjb2x1bW4gaW5kZXggKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXHJcbiAgICAgICAgICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxyXG4gICAgICAgICAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcclxuICAgICAgICAgKiBcIntzdHJpbmd9Om5hbWVcIiAgICAgLSBjb2x1bW4gbmFtZVxyXG4gICAgICAgICAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gY2FuIGJlIGFuIGFycmF5IG9mIHRoZXNlIGl0ZW1zLCBjb21tYSBzZXBhcmF0ZWQgbGlzdCwgb3IgYW4gYXJyYXkgb2YgY29tbWFcclxuICAgICAgICAvLyBzZXBhcmF0ZWQgbGlzdHNcclxuXHJcbiAgICAgICAgdmFyIF9fcmVfY29sdW1uX3NlbGVjdG9yID0gL14oW146XSspOihuYW1lfHZpc0lkeHx2aXNpYmxlKSQvO1xyXG5cclxuXHJcbiAgICAgICAgLy8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXHJcbiAgICAgICAgLy8gaXRlcmF0b3IgY2FsbGJhY2sgaW4gY29sdW1ucygpLmRhdGEoKVxyXG4gICAgICAgIHZhciBfX2NvbHVtbkRhdGEgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbiwgcjEsIHIyLCByb3dzKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDAsIGllbiA9IHJvd3MubGVuZ3RoOyByb3cgPCBpZW47IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBhLnB1c2goX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd3Nbcm93XSwgY29sdW1uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG4gICAgICAgICAgICAgICAgbmFtZXMgPSBfcGx1Y2soY29sdW1ucywgJ3NOYW1lJyksXHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IF9wbHVjayhjb2x1bW5zLCAnblRoJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxJbnQgPSBfaW50VmFsKHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gYWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JhbmdlKGNvbHVtbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGluZGV4XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnQgPj0gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbEludCA6IC8vIENvdW50IGZyb20gbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciA9IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyhzZXR0aW5ncywgb3B0cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2NvbHVtbkRhdGEoc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpZHhdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgPyBpZHggOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgcy5tYXRjaChfX3JlX2NvbHVtbl9zZWxlY3RvcikgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzSWR4JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzaWJsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpc2libGUgaW5kZXggZ2l2ZW4sIGNvbnZlcnQgdG8gY29sdW1uIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50aW5nIGZyb20gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc0NvbHVtbnMgPSAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wuYlZpc2libGUgPyBpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Zpc0NvbHVtbnNbdmlzQ29sdW1ucy5sZW5ndGggKyBpZHhdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50aW5nIGZyb20gdGhlIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoc2V0dGluZ3MsIGlkeCldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gbWF0Y2hbMV0gPyBpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2VsbCBpbiB0aGUgdGFibGUgYm9keVxyXG4gICAgICAgICAgICAgICAgaWYgKHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzLl9EVF9DZWxsSW5kZXguY29sdW1uXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIFRIIGVsZW1lbnRzIGZvciB0aGUgY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgdmFyIGpxUmVzdWx0ID0gJChub2RlcylcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkodGhpcywgbm9kZXMpOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGpxUmVzdWx0Lmxlbmd0aCB8fCAhcy5ub2RlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYSBub2RlIHdoaWNoIG1pZ2h0IGhhdmUgYSBgZHQtY29sdW1uYCBkYXRhIGF0dHJpYnV0ZSwgb3IgYmVcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgb3Igc3VjaCBhbiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LWNvbHVtbl0nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob3N0Lmxlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICAgICAgW2hvc3QuZGF0YSgnZHQtY29sdW1uJyldIDpcclxuICAgICAgICAgICAgICAgICAgICBbXTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfcnVuKCdjb2x1bW4nLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBfX3NldENvbHVtblZpcyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCB2aXMpIHtcclxuICAgICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICAgICBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG4gICAgICAgICAgICAgICAgY29sID0gY29sc1tjb2x1bW5dLFxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHNldHRpbmdzLmFvRGF0YSxcclxuICAgICAgICAgICAgICAgIHJvdywgY2VsbHMsIGksIGllbiwgdHI7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXRcclxuICAgICAgICAgICAgaWYgKHZpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sLmJWaXNpYmxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXRcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcbiAgICAgICAgICAgIGlmIChjb2wuYlZpc2libGUgPT09IHZpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgY29sdW1uXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxyXG4gICAgICAgICAgICAgICAgdmFyIGluc2VydEJlZm9yZSA9ICQuaW5BcnJheSh0cnVlLCBfcGx1Y2soY29scywgJ2JWaXNpYmxlJyksIGNvbHVtbiArIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0ciA9IGRhdGFbaV0ublRyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGNhbiBhY3QgbGlrZSBhcHBlbmRDaGlsZCBpZiAybmQgYXJnIGlzIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0QmVmb3JlKGNlbGxzW2NvbHVtbl0sIGNlbGxzW2luc2VydEJlZm9yZV0gfHwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbHVtblxyXG4gICAgICAgICAgICAgICAgJChfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbHVtbikpLmRldGFjaCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21tb24gYWN0aW9uc1xyXG4gICAgICAgICAgICBjb2wuYlZpc2libGUgPSB2aXM7XHJcbiAgICAgICAgICAgIF9mbkRyYXdIZWFkKHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlcik7XHJcbiAgICAgICAgICAgIF9mbkRyYXdIZWFkKHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3Rlcik7XHJcblxyXG4gICAgICAgICAgICBfZm5TYXZlU3RhdGUoc2V0dGluZ3MpO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW5zKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuICAgICAgICAgICAgLy8gYXJndW1lbnQgc2hpZnRpbmdcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0cyA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0cyA9IF9zZWxlY3Rvcl9vcHRzKG9wdHMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfcm93X3NlbGVjdG9yP1xyXG4gICAgICAgICAgICBpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmZvb3RlcigpJywgJ2NvbHVtbigpLmZvb3RlcigpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UZjtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5kYXRhKCknLCAnY29sdW1uKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ubURhdGE7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfcGx1Y2tfb3JkZXIoc2V0dGluZ3MuYW9EYXRhLCByb3dzLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5ub2RlcygpJywgJ2NvbHVtbigpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAodmlzLCBjYWxjKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLmJWaXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlXHJcbiAgICAgICAgICAgICAgICBfX3NldENvbHVtblZpcyhzZXR0aW5ncywgY29sdW1uLCB2aXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyb3VwIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2VzXHJcbiAgICAgICAgICAgIGlmICh2aXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi12aXNpYmlsaXR5JywgW3NldHRpbmdzLCBjb2x1bW4sIHZpcywgY2FsY10pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmFkanVzdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuaW5kZXhlcygpJywgJ2NvbHVtbigpLmluZGV4KCknLCBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAndmlzaWJsZScgP1xyXG4gICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKHNldHRpbmdzLCBjb2x1bW4pIDpcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW47XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW5zLmFkanVzdCgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICh0eXBlLCBpZHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmcm9tVmlzaWJsZScgfHwgdHlwZSA9PT0gJ3RvRGF0YScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoY3R4LCBpZHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShjdHgsIGlkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcignY29sdW1uKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9maXJzdCh0aGlzLmNvbHVtbnMoc2VsZWN0b3IsIG9wdHMpKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgX19jZWxsX3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xyXG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoX3BsdWNrX29yZGVyKGRhdGEsIHJvd3MsICdhbkNlbGxzJykpO1xyXG4gICAgICAgICAgICB2YXIgYWxsQ2VsbHMgPSAkKFtdLmNvbmNhdC5hcHBseShbXSwgY2VsbHMpKTtcclxuICAgICAgICAgICAgdmFyIHJvdztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm5TZWxlY3RvciA9IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCB8fCBmblNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNlbGxzIGFuZCBmdW5jdGlvbiBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICBhID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHJvd3MubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmblNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3QgPSBkYXRhW3Jvd107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKG8sIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGopLCBob3N0LmFuQ2VsbHMgPyBob3N0LmFuQ2VsbHNbal0gOiBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBhbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW5kZXhcclxuICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QocykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXHJcbiAgICAgICAgICAgICAgICB2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocylcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAvLyB1c2UgYSBuZXcgb2JqZWN0LCBpbiBjYXNlIHNvbWVvbmUgY2hhbmdlcyB0aGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IGVsLl9EVF9DZWxsSW5kZXgucm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlbC5fRFRfQ2VsbEluZGV4LmNvbHVtblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoanFSZXN1bHQubGVuZ3RoIHx8ICFzLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgc2VsZWN0b3IgaXMgYSBub2RlLCBhbmQgdGhlcmUgaXMgb25lIGxhc3Qgb3B0aW9uIC0gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG1pZ2h0IGJlIGEgY2hpbGQgb2YgYW4gZWxlbWVudCB3aGljaCBoYXMgZHQtcm93IGFuZCBkdC1jb2x1bW5cclxuICAgICAgICAgICAgICAgIC8vIGRhdGEgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgaG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob3N0Lmxlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICAgICAgW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBob3N0LmRhdGEoJ2R0LXJvdycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGhvc3QuZGF0YSgnZHQtY29sdW1uJylcclxuICAgICAgICAgICAgICAgICAgICB9XSA6XHJcbiAgICAgICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX3J1bignY2VsbCcsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxscygpJywgZnVuY3Rpb24gKHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cykge1xyXG4gICAgICAgICAgICAvLyBBcmd1bWVudCBzaGlmdGluZ1xyXG4gICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHJvd1NlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvd1NlbGVjdG9yLnJvdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcm93U2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93U2VsZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSBjb2x1bW5TZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TZWxlY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChjb2x1bW5TZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIG9wdHMgPSBjb2x1bW5TZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2VsbCBzZWxlY3RvclxyXG4gICAgICAgICAgICBpZiAoY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fY2VsbF9zZWxlY3RvcihzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKG9wdHMpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3JcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoY29sdW1uU2VsZWN0b3IsIG9wdHMpO1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMucm93cyhyb3dTZWxlY3Rvciwgb3B0cyk7XHJcbiAgICAgICAgICAgIHZhciBhLCBpLCBpZW4sIGosIGplbjtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgIGEgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSByb3dzW2lkeF0ubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSBjb2x1bW5zW2lkeF0ubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93c1tpZHhdW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5zW2lkeF1bal1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuXHJcbiAgICAgICAgICAgICQuZXh0ZW5kKGNlbGxzLnNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgICAgICBjb2xzOiBjb2x1bW5TZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIHJvd3M6IHJvd1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgb3B0czogb3B0c1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjZWxscztcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd107XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgJiYgZGF0YS5hbkNlbGxzID9cclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFuQ2VsbHNbY29sdW1uXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NlbGxzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBjb2x1bW4pO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NlbGxzKCkuY2FjaGUoKScsICdjZWxsKCkuY2FjaGUoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9EYXRhW3Jvd11bdHlwZV1bY29sdW1uXTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGNvbHVtbiwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5pbmRleGVzKCknLCAnY2VsbCgpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShzZXR0aW5ncywgY29sdW1uKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKHNyYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvdywgc3JjLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxsKCknLCBmdW5jdGlvbiAocm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfZmlyc3QodGhpcy5jZWxscyhyb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMpKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NlbGwoKS5kYXRhKCknLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIGNlbGwubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YShjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbikgOlxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0XHJcbiAgICAgICAgICAgIF9mblNldENlbGxEYXRhKGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uLCBkYXRhKTtcclxuICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShjdHhbMF0sIGNlbGxbMF0ucm93LCAnZGF0YScsIGNlbGxbMF0uY29sdW1uKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBjdXJyZW50IG9yZGVyaW5nIChzb3J0aW5nKSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIHRhYmxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2FycmF5fSAyRCBhcnJheSBjb250YWluaW5nIHRoZSBzb3J0aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3RcclxuICAgICAgICAgKiAgIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuIEVhY2ggZWxlbWVudCBpbiB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudHNcclxuICAgICAgICAgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXHJcbiAgICAgICAgICogICAyIGlubmVyIGFycmF5cykuIFRoZSBpbm5lciBhcnJheXMgbWF5IGhhdmUgMiBvciAzIGVsZW1lbnRzLiBUaGUgZmlyc3QgaXNcclxuICAgICAgICAgKiAgIHRoZSBjb2x1bW4gaW5kZXggdGhhdCB0aGUgc29ydGluZyBjb25kaXRpb24gYXBwbGllcyB0bywgdGhlIHNlY29uZCBpcyB0aGVcclxuICAgICAgICAgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcclxuICAgICAgICAgKiAgIGluZGV4IG9mIHRoZSBzb3J0aW5nIG9yZGVyIGZyb20gdGhlIGBjb2x1bW4uc29ydGluZ2AgaW5pdGlhbGlzYXRpb24gYXJyYXkuXHJcbiAgICAgICAgICovLyoqXHJcbiAgICAgICAgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBvcmRlciBDb2x1bW4gaW5kZXggdG8gc29ydCB1cG9uLlxyXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBEaXJlY3Rpb24gb2YgdGhlIHNvcnQgdG8gYmUgYXBwbGllZCAoYGFzY2Agb3IgYGRlc2NgKVxyXG4gICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcbiAgICAgICAgKi8vKipcclxuICAgICAgICAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAxRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXHJcbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBbLi4uXSBPcHRpb25hbCBhZGRpdGlvbmFsIHNvcnRpbmcgY29uZGl0aW9uc1xyXG4gICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcbiAgICAgICAgKi8vKipcclxuICAgICAgICAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAyRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXHJcbiAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuICAgICAgICAqL1xyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ29yZGVyKCknLCBmdW5jdGlvbiAob3JkZXIsIGRpcikge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKG9yZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGdldFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hYVNvcnRpbmcgOlxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc2V0XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgY29sdW1uIC8gZGlyZWN0aW9uIHBhc3NlZCBpblxyXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBbW29yZGVyLCBkaXJdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmRlci5sZW5ndGggJiYgISQuaXNBcnJheShvcmRlclswXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxyXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIDJEIGFycmF5IHdhcyBwYXNzZWQgaW5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gb3JkZXIuc2xpY2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge25vZGV8alF1ZXJ5fHN0cmluZ30gbm9kZSBJZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2ggdGhlXHJcbiAgICAgICAgICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcclxuICAgICAgICAgKiAgIGNvbGxlY3Rpb24gb2Ygbm9kZXMgb3IgYSBqUXVlcnkgc2VsZWN0b3Igd2hpY2ggd2lsbCBpZGVudGlmeSB0aGUgbm9kZShzKS5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcignb3JkZXIubGlzdGVuZXIoKScsIGZ1bmN0aW9uIChub2RlLCBjb2x1bW4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgX2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdvcmRlci5maXhlZCgpJywgZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICBpZiAoIXNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIHZhciBmaXhlZCA9IGN0eC5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hYVNvcnRpbmdGaXhlZCA6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmlzQXJyYXkoZml4ZWQpID9cclxuICAgICAgICAgICAgICAgICAgICB7IHByZTogZml4ZWQgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSAkLmV4dGVuZCh0cnVlLCB7fSwgc2V0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcihbXHJcbiAgICAgICAgICAgICdjb2x1bW5zKCkub3JkZXIoKScsXHJcbiAgICAgICAgICAgICdjb2x1bW4oKS5vcmRlcigpJ1xyXG4gICAgICAgIF0sIGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc29ydCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGF0W2ldLCBmdW5jdGlvbiAoaiwgY29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydC5wdXNoKFtjb2wsIGRpcl0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gc29ydDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcignc2VhcmNoKCknLCBmdW5jdGlvbiAoaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNldFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGUoc2V0dGluZ3MsICQuZXh0ZW5kKHt9LCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHtcclxuICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogaW5wdXQgKyBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYlJlZ2V4XCI6IHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcclxuICAgICAgICAgICAgICAgICAgICBcImJTbWFydFwiOiBzbWFydCA9PT0gbnVsbCA/IHRydWUgOiBzbWFydCxcclxuICAgICAgICAgICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxyXG4gICAgICAgICAgICAgICAgfSksIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoXHJcbiAgICAgICAgICAgICdjb2x1bW5zKCkuc2VhcmNoKCknLFxyXG4gICAgICAgICAgICAnY29sdW1uKCkuc2VhcmNoKCknLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZVNlYXJjaFtjb2x1bW5dLnNTZWFyY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHByZVNlYXJjaFtjb2x1bW5dLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic1NlYXJjaFwiOiBpbnB1dCArIFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYlJlZ2V4XCI6IHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiU21hcnRcIjogc21hcnQgPT09IG51bGwgPyB0cnVlIDogc21hcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFN0YXRlIEFQSSBtZXRob2RzXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3N0YXRlKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dFswXS5vU2F2ZWRTdGF0ZSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUuY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGFuIGVtcHR5IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHt9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZS5sb2FkZWQoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUuc2F2ZSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIF9mblNhdmVTdGF0ZShzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXHJcbiAgICAgICAgICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cclxuICAgICAgICAgKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cclxuICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0b1xyXG4gICAgICAgICAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxyXG4gICAgICAgICAqICAgIHN1aXRhYmxlXHJcbiAgICAgICAgICogIEBzdGF0aWNcclxuICAgICAgICAgKiAgQGR0b3B0IEFQSS1TdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERhdGFUYWJsZS52ZXJzaW9uQ2hlY2sgPSBEYXRhVGFibGUuZm5WZXJzaW9uQ2hlY2sgPSBmdW5jdGlvbiAodmVyc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgYVRoaXMgPSBEYXRhVGFibGUudmVyc2lvbi5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIHZhciBpVGhpcywgaVRoYXQ7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGFUaGF0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaVRoaXMgPSBwYXJzZUludChhVGhpc1tpXSwgMTApIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpVGhhdCA9IHBhcnNlSW50KGFUaGF0W2ldLCAxMCkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQYXJ0cyBhcmUgdGhlIHNhbWUsIGtlZXAgY29tcGFyaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaVRoaXMgPT09IGlUaGF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGFydHMgYXJlIGRpZmZlcmVudCwgcmV0dXJuIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaVRoaXMgPiBpVGhhdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfGpxdWVyeXxzdHJpbmd9IHRhYmxlIFRhYmxlIG5vZGUsIGpRdWVyeSBvYmplY3Qgb3IgalF1ZXJ5XHJcbiAgICAgICAgICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxyXG4gICAgICAgICAqICAgICAgdGFibGUgaXMgcGFzc2VkIG9uLCBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGNoZWNrZWRcclxuICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgdGhlIHRhYmxlIGdpdmVuIGlzIGEgRGF0YVRhYmxlLCBvciBmYWxzZSBvdGhlcndpc2VcclxuICAgICAgICAgKiAgQHN0YXRpY1xyXG4gICAgICAgICAqICBAZHRvcHQgQVBJLVN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgaWYgKCAhICQuZm4uRGF0YVRhYmxlLmlzRGF0YVRhYmxlKCAnI2V4YW1wbGUnICkgKSB7XHJcbiAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG4gICAgICAgICAqICAgIH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBEYXRhVGFibGUuaXNEYXRhVGFibGUgPSBEYXRhVGFibGUuZm5Jc0RhdGFUYWJsZSA9IGZ1bmN0aW9uICh0YWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcclxuICAgICAgICAgICAgdmFyIGlzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFibGUgaW5zdGFuY2VvZiBEYXRhVGFibGUuQXBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJC5lYWNoKERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKGksIG8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkID0gby5uU2Nyb2xsSGVhZCA/ICQoJ3RhYmxlJywgby5uU2Nyb2xsSGVhZClbMF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaXM7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbGwgRGF0YVRhYmxlIHRhYmxlcyB0aGF0IGhhdmUgYmVlbiBpbml0aWFsaXNlZCAtIG9wdGlvbmFsbHkgeW91IGNhblxyXG4gICAgICAgICAqIHNlbGVjdCB0byBnZXQgb25seSBjdXJyZW50bHkgdmlzaWJsZSB0YWJsZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbdmlzaWJsZT1mYWxzZV0gRmxhZyB0byBpbmRpY2F0ZSBpZiB5b3Ugd2FudCBhbGwgKGRlZmF1bHQpXHJcbiAgICAgICAgICogICAgb3IgdmlzaWJsZSB0YWJsZXMgb25seS5cclxuICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXHJcbiAgICAgICAgICogICAgRGF0YVRhYmxlc1xyXG4gICAgICAgICAqICBAc3RhdGljXHJcbiAgICAgICAgICogIEBkdG9wdCBBUEktU3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAqICAgICAgJCh0YWJsZSkuRGF0YVRhYmxlKCkuY29sdW1ucy5hZGp1c3QoKTtcclxuICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLnRhYmxlcyA9IERhdGFUYWJsZS5mblRhYmxlcyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcGkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIGFwaSA9IHZpc2libGUuYXBpO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHZpc2libGUudmlzaWJsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGEgPSAkLm1hcChEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUgfHwgKHZpc2libGUgJiYgJChvLm5UYWJsZSkuaXMoJzp2aXNpYmxlJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ublRhYmxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcGkgP1xyXG4gICAgICAgICAgICAgICAgbmV3IF9BcGkoYSkgOlxyXG4gICAgICAgICAgICAgICAgYTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4gbm90YXRpb24uIFRoaXMgaXMgbWFkZSBwdWJsaWNcclxuICAgICAgICAgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcclxuICAgICAgICAgKiBlaXRoZXIgdGhlIDEuOSBzdHlsZSBIdW5nYXJpYW4gbm90YXRpb24sIG9yIHRoZSAxLjEwKyBzdHlsZSBjYW1lbENhc2VcclxuICAgICAgICAgKiBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxyXG4gICAgICAgICAqICAgIG1hcHBlZC5cclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXHJcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXHJcbiAgICAgICAgICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XHJcbiAgICAgICAgICogICAgd29uJ3QgYmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLmNhbWVsVG9IdW5nYXJpYW4gPSBfZm5DYW1lbFRvSHVuZ2FyaWFuO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcignJCgpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgcm93cyA9IHRoaXMucm93cyhvcHRzKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3NcclxuICAgICAgICAgICAgICAgIGpxUm93cyA9ICQocm93cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gJChbXS5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBqcVJvd3MuZmlsdGVyKHNlbGVjdG9yKS50b0FycmF5KCksXHJcbiAgICAgICAgICAgICAgICBqcVJvd3MuZmluZChzZWxlY3RvcikudG9BcnJheSgpXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8galF1ZXJ5IGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIHRoZSB0YWJsZXNcclxuICAgICAgICAkLmVhY2goWydvbicsICdvbmUnLCAnb2ZmJ10sIGZ1bmN0aW9uIChpLCBrZXkpIHtcclxuICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihrZXkgKyAnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBgZHRgIG5hbWVzcGFjZSBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgYXJnc1swXSA9ICQubWFwKGFyZ3NbMF0uc3BsaXQoL1xccy8pLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZS5tYXRjaCgvXFwuZHRcXGIvKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgKyAnLmR0JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGU7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluc3QgPSAkKHRoaXMudGFibGVzKCkubm9kZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0W2tleV0uYXBwbHkoaW5zdCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjbGVhcigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIF9mbkNsZWFyVGFibGUoc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdpbml0KCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoID8gY3R4WzBdLm9Jbml0IDogbnVsbDtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2RhdGEoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrKHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScpO1xyXG4gICAgICAgICAgICB9KS5mbGF0dGVuKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdkZXN0cm95KCknLCBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZSA9IHJlbW92ZSB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gc2V0dGluZ3MublRhYmxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRib2R5ID0gc2V0dGluZ3MublRCb2R5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZWFkID0gc2V0dGluZ3MublRIZWFkO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRmb290ID0gc2V0dGluZ3MublRGb290O1xyXG4gICAgICAgICAgICAgICAgdmFyIGpxVGFibGUgPSAkKHRhYmxlKTtcclxuICAgICAgICAgICAgICAgIHZhciBqcVRib2R5ID0gJCh0Ym9keSk7XHJcbiAgICAgICAgICAgICAgICB2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcclxuICAgICAgICAgICAgICAgIHZhciByb3dzID0gJC5tYXAoc2V0dGluZ3MuYW9EYXRhLCBmdW5jdGlvbiAocikgeyByZXR1cm4gci5uVHI7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIGllbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGbGFnIHRvIG5vdGUgdGhhdCB0aGUgdGFibGUgaXMgY3VycmVudGx5IGJlaW5nIGRlc3Ryb3llZCAtIG5vIGFjdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRha2VuXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5iRGVzdHJveWluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyZSBvZmYgdGhlIGRlc3Ryb3kgY2FsbGJhY2tzIGZvciBwbHVnLWlucyBldGNcclxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQsIG1ha2UgYWxsIGNvbHVtbnMgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShzZXR0aW5ncykuY29sdW1ucygpLnZpc2libGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHJlbW92aW5nIHRoZW1cclxuICAgICAgICAgICAgICAgIGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xyXG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZignLkRULScgKyBzZXR0aW5ncy5zSW5zdGFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIHdlIGhhZCB0byBicmVhayB0aGUgdGFibGUgdXAgLSByZXN0b3JlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAodGFibGUgIT0gdGhlYWQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAganFUYWJsZS5hcHBlbmQodGhlYWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0Zm9vdCAmJiB0YWJsZSAhPSB0Zm9vdC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgICAgICBqcVRhYmxlLmFwcGVuZCh0Zm9vdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gW107XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXMoc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICQocm93cykucmVtb3ZlQ2xhc3Moc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgJCgndGgsIHRkJywgdGhlYWQpLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1NvcnRhYmxlICsgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0YWJsZUFzYyArICcgJyArIGNsYXNzZXMuc1NvcnRhYmxlRGVzYyArICcgJyArIGNsYXNzZXMuc1NvcnRhYmxlTm9uZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIFRSIGVsZW1lbnRzIGJhY2sgaW50byB0aGUgdGFibGUgaW4gdGhlaXIgb3JpZ2luYWwgb3JkZXJcclxuICAgICAgICAgICAgICAgIGpxVGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgIGpxVGJvZHkuYXBwZW5kKHJvd3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xyXG4gICAgICAgICAgICAgICAganFUYWJsZVtyZW1vdmVkTWV0aG9kXSgpO1xyXG4gICAgICAgICAgICAgICAganFXcmFwcGVyW3JlbW92ZWRNZXRob2RdKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byByZWF0dGFjaCB0aGUgdGFibGUgdG8gdGhlIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZSAmJiBvcmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGFjdHMgbGlrZSBhcHBlbmRDaGlsZCBpZiAhYXJnWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZy5pbnNlcnRCZWZvcmUodGFibGUsIHNldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIHJlc3RvcmUgZGlyZWN0bHkgdG8gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgIGpxVGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnd2lkdGgnLCBzZXR0aW5ncy5zRGVzdHJveVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5zVGFibGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2VyZSBvcmlnaW5hbGx5IHN0cmlwZSBjbGFzc2VzIC0gdGhlbiB3ZSBhZGQgdGhlbSBiYWNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsYXNzZXMgLSBidXQgaXQncyBhIGdvb2QgZWZmb3J0IHdpdGhvdXQgZ2V0dGluZyBjYXJyaWVkIGF3YXlcclxuICAgICAgICAgICAgICAgICAgICBpZW4gPSBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGllbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqcVRib2R5LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIFJlbW92ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZyb20gdGhlIHNldHRpbmdzIGFycmF5ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuc2V0dGluZ3Muc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxyXG4gICAgICAgICQuZWFjaChbJ2NvbHVtbicsICdyb3cnLCAnY2VsbCddLCBmdW5jdGlvbiAoaSwgdHlwZSkge1xyXG4gICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKHR5cGUgKyAncygpLmV2ZXJ5KCknLCBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IodHlwZSwgZnVuY3Rpb24gKHNldHRpbmdzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm93cyBhbmQgY29sdW1uczpcclxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnMSAtIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFyZzMgLSBsb29wIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnNCAtIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENlbGxzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBhcmcxIC0gcm93IGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFyZzIgLSBjb2x1bW4gaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnNCAtIGxvb3AgY291bnRlclxyXG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVt0eXBlXShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnY2VsbCcgPyBhcmcyIDogb3B0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdjZWxsJyA/IG9wdHMgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnMSwgYXJnMiwgYXJnMywgYXJnNFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvLyBpMThuIG1ldGhvZCBmb3IgZXh0ZW5zaW9ucyB0byBiZSBhYmxlIHRvIHVzZSB0aGUgbGFuZ3VhZ2Ugb2JqZWN0IGZyb20gdGhlXHJcbiAgICAgICAgLy8gRGF0YVRhYmxlXHJcbiAgICAgICAgX2FwaV9yZWdpc3RlcignaTE4bigpJywgZnVuY3Rpb24gKHRva2VuLCBkZWYsIHBsdXJhbCkge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBfZm5HZXRPYmplY3REYXRhRm4odG9rZW4pKGN0eC5vTGFuZ3VhZ2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gZGVmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KHJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlZFtwbHVyYWxdICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkW3BsdXJhbF0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkLl87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZC5yZXBsYWNlKCclZCcsIHBsdXJhbCk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcclxuICAgICAgICAgKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcclxuICAgICAgICAgKiBvbmx5IGZvciBub24tcmVsZWFzZSBidWlsZHMuIFNlZSBodHRwOi8vc2VtdmVyLm9yZy8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICogIEBtZW1iZXJcclxuICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICogIEBkZWZhdWx0IFZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLnZlcnNpb24gPSBcIjEuMTAuMTZcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpdmF0ZSBkYXRhIHN0b3JlLCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3Mgb2JqZWN0cyB0aGF0IGFyZVxyXG4gICAgICAgICAqIGNyZWF0ZWQgZm9yIHRoZSB0YWJsZXMgb24gYSBnaXZlbiBwYWdlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLnNldHRpbmdzYCBvYmplY3QgaXMgYWxpYXNlZCB0b1xyXG4gICAgICAgICAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCB0aHJvdWdoIHdoaWNoIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmRcclxuICAgICAgICAgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxyXG4gICAgICAgICAqICBAbWVtYmVyXHJcbiAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICogIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLnNldHRpbmdzID0gW107XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcclxuICAgICAgICAgKiBhdmFpbGFibGUgdG8gaXQuIFRoZXNlIG1vZGVscyBkZWZpbmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgdXNlZCB0byBob2xkXHJcbiAgICAgICAgICogdGhlIGFjdGl2ZSBzdGF0ZSBhbmQgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFibGUuXHJcbiAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEYXRhVGFibGUubW9kZWxzID0ge307XHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcclxuICAgICAgICAgKiBzZWFyY2ggaW5mb3JtYXRpb24gZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXJzLlxyXG4gICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoID0ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHRydWUsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXBwbGllZCBzZWFyY2ggdGVybVxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNTZWFyY2hcIjogXCJcIixcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxyXG4gICAgICAgICAgICAgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcclxuICAgICAgICAgICAgICogcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlJlZ2V4XCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBpcyB0byB1c2UgaXRzIHNtYXJ0IGZpbHRlcmluZyBvciBub3QuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTbWFydFwiOiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcclxuICAgICAgICAgKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xyXG4gICAgICAgICAqIGFvRGF0YSBhcnJheS5cclxuICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERhdGFUYWJsZS5tb2RlbHMub1JvdyA9IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcclxuICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiblRyXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxyXG4gICAgICAgICAgICAgKiBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXkgbm9kZXNcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFuQ2VsbHNcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEYXRhIG9iamVjdCBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdy4gVGhpcyBpcyBlaXRoZXJcclxuICAgICAgICAgICAgICogYW4gYXJyYXkgaWYgdXNpbmcgdGhlIHRyYWRpdGlvbmFsIGZvcm0gb2YgRGF0YVRhYmxlcywgb3IgYW4gb2JqZWN0IGlmXHJcbiAgICAgICAgICAgICAqIHVzaW5nIG1EYXRhIG9wdGlvbnMuIFRoZSBleGFjdCB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBwYXNzZWQgaW5cclxuICAgICAgICAgICAgICogZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSwgb3Igd2lsbCBiZSBhbiBhcnJheSBpZiB1c2luZyBET00gYSBkYXRhXHJcbiAgICAgICAgICAgICAqIHNvdXJjZS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5fG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiX2FEYXRhXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNvcnRpbmcgZGF0YSBjYWNoZSAtIHRoaXMgYXJyYXkgaXMgb3N0ZW5zaWJseSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXHJcbiAgICAgICAgICAgICAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXHJcbiAgICAgICAgICAgICAqIG5lZWRlZCksIGFuZCBob2xkcyB0aGUgZGF0YSB0aGF0IGlzIHVzZWQgZm9yIHNvcnRpbmcgZWFjaCBjb2x1bW4gaW4gdGhlXHJcbiAgICAgICAgICAgICAqIHJvdy4gV2UgZG8gdGhpcyBjYWNoZSBnZW5lcmF0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgc29ydCBpbiBvcmRlciB0aGF0XHJcbiAgICAgICAgICAgICAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXHJcbiAgICAgICAgICAgICAqIHBlciBzb3J0LiBUaGlzIGFycmF5IHNob3VsZCBub3QgYmUgcmVhZCBmcm9tIG9yIHdyaXR0ZW4gdG8gYnkgYW55dGhpbmdcclxuICAgICAgICAgICAgICogb3RoZXIgdGhhbiB0aGUgbWFzdGVyIHNvcnRpbmcgbWV0aG9kcy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfYVNvcnREYXRhXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXHJcbiAgICAgICAgICAgICAqIGluY3JlYXNlIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZmlsdGVyaW5nIGluIERhdGFUYWJsZXNcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfYUZpbHRlckRhdGFcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXJpbmcgZGF0YSBjYWNoZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgY2VsbCBmaWx0ZXJpbmcgY2FjaGUsIGJ1dFxyXG4gICAgICAgICAgICAgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcclxuICAgICAgICAgICAgICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxyXG4gICAgICAgICAgICAgKiBuZWVkZWQgb24gZXZlcnkgc2VhcmNoIChtZW1vcnkgdHJhZGVkIGZvciBwZXJmb3JtYW5jZSlcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfc0ZpbHRlclJvd1wiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxyXG4gICAgICAgICAgICAgKiBjYW4gcXVpY2tseSBsb29rIGF0IHRoaXMgdmFyaWFibGUgcmF0aGVyIHRoYW4gbmVlZGluZyB0byBkbyBhIERPTSBjaGVja1xyXG4gICAgICAgICAgICAgKiBvbiBjbGFzc05hbWUgZm9yIHRoZSBuVHIgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuICAgICAgICAgICAgICogIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIl9zUm93U3RyaXBlXCI6IFwiXCIsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2VcclxuICAgICAgICAgICAgICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxyXG4gICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcclxuICAgICAgICAgICAgICogb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzcmNcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRleCBpbiB0aGUgYW9EYXRhIGFycmF5LiBUaGlzIHNhdmVzIGFuIGluZGV4T2YgbG9va3VwIHdoZW4gd2UgaGF2ZSB0aGVcclxuICAgICAgICAgICAgICogb2JqZWN0LCBidXQgd2FudCB0byBrbm93IHRoZSBpbmRleFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50ZWdlclxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgLTFcclxuICAgICAgICAgICAgICogIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlkeFwiOiAtMVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XHJcbiAgICAgICAgICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcclxuICAgICAgICAgKiBEYXRhVGFibGVzIG5lZWRzIGFib3V0IGVhY2ggaW5kaXZpZHVhbCBjb2x1bW4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cclxuICAgICAgICAgKiBidXQgdGhpcyBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLlxyXG4gICAgICAgICAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcclxuICAgICAgICAgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb2x1bW4gaW5kZXguIFRoaXMgY291bGQgYmUgd29ya2VkIG91dCBvbi10aGUtZmx5IHdpdGggJC5pbkFycmF5LCBidXQgaXRcclxuICAgICAgICAgICAgICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlkeFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cclxuICAgICAgICAgICAgICogaXMgc29ydGVkLiBUaGF0IHRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXkgYWxsb3dzIG11bHRpLWNvbHVtbiBzb3J0aW5nXHJcbiAgICAgICAgICAgICAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcclxuICAgICAgICAgICAgICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcclxuICAgICAgICAgICAgICogY29sdW1ucyB0byBiZSBzb3J0ZWQgb24gKHR5cGljYWxseSBpdCB3aWxsIGJlIGEgc2luZ2xlIGludGVnZXIgcG9pbnRpbmdcclxuICAgICAgICAgICAgICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYURhdGFTb3J0XCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lIHRoZSBzb3J0aW5nIGRpcmVjdGlvbnMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY29sdW1uLCBpbiBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgKiBhcyB0aGUgY29sdW1uIGlzIHJlcGVhdGVkbHkgc29ydGVkIHVwb24gLSBpLmUuIHRoZSBmaXJzdCB2YWx1ZSBpcyB1c2VkXHJcbiAgICAgICAgICAgICAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cclxuICAgICAgICAgICAgICogU29ydCBpdCBhZ2FpbiAoY2xpY2sgYWdhaW4pIGFuZCBpdCB3aWxsIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXguXHJcbiAgICAgICAgICAgICAqIFJlcGVhdCB1bnRpbCBsb29wLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYXNTb3J0aW5nXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNlYXJjaGFibGUsIGFuZCB0aHVzIHNob3VsZCBiZSBpbmNsdWRlZFxyXG4gICAgICAgICAgICAgKiBpbiB0aGUgZmlsdGVyaW5nIG9yIG5vdC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlNlYXJjaGFibGVcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc29ydGFibGUgb3Igbm90LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiU29ydGFibGVcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiVmlzaWJsZVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN0b3JlIGZvciBtYW51YWwgdHlwZSBhc3NpZ25tZW50IHVzaW5nIHRoZSBgY29sdW1uLnR5cGVgIG9wdGlvbi4gVGhpc1xyXG4gICAgICAgICAgICAgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfc01hbnVhbFR5cGVcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIEhUTUw1IGRhdGEgYXR0cmlidXRlcyBzaG91bGQgYmUgdXNlZCBhcyB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgKiBzb3VyY2UgZm9yIGZpbHRlcmluZyBvciBzb3J0aW5nLiBUcnVlIGlzIGVpdGhlciBhcmUuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiX2JBdHRyU3JjXCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxyXG4gICAgICAgICAgICAgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXHJcbiAgICAgICAgICAgICAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7ZWxlbWVudH0gblRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuQ3JlYXRlZENlbGxcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGdW5jdGlvbiB0byBnZXQgZGF0YSBmcm9tIGEgY2VsbCBpbiBhIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cclxuICAgICAgICAgICAgICogYWNjZXNzIGRhdGEgZGlyZWN0bHkgdGhyb3VnaCBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxyXG4gICAgICAgICAgICAgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xyXG4gICAgICAgICAgICAgKiByZXF1aXJlZC4gVGhpcyBmdW5jdGlvbiBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIGJ5IHRoZSBjb2x1bW5cclxuICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gbWV0aG9kXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGFycmF5L29iamVjdCBmb3IgdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAqICAgIChpLmUuIGFvRGF0YVtdLl9hRGF0YSlcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxyXG4gICAgICAgICAgICAgKiAgICAnZGlzcGxheScsICd0eXBlJyAnZmlsdGVyJyAnc29ydCdcclxuICAgICAgICAgICAgICogIEByZXR1cm5zIHsqfSBUaGUgZGF0YSBmb3IgdGhlIGNlbGwgZnJvbSB0aGUgZ2l2ZW4gcm93J3MgZGF0YVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmbkdldERhdGFcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGdW5jdGlvbiB0byBzZXQgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XHJcbiAgICAgICAgICAgICAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxyXG4gICAgICAgICAgICAgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtbiBpbml0aWFsaXNhdGlvbiBtZXRob2RcclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBzVmFsdWUgVmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuU2V0RGF0YVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByb3BlcnR5IHRvIHJlYWQgdGhlIHZhbHVlIGZvciB0aGUgY2VsbHMgaW4gdGhlIGNvbHVtbiBmcm9tIHRoZSBkYXRhXHJcbiAgICAgICAgICAgICAqIHNvdXJjZSBhcnJheSAvIG9iamVjdC4gSWYgbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBjb250ZW50IGlzIHVzZWQsIGlmIGFcclxuICAgICAgICAgICAgICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvbnxpbnR8c3RyaW5nfG51bGxcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwibURhdGFcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcclxuICAgICAgICAgICAgICogdGhlIGRhdGEgLSBpLmUuIGl0IGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBtRGF0YSwgYnV0IHdpdGhvdXQgdGhlXHJcbiAgICAgICAgICAgICAqICdzZXQnIG9wdGlvbiwgYW5kIGFsc28gdGhlIGRhdGEgZmVkIHRvIGl0IGlzIHRoZSByZXN1bHQgZnJvbSBtRGF0YS5cclxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvbnxpbnR8c3RyaW5nfG51bGxcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwibVJlbmRlclwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcclxuICAgICAgICAgICAgICogbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gKGlmIHNvcnRpbmcgaXMgZW5hYmxlZC4pXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm5UaFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVuaXF1ZSBmb290ZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gKGlmIHRoZXJlIGlzIG9uZSkuIE5vdCB1c2VkXHJcbiAgICAgICAgICAgICAqIGluIERhdGFUYWJsZXMgYXMgc3VjaCwgYnV0IGNhbiBiZSB1c2VkIGZvciBwbHVnLWlucyB0byByZWZlcmVuY2UgdGhlXHJcbiAgICAgICAgICAgICAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm5UZlwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzQ2xhc3NcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXHJcbiAgICAgICAgICAgICAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcclxuICAgICAgICAgICAgICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXHJcbiAgICAgICAgICAgICAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXHJcbiAgICAgICAgICAgICAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcclxuICAgICAgICAgICAgICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xyXG4gICAgICAgICAgICAgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXHJcbiAgICAgICAgICAgICAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic0NvbnRlbnRQYWRkaW5nXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXHJcbiAgICAgICAgICAgICAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBtRGF0YVxyXG4gICAgICAgICAgICAgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWUgZm9yIHRoZSBjb2x1bW4sIGFsbG93aW5nIHJlZmVyZW5jZSB0byB0aGUgY29sdW1uIGJ5IG5hbWUgYXMgd2VsbCBhc1xyXG4gICAgICAgICAgICAgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzTmFtZVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxyXG4gICAgICAgICAgICAgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgc3RkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNTb3J0RGF0YVR5cGVcIjogJ3N0ZCcsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1NvcnRpbmdDbGFzc1wiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXHJcbiAgICAgICAgICAgICAqIHdoZW4galF1ZXJ5IFVJIHRoZW1pbmcgaXMgdXNlZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU29ydGluZ0NsYXNzSlVJXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGl0bGUgb2YgdGhlIGNvbHVtbiAtIHdoYXQgaXMgc2VlbiBpbiB0aGUgVEggZWxlbWVudCAoblRoKS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzVGl0bGVcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzVHlwZVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzV2lkdGhcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNXaWR0aE9yaWdcIjogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIERldmVsb3BlciBub3RlOiBUaGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGJlbG93IGFyZSBnaXZlbiBpbiBIdW5nYXJpYW5cclxuICAgICAgICAgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXHJcbiAgICAgICAgICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxyXG4gICAgICAgICAqIGJyZWFraW5nIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHV0dGVybHkgd2l0aCB0aGlzIGNoYW5nZSwgdGhlIEh1bmdhcmlhblxyXG4gICAgICAgICAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcclxuICAgICAgICAgKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxyXG4gICAgICAgICAqIHRvIGNyZWF0ZSBhIG1hcCBmcm9tIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbCBjYXNlIChnb2luZyB0aGUgb3RoZXIgZGlyZWN0aW9uXHJcbiAgICAgICAgICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYXQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXHJcbiAgICAgICAgICogb2YgRGF0YVRhYmxlcywgd2hpbGUgdGhpcyBtZXRob2QgaXMgYWJvdXQgYSAwLjVLIGhpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcclxuICAgICAgICAgKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxyXG4gICAgICAgICAqIGluc3RhbGxzICh0aGVyZWZvcmUgaXMgb24taG9sZCB1bnRpbCB2MikuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpc2F0aW9uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvblxyXG4gICAgICAgICAqIHRpbWUuXHJcbiAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEYXRhVGFibGUuZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBhcnJheSBvZiBkYXRhIHRvIHVzZSBmb3IgdGhlIHRhYmxlLCBwYXNzZWQgaW4gYXQgaW5pdGlhbGlzYXRpb24gd2hpY2hcclxuICAgICAgICAgICAgICogd2lsbCBiZSB1c2VkIGluIHByZWZlcmVuY2UgdG8gYW55IGRhdGEgd2hpY2ggaXMgYWxyZWFkeSBpbiB0aGUgRE9NLiBUaGlzIGlzXHJcbiAgICAgICAgICAgICAqIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGNvbnN0cnVjdGluZyB0YWJsZXMgcHVyZWx5IGluIEphdmFzY3JpcHQsIGZvclxyXG4gICAgICAgICAgICAgKiBleGFtcGxlIHdpdGggYSBjdXN0b20gQWpheCBjYWxsLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kYXRhXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBhIDJEIGFycmF5IGRhdGEgc291cmNlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA0LjAnLCAnV2luIDk1KycsIDQsICdYJ10sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA1LjAnLCAnV2luIDk1KycsIDUsICdDJ10sXHJcbiAgICAgICAgICAgICAqICAgICAgICBdLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhcyBhIGRhdGEgc291cmNlIChgZGF0YWApXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA0LjBcIixcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNCxcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiWFwiXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA1LjBcIixcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNSxcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiQ1wiXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIF0sXHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiwgICBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIsICBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiUGxhdGZvcm1cIiwgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIsICBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiwgICAgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFhRGF0YVwiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXHJcbiAgICAgICAgICAgICAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXHJcbiAgICAgICAgICAgICAqIHVwb24sIGFuZCB0aGUgc29ydGluZyBkaXJlY3Rpb24sIHdpdGggdGhpcyB2YXJpYWJsZS4gVGhlIGBzb3J0aW5nYCBhcnJheVxyXG4gICAgICAgICAgICAgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXHJcbiAgICAgICAgICAgICAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlclwiOiBbXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhYVNvcnRpbmdcIjogW1swLCAnYXNjJ11dLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsIHRvIHRoZSBgc29ydGluZ2AgcGFyYW1ldGVyLCBidXRcclxuICAgICAgICAgICAgICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXHJcbiAgICAgICAgICAgICAqIGlzIHRoYXQgeW91IGNvdWxkIGhhdmUgYSBjb2x1bW4gKHZpc2libGUgb3IgaGlkZGVuKSB3aGljaCB0aGUgc29ydGluZ1xyXG4gICAgICAgICAgICAgKiB3aWxsIGFsd2F5cyBiZSBmb3JjZWQgb24gZmlyc3QgLSBhbnkgc29ydGluZyBhZnRlciB0aGF0IChmcm9tIHRoZSB1c2VyKVxyXG4gICAgICAgICAgICAgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3NcclxuICAgICAgICAgICAgICogdG9nZXRoZXIuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyRml4ZWRcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlckZpeGVkXCI6IFtbMCwnYXNjJ11dXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERhdGFUYWJsZXMgY2FuIGJlIGluc3RydWN0ZWQgdG8gbG9hZCBkYXRhIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlIGZyb20gYVxyXG4gICAgICAgICAgICAgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSBgYWpheGAgcHJvcGVydHkgaGFzIHRocmVlIGRpZmZlcmVudCBtb2RlcyBvZiBvcGVyYXRpb24sIGRlcGVuZGluZyBvblxyXG4gICAgICAgICAgICAgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAqIGBzdHJpbmdgIC0gU2V0IHRoZSBVUkwgZnJvbSB3aGVyZSB0aGUgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20uXHJcbiAgICAgICAgICAgICAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cclxuICAgICAgICAgICAgICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIGBzdHJpbmdgXHJcbiAgICAgICAgICAgICAqIC0tLS0tLS0tXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxyXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBgb2JqZWN0YFxyXG4gICAgICAgICAgICAgKiAtLS0tLS0tLVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xyXG4gICAgICAgICAgICAgKiBbalF1ZXJ5LmFqYXhdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxyXG4gICAgICAgICAgICAgKiBvZiB0aGUgQWpheCByZXF1ZXN0LiBEYXRhVGFibGVzIGhhcyBhIG51bWJlciBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgd2hpY2hcclxuICAgICAgICAgICAgICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcclxuICAgICAgICAgICAgICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcclxuICAgICAgICAgICAgICogdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGluIERhdGFUYWJsZXMgb3JcclxuICAgICAgICAgICAgICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICogYGRhdGFgIC0gQXMgd2l0aCBqUXVlcnksIGBkYXRhYCBjYW4gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBidXQgaXRcclxuICAgICAgICAgICAgICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXHJcbiAgICAgICAgICAgICAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXHJcbiAgICAgICAgICAgICAqICAgcGFyYW1ldGVycyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCBEYXRhVGFibGVzIGhhcyByZWFkaWVkIGZvciBzZW5kaW5nLiBBblxyXG4gICAgICAgICAgICAgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xyXG4gICAgICAgICAgICAgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXHJcbiAgICAgICAgICAgICAqICAgbm90IHJldHVybiBhbnl0aGluZyBmcm9tIHRoZSBmdW5jdGlvbi4gVGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlclBhcmFtc2BcclxuICAgICAgICAgICAgICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogKiBgZGF0YVNyY2AgLSBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvclxyXG4gICAgICAgICAgICAgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXHJcbiAgICAgICAgICAgICAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgICAqICAgYWxsb3dzIHRoYXQgcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWRcclxuICAgICAgICAgICAgICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxyXG4gICAgICAgICAgICAgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXHJcbiAgICAgICAgICAgICAqICAgdGhlIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXNcclxuICAgICAgICAgICAgICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXHJcbiAgICAgICAgICAgICAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBzdXBlcnNlZGVzIGBzQWpheERhdGFQcm9wYCBmcm9tXHJcbiAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyAxLjktLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAqIGBzdWNjZXNzYCAtIFNob3VsZCBub3QgYmUgb3ZlcnJpZGRlbiBpdCBpcyB1c2VkIGludGVybmFsbHkgaW5cclxuICAgICAgICAgICAgICogICBEYXRhVGFibGVzLiBUbyBtYW5pcHVsYXRlIC8gdHJhbnNmb3JtIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogYGZ1bmN0aW9uYFxyXG4gICAgICAgICAgICAgKiAtLS0tLS0tLS0tXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEFzIGEgZnVuY3Rpb24sIG1ha2luZyB0aGUgQWpheCBjYWxsIGlzIGxlZnQgdXAgdG8geW91cnNlbGYgYWxsb3dpbmdcclxuICAgICAgICAgICAgICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXHJcbiAgICAgICAgICAgICAqIHRoYW4gQWpheCBjb3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSwgc3VjaCBhcyBXZWIgc3RvcmFnZVxyXG4gICAgICAgICAgICAgKiBvciBhbiBBSVIgZGF0YWJhc2UuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBpcyBnaXZlbiBmb3VyIHBhcmFtZXRlcnMgYW5kIG5vIHJldHVybiBpcyByZXF1aXJlZC4gVGhlXHJcbiAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgYXJlOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAxLiBfb2JqZWN0XyAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgICAqIDIuIF9mdW5jdGlvbl8gLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IG11c3QgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgcmVxdWlyZWRcclxuICAgICAgICAgICAgICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICogICAgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXHJcbiAgICAgICAgICAgICAqIDMuIF9vYmplY3RfIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgZm9yIHRoZSB0YWJsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlckRhdGFgIGZyb20gRGF0YVRhYmxlcyAxLjktLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhcclxuICAgICAgICAgICAgICogIEBzaW5jZSAxLjEwLjBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LlxyXG4gICAgICAgICAgICAgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXHJcbiAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiBcImRhdGEuanNvblwiXHJcbiAgICAgICAgICAgICAqICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2VcclxuICAgICAgICAgICAgICogICAvLyBgZGF0YWAgdG8gYHRhYmxlRGF0YWAgKGkuZS4gYHsgdGFibGVEYXRhOiBbIC4uLmRhdGEuLi4gXSB9YClcclxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IFwidGFibGVEYXRhXCJcclxuICAgICAgICAgICAgICogICAgIH1cclxuICAgICAgICAgICAgICogICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheCwgdXNpbmcgYGRhdGFTcmNgIHRvIHJlYWQgZGF0YVxyXG4gICAgICAgICAgICAgKiAgIC8vIGZyb20gYSBwbGFpbiBhcnJheSByYXRoZXIgdGhhbiBhbiBhcnJheSBpbiBhbiBvYmplY3RcclxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcclxuICAgICAgICAgICAgICogICAgIH1cclxuICAgICAgICAgICAgICogICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgLy8gTWFuaXB1bGF0ZSB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgLSBhZGQgYSBsaW5rIHRvIGRhdGFcclxuICAgICAgICAgICAgICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xyXG4gICAgICAgICAgICAgKiAgIC8vIGlzIGp1c3QgYSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdGhlIGRhdGEgY2FuIGJlIG1hbmlwdWxhdGVkKS5cclxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IGZ1bmN0aW9uICgganNvbiApIHtcclxuICAgICAgICAgICAgICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgIGpzb25baV1bMF0gPSAnPGEgaHJlZj1cIi9tZXNzYWdlLycranNvbltpXVswXSsnPlZpZXcgbWVzc2FnZTwvYT4nO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgICByZXR1cm4ganNvbjtcclxuICAgICAgICAgICAgICogICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAgICAgKiAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxyXG4gICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICBcImFqYXhcIjoge1xyXG4gICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBkICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxyXG4gICAgICAgICAgICAgKiAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAqICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgIH1cclxuICAgICAgICAgICAgICogICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgLy8gU2VuZCByZXF1ZXN0IGFzIFBPU1RcclxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuICAgICAgICAgICAgICogICAgICAgXCJ0eXBlXCI6IFwiUE9TVFwiXHJcbiAgICAgICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICAgICAqICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSAoY291bGQgaW50ZXJmYWNlIHdpdGggYSBmb3JtIGZvclxyXG4gICAgICAgICAgICAgKiAgIC8vIGFkZGluZywgZWRpdGluZyBhbmQgcmVtb3Zpbmcgcm93cykuXHJcbiAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgIGNhbGxiYWNrKFxyXG4gICAgICAgICAgICAgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcclxuICAgICAgICAgICAgICogICAgICAgKTtcclxuICAgICAgICAgICAgICogICAgIH1cclxuICAgICAgICAgICAgICogICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFqYXhcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byByZWFkaWx5IHNwZWNpZnkgdGhlIGVudHJpZXMgaW4gdGhlIGxlbmd0aCBkcm9wXHJcbiAgICAgICAgICAgICAqIGRvd24gbWVudSB0aGF0IERhdGFUYWJsZXMgc2hvd3Mgd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuIEl0IGNhbiBiZVxyXG4gICAgICAgICAgICAgKiBlaXRoZXIgYSAxRCBhcnJheSBvZiBvcHRpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYm90aCB0aGUgZGlzcGxheWVkXHJcbiAgICAgICAgICAgICAqIG9wdGlvbiBhbmQgdGhlIHZhbHVlLCBvciBhIDJEIGFycmF5IHdoaWNoIHdpbGwgdXNlIHRoZSBhcnJheSBpbiB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICogcG9zaXRpb24gYXMgdGhlIHZhbHVlLCBhbmQgdGhlIGFycmF5IGluIHRoZSBzZWNvbmQgcG9zaXRpb24gYXMgdGhlXHJcbiAgICAgICAgICAgICAqIGRpc3BsYXllZCBvcHRpb25zICh1c2VmdWwgZm9yIGxhbmd1YWdlIHN0cmluZ3Mgc3VjaCBhcyAnQWxsJykuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYHBhZ2VMZW5ndGhgIHByb3BlcnR5IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlXHJcbiAgICAgICAgICAgICAqIGZpcnN0IHZhbHVlIGdpdmVuIGluIHRoaXMgYXJyYXksIHVubGVzcyBgcGFnZUxlbmd0aGAgaXMgYWxzbyBwcm92aWRlZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbIDEwLCAyNSwgNTAsIDEwMCBdXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGVuZ3RoTWVudVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgMjUsIDUwLCAtMV0sIFsxMCwgMjUsIDUwLCBcIkFsbFwiXV1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYUxlbmd0aE1lbnVcIjogWzEwLCAyNSwgNTAsIDEwMF0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBgY29sdW1uc2Agb3B0aW9uIGluIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBkZWZpbmVcclxuICAgICAgICAgICAgICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxyXG4gICAgICAgICAgICAgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcclxuICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LiBOb3RlIHRoYXQgaWYgeW91IHVzZSBgY29sdW1uc2AgdG9cclxuICAgICAgICAgICAgICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxyXG4gICAgICAgICAgICAgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcclxuICAgICAgICAgICAgICogdG8gc3BlY2lmeSBhbnkgb3B0aW9ucykuXHJcbiAgICAgICAgICAgICAqICBAbWVtYmVyXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvQ29sdW1uc1wiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXHJcbiAgICAgICAgICAgICAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2ZcclxuICAgICAgICAgICAgICogZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBUaGlzIGFsbG93cyBncmVhdCBmbGV4aWJpbGl0eSB3aGVuIGNyZWF0aW5nXHJcbiAgICAgICAgICAgICAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcclxuICAgICAgICAgICAgICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXHJcbiAgICAgICAgICAgICAqIG9wdGlvbnMgYXZhaWxhYmxlOiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0sIGJ1dCBpdCBfbXVzdF9cclxuICAgICAgICAgICAgICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXHJcbiAgICAgICAgICAgICAqIGFycmF5IG1heSBiZTpcclxuICAgICAgICAgICAgICogICA8dWw+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPmEgbmVnYXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSByaWdodDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cclxuICAgICAgICAgICAgICogICA8L3VsPlxyXG4gICAgICAgICAgICAgKiAgQG1lbWJlclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbkRlZnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBgc2VhcmNoYCwgdGhpcyBwYXJhbWV0ZXIgZGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBjb2x1bW5cclxuICAgICAgICAgICAgICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcclxuICAgICAgICAgICAgICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAqIGBzZWFyY2hgIGFuZCBgZXNjYXBlUmVnZXhgICh0aGUgbGF0dGVyIGlzIG9wdGlvbmFsKS4gJ251bGwnIGlzIGFsc29cclxuICAgICAgICAgICAgICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaENvbHNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJzZWFyY2hcIjogXCJeWzAtOV1cIiwgXCJlc2NhcGVSZWdleFwiOiBmYWxzZSB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBhcnJheSBvZiBDU1MgY2xhc3NlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGRpc3BsYXllZCByb3dzLiBUaGlzXHJcbiAgICAgICAgICAgICAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3NcclxuICAgICAgICAgICAgICogc2VxdWVudGlhbGx5LCBsb29waW5nIHdoZW4gcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcclxuICAgICAgICAgICAgICogICAgb3B0aW9uczwvaT5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdHJpcGVDbGFzc2VzXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgKiBhcyBhbiBvcHRpbWlzYXRpb24gKGl0IHRha2VzIHNvbWUgdGltZSB0byBjYWxjdWxhdGUgdGhlIHdpZHRocykgaWYgdGhlXHJcbiAgICAgICAgICAgICAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hdXRvV2lkdGhcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiYXV0b1dpZHRoXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJBdXRvV2lkdGhcIjogdHJ1ZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3VcclxuICAgICAgICAgICAgICogYXJlIHVzaW5nIGFuIEFqYXggb3IgSlMgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBvcHRpb24sIHdoZW4gc2V0IHRvXHJcbiAgICAgICAgICAgICAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxyXG4gICAgICAgICAgICAgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxyXG4gICAgICAgICAgICAgKiB0aW1lLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJEZWZlclJlbmRlclwiOiBmYWxzZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXHJcbiAgICAgICAgICAgICAqIG9uZSB3aGljaCBoYXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG5ldyBpbml0aWFsaXNhdGlvbiBvYmplY3QgcGFzc2VkLiBJZiBub1xyXG4gICAgICAgICAgICAgKiB0YWJsZSBtYXRjaGVzIHRoZSBzZWxlY3RvciwgdGhlbiB0aGUgbmV3IERhdGFUYWJsZSB3aWxsIGJlIGNvbnN0cnVjdGVkIGFzXHJcbiAgICAgICAgICAgICAqIHBlciBub3JtYWwuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZXN0cm95XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwic3JvbGxZXCI6IFwiMjAwcHhcIixcclxuICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2VcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgLy8gU29tZSB0aW1lIGxhdGVyLi4uLlxyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImZpbHRlclwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwiZGVzdHJveVwiOiB0cnVlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJEZXN0cm95XCI6IGZhbHNlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXHJcbiAgICAgICAgICAgICAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcclxuICAgICAgICAgICAgICogd2lsbCBtYXRjaCBhIHJvdyBjb250YWluaW5nIHRob3NlIHdvcmRzLCBldmVuIGlmIG5vdCBpbiB0aGUgb3JkZXIgdGhhdCB3YXNcclxuICAgICAgICAgICAgICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxyXG4gICAgICAgICAgICAgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcclxuICAgICAgICAgICAgICogZGVmYXVsdCBmaWx0ZXJpbmcgaW5wdXQgYm94IGFuZCByZXRhaW4gZmlsdGVyaW5nIGFiaWxpdGllcywgcGxlYXNlIHVzZVxyXG4gICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hpbmdcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoaW5nXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJGaWx0ZXJcIjogdHJ1ZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICogYWJvdXQgdGhlIGRhdGEgdGhhdCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgaW5jbHVkaW5nIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJJbmZvXCI6IHRydWUsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbG93cyB0aGUgZW5kIHVzZXIgdG8gc2VsZWN0IHRoZSBzaXplIG9mIGEgZm9ybWF0dGVkIHBhZ2UgZnJvbSBhIHNlbGVjdFxyXG4gICAgICAgICAgICAgKiBtZW51IChzaXplcyBhcmUgMTAsIDI1LCA1MCBhbmQgMTAwKS4gUmVxdWlyZXMgcGFnaW5hdGlvbiAoYHBhZ2luYXRlYCkuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhDaGFuZ2VcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwibGVuZ3RoQ2hhbmdlXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgcGFnaW5hdGlvbi5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmdcIjogZmFsc2VcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlBhZ2luYXRlXCI6IHRydWUsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIGEgJ3Byb2Nlc3NpbmcnIGluZGljYXRvciB3aGVuIHRoZSB0YWJsZSBpc1xyXG4gICAgICAgICAgICAgKiBiZWluZyBwcm9jZXNzZWQgKGUuZy4gYSBzb3J0KS4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB0YWJsZXMgd2l0aFxyXG4gICAgICAgICAgICAgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcclxuICAgICAgICAgICAgICogdGhlIGVudHJpZXMuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWVcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHJpZXZlIHRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLiBOb3RlIHRoYXQgaWYgdGhlXHJcbiAgICAgICAgICAgICAqIHRhYmxlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQsIHRoaXMgcGFyYW1ldGVyIHdpbGwgY2F1c2UgRGF0YVRhYmxlc1xyXG4gICAgICAgICAgICAgKiB0byBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNldCB1cCAtIGl0IHdpbGwgbm90IHRha2VcclxuICAgICAgICAgICAgICogYWNjb3VudCBvZiBhbnkgY2hhbmdlcyB5b3UgbWlnaHQgaGF2ZSBtYWRlIHRvIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3RcclxuICAgICAgICAgICAgICogcGFzc2VkIHRvIERhdGFUYWJsZXMgKHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpcyBhbiBhY2tub3dsZWRnZW1lbnRcclxuICAgICAgICAgICAgICogdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGlzKS4gYGRlc3Ryb3lgIGNhbiBiZSB1c2VkIHRvIHJlaW5pdGlhbGlzZSBhIHRhYmxlIGlmXHJcbiAgICAgICAgICAgICAqIHlvdSBuZWVkLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmV0cmlldmVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICBpbml0VGFibGUoKTtcclxuICAgICAgICAgICAgICogICAgICB0YWJsZUFjdGlvbnMoKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICBmdW5jdGlvbiBpbml0VGFibGUgKClcclxuICAgICAgICAgICAgICogICAge1xyXG4gICAgICAgICAgICAgKiAgICAgIHJldHVybiAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwcHhcIixcclxuICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcInJldHJpZXZlXCI6IHRydWVcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH1cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgZnVuY3Rpb24gdGFibGVBY3Rpb25zICgpXHJcbiAgICAgICAgICAgICAqICAgIHtcclxuICAgICAgICAgICAgICogICAgICB2YXIgdGFibGUgPSBpbml0VGFibGUoKTtcclxuICAgICAgICAgICAgICogICAgICAvLyBwZXJmb3JtIEFQSSBvcGVyYXRpb25zIHdpdGggb1RhYmxlXHJcbiAgICAgICAgICAgICAqICAgIH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlJldHJpZXZlXCI6IGZhbHNlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGVuIHZlcnRpY2FsICh5KSBzY3JvbGxpbmcgaXMgZW5hYmxlZCwgRGF0YVRhYmxlcyB3aWxsIGZvcmNlIHRoZSBoZWlnaHQgb2ZcclxuICAgICAgICAgICAgICogdGhlIHRhYmxlJ3Mgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGhlaWdodCBhdCBhbGwgdGltZXMgKHVzZWZ1bCBmb3IgbGF5b3V0KS5cclxuICAgICAgICAgICAgICogSG93ZXZlciwgdGhpcyBjYW4gbG9vayBvZGQgd2hlbiBmaWx0ZXJpbmcgZGF0YSBkb3duIHRvIGEgc21hbGwgZGF0YSBzZXQsXHJcbiAgICAgICAgICAgICAqIGFuZCB0aGUgZm9vdGVyIGlzIGxlZnQgXCJmbG9hdGluZ1wiIGZ1cnRoZXIgZG93bi4gVGhpcyBwYXJhbWV0ZXIgKHdoZW5cclxuICAgICAgICAgICAgICogZW5hYmxlZCkgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSdzIHZpZXdwb3J0IGRvd24gd2hlblxyXG4gICAgICAgICAgICAgKiB0aGUgcmVzdWx0IHNldCB3aWxsIGZpdCB3aXRoaW4gdGhlIGdpdmVuIFkgaGVpZ2h0LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsQ29sbGFwc2VcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlNjcm9sbENvbGxhcHNlXCI6IGZhbHNlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxyXG4gICAgICAgICAgICAgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxyXG4gICAgICAgICAgICAgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJTaWRlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInhoci5waHBcIlxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgc29ydGluZyBvZiBjb2x1bW5zLiBTb3J0aW5nIG9mIGluZGl2aWR1YWwgY29sdW1ucyBjYW4gYmVcclxuICAgICAgICAgICAgICogZGlzYWJsZWQgYnkgdGhlIGBzb3J0YWJsZWAgb3B0aW9uIGZvciBlYWNoIGNvbHVtbi5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyaW5nXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyaW5nXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTb3J0XCI6IHRydWUsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNwbGF5IERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gc29ydCBtdWx0aXBsZSBjb2x1bW5zIGF0IHRoZVxyXG4gICAgICAgICAgICAgKiBzYW1lIHRpbWUgKGFjdGl2YXRlZCBieSBzaGlmdC1jbGljayBieSB0aGUgdXNlcikuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyTXVsdGlcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIERpc2FibGUgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmcgYWJpbGl0eVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyTXVsdGlcIjogZmFsc2VcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxyXG4gICAgICAgICAgICAgKiBjZWxsIHRoYXQgaXMgZm91bmQgZm9yIGEgc2luZ2xlIGNvbHVtbiwgb3IgdGhlIGJvdHRvbSAoZmFsc2UgLSBkZWZhdWx0KS5cclxuICAgICAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNlbGxzVG9wXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJDZWxsc1RvcFwiOiB0cnVlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTb3J0Q2VsbHNUb3BcIjogZmFsc2UsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxyXG4gICAgICAgICAgICAgKiBgc29ydGluZ1xcXzNgIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgc29ydGVkIG9uLiBUaGlzIGlzXHJcbiAgICAgICAgICAgICAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXHJcbiAgICAgICAgICAgICAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXHJcbiAgICAgICAgICAgICAqIHR1cm4gdGhpcyBvZmYuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNsYXNzZXNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJDbGFzc2VzXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBzdGF0ZSBzYXZpbmcuIFdoZW4gZW5hYmxlZCBIVE1MNSBgbG9jYWxTdG9yYWdlYCB3aWxsIGJlXHJcbiAgICAgICAgICAgICAqIHVzZWQgdG8gc2F2ZSB0YWJsZSBkaXNwbGF5IGluZm9ybWF0aW9uIHN1Y2ggYXMgcGFnaW5hdGlvbiBpbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgICogZGlzcGxheSBsZW5ndGgsIGZpbHRlcmluZyBhbmQgc29ydGluZy4gQXMgc3VjaCB3aGVuIHRoZSBlbmQgdXNlciByZWxvYWRzXHJcbiAgICAgICAgICAgICAqIHRoZSBwYWdlIHRoZSBkaXNwbGF5IGRpc3BsYXkgd2lsbCBtYXRjaCB3aGF0IHRoeSBoYWQgcHJldmlvdXNseSBzZXQgdXAuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIER1ZSB0byB0aGUgdXNlIG9mIGBsb2NhbFN0b3JhZ2VgIHRoZSBkZWZhdWx0IHN0YXRlIHNhdmluZyBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAqIGluIElFNiBvciA3LiBJZiBzdGF0ZSBzYXZpbmcgaXMgcmVxdWlyZWQgaW4gdGhvc2UgYnJvd3NlcnMsIHVzZVxyXG4gICAgICAgICAgICAgKiBgc3RhdGVTYXZlQ2FsbGJhY2tgIHRvIHByb3ZpZGUgYSBzdG9yYWdlIHNvbHV0aW9uIHN1Y2ggYXMgY29va2llcy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWVcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFRSIGVsZW1lbnQgaXMgY3JlYXRlZCAoYW5kIGFsbCBURCBjaGlsZFxyXG4gICAgICAgICAgICAgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcclxuICAgICAgICAgICAgICogbWFuaXB1bGF0aW9uIG9mIHRoZSBUUiBlbGVtZW50IChhZGRpbmcgY2xhc3NlcyBldGMpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHJvdyBpbiB0aGUgaW50ZXJuYWwgYW9EYXRhIGFycmF5XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY3JlYXRlZFJvd1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGF0YUluZGV4ICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcclxuICAgICAgICAgICAgICogICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmbkNyZWF0ZWRSb3dcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xyXG4gICAgICAgICAgICAgKiBkeW5hbWljYWxseSBtb2RpZnkgYW55IGFzcGVjdCB5b3Ugd2FudCBhYm91dCB0aGUgY3JlYXRlZCBET00uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZHJhd0NhbGxiYWNrXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiZHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyByZWRyYXduIHRoZSB0YWJsZScgKTtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5EcmF3Q2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWRlbnRpY2FsIHRvIGZuSGVhZGVyQ2FsbGJhY2soKSBidXQgZm9yIHRoZSB0YWJsZSBmb290ZXIgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIG1vZGlmeSB0aGUgdGFibGUgZm9vdGVyIG9uIGV2ZXJ5ICdkcmF3JyBldmVudC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGZvb3QgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBmb290ZXJcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXHJcbiAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxyXG4gICAgICAgICAgICAgKiAgICBkaXNwbGF5IGFycmF5XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZm9vdGVyQ2FsbGJhY2tcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJmb290ZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggdGZvb3QsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHRmb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiU3RhcnRpbmcgaW5kZXggaXMgXCIrc3RhcnQ7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5Gb290ZXJDYWxsYmFja1wiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcclxuICAgICAgICAgICAgICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcclxuICAgICAgICAgICAgICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xyXG4gICAgICAgICAgICAgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcclxuICAgICAgICAgICAgICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogIEBtZW1iZXJcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSB0b0Zvcm1hdCBudW1iZXIgdG8gYmUgZm9ybWF0dGVkXHJcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcclxuICAgICAgICAgICAgICogICAgLy8gdGhpcyBjYW4gYWxzbyBiZSBkb25lIHdpdGggdGhlIGxhbmd1YWdlLnRob3VzYW5kcyBvcHRpb24pXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJmb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcclxuICAgICAgICAgICAgICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcclxuICAgICAgICAgICAgICogICAgICAgICAgKTtcclxuICAgICAgICAgICAgICogICAgICAgIH07XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICh0b0Zvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9MYW5ndWFnZS5zVGhvdXNhbmRzXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXHJcbiAgICAgICAgICAgICAqIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgaGVhZGVyIHJvdy4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgYW5kXHJcbiAgICAgICAgICAgICAqIGRpc3BsYXkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGhlYWQgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBoZWFkZXJcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXHJcbiAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxyXG4gICAgICAgICAgICAgKiAgICBkaXNwbGF5IGFycmF5XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaGVhZGVyQ2FsbGJhY2tcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJmaGVhZGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIGhlYWQsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJEaXNwbGF5aW5nIFwiKyhlbmQtc3RhcnQpK1wiIHJlY29yZHNcIjtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudFxyXG4gICAgICAgICAgICAgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxyXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcclxuICAgICAgICAgICAgICogYmUgdGltZXMgd2hlcmUgeW91IHdpc2ggdG8gY3VzdG9taXNlIHRoZSBzdHJpbmcgZnVydGhlci4gVGhpcyBjYWxsYmFja1xyXG4gICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gbWF4IFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSB0YWJsZSAocmVnYXJkbGVzcyBvZlxyXG4gICAgICAgICAgICAgKiAgICBmaWx0ZXJpbmcpXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBwcmUgVGhlIHN0cmluZyB0aGF0IERhdGFUYWJsZXMgaGFzIGZvcm1hdHRlZCB1c2luZyBpdCdzXHJcbiAgICAgICAgICAgICAqICAgIG93biBydWxlc1xyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgIFwiaW5mb0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgcHJlICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xyXG4gICAgICAgICAgICAgKiAgICAgIH1cclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuIE5vcm1hbGx5IERhdGFUYWJsZXMgd2lsbFxyXG4gICAgICAgICAgICAgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgKiBob3dldmVyLCB0aGlzIGRvZXMgbm90IGhvbGQgdHJ1ZSB3aGVuIHVzaW5nIGV4dGVybmFsIGxhbmd1YWdlIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAqIHNpbmNlIHRoYXQgaXMgb2J0YWluZWQgdXNpbmcgYW4gYXN5bmMgWEhSIGNhbGwuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgSlNPTiBvYmplY3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgLSBvbmx5XHJcbiAgICAgICAgICAgICAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImluaXRDb21wbGV0ZVwiOiBmdW5jdGlvbihzZXR0aW5ncywganNvbikge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbGVkIGF0IHRoZSB2ZXJ5IHN0YXJ0IG9mIGVhY2ggdGFibGUgZHJhdyBhbmQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZVxyXG4gICAgICAgICAgICAgKiBkcmF3IGJ5IHJldHVybmluZyBmYWxzZSwgYW55IG90aGVyIHJldHVybiAoaW5jbHVkaW5nIHVuZGVmaW5lZCkgcmVzdWx0cyBpblxyXG4gICAgICAgICAgICAgKiB0aGUgZnVsbCBkcmF3IG9jY3VycmluZykuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2lsbCBjYW5jZWwgdGhlIGRyYXcsIGFueXRoaW5nIGVsc2UgKGluY2x1ZGluZyBub1xyXG4gICAgICAgICAgICAgKiAgICByZXR1cm4pIHdpbGwgYWxsb3cgaXQgdG8gY29tcGxldGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJlRHJhd0NhbGxiYWNrXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwicHJlRHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgaWYgKCAkKCcjdGVzdCcpLnZhbCgpID09IDEgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuUHJlRHJhd0NhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byAncG9zdCBwcm9jZXNzJyBlYWNoIHJvdyBhZnRlciBpdCBoYXZlIGJlZW5cclxuICAgICAgICAgICAgICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXHJcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleCBUaGUgZGlzcGxheSBpbmRleCBmb3IgdGhlIGN1cnJlbnQgdGFibGUgZHJhd1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2ZcclxuICAgICAgICAgICAgICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcclxuICAgICAgICAgICAgICogICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxyXG4gICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgZnVuY3Rpb24gd2hpY2ggb2J0YWluc1xyXG4gICAgICAgICAgICAgKiB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgc28gc29tZXRoaW5nIG1vcmUgc3VpdGFibGUgZm9yIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxyXG4gICAgICAgICAgICAgKiBBSVIgZGF0YWJhc2UuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQG1lbWJlclxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBIVFRQIHNvdXJjZSB0byBvYnRhaW4gdGhlIGRhdGEgZnJvbSAoYGFqYXhgKVxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBBIGtleS92YWx1ZSBwYWlyIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIHRvIHNlbmRcclxuICAgICAgICAgICAgICogICAgdG8gdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24gb2YgdGhlIGRhdGEgZ2V0XHJcbiAgICAgICAgICAgICAqICAgIHByb2Nlc3MgdGhhdCB3aWxsIGRyYXcgdGhlIGRhdGEgb24gdGhlIHBhZ2UuXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlckRhdGFcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcbiAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEl0IGlzIG9mdGVuIHVzZWZ1bCB0byBzZW5kIGV4dHJhIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIG1ha2luZyBhbiBBamF4XHJcbiAgICAgICAgICAgICAqIHJlcXVlc3QgLSBmb3IgZXhhbXBsZSBjdXN0b20gZmlsdGVyaW5nIGluZm9ybWF0aW9uLCBhbmQgdGhpcyBjYWxsYmFja1xyXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBtYWtlcyBpdCB0cml2aWFsIHRvIHNlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHNlcnZlci4gVGhlXHJcbiAgICAgICAgICAgICAqIHBhc3NlZCBpbiBwYXJhbWV0ZXIgaXMgdGhlIGRhdGEgc2V0IHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnlcclxuICAgICAgICAgICAgICogRGF0YVRhYmxlcywgYW5kIHlvdSBjYW4gYWRkIHRvIHRoaXMgb3IgbW9kaWZ5IGl0IGFzIHlvdSByZXF1aXJlLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSBhcnJheSAoYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBhcmUgbmFtZS92YWx1ZVxyXG4gICAgICAgICAgICAgKiAgICBwYWlycykgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieSBEYXRhVGFibGVzIGFuZCB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcbiAgICAgICAgICAgICAqICAgIHNlcnZlci4gSW4gdGhlIGNhc2Ugb2YgQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAqICAgIHRoaXMgd2lsbCBiZSBhbiBlbXB0eSBhcnJheSwgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlcmUgd2lsbCBiZSBhXHJcbiAgICAgICAgICAgICAqICAgIHNpZ25pZmljYW50IG51bWJlciBvZiBwYXJhbWV0ZXJzIVxyXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge3VuZGVmaW5lZH0gRW5zdXJlIHRoYXQgeW91IG1vZGlmeSB0aGUgZGF0YSBhcnJheSBwYXNzZWQgaW4sXHJcbiAgICAgICAgICAgICAqICAgIGFzIHRoaXMgaXMgcGFzc2VkIGJ5IHJlZmVyZW5jZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclBhcmFtc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuU2VydmVyUGFyYW1zXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXHJcbiAgICAgICAgICAgICAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcclxuICAgICAgICAgICAgICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQG1lbWJlclxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjYW4gYmUgZXhlY3V0ZWQgd2hlbiBkb25lLiBJdFxyXG4gICAgICAgICAgICAgKiAgICBzaG91bGQgYmUgcGFzc2VkIHRoZSBsb2FkZWQgc3RhdGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiAgQHJldHVybiB7b2JqZWN0fSBUaGUgRGF0YVRhYmxlcyBzdGF0ZSBvYmplY3QgdG8gYmUgbG9hZGVkXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkQ2FsbGJhY2tcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAkLmFqYXgoIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9sb2FkXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIGNhbGxiYWNrKCBqc29uICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0YVRhYmxlc18nICsgc2V0dGluZ3Muc0luc3RhbmNlICsgJ18nICsgbG9jYXRpb24ucGF0aG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgcHJpb3IgdG8gbG9hZGluZyB0aGF0IHN0YXRlLlxyXG4gICAgICAgICAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZCBkYXRhLCBidXRcclxuICAgICAgICAgICAgICogcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGUuIE5vdGUgdGhhdCBmb3JcclxuICAgICAgICAgICAgICogcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYHN0YXRlTG9hZFBhcmFtc2AgZXZlbnQgdG8gbG9hZCBwYXJhbWV0ZXJzIGZvclxyXG4gICAgICAgICAgICAgKiBhIHBsdWctaW4uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgbG9hZGVkXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkUGFyYW1zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBsb2FkZWRcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIERpc2FsbG93IHN0YXRlIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuU3RhdGVMb2FkUGFyYW1zXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXHJcbiAgICAgICAgICAgICAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkZWRcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIGFsZXJ0KCAnU2F2ZWQgZmlsdGVyIHdhczogJytkYXRhLm9TZWFyY2guc1NlYXJjaCApO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmblN0YXRlTG9hZGVkXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNhdmUgdGhlIHRhYmxlIHN0YXRlLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gZGVmaW5lIHdoZXJlIGFuZCBob3cgdGhlIHN0YXRlXHJcbiAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUgaXMgc3RvcmVkIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIHVzZSBgbG9jYWxTdG9yYWdlYFxyXG4gICAgICAgICAgICAgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAbWVtYmVyXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVDYWxsYmFja1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB3aXRoIHRoZSBzdGF0ZSBvYmplY3RcclxuICAgICAgICAgICAgICogICAgICAgICAgJC5hamF4KCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfc2F2ZVwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCJcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKCkge31cclxuICAgICAgICAgICAgICogICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmblN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLnNldEl0ZW0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdEYXRhVGFibGVzXycgKyBzZXR0aW5ncy5zSW5zdGFuY2UgKyAnXycgKyBsb2NhdGlvbi5wYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHRvIGJlIHNhdmVkLiBDYWxsZWQgd2hlbiB0aGUgdGFibGVcclxuICAgICAgICAgICAgICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxyXG4gICAgICAgICAgICAgKiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdCBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yXHJcbiAgICAgICAgICAgICAqIG90aGVyIHN0YXRlIHByb3BlcnRpZXMgb3IgbW9kaWZpY2F0aW9uLiBOb3RlIHRoYXQgZm9yIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZFxyXG4gICAgICAgICAgICAgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVBhcmFtc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgc2F2ZWRcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkLiBBZnRlciB0aGlzIHBlcmlvZFxyXG4gICAgICAgICAgICAgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cclxuICAgICAgICAgICAgICogVmFsdWUgaXMgZ2l2ZW4gaW4gc2Vjb25kcy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUR1cmF0aW9uXCI6IDYwKjYwKjI0OyAvLyAxIGRheVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGwgbm90IG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgKiBwYWdlIGRyYXcgLSByYXRoZXIgaXQgd2lsbCB1c2UgdGhlIGRhdGEgYWxyZWFkeSBvbiB0aGUgcGFnZSAobm8gc29ydGluZyBldGNcclxuICAgICAgICAgICAgICogd2lsbCBiZSBhcHBsaWVkIHRvIGl0KSwgdGh1cyBzYXZpbmcgb24gYW4gWEhSIGF0IGxvYWQgdGltZS4gYGRlZmVyTG9hZGluZ2BcclxuICAgICAgICAgICAgICogaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGRlZmVycmVkIGxvYWRpbmcgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBhbHNvIHVzZWRcclxuICAgICAgICAgICAgICogdG8gdGVsbCBEYXRhVGFibGVzIGhvdyBtYW55IHJlY29yZHMgdGhlcmUgYXJlIGluIHRoZSBmdWxsIHRhYmxlIChhbGxvd2luZ1xyXG4gICAgICAgICAgICAgKiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBhbmQgcGFnaW5hdGlvbiB0byBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5KS4gSW4gdGhlIGNhc2VcclxuICAgICAgICAgICAgICogd2hlcmUgYSBmaWx0ZXJpbmcgaXMgYXBwbGllZCB0byB0aGUgdGFibGUgb24gaW5pdGlhbCBsb2FkLCB0aGlzIGNhbiBiZVxyXG4gICAgICAgICAgICAgKiBpbmRpY2F0ZWQgYnkgZ2l2aW5nIHRoZSBwYXJhbWV0ZXIgYXMgYW4gYXJyYXksIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzXHJcbiAgICAgICAgICAgICAqIHRoZSBudW1iZXIgb2YgcmVjb3JkcyBhdmFpbGFibGUgYWZ0ZXIgZmlsdGVyaW5nIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlXHJcbiAgICAgICAgICAgICAqIG51bWJlciBvZiByZWNvcmRzIHdpdGhvdXQgZmlsdGVyaW5nIChhbGxvd2luZyB0aGUgdGFibGUgaW5mb3JtYXRpb24gZWxlbWVudFxyXG4gICAgICAgICAgICAgKiB0byBiZSBzaG93biBjb3JyZWN0bHkpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50IHwgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJMb2FkaW5nXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyA1NyByZWNvcmRzIGF2YWlsYWJsZSBpbiB0aGUgdGFibGUsIG5vIGZpbHRlcmluZyBhcHBsaWVkXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogNTdcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIDU3IHJlY29yZHMgYWZ0ZXIgZmlsdGVyaW5nLCAxMDAgd2l0aG91dCBmaWx0ZXJpbmcgKGFuIGluaXRpYWwgZmlsdGVyIGFwcGxpZWQpXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogWyA1NywgMTAwIF0sXHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNlYXJjaFwiOiB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwibXlfZmlsdGVyXCJcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiaURlZmVyTG9hZGluZ1wiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IG9uIGEgc2luZ2xlIHBhZ2Ugd2hlbiB1c2luZyBwYWdpbmF0aW9uLiBJZlxyXG4gICAgICAgICAgICAgKiBmZWF0dXJlIGVuYWJsZWQgKGBsZW5ndGhDaGFuZ2VgKSB0aGVuIHRoZSBlbmQgdXNlciB3aWxsIGJlIGFibGUgdG8gb3ZlcnJpZGVcclxuICAgICAgICAgICAgICogdGhpcyB0byBhIGN1c3RvbSBzZXR0aW5nIHVzaW5nIGEgcG9wLXVwIG1lbnUuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDEwXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2VMZW5ndGhcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdlTGVuZ3RoXCI6IDUwXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGRhdGEgZGlzcGxheSB3aGVuIHVzaW5nIERhdGFUYWJsZXMgd2l0aFxyXG4gICAgICAgICAgICAgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxyXG4gICAgICAgICAgICAgKiB0aGUgcGFnZSBudW1iZXIsIHNvIGlmIHlvdSBoYXZlIDEwIHJlY29yZHMgcGVyIHBhZ2UgYW5kIHdhbnQgdG8gc3RhcnQgb25cclxuICAgICAgICAgICAgICogdGhlIHRoaXJkIHBhZ2UsIGl0IHNob3VsZCBiZSBcIjIwXCIuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGlzcGxheVN0YXJ0XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiaURpc3BsYXlTdGFydFwiOiAwLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIChzb3J0aW5nLCBwYWdpbmcsXHJcbiAgICAgICAgICAgICAqIGFuZCBmaWx0ZXJpbmcpIGJ5IGFkZGluZyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHRvIHRoZSByZXF1aXJlZCBlbGVtZW50cy4gVGhpc1xyXG4gICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIHRhYiB0aHJvdWdoIHRoZSBjb250cm9scyBhbmQgcHJlc3MgdGhlIGVudGVyIGtleSB0byBhY3RpdmF0ZSB0aGVtLlxyXG4gICAgICAgICAgICAgKiBUaGUgdGFiaW5kZXggaXMgZGVmYXVsdCAwLCBtZWFuaW5nIHRoYXQgdGhlIHRhYiBmb2xsb3dzIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudC5cclxuICAgICAgICAgICAgICogWW91IGNhbiBvdmVycnVsZSB0aGlzIHVzaW5nIHRoaXMgcGFyYW1ldGVyIGlmIHlvdSB3aXNoLiBVc2UgYSB2YWx1ZSBvZiAtMSB0b1xyXG4gICAgICAgICAgICAgKiBkaXNhYmxlIGJ1aWx0LWluIGtleWJvYXJkIG5hdmlnYXRpb24uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMudGFiSW5kZXhcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJ0YWJJbmRleFwiOiAxXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlUYWJJbmRleFwiOiAwLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbGFzc2VzIHRoYXQgRGF0YVRhYmxlcyBhc3NpZ25zIHRvIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMgYW5kIGZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqIHRoYXQgaXQgYWRkcyB0byB0aGUgSFRNTCB0YWJsZS4gVGhpcyBhbGxvd3MgY2xhc3NlcyB0byBiZSBjb25maWd1cmVkXHJcbiAgICAgICAgICAgICAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcclxuICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5leHQub1N0ZENsYXNzZXN9IG9iamVjdCkuXHJcbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY2xhc3Nlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvQ2xhc3Nlc1wiOiB7fSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xyXG4gICAgICAgICAgICAgKiBhcmUgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIG1vZGlmaWVkIHRoZW0gaW5kaXZpZHVhbGx5IG9yXHJcbiAgICAgICAgICAgICAqIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVtIGFsbCBhcyByZXF1aXJlZC5cclxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvTGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdHJpbmdzIHRoYXQgYXJlIHVzZWQgZm9yIFdBSS1BUklBIGxhYmVscyBhbmQgY29udHJvbHMgb25seSAodGhlc2UgYXJlIG5vdFxyXG4gICAgICAgICAgICAgICAgICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xyXG4gICAgICAgICAgICAgICAgICogbXVzdCBiZSBpbnRlcm5hdGlvbmFsaXNlZCBhcyB3ZWxsKS5cclxuICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJvQXJpYVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcclxuICAgICAgICAgICAgICAgICAgICAgKiBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnRBc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiYXJpYVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcclxuICAgICAgICAgICAgICAgICAgICAgKiBzb3J0ZWQgZGVzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0RGVzY2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJhcmlhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwic29ydERlc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBkZXNjZW5kaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzU29ydERlc2NlbmRpbmdcIjogXCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGRlc2NlbmRpbmdcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gc3RyaW5nIHVzZWQgYnkgRGF0YVRhYmxlcyBmb3IgdGhlIGJ1aWx0LWluIHBhZ2luYXRpb25cclxuICAgICAgICAgICAgICAgICAqIGNvbnRyb2wgdHlwZXMuXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcIm9QYWdpbmF0ZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgZmlyc3QgcGFnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IEZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5maXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImZpcnN0XCI6IFwiRmlyc3QgcGFnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIFwic0ZpcnN0XCI6IFwiRmlyc3RcIixcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGxhc3QgcGFnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IExhc3RcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmxhc3RcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJsYXN0XCI6IFwiTGFzdCBwYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzTGFzdFwiOiBcIkxhc3RcIixcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ25leHQnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIG5leHQgcGFnZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBOZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5uZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwibmV4dFwiOiBcIk5leHQgcGFnZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIFwic05leHRcIjogXCJOZXh0XCIsXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICdwcmV2aW91cycgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG9cclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcHJldmlvdXMgcGFnZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBQcmV2aW91c1xyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUucHJldmlvdXNcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJwcmV2aW91c1wiOiBcIlByZXZpb3VzIHBhZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBcInNQcmV2aW91c1wiOiBcIlByZXZpb3VzXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHN0cmluZyBpcyBzaG93biBpbiBwcmVmZXJlbmNlIHRvIGB6ZXJvUmVjb3Jkc2Agd2hlbiB0aGUgdGFibGUgaXNcclxuICAgICAgICAgICAgICAgICAqIGVtcHR5IG9mIGRhdGEgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS4gTm90ZSB0aGF0IHRoaXMgaXMgYW4gb3B0aW9uYWxcclxuICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlciAtIGlmIGl0IGlzIG5vdCBnaXZlbiwgdGhlIHZhbHVlIG9mIGB6ZXJvUmVjb3Jkc2Agd2lsbCBiZSB1c2VkXHJcbiAgICAgICAgICAgICAgICAgKiBpbnN0ZWFkIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgZ2l2ZW4gdmFsdWUpLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IE5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5lbXB0eVRhYmxlXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImVtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic0VtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgc3RyaW5nIGdpdmVzIGluZm9ybWF0aW9uIHRvIHRoZSBlbmQgdXNlciBhYm91dCB0aGUgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcclxuICAgICAgICAgICAgICAgICAqIHVzZWQgaW4gdGhlIHN0cmluZyBhbmQgd2lsbCBiZSBkeW5hbWljYWxseSByZXBsYWNlZCBhcyB0aGUgdGFibGVcclxuICAgICAgICAgICAgICAgICAqIGRpc3BsYXkgdXBkYXRlcy4gVGhpcyB0b2tlbnMgY2FuIGJlIHBsYWNlZCBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nLCBvclxyXG4gICAgICAgICAgICAgICAgICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICogYFxcX1NUQVJUXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGZpcnN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXHJcbiAgICAgICAgICAgICAgICAgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxyXG4gICAgICAgICAgICAgICAgICogKiBgXFxfVE9UQUxcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIGFmdGVyIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICogKiBgXFxfTUFYXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSB3aXRob3V0IGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgKiAqIGBcXF9QQUdFU1xcX2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXMgb2YgZGF0YSBpbiB0aGUgdGFibGVcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJpbmZvXCI6IFwiU2hvd2luZyBwYWdlIF9QQUdFXyBvZiBfUEFHRVNfXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcIixcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcclxuICAgICAgICAgICAgICAgICAqIGZvcm1hdCBvZiB0aGlzIHN0cmluZyBzaG91bGQgbWF0Y2ggYGluZm9gLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0VtcHR5XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9FbXB0eVwiOiBcIk5vIGVudHJpZXMgdG8gc2hvd1wiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic0luZm9FbXB0eVwiOiBcIlNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1wiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZW4gYSB1c2VyIGZpbHRlcnMgdGhlIGluZm9ybWF0aW9uIGluIGEgdGFibGUsIHRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgKiB0byB0aGUgaW5mb3JtYXRpb24gKGBpbmZvYCkgdG8gZ2l2ZSBhbiBpZGVhIG9mIGhvdyBzdHJvbmcgdGhlIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IChmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvRmlsdGVyZWRcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiaW5mb0ZpbHRlcmVkXCI6IFwiIC0gZmlsdGVyaW5nIGZyb20gX01BWF8gcmVjb3Jkc1wiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgY2FuIGJlIHVzZWZ1bCB0byBhcHBlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIGluZm8gc3RyaW5nIGF0IHRpbWVzLFxyXG4gICAgICAgICAgICAgICAgICogYW5kIHRoaXMgdmFyaWFibGUgZG9lcyBleGFjdGx5IHRoYXQuIFRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhcHBlbmRlZCB0b1xyXG4gICAgICAgICAgICAgICAgICogdGhlIGBpbmZvYCAoYGluZm9FbXB0eWAgYW5kIGBpbmZvRmlsdGVyZWRgIGluIHdoYXRldmVyIGNvbWJpbmF0aW9uIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAgICAgKiBiZWluZyB1c2VkKSBhdCBhbGwgdGltZXMuXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1Bvc3RGaXhcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiaW5mb1Bvc3RGaXhcIjogXCJBbGwgcmVjb3JkcyBzaG93biBhcmUgZGVyaXZlZCBmcm9tIHJlYWwgaW5mb3JtYXRpb24uXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGRlY2ltYWwgcGxhY2Ugb3BlcmF0b3IgaXMgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIG90aGVyXHJcbiAgICAgICAgICAgICAgICAgKiBsYW5ndWFnZSBvcHRpb25zIHNpbmNlIERhdGFUYWJsZXMgZG9lc24ndCBvdXRwdXQgZmxvYXRpbmcgcG9pbnRcclxuICAgICAgICAgICAgICAgICAqIG51bWJlcnMsIHNvIGl0IHdvbid0IGV2ZXIgdXNlIHRoaXMgZm9yIGRpc3BsYXkgb2YgYSBudW1iZXIuIFJhdGhlcixcclxuICAgICAgICAgICAgICAgICAqIHdoYXQgdGhpcyBwYXJhbWV0ZXIgZG9lcyBpcyBtb2RpZnkgdGhlIHNvcnQgbWV0aG9kcyBvZiB0aGUgdGFibGUgc29cclxuICAgICAgICAgICAgICAgICAqIHRoYXQgbnVtYmVycyB3aGljaCBhcmUgaW4gYSBmb3JtYXQgd2hpY2ggaGFzIGEgY2hhcmFjdGVyIG90aGVyIHRoYW5cclxuICAgICAgICAgICAgICAgICAqIGEgcGVyaW9kIChgLmApIGFzIGEgZGVjaW1hbCBwbGFjZSB3aWxsIGJlIHNvcnRlZCBudW1lcmljYWxseS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgbnVtYmVycyB3aXRoIGRpZmZlcmVudCBkZWNpbWFsIHBsYWNlcyBjYW5ub3QgYmUgc2hvd24gaW5cclxuICAgICAgICAgICAgICAgICAqIHRoZSBzYW1lIHRhYmxlIGFuZCBzdGlsbCBiZSBzb3J0YWJsZSwgdGhlIHRhYmxlIG11c3QgYmUgY29uc2lzdGVudC5cclxuICAgICAgICAgICAgICAgICAqIEhvd2V2ZXIsIG11bHRpcGxlIGRpZmZlcmVudCB0YWJsZXMgb24gdGhlIHBhZ2UgY2FuIHVzZSBkaWZmZXJlbnRcclxuICAgICAgICAgICAgICAgICAqIGRlY2ltYWwgcGxhY2UgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmRlY2ltYWxcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGVjaW1hbFwiOiBcIixcIlxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCIuXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzRGVjaW1hbFwiOiBcIlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgaGFzIGEgYnVpbGQgaW4gbnVtYmVyIGZvcm1hdHRlciAoYGZvcm1hdE51bWJlcmApIHdoaWNoIGlzXHJcbiAgICAgICAgICAgICAgICAgKiB1c2VkIHRvIGZvcm1hdCBsYXJnZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQnkgZGVmYXVsdCBhIGNvbW1hIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSB0cml2aWFsbHkgY2hhbmdlZCB0byBhbnlcclxuICAgICAgICAgICAgICAgICAqIGNoYXJhY3RlciB5b3Ugd2lzaCB3aXRoIHRoaXMgcGFyYW1ldGVyLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0ICxcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnRob3VzYW5kc1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCInXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzVGhvdXNhbmRzXCI6IFwiLFwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGFpbCB0aGUgYWN0aW9uIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSBkcm9wIGRvd24gbWVudSBmb3IgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBwYWdpbmF0aW9uIGxlbmd0aCBvcHRpb24gaXMgY2hhbmdlZC4gVGhlICdfTUVOVV8nIHZhcmlhYmxlIGlzIHJlcGxhY2VkXHJcbiAgICAgICAgICAgICAgICAgKiB3aXRoIGEgZGVmYXVsdCBzZWxlY3QgbGlzdCBvZiAxMCwgMjUsIDUwIGFuZCAxMDAsIGFuZCBjYW4gYmUgcmVwbGFjZWRcclxuICAgICAgICAgICAgICAgICAqIHdpdGggYSBjdXN0b20gc2VsZWN0IGJveCBpZiByZXF1aXJlZC5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBTaG93IF9NRU5VXyBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sZW5ndGhNZW51XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAvLyBMYW5ndWFnZSBjaGFuZ2Ugb25seVxyXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6IFwiRGlzcGxheSBfTUVOVV8gcmVjb3Jkc1wiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAvLyBMYW5ndWFnZSBhbmQgb3B0aW9ucyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiAnRGlzcGxheSA8c2VsZWN0PicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMTBcIj4xMDwvb3B0aW9uPicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMjBcIj4yMDwvb3B0aW9uPicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMzBcIj4zMDwvb3B0aW9uPicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNDBcIj40MDwvb3B0aW9uPicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNTBcIj41MDwvb3B0aW9uPicrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiLTFcIj5BbGw8L29wdGlvbj4nK1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPC9zZWxlY3Q+IHJlY29yZHMnXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic0xlbmd0aE1lbnVcIjogXCJTaG93IF9NRU5VXyBlbnRyaWVzXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hlbiB1c2luZyBBamF4IHNvdXJjZWQgZGF0YSBhbmQgZHVyaW5nIHRoZSBmaXJzdCBkcmF3IHdoZW4gRGF0YVRhYmxlcyBpc1xyXG4gICAgICAgICAgICAgICAgICogZ2F0aGVyaW5nIHRoZSBkYXRhLCB0aGlzIG1lc3NhZ2UgaXMgc2hvd24gaW4gYW4gZW1wdHkgcm93IGluIHRoZSB0YWJsZSB0b1xyXG4gICAgICAgICAgICAgICAgICogaW5kaWNhdGUgdG8gdGhlIGVuZCB1c2VyIHRoZSB0aGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuIE5vdGUgdGhhdCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXIgaXMgbm90IHVzZWQgd2hlbiBsb2FkaW5nIGRhdGEgYnkgc2VydmVyLXNpZGUgcHJvY2Vzc2luZywganVzdFxyXG4gICAgICAgICAgICAgICAgICogQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IExvYWRpbmcuLi5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxvYWRpbmdSZWNvcmRzXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImxvYWRpbmdSZWNvcmRzXCI6IFwiUGxlYXNlIHdhaXQgLSBsb2FkaW5nLi4uXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzTG9hZGluZ1JlY29yZHNcIjogXCJMb2FkaW5nLi4uXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGV4dCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFibGUgaXMgcHJvY2Vzc2luZyBhIHVzZXIgYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiAodXN1YWxseSBhIHNvcnQgY29tbWFuZCBvciBzaW1pbGFyKS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBQcm9jZXNzaW5nLi4uXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInByb2Nlc3NpbmdcIjogXCJEYXRhVGFibGVzIGlzIGN1cnJlbnRseSBidXN5XCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzUHJvY2Vzc2luZ1wiOiBcIlByb2Nlc3NpbmcuLi5cIixcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRhaWxzIHRoZSBhY3Rpb25zIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBmaWx0ZXJpbmcgaW5wdXQgdGV4dCBib3guIFRoZSB2YXJpYWJsZSBcIl9JTlBVVF9cIiwgaWYgdXNlZCBpbiB0aGUgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgSFRNTCB0ZXh0IGJveCBmb3IgdGhlIGZpbHRlcmluZyBpbnB1dCBhbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICogY29udHJvbCBvdmVyIHdoZXJlIGl0IGFwcGVhcnMgaW4gdGhlIHN0cmluZy4gSWYgXCJfSU5QVVRfXCIgaXMgbm90IGdpdmVuXHJcbiAgICAgICAgICAgICAgICAgKiB0aGVuIHRoZSBpbnB1dCBib3ggaXMgYXBwZW5kZWQgdG8gdGhlIHN0cmluZyBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNlYXJjaDpcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogICAgLy8gSW5wdXQgdGV4dCBib3ggd2lsbCBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiRmlsdGVyIHJlY29yZHM6XCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgIC8vIFNwZWNpZnkgd2hlcmUgdGhlIGZpbHRlciBzaG91bGQgYXBwZWFyXHJcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkFwcGx5IGZpbHRlciBfSU5QVVRfIHRvIHRhYmxlXCJcclxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFzc2lnbiBhIGBwbGFjZWhvbGRlcmAgYXR0cmlidXRlIHRvIHRoZSBzZWFyY2ggYGlucHV0YCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcInNTZWFyY2hQbGFjZWhvbGRlclwiOiBcIlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSwgd2hpY2ggRGF0YVRhYmxlcyB3aWxsIGxvb2sgdXAgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxyXG4gICAgICAgICAgICAgICAgICogSXQgbXVzdCBzdG9yZSB0aGUgVVJMIG9mIHRoZSBsYW5ndWFnZSBmaWxlLCB3aGljaCBpcyBpbiBhIEpTT04gZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBpbml0aWFsaXNlciBvYmplY3QgKGkuZS4gdGhlIGFib3ZlIHBhcmFtZXRlcnMpLiBQbGVhc2UgcmVmZXIgdG8gb25lIG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgZXhhbXBsZSBsYW5ndWFnZSBmaWxlcyB0byBzZWUgaG93IHRoaXMgd29ya3MgaW4gYWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS51cmxcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidXJsXCI6IFwiaHR0cDovL3d3dy5zcHJ5bWVkaWEuY28udWsvZGF0YVRhYmxlcy9sYW5nLnR4dFwiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic1VybFwiOiBcIlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXHJcbiAgICAgICAgICAgICAgICAgKiBkaXNwbGF5ZWQgYWZ0ZXIgZmlsdGVyaW5nLiBgZW1wdHlUYWJsZWAgaXMgc2hvd24gd2hlbiB0aGVyZSBpcyBzaW1wbHkgbm9cclxuICAgICAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGluIHRoZSB0YWJsZSBhdCBhbGwgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS56ZXJvUmVjb3Jkc1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ6ZXJvUmVjb3Jkc1wiOiBcIk5vIHJlY29yZHMgdG8gZGlzcGxheVwiXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcclxuICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxyXG4gICAgICAgICAgICAgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcclxuICAgICAgICAgICAgICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXHJcbiAgICAgICAgICAgICAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxyXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcclxuICAgICAgICAgICAgICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXHJcbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9IClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwib1NlYXJjaFwiOiAkLmV4dGVuZCh7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoKSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcbiAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3IgYGFhRGF0YWAgZm9yXHJcbiAgICAgICAgICAgICAqIGNvbXBhdGliaWxpdHkgd2l0aCBEYXRhVGFibGVzIDEuOS0pIHdoZW4gb2J0YWluaW5nIGRhdGEgZnJvbSBhbiBBamF4XHJcbiAgICAgICAgICAgICAqIHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyIGFsbG93cyB0aGF0XHJcbiAgICAgICAgICAgICAqIHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkIG9iamVjdCBub3RhdGlvbiB0b1xyXG4gICAgICAgICAgICAgKiBnZXQgYSBkYXRhIHNvdXJjZSBmb3IgbXVsdGlwbGUgbGV2ZWxzIG9mIG5lc3RpbmcuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGRhdGFcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4RGF0YVByb3BcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCI6IFwiZGF0YVwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cclxuICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGluc3RydWN0IERhdGFUYWJsZXMgdG8gbG9hZCBkYXRhIGZyb20gYW4gZXh0ZXJuYWxcclxuICAgICAgICAgICAgICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxyXG4gICAgICAgICAgICAgKiBhbHJlYWR5IGhhdmUpLiBTaW1wbHkgcHJvdmlkZSBhIHVybCBhIEpTT04gb2JqZWN0IGNhbiBiZSBvYnRhaW5lZCBmcm9tLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFNvdXJjZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNBamF4U291cmNlXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgaW5pdGlhbGlzYXRpb24gdmFyaWFibGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGV4YWN0bHkgd2hlcmUgaW4gdGhlXHJcbiAgICAgICAgICAgICAqIERPTSB5b3Ugd2FudCBEYXRhVGFibGVzIHRvIGluamVjdCB0aGUgdmFyaW91cyBjb250cm9scyBpdCBhZGRzIHRvIHRoZSBwYWdlXHJcbiAgICAgICAgICAgICAqIChmb3IgZXhhbXBsZSB5b3UgbWlnaHQgd2FudCB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBhdCB0aGUgdG9wIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiB0YWJsZSkuIERJViBlbGVtZW50cyAod2l0aCBvciB3aXRob3V0IGEgY3VzdG9tIGNsYXNzKSBjYW4gYWxzbyBiZSBhZGRlZCB0b1xyXG4gICAgICAgICAgICAgKiBhaWQgc3R5bGluZy4gVGhlIGZvbGxvdyBzeW50YXggaXMgdXNlZDpcclxuICAgICAgICAgICAgICogICA8dWw+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkOlxyXG4gICAgICAgICAgICAgKiAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cclxuICAgICAgICAgICAgICogICAgICAgPC91bD5cclxuICAgICAgICAgICAgICogICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIGFsbG93ZWQ6XHJcbiAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICogICAgICAgICA8bGk+J0gnIC0galF1ZXJ5VUkgdGhlbWUgXCJoZWFkZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nRicgLSBqUXVlcnlVSSB0aGVtZSBcImZvb3RlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWJsIHVpLWNvcm5lci1iciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAqICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgc3ludGF4IGlzIGV4cGVjdGVkOlxyXG4gICAgICAgICAgICAgKiAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7JyBhbmQgJyZndDsnIC0gZGl2IGVsZW1lbnRzPC9saT5cclxuICAgICAgICAgICAgICogICAgICAgICA8bGk+JyZsdDtcImNsYXNzXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGEgY2xhc3M8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O1wiI2lkXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGFuIElEPC9saT5cclxuICAgICAgICAgICAgICogICAgICAgPC91bD5cclxuICAgICAgICAgICAgICogICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+RXhhbXBsZXM6XHJcbiAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICogICAgICAgICA8bGk+JyZsdDtcIndyYXBwZXJcImZsaXB0Jmd0Oyc8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O2xmJmx0O3QmZ3Q7aXAmZ3Q7JzwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAqICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGxmcnRpcCA8aT4od2hlbiBgalF1ZXJ5VUlgIGlzIGZhbHNlKTwvaT4gPGI+b3I8L2I+XHJcbiAgICAgICAgICAgICAqICAgIDxcIkhcImxmcj50PFwiRlwiaXA+IDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgdHJ1ZSk8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImRvbVwiOiAnJmx0O1widG9wXCJpJmd0O3J0Jmx0O1wiYm90dG9tXCJmbHAmZ3Q7Jmx0O1wiY2xlYXJcIiZndDsnXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNEb21cIjogXCJsZnJ0aXBcIixcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoIGRlbGF5IG9wdGlvbi4gVGhpcyB3aWxsIHRocm90dGxlIGZ1bGwgdGFibGUgc2VhcmNoZXMgdGhhdCB1c2UgdGhlXHJcbiAgICAgICAgICAgICAqIERhdGFUYWJsZXMgcHJvdmlkZWQgc2VhcmNoIGlucHV0IGVsZW1lbnQgKGl0IGRvZXMgbm90IGVmZmVjdCBjYWxscyB0b1xyXG4gICAgICAgICAgICAgKiBgZHQtYXBpIHNlYXJjaCgpYCwgcHJvdmlkaW5nIGEgZGVsYXkgYmVmb3JlIHRoZSBzZWFyY2ggaXMgbWFkZS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGludGVnZXJcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoRGVsYXlcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZWFyY2hEZWxheVwiOiAyMDBcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzZWFyY2hEZWxheVwiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIGZlYXR1cmVzIHNpeCBkaWZmZXJlbnQgYnVpbHQtaW4gb3B0aW9ucyBmb3IgdGhlIGJ1dHRvbnMgdG9cclxuICAgICAgICAgICAgICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAqIGBudW1iZXJzYCAtIFBhZ2UgbnVtYmVyIGJ1dHRvbnMgb25seVxyXG4gICAgICAgICAgICAgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxyXG4gICAgICAgICAgICAgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcclxuICAgICAgICAgICAgICogKiBgZnVsbGAgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zXHJcbiAgICAgICAgICAgICAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xyXG4gICAgICAgICAgICAgKiAqIGBmaXJzdF9sYXN0X251bWJlcnNgIC0gJ0ZpcnN0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXHJcbiAgICAgICAgICAgICAqICBcclxuICAgICAgICAgICAgICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHNpbXBsZV9udW1iZXJzXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1R5cGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIjogXCJzaW1wbGVfbnVtYmVyc1wiLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXHJcbiAgICAgICAgICAgICAqIGNlcnRhaW4gbGF5b3V0LCBvciB5b3UgaGF2ZSBhIGxhcmdlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0YWJsZSwgeW91XHJcbiAgICAgICAgICAgICAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXHJcbiAgICAgICAgICAgICAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cclxuICAgICAgICAgICAgICogc2Nyb2xsIGhvcml6b250YWxseSB3aGVuIG5lZWRlZCwgb3IgYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2hcclxuICAgICAgICAgICAgICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxyXG4gICAgICAgICAgICAgKiBpcyByZWNvbW1lbmRlZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW58c3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhcIjogdHJ1ZSxcclxuICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU2Nyb2xsWFwiOiBcIlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcclxuICAgICAgICAgICAgICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxyXG4gICAgICAgICAgICAgKiB0YWJsZSB3aGljaCByZXF1aXJlcyB0byBiZSB3ZWxsIHNwYWNlZCwgdGhpcyBwYXJhbWV0ZXIgaXMgdXNlZnVsIGZvclxyXG4gICAgICAgICAgICAgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcclxuICAgICAgICAgICAgICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxyXG4gICAgICAgICAgICAgKiBtZWFzdXJlbWVudCkuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU2Nyb2xsWElubmVyXCI6IFwiXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXHJcbiAgICAgICAgICAgICAqIHRvIHRoZSBnaXZlbiBoZWlnaHQsIGFuZCBlbmFibGUgc2Nyb2xsaW5nIGZvciBhbnkgZGF0YSB3aGljaCBvdmVyZmxvd3MgdGhlXHJcbiAgICAgICAgICAgICAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcclxuICAgICAgICAgICAgICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXHJcbiAgICAgICAgICAgICAqIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZSkuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXJcclxuICAgICAgICAgICAgICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU2Nyb2xsWVwiOiBcIlwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cclxuICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIEhUVFAgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBtYWtlIHRoZSBBamF4IGNhbGwgZm9yIHNlcnZlci1zaWRlXHJcbiAgICAgICAgICAgICAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IEdFVFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxyXG4gICAgICAgICAgICAgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXHJcbiAgICAgICAgICAgICAqIGdlbmVyYXRlIHN1aXRhYmxlIG1hcmstdXAgZm9yIGEgc2l0ZS4gRm9yIGV4YW1wbGUgdGhlIEJvb3RzdHJhcFxyXG4gICAgICAgICAgICAgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXHJcbiAgICAgICAgICAgICAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXHJcbiAgICAgICAgICAgICAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ3xvYmplY3RcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yZW5kZXJlclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJyZW5kZXJlclwiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxyXG4gICAgICAgICAgICAgKiB0byBzZXQgYXMgdGhlIGBpZGAgcHJvcGVydHkgaW4gdGhlIG5vZGUuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IERUX1Jvd0lkXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93SWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwicm93SWRcIjogXCJEVF9Sb3dJZFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKERhdGFUYWJsZS5kZWZhdWx0cyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBEZXZlbG9wZXIgbm90ZSAtIFNlZSBub3RlIGluIG1vZGVsLmRlZmF1bHRzLmpzIGFib3V0IHRoZSB1c2Ugb2YgSHVuZ2FyaWFuXHJcbiAgICAgICAgICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cclxuICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXHJcbiAgICAgICAgICAgICAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxyXG4gICAgICAgICAgICAgKiBkb2luZyBhIHNvcnQgb3IgdXNlIHRoZSBkYXRhIGZyb20gYSBkaWZmZXJlbnQgY29sdW1uLiBGb3IgZXhhbXBsZSBmaXJzdFxyXG4gICAgICAgICAgICAgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXHJcbiAgICAgICAgICAgICAqIHR3byBjb2x1bW5zLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXl8aW50XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyRGF0YVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0sIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMSwgMCBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMSwgMCBdIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFEYXRhU29ydFwiOiBudWxsLFxyXG4gICAgICAgICAgICBcImlEYXRhU29ydFwiOiAtMSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXHJcbiAgICAgICAgICAgICAqIGJlaGF2aW91ciBvZiB0aGUgc29ydCBoYW5kbGVyIChpLmUuIG9ubHkgYWxsb3cgYXNjZW5kaW5nIG9yZGVyaW5nIGV0YylcclxuICAgICAgICAgICAgICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgWyAnYXNjJywgJ2Rlc2MnIF1cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiBdLCBcInRhcmdldHNcIjogWyAzIF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFzU29ydGluZ1wiOiBbJ2FzYycsICdkZXNjJ10sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uc2VhcmNoYWJsZVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTZWFyY2hhYmxlXCI6IHRydWUsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlcmFibGVcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlNvcnRhYmxlXCI6IHRydWUsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIHRoaXMgY29sdW1uLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi52aXNpYmxlXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlZpc2libGVcIjogdHJ1ZSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXHJcbiAgICAgICAgICAgICAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcclxuICAgICAgICAgICAgICogYWxsb3dpbmcgeW91IHRvIG1vZGlmeSB0aGUgRE9NIGVsZW1lbnQgKGFkZCBiYWNrZ3JvdW5kIGNvbG91ciBmb3IgZXhhbXBsZSkgd2hlbiB0aGVcclxuICAgICAgICAgICAgICogZWxlbWVudCBpcyBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtlbGVtZW50fSB0ZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7Kn0gY2VsbERhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXHJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gcm93RGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHJvdyBUaGUgcm93IGluZGV4IGZvciB0aGUgYW9EYXRhIGRhdGEgc3RvcmVcclxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBpbmRleCBmb3IgYW9Db2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNyZWF0ZWRDZWxsXHJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSwgcm93RGF0YSwgcm93LCBjb2wpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBpZiAoIGNlbGxEYXRhID09IFwiMS43XCIgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ2JsdWUnKVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBoYXMgYmVlbiByZXBsYWNlZCBieSBgZGF0YWAgaW4gRGF0YVRhYmxlcyB0byBlbnN1cmUgbmFtaW5nXHJcbiAgICAgICAgICAgICAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcclxuICAgICAgICAgICAgICogY29tcGF0aWJpbGl0eSBpbiBEYXRhVGFibGVzIGZvciB0aGlzIG9wdGlvbiwgYnV0IGl0IGlzIHN0cm9uZ2x5XHJcbiAgICAgICAgICAgICAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgZGF0YWAgaW4gcHJlZmVyZW5jZSB0byBgZGF0YVByb3BgLlxyXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxyXG4gICAgICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAqIGluY2x1ZGluZyBkZWVwbHkgbmVzdGVkIG9iamVjdHMgLyBwcm9wZXJ0aWVzLiBgZGF0YWAgY2FuIGJlIGdpdmVuIGluIGFcclxuICAgICAgICAgICAgICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcclxuICAgICAgICAgICAgICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxyXG4gICAgICAgICAgICAgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxyXG4gICAgICAgICAgICAgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcclxuICAgICAgICAgICAgICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XHJcbiAgICAgICAgICAgICAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxyXG4gICAgICAgICAgICAgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3JcclxuICAgICAgICAgICAgICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxyXG4gICAgICAgICAgICAgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXHJcbiAgICAgICAgICAgICAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxyXG4gICAgICAgICAgICAgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcclxuICAgICAgICAgICAgICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcclxuICAgICAgICAgICAgICogICAgICByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxyXG4gICAgICAgICAgICAgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXHJcbiAgICAgICAgICAgICAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxyXG4gICAgICAgICAgICAgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cclxuICAgICAgICAgICAgICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XHJcbiAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gbm90YXRpb24gaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBgcmVuZGVyYCByYXRoZXIgdGhhblxyXG4gICAgICAgICAgICAgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXHJcbiAgICAgICAgICAgICAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xyXG4gICAgICAgICAgICAgKiAgIGRhdGEgZGlyZWN0bHkgZnJvbSBpdC4gVGhpcyBhY3Rpb24gaGFzIGVmZmVjdHMgb24gdHdvIG90aGVyXHJcbiAgICAgICAgICAgICAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcclxuICAgICAgICAgICAgICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxyXG4gICAgICAgICAgICAgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgdmFsdWUgZGVmaW5lZCBieVxyXG4gICAgICAgICAgICAgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cclxuICAgICAgICAgICAgICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXHJcbiAgICAgICAgICAgICAqICAgICAgb3B0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHdob2xlIGRhdGEgc291cmNlIGZvciB0aGVcclxuICAgICAgICAgICAgICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxyXG4gICAgICAgICAgICAgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXHJcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgICAqICAgICogUGFyYW1ldGVyczpcclxuICAgICAgICAgICAgICogICAgICAqIGB7YXJyYXl8b2JqZWN0fWAgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93XHJcbiAgICAgICAgICAgICAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxyXG4gICAgICAgICAgICAgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgKiAgICAgICAgd2hlbiBnYXRoZXJpbmcgZGF0YS4gTm90ZSB0aGF0IHdoZW4gYHVuZGVmaW5lZGAgaXMgZ2l2ZW4gZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxyXG4gICAgICAgICAgICAgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cclxuICAgICAgICAgICAgICogICAgKiBSZXR1cm46XHJcbiAgICAgICAgICAgICAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXHJcbiAgICAgICAgICAgICAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICogICAgICAgIGZvciB0aGUgZGF0YSByZXF1ZXN0ZWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcclxuICAgICAgICAgICAgICogZm9ybWF0dGluZyBvZiBkYXRhIGZvciBvdXRwdXQsIHlvdSB3aWxsIGxpa2VseSB3YW50IHRvIHVzZSBgcmVuZGVyYCB3aGljaFxyXG4gICAgICAgICAgICAgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcmlvciB0byBEYXRhVGFibGVzIDEuOS4yIGBkYXRhYCB3YXMgY2FsbGVkIGBtRGF0YVByb3BgLiBUaGVcclxuICAgICAgICAgICAgICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcclxuICAgICAgICAgICAgICogYmUgdXNlZCBieSBEYXRhVGFibGVzLCBhcyBpdCBhdXRvbWF0aWNhbGx5IG1hcHMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXdcclxuICAgICAgICAgICAgICogaWYgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG51bGxcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+VXNlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBjb2x1bW4gaW5kZXg8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBSZWFkIHRhYmxlIGRhdGEgZnJvbSBvYmplY3RzXHJcbiAgICAgICAgICAgICAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcclxuICAgICAgICAgICAgICogICAgLy8gICB7XHJcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcclxuICAgICAgICAgICAgICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcclxuICAgICAgICAgICAgICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHt2YWx1ZX0sXHJcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJ2ZXJzaW9uXCI6IHt2YWx1ZX0sXHJcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XHJcbiAgICAgICAgICAgICAqICAgIC8vICAgfVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvb2JqZWN0cy50eHRcIixcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBSZWFkIGluZm9ybWF0aW9uIGZyb20gZGVlcGx5IG5lc3RlZCBvYmplY3RzXHJcbiAgICAgICAgICAgICAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcclxuICAgICAgICAgICAgICogICAgLy8gICB7XHJcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcclxuICAgICAgICAgICAgICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcclxuICAgICAgICAgICAgICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcclxuICAgICAgICAgICAgICogICAgLy8gICAgICAgICBcImlubmVyXCI6IHt2YWx1ZX1cclxuICAgICAgICAgICAgICogICAgLy8gICAgICB9LFxyXG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgICAge3ZhbHVlfSwge3ZhbHVlfVxyXG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIF1cclxuICAgICAgICAgICAgICogICAgLy8gICB9XHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmlubmVyXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5kZXRhaWxzLjBcIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmRldGFpbHMuMVwiIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxyXG4gICAgICAgICAgICAgKiAgICAvLyBzb3J0aW5nLCBmaWx0ZXJpbmcgYW5kIGRpc3BsYXkuIEluIHRoaXMgY2FzZSwgY3VycmVuY3kgKHByaWNlKVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZSA9IHZhbDtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNsYXkgYW5kIGZpbHRlciB2YWx1ZXMgZm9yIGVmZmljaWVuY3lcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9kaXNwbGF5ID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2ZpbHRlciAgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCkrXCIgXCIrdmFsO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZGlzcGxheScpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZGlzcGxheTtcclxuICAgICAgICAgICAgICogICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZpbHRlcicpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZmlsdGVyO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgICAgICAvLyAnc29ydCcsICd0eXBlJyBhbmQgdW5kZWZpbmVkIGFsbCBqdXN0IHVzZSB0aGUgaW50ZWdlclxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2U7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgZGVmYXVsdCBjb250ZW50XHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiQ2xpY2sgdG8gZWRpdFwiXHJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGFycmF5IG5vdGF0aW9uIC0gb3V0cHV0dGluZyBhIGxpc3QgZnJvbSBhbiBhcnJheVxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogXCJuYW1lWywgXVwiXHJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwibURhdGFcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxyXG4gICAgICAgICAgICAgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcclxuICAgICAgICAgICAgICogc29ydGluZyBldGMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBmb3IgdGhlIHRhYmxlLCB1c2UgdGhpc1xyXG4gICAgICAgICAgICAgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXHJcbiAgICAgICAgICAgICAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxyXG4gICAgICAgICAgICAgKiB0aGlzIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgdG8gZWZmZWN0IGl0c1xyXG4gICAgICAgICAgICAgKiBiZWhhdmlvdXI6XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxyXG4gICAgICAgICAgICAgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXHJcbiAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXHJcbiAgICAgICAgICAgICAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xyXG4gICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcclxuICAgICAgICAgICAgICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXHJcbiAgICAgICAgICAgICAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxyXG4gICAgICAgICAgICAgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXHJcbiAgICAgICAgICAgICAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cclxuICAgICAgICAgICAgICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXHJcbiAgICAgICAgICAgICAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcclxuICAgICAgICAgICAgICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxyXG4gICAgICAgICAgICAgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xyXG4gICAgICAgICAgICAgKiAgICAgIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXHJcbiAgICAgICAgICAgICAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcclxuICAgICAgICAgICAgICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXHJcbiAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxyXG4gICAgICAgICAgICAgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiAqIGBvYmplY3RgIC0gdXNlIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IGRhdGEgdHlwZXMgcmVxdWVzdGVkIGJ5XHJcbiAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xyXG4gICAgICAgICAgICAgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXHJcbiAgICAgICAgICAgICAqICAgZGVmaW5lZCB1c2luZyBhbiBpbnRlZ2VyLCBzdHJpbmcgb3IgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgcnVsZXMgYXNcclxuICAgICAgICAgICAgICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxyXG4gICAgICAgICAgICAgKiAgIHRoZSBkYXRhIHR5cGUgcmVxdWVzdGVkIGJ5IERhdGFUYWJsZXMuXHJcbiAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcclxuICAgICAgICAgICAgICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcclxuICAgICAgICAgICAgICogICAgKiBQYXJhbWV0ZXJzOlxyXG4gICAgICAgICAgICAgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXHJcbiAgICAgICAgICAgICAqICAgICAgKiB7c3RyaW5nfSBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdmaWx0ZXInLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxyXG4gICAgICAgICAgICAgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxyXG4gICAgICAgICAgICAgKiAgICAgICAgYGRhdGFgKVxyXG4gICAgICAgICAgICAgKiAgICAqIFJldHVybjpcclxuICAgICAgICAgICAgICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiAgICAgICAgZGF0YSByZXF1ZXN0ZWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG9iamVjdHxudWxsXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIFVzZSB0aGUgZGF0YSBzb3VyY2UgdmFsdWUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnJlbmRlclxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIENyZWF0ZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0c1xyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvZGVlcC50eHRcIixcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJyZW5kZXJcIjogXCJbLCBdLm5hbWVcIlxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxyXG4gICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcclxuICAgICAgICAgICAgICogICAgLy8gVGhpcyB3b3VsZCBiZSB1c2VkIHdpdGggYSBkYXRhIHNvdXJjZSBzdWNoIGFzOlxyXG4gICAgICAgICAgICAgKiAgICAvLyAgIHsgXCJwaG9uZVwiOiA1NTUyMzY4LCBcInBob25lX2ZpbHRlclwiOiBcIjU1NTIzNjggNTU1LTIzNjhcIiwgXCJwaG9uZV9kaXNwbGF5XCI6IFwiNTU1LTIzNjhcIiB9XHJcbiAgICAgICAgICAgICAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcclxuICAgICAgICAgICAgICogICAgLy8gKHdoaWNoIGhhcyBib3RoIGZvcm1zKSBpcyB1c2VkIGZvciBmaWx0ZXJpbmcgZm9yIGlmIGEgdXNlciBpbnB1dHMgZWl0aGVyIGZvcm1hdCwgd2hpbGVcclxuICAgICAgICAgICAgICogICAgLy8gdGhlIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIgaXMgdGhlIG9uZSB0aGF0IGlzIHNob3duIGluIHRoZSB0YWJsZS5cclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImZpbHRlclwiOiBcInBob25lX2ZpbHRlclwiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInBob25lX2Rpc3BsYXlcIlxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2VcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IFwiZG93bmxvYWRfbGlua1wiLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJytkYXRhKydcIj5Eb3dubG9hZDwvYT4nO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwibVJlbmRlclwiOiBudWxsLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGFuZ2UgdGhlIGNlbGwgdHlwZSBjcmVhdGVkIGZvciB0aGUgY29sdW1uIC0gZWl0aGVyIFREIGNlbGxzIG9yIFRIIGNlbGxzLiBUaGlzXHJcbiAgICAgICAgICAgICAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXHJcbiAgICAgICAgICAgICAqIHRvIGFjdCBhcyBhIGhlYWRlciBmb3IgYSByb3cgKHlvdSBtYXkgd2lzaCB0byBhZGQgc2NvcGU9J3JvdycgdG8gdGhlIFRIIGVsZW1lbnRzKS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdGRcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2VsbFR5cGVcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBNYWtlIHRoZSBmaXJzdCBjb2x1bW4gdXNlIFRIIGNlbGxzXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiY2VsbFR5cGVcIjogXCJ0aFwiXHJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic0NlbGxUeXBlXCI6IFwidGRcIixcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xhc3MgdG8gZ2l2ZSB0byBlYWNoIGNlbGwgaW4gdGhpcyBjb2x1bW4uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2xhc3NcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNDbGFzc1wiOiBcIlwiLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcclxuICAgICAgICAgICAgICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxyXG4gICAgICAgICAgICAgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcclxuICAgICAgICAgICAgICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcclxuICAgICAgICAgICAgICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xyXG4gICAgICAgICAgICAgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXHJcbiAgICAgICAgICAgICAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcclxuICAgICAgICAgICAgICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cclxuICAgICAgICAgICAgICogR2VuZXJhbGx5IHlvdSBzaG91bGRuJ3QgbmVlZCB0aGlzIVxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8aT5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY29udGVudFBhZGRpbmdcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJjb250ZW50UGFkZGluZ1wiOiBcIm1tbVwiXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgYGRhdGFgXHJcbiAgICAgICAgICAgICAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGVmYXVsdENvbnRlbnRcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIixcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcInRhcmdldHNcIjogWyAtMSBdXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiBEYXRhVGFibGVzJyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBJdCBjYW5cclxuICAgICAgICAgICAgICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcclxuICAgICAgICAgICAgICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xyXG4gICAgICAgICAgICAgKiBhbHNvIGFsbG93IERhdGFUYWJsZXMgdG8gcmVvcmRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaWYgaXQgY29tZXNcclxuICAgICAgICAgICAgICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcclxuICAgICAgICAgICAgICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm5hbWVcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIsIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIgfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiB9XHJcbiAgICAgICAgICAgICAqICAgICAgICBdXHJcbiAgICAgICAgICAgICAqICAgICAgfSApO1xyXG4gICAgICAgICAgICAgKiAgICB9ICk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNOYW1lXCI6IFwiXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgYSBkYXRhIHNvdXJjZSB0eXBlIGZvciB0aGUgb3JkZXJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZFxyXG4gICAgICAgICAgICAgKiByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdGFibGUgKHVwZGF0aW5nIHRoZSBpbnRlcm5hbGx5IGNhY2hlZFxyXG4gICAgICAgICAgICAgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxyXG4gICAgICAgICAgICAgKiBlZGl0YWJsZSBlbGVtZW50cyBzdWNoIGFzIGZvcm0gaW5wdXRzLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBzdGRcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhVHlwZVxyXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0YXJnZXRzXCI6IFsgMiwgMyBdIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwibnVtZXJpY1wiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9LFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiLCBcInRhcmdldHNcIjogWyA1IF0gfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0eXBlXCI6IFwibnVtZXJpY1wiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgXVxyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIGNvbHVtbi5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5EZXJpdmVkIGZyb20gdGhlICdUSCcgdmFsdWUgZm9yIHRoaXMgY29sdW1uIGluIHRoZVxyXG4gICAgICAgICAgICAgKiAgICBvcmlnaW5hbCBIVE1MIHRhYmxlLjwvaT5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udGl0bGVcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1RpdGxlXCI6IG51bGwsXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcclxuICAgICAgICAgICAgICogb3JkZXJlZC4gRm91ciB0eXBlcyAoc3RyaW5nLCBudW1lcmljLCBkYXRlIGFuZCBodG1sICh3aGljaCB3aWxsIHN0cmlwXHJcbiAgICAgICAgICAgICAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxyXG4gICAgICAgICAgICAgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXHJcbiAgICAgICAgICAgICAqIGRhdGUuIEZvciBleGFtcGxlOiBcIk1hciAyNiwgMjAwOCA1OjAzIFBNXCIuIE1heSB0YWtlIHRoZSB2YWx1ZXM6ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICAgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcclxuICAgICAgICAgICAgICogdGhyb3VnaCBwbHVnLWlucy5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnR5cGVcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1R5cGVcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcclxuICAgICAgICAgICAgICogKDNlbSwgMjBweCBldGMpLiBEYXRhVGFibGVzIGFwcGxpZXMgJ3NtYXJ0JyB3aWR0aHMgdG8gY29sdW1ucyB3aGljaCBoYXZlIG5vdFxyXG4gICAgICAgICAgICAgKiBiZWVuIGdpdmVuIGEgc3BlY2lmaWMgd2lkdGggdGhyb3VnaCB0aGlzIGludGVyZmFjZSBlbnN1cmluZyB0aGF0IHRoZSB0YWJsZVxyXG4gICAgICAgICAgICAgKiByZW1haW5zIHJlYWRhYmxlLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG9tYXRpYzwvaT5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ud2lkdGhcclxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiIH0sXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICogICAgICAgIF1cclxuICAgICAgICAgICAgICogICAgICB9ICk7XHJcbiAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1dpZHRoXCI6IG51bGxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfZm5IdW5nYXJpYW5NYXAoRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgLSB0aGlzIGhvbGRzIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciBhXHJcbiAgICAgICAgICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxyXG4gICAgICAgICAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcclxuICAgICAgICAgKiB3aXRoIHRoZSBzZXR0aW5ncyBhdHRhY2hlZCB0byB0aGF0IGluc3RhbmNlLCBidXQgcmF0aGVyIGluc3RhbmNlcyBvZiB0aGVcclxuICAgICAgICAgKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxyXG4gICAgICAgICAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxyXG4gICAgICAgICAqIGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcclxuICAgICAgICAgKiBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLiBJdCBzaG91bGRcclxuICAgICAgICAgKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxyXG4gICAgICAgICAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgKiAgQHRvZG8gUmVhbGx5IHNob3VsZCBhdHRhY2ggdGhlIHNldHRpbmdzIG9iamVjdCB0byBpbmRpdmlkdWFsIGluc3RhbmNlcyBzbyB3ZVxyXG4gICAgICAgICAqICAgIGRvbid0IG5lZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb24gZWFjaCAkKCkuZGF0YVRhYmxlKCkgY2FsbCAoaWYgdGhlXHJcbiAgICAgICAgICogICAgdGFibGUgYWxyZWFkeSBleGlzdHMpLiBJdCB3b3VsZCBhbHNvIHNhdmUgcGFzc2luZyBvU2V0dGluZ3MgYXJvdW5kIGFuZFxyXG4gICAgICAgICAqICAgIGludG8gZXZlcnkgc2luZ2xlIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGEgdmVyeSBzaWduaWZpY2FudFxyXG4gICAgICAgICAqICAgIGFyY2hpdGVjdHVyZSBjaGFuZ2UgZm9yIERhdGFUYWJsZXMgYW5kIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBicmVha1xyXG4gICAgICAgICAqICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucy4gVGhpcyBpcyBzb21ldGhpbmcgdGhhdFxyXG4gICAgICAgICAqICAgIHdpbGwgYmUgZG9uZSBpbiAyLjAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcmltYXJ5IGZlYXR1cmVzIG9mIERhdGFUYWJsZXMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdGUuXHJcbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm9GZWF0dXJlc1wiOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIHNheSBpZiBEYXRhVGFibGVzIHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyeSB0byBjYWxjdWxhdGUgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYkF1dG9XaWR0aFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVsYXkgdGhlIGNyZWF0aW9uIG9mIFRSIGFuZCBURCBlbGVtZW50cyB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseVxyXG4gICAgICAgICAgICAgICAgICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXHJcbiAgICAgICAgICAgICAgICAgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xyXG4gICAgICAgICAgICAgICAgICogZGlmZmVyZW5jZSBhdCBhbGwgZnJvIERPTSBhbmQgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGlzIG5vIGZpbHRlcmluZyBhdCBhbGwgb24gdGhlIHRhYmxlLCBpbmNsdWRpbmcgZm5GaWx0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBUbyBqdXN0IHJlbW92ZSB0aGUgZmlsdGVyaW5nIGlucHV0IHVzZSBzRG9tIGFuZCByZW1vdmUgdGhlICdmJyBvcHRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYkZpbHRlclwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGFibGUgaW5mb3JtYXRpb24gZWxlbWVudCAodGhlICdTaG93aW5nIHggb2YgeSByZWNvcmRzJyBkaXYpIGVuYWJsZVxyXG4gICAgICAgICAgICAgICAgICogZmxhZy5cclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJiSW5mb1wiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJlc2VudCBhIHVzZXIgY29udHJvbCBhbGxvd2luZyB0aGUgZW5kIHVzZXIgdG8gY2hhbmdlIHRoZSBwYWdlIHNpemVcclxuICAgICAgICAgICAgICAgICAqIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcImJMZW5ndGhDaGFuZ2VcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gZW5hYmxlZCBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkIHRoZW4gbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgKiBjaGFuZ2luZyBtdXN0IGFsc28gYmUgZGlzYWJsZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYlBhZ2luYXRlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcm9jZXNzaW5nIGluZGljYXRvciBlbmFibGUgZmxhZyB3aGVuZXZlciBEYXRhVGFibGVzIGlzIGVuYWN0aW5nIGFcclxuICAgICAgICAgICAgICAgICAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZW5hYmxlZCBmbGFnIC0gd2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbFxyXG4gICAgICAgICAgICAgICAgICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcclxuICAgICAgICAgICAgICAgICAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTb3J0aW5nIGVuYWJsZW1lbnQgZmxhZy5cclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJiU29ydFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTXVsdGktY29sdW1uIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJiU29ydE11bHRpXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXHJcbiAgICAgICAgICAgICAgICAgKiB2aXN1YWwgaGlnaGxpZ2h0IG9yIG5vdC4gVGhpcyBjYW4gc2xvdyB0aGluZ3MgZG93biB3aGVuIGVuYWJsZWQgc2luY2VcclxuICAgICAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJiU29ydENsYXNzZXNcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0YXRlIHNhdmluZyBlbmFibGVtZW50IGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYlN0YXRlU2F2ZVwiOiBudWxsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cclxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwib1Njcm9sbFwiOiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIHRhYmxlIGlzIHNob3J0ZXIgaW4gaGVpZ2h0IHRoYW4gc1Njcm9sbFksIGNvbGxhcHNlIHRoZVxyXG4gICAgICAgICAgICAgICAgICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYkNvbGxhcHNlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGUgd2ViLWJyb3dzZXIncyBwbGF0Zm9ybS4gQ2FsY3VsYXRlZFxyXG4gICAgICAgICAgICAgICAgICogZHVyaW5nIHRhYmxlIGluaXRpYWxpc2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgXCJpQmFyV2lkdGhcIjogMCxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFZpZXdwb3J0IHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZy4gSG9yaXpvbnRhbCBzY3JvbGxpbmcgaXNcclxuICAgICAgICAgICAgICAgICAqIGRpc2FibGVkIGlmIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcInNYXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3VcclxuICAgICAgICAgICAgICAgICAqIHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhpcy5cclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic1hJbm5lclwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVmlld3BvcnQgaGVpZ2h0IGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyBpcyBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICogaWYgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwic1lcIjogbnVsbFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXHJcbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm9MYW5ndWFnZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uLiBTZWVcclxuICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuZm5JbmZvQ2FsbGJhY2t9XHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJyb3dzZXIgc3VwcG9ydCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm9Ccm93c2VyXCI6IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgdGhlIGJyb3dzZXIgaW5jb3JyZWN0bHkgY2FsY3VsYXRlcyB3aWR0aDoxMDAlIGluc2lkZSBhXHJcbiAgICAgICAgICAgICAgICAgKiBzY3JvbGxpbmcgZWxlbWVudCAoSUU2LzcpXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYlNjcm9sbE92ZXJzaXplXCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgb24gdGhlIHJpZ2h0IG9yIGxlZnQgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBzY3JvbGxpbmcgY29udGFpbmVyIC0gbmVlZGVkIGZvciBydGwgbGFuZ3VhZ2UgbGF5b3V0LCBhbHRob3VnaCBub3RcclxuICAgICAgICAgICAgICAgICAqIGFsbCBicm93c2VycyBtb3ZlIHRoZSBzY3JvbGxiYXIgKFNhZmFyaSkuXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYlNjcm9sbGJhckxlZnRcIjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGbGFnIGZvciBpZiBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBpcyBmdWxseSBzdXBwb3J0ZWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFwiYkJvdW5kaW5nXCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnJvd3NlciBzY3JvbGxiYXIgd2lkdGhcclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBcImJhcldpZHRoXCI6IDBcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBcImFqYXhcIjogbnVsbCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxyXG4gICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIG9mIHRoaXMgb2JqZWN0IG1hdGNoIHdoYXQgaXMgYWxsb3dlZCBieSBzRG9tIC0gaS5lLlxyXG4gICAgICAgICAgICAgKiAgIDx1bD5cclxuICAgICAgICAgICAgICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxyXG4gICAgICAgICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYWFuRmVhdHVyZXNcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcclxuICAgICAgICAgICAgICogaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9EYXRhXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGluZGV4ZXMgd2hpY2ggYXJlIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgKGFmdGVyIGZpbHRlcmluZyBldGMpXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYWlEaXNwbGF5XCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGluZGV4ZXMgZm9yIGRpc3BsYXkgLSBubyBmaWx0ZXJpbmdcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhaURpc3BsYXlNYXN0ZXJcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFwIG9mIHJvdyBpZHMgdG8gZGF0YSBpbmRleGVzXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFJZHNcIjoge30sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBjb2x1bW4gdGhhdCBpcyBpbiB1c2VcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb0NvbHVtbnNcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgaGVhZGVyXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9IZWFkZXJcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgZm9vdGVyXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9Gb290ZXJcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgdGhlIGFwcGxpZWQgZ2xvYmFsIHNlYXJjaCBpbmZvcm1hdGlvbiBpbiBjYXNlIHdlIHdhbnQgdG8gZm9yY2UgYVxyXG4gICAgICAgICAgICAgKiByZXNlYXJjaCBvciBjb21wYXJlIHRoZSBvbGQgc2VhcmNoIHRvIGEgbmV3IG9uZS5cclxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvUHJldmlvdXNTZWFyY2hcIjoge30sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcmUgdGhlIGFwcGxpZWQgc2VhcmNoIGZvciBlYWNoIGNvbHVtbiAtIHNlZVxyXG4gICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNofSBmb3IgdGhlIGZvcm1hdCB0aGF0IGlzIHVzZWQgZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvUHJlU2VhcmNoQ29sc1wiOiBbXSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxyXG4gICAgICAgICAgICAgKiB1c2VkIGluIHRoZSBmb2xsb3dpbmcgbWFubmVyOlxyXG4gICAgICAgICAgICAgKiA8dWw+XHJcbiAgICAgICAgICAgICAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cclxuICAgICAgICAgICAgICogICA8bGk+SW5kZXggMSAtIGN1cnJlbnQgc29ydGluZyBkaXJlY3Rpb248L2xpPlxyXG4gICAgICAgICAgICAgKiA8L3VsPlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYWFTb3J0aW5nXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU29ydGluZyB0aGF0IGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAoaS5lLiBwcmVmaXhlZCBpbiBmcm9udCBvZlxyXG4gICAgICAgICAgICAgKiBhYVNvcnRpbmcpLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsYXNzZXMgdG8gdXNlIGZvciB0aGUgc3RyaXBpbmcgb2YgYSB0YWJsZS5cclxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhc0Rlc3Ryb3lTdHJpcGVzXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic0Rlc3Ryb3lXaWR0aFwiOiAwLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvUm93Q2FsbGJhY2tcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb0hlYWRlckNhbGxiYWNrXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb0Zvb3RlckNhbGxiYWNrXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb0RyYXdDYWxsYmFja1wiOiBbXSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2tcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2ZcclxuICAgICAgICAgICAgICogZmFsc2Ugd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb1ByZURyYXdDYWxsYmFja1wiOiBbXSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvSW5pdENvbXBsZXRlXCI6IFtdLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdG8gYmUgc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmcsIHByaW9yIHRvXHJcbiAgICAgICAgICAgICAqIHNhdmluZyBzdGF0ZS5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdGhhdCBoYXZlIGJlZW4gc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmdcclxuICAgICAgICAgICAgICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9TdGF0ZUxvYWRQYXJhbXNcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxyXG4gICAgICAgICAgICAgKiBsb2FkZWRcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb1N0YXRlTG9hZGVkXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlIHRoZSB0YWJsZSBJRCBmb3IgcXVpY2sgYWNjZXNzXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1RhYmxlSWRcIjogXCJcIixcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgVEFCTEUgbm9kZSBmb3IgdGhlIG1haW4gdGFibGVcclxuICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiblRhYmxlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGVybWFuZW50IHJlZiB0byB0aGUgdGhlYWQgZWxlbWVudFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJuVEhlYWRcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Zm9vdCBlbGVtZW50IC0gaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm5URm9vdFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRib2R5IGVsZW1lbnRcclxuICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiblRCb2R5XCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FjaGUgdGhlIHdyYXBwZXIgbm9kZSAoY29udGFpbnMgYWxsIERhdGFUYWJsZXMgY29udHJvbGxlZCBlbGVtZW50cylcclxuICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiblRhYmxlV3JhcHBlclwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlIGlmIHdoZW4gdXNpbmcgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGUgbG9hZGluZyBvZiBkYXRhXHJcbiAgICAgICAgICAgICAqIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgc2Vjb25kIGRyYXcuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiRGVmZXJMb2FkaW5nXCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlIGlmIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBoYXMgYmVlbiByZWFkIGluXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiSW5pdGlhbGlzZWRcIjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5mb3JtYXRpb24gYWJvdXQgb3BlbiByb3dzLiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIHRoZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAqICduVHInIGFuZCAnblBhcmVudCdcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb09wZW5Sb3dzXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERpY3RhdGUgdGhlIHBvc2l0aW9uaW5nIG9mIERhdGFUYWJsZXMnIGNvbnRyb2wgZWxlbWVudHMgLSBzZWVcclxuICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cclxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzRG9tXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoIGRlbGF5IChpbiBtUylcclxuICAgICAgICAgICAgICogIEB0eXBlIGludGVnZXJcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic2VhcmNoRGVsYXlcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGljaCB0eXBlIG9mIHBhZ2luYXRpb24gc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHR3b19idXR0b25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwic1BhZ2luYXRpb25UeXBlXCI6IFwidHdvX2J1dHRvblwiLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzdGF0ZSBkdXJhdGlvbiAoZm9yIGBzdGF0ZVNhdmVgKSBpbiBzZWNvbmRzLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlTdGF0ZUR1cmF0aW9uXCI6IDAsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxyXG4gICAgICAgICAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgICAqICAgPHVsPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xyXG4gICAgICAgICAgICAgKiAgICAgICBhbmQgdGhlIEpTT04gc3RyaW5nIHRvIHNhdmUgdGhhdCBoYXMgYmVlbiB0aHVzIGZhciBjcmVhdGVkLiBSZXR1cm5zXHJcbiAgICAgICAgICAgICAqICAgICAgIGEgSlNPTiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBhIGpzb24gb2JqZWN0XHJcbiAgICAgICAgICAgICAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XHJcbiAgICAgICAgICAgICAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XHJcbiAgICAgICAgICAgICAqICAgPC91bD5cclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJhb1N0YXRlU2F2ZVwiOiBbXSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIGxvYWRpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxyXG4gICAgICAgICAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgICAqICAgPHVsPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xyXG4gICAgICAgICAgICAgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxyXG4gICAgICAgICAgICAgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxyXG4gICAgICAgICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYW9TdGF0ZUxvYWRcIjogW10sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RhdGUgdGhhdCB3YXMgc2F2ZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2VcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN0YXRlIHRoYXQgd2FzIGxvYWRlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNvdXJjZSB1cmwgZm9yIEFKQVggZGF0YSBmb3IgdGhlIHRhYmxlLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInNBamF4U291cmNlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJvcGVydHkgZnJvbSBhIGdpdmVuIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHRhYmxlIGRhdGEgZnJvbS4gVGhpc1xyXG4gICAgICAgICAgICAgKiBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nICh3aGVuIG5vdCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nKSwgaW4gd2hpY2ggY2FzZVxyXG4gICAgICAgICAgICAgKiBpdCBpcyAgYXNzdW1lZCBhbiBhbiBhcnJheSBpcyBnaXZlbiBkaXJlY3RseS5cclxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTm90ZSBpZiBkcmF3IHNob3VsZCBiZSBibG9ja2VkIHdoaWxlIGdldHRpbmcgZGF0YVxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiQWpheERhdGFHZXRcIjogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBqUXVlcnkgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIGZvciBzZXJ2ZXItc2lkZSBkYXRhIGdhdGhlcmluZy5cclxuICAgICAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igd29ya2luZyB3aXRoIHRoZSBYSFIgaW5mb3JtYXRpb24gaW4gb25lIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiBjYWxsYmFja3NcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJqcVhIUlwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwianNvblwiOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIm9BamF4RGF0YVwiOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRnVuY3Rpb25zIHdoaWNoIGFyZSBjYWxsZWQgcHJpb3IgdG8gc2VuZGluZyBhbiBBamF4IHJlcXVlc3Qgc28gZXh0cmFcclxuICAgICAgICAgICAgICogcGFyYW1ldGVycyBjYW4gZWFzaWx5IGJlIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlbmQgdGhlIFhIUiBIVFRQIG1ldGhvZCAtIEdFVCBvciBQT1NUIChjb3VsZCBiZSBQVVQgb3IgREVMRVRFIGlmXHJcbiAgICAgICAgICAgICAqIHJlcXVpcmVkKS5cclxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzU2VydmVyTWV0aG9kXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRm9ybWF0IG51bWJlcnMgZm9yIGRpc3BsYXkuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExpc3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgdXNlciBzZWxlY3RhYmxlIGxlbmd0aCBtZW51LlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFMZW5ndGhNZW51XCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ291bnRlciBmb3IgdGhlIGRyYXdzIHRoYXQgdGhlIHRhYmxlIGRvZXMuIEFsc28gdXNlZCBhcyBhIHRyYWNrZXIgZm9yXHJcbiAgICAgICAgICAgICAqIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJpRHJhd1wiOiAwLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlIGlmIGEgcmVkcmF3IGlzIGJlaW5nIGRvbmUgLSB1c2VmdWwgZm9yIEFqYXhcclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJEcmF3aW5nXCI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERyYXcgaW5kZXggKGlEcmF3KSBvZiB0aGUgbGFzdCBlcnJvciB3aGVuIHBhcnNpbmcgdGhlIHJldHVybmVkIGRhdGFcclxuICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgLTFcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiaURyYXdFcnJvclwiOiAtMSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYWdpbmcgZGlzcGxheSBsZW5ndGhcclxuICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMTBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhZ2luZyBzdGFydCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSByZXN1bHQgc2V0XHJcbiAgICAgICAgICAgICAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cclxuICAgICAgICAgICAgICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxyXG4gICAgICAgICAgICAgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfaVJlY29yZHNUb3RhbFwiOiAwLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxyXG4gICAgICAgICAgICAgKiAoaS5lLiBhZnRlciBmaWx0ZXJpbmcpLiBVc2UgZm5SZWNvcmRzRGlzcGxheSByYXRoZXIgdGhhblxyXG4gICAgICAgICAgICAgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXHJcbiAgICAgICAgICAgICAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJfaVJlY29yZHNEaXNwbGF5XCI6IDAsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwib0NsYXNzZXNcIjoge30sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcclxuICAgICAgICAgICAgICogY2FsbGJhY2sgaWYgZmlsdGVyaW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXHJcbiAgICAgICAgICAgICAqIGV2ZW50cy5cclxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJiRmlsdGVyZWRcIjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcclxuICAgICAgICAgICAgICogY2FsbGJhY2sgaWYgc29ydGluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxyXG4gICAgICAgICAgICAgKiBldmVudHMuXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYlNvcnRlZFwiOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxyXG4gICAgICAgICAgICAgKiBvbmUgdW5pcXVlIGNlbGwgcGVyIGNvbHVtbiwgaWYgdGhlIHRvcCBvbmUgKHRydWUpIG9yIGJvdHRvbSBvbmUgKGZhbHNlKVxyXG4gICAgICAgICAgICAgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImJTb3J0Q2VsbHNUb3BcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXNhdGlvbiBvYmplY3QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGVcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvSW5pdFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlc3Ryb3kgY2FsbGJhY2sgZnVuY3Rpb25zIC0gZm9yIHBsdWctaW5zIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZVxyXG4gICAgICAgICAgICAgKiBkZXN0cm95IHNvIHRoZXkgY2FuIGNsZWFuIHVwIG1hcmt1cCBhbmQgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGJlZm9yZSBmaWx0ZXJpbmdcclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImZuUmVjb3Jkc1RvdGFsXCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5EYXRhU291cmNlKHRoaXMpID09ICdzc3AnID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJmblJlY29yZHNEaXNwbGF5XCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5EYXRhU291cmNlKHRoaXMpID09ICdzc3AnID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFpRGlzcGxheS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBkaXNwbGF5IGVuZCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiZm5EaXNwbGF5RW5kXCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5faURpc3BsYXlTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBjYWxjID0gc3RhcnQgKyBsZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkcyA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRlID0gZmVhdHVyZXMuYlBhZ2luYXRlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU2VydmVyU2lkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWdpbmF0ZSA9PT0gZmFsc2UgfHwgbGVuID09PSAtMSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgcmVjb3JkcyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHN0YXJ0ICsgbGVuLCB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwYWdpbmF0ZSB8fCBjYWxjID4gcmVjb3JkcyB8fCBsZW4gPT09IC0xID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkcyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGlzIHRhYmxlXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwib0luc3RhbmNlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggaW5zdGFuY2Ugb2YgdGhlIERhdGFUYWJsZXMgb2JqZWN0LiBJZiB0aGVyZVxyXG4gICAgICAgICAgICAgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cclxuICAgICAgICAgICAgICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJzSW5zdGFuY2VcIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXHJcbiAgICAgICAgICAgICAqIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIGFuZCBpdHMgY29udHJvbHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcImlUYWJJbmRleFwiOiAwLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJuU2Nyb2xsSGVhZFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJuU2Nyb2xsRm9vdFwiOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExhc3QgYXBwbGllZCBzb3J0XHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFwiYUxhc3RTb3J0XCI6IFtdLFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN0b3JlZCBwbHVnLWluIGluc3RhbmNlc1xyXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJvUGx1Z2luc1wiOiB7fSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGdldCBhIHJvdydzIGlkIGZyb20gdGhlIHJvdydzIGRhdGFcclxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcInJvd0lkRm5cIjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEYXRhIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIGEgcm93J3MgaWRcclxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgXCJyb3dJZFwiOiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXh0ZW5zaW9uIG9iamVjdCBmb3IgRGF0YVRhYmxlcyB0aGF0IGlzIHVzZWQgdG8gcHJvdmlkZSBhbGwgZXh0ZW5zaW9uXHJcbiAgICAgICAgICogb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5leHRgIG9iamVjdCBpcyBhdmFpbGFibGUgdGhyb3VnaFxyXG4gICAgICAgICAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcclxuICAgICAgICAgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxyXG4gICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEYXRhVGFibGVzIGV4dGVuc2lvbnNcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBUaGlzIG5hbWVzcGFjZSBhY3RzIGFzIGEgY29sbGVjdGlvbiBhcmVhIGZvciBwbHVnLWlucyB0aGF0IGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgICAgICogZXh0ZW5kIERhdGFUYWJsZXMgY2FwYWJpbGl0aWVzLiBJbmRlZWQgbWFueSBvZiB0aGUgYnVpbGQgaW4gbWV0aG9kc1xyXG4gICAgICAgICAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3JcclxuICAgICAgICAgKiBleGFtcGxlKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XHJcbiAgICAgICAgICogcmVhc29uc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBEYXRhVGFibGUuZXh0ID0gX2V4dCA9IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcclxuICAgICAgICAgICAgICogZGVmaW5lZCBoZXJlIHNvIG90aGVyIGV4dGVuc2lvbnMgY2FuIGRlZmluZSBidXR0b25zIHJlZ2FyZGxlc3Mgb2YgbG9hZFxyXG4gICAgICAgICAgICAgKiBvcmRlci4gSXQgaXMgX25vdF8gdXNlZCBieSBEYXRhVGFibGVzIGNvcmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBidXR0b25zOiB7fSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCBjbGFzcyBuYW1lc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3Nlczoge30sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERhdGFUYWJsZXMgYnVpbGQgdHlwZSAoZXhwYW5kZWQgYnkgdGhlIGRvd25sb2FkIGJ1aWxkZXIpXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGJ1aWxkZXI6IFwiLXNvdXJjZS1cIixcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXJyb3IgcmVwb3J0aW5nLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXHJcbiAgICAgICAgICAgICAqICd0aHJvdycsICdub25lJyBvciBhIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBhbGVydFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZXJyTW9kZTogXCJhbGVydFwiLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGZWF0dXJlIHBsdWctaW5zLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogVGhpcyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdoaWNoIGRlc2NyaWJlIHRoZSBmZWF0dXJlIHBsdWctaW5zIHRoYXQgYXJlXHJcbiAgICAgICAgICAgICAqIGF2YWlsYWJsZSB0byBEYXRhVGFibGVzLiBUaGVzZSBmZWF0dXJlIHBsdWctaW5zIGFyZSB0aGVuIGF2YWlsYWJsZSBmb3JcclxuICAgICAgICAgICAgICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIEVhY2ggZmVhdHVyZSBwbHVnLWluIGlzIGRlc2NyaWJlZCBieSBhbiBvYmplY3Qgd2hpY2ggbXVzdCBoYXZlIHRoZVxyXG4gICAgICAgICAgICAgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqICogYGZuSW5pdGAgLSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gaW5pdGlhbGlzZSB0aGUgcGx1Zy1pbixcclxuICAgICAgICAgICAgICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXHJcbiAgICAgICAgICAgICAqICAgaW5zdGlsbGF0aW9uIG9wdGlvbi4gVGhpcyBpcyBjYXNlIHNlbnNpdGl2ZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxyXG4gICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEFuZCB0aGUgZm9sbG93aW5nIHJldHVybiBpcyBleHBlY3RlZDpcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqICoge25vZGV8bnVsbH0gVGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgeW91ciBmZWF0dXJlLiBOb3RlIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqICAgcmV0dXJuIG1heSBhbHNvIGJlIHZvaWQgaWYgeW91ciBwbHVnLWluIGRvZXMgbm90IHJlcXVpcmUgdG8gaW5qZWN0IGFueVxyXG4gICAgICAgICAgICAgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxyXG4gICAgICAgICAgICAgKiAgIGJlIHVzZWZ1bCB3aGVuIGRldmVsb3BpbmcgYSBwbHVnLWluIHdoaWNoIGFsbG93cyB0YWJsZSBjb250cm9sIHZpYVxyXG4gICAgICAgICAgICAgKiAgIGtleWJvYXJkIGVudHJ5XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LmZlYXR1cmVzLnB1c2goIHtcclxuICAgICAgICAgICAgICogICAgICBcImZuSW5pdFwiOiBmdW5jdGlvbiggb1NldHRpbmdzICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcclxuICAgICAgICAgICAgICogICAgICB9LFxyXG4gICAgICAgICAgICAgKiAgICAgIFwiY0ZlYXR1cmVcIjogXCJUXCJcclxuICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZmVhdHVyZTogW10sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJvdyBzZWFyY2hpbmcuXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXHJcbiAgICAgICAgICAgICAqIHNlYXJjaGluZywgYW5kIGEgbG90IG1vcmUgY29tcHJlaGVuc2l2ZSBhcyBpdCBhbGxvd3MgeW91IGNvbXBsZXRlIGNvbnRyb2xcclxuICAgICAgICAgICAgICogb3ZlciB0aGUgc2VhcmNoaW5nIGxvZ2ljLiBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBpcyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXHJcbiAgICAgICAgICAgICAqIGFuZCB5b3VyIGxvZ2ljIGRlY2lkZXMgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2hpbmcgZGF0YSBzZXRcclxuICAgICAgICAgICAgICogb3Igbm90LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBTZWFyY2hpbmcgZnVuY3Rpb25zIGhhdmUgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcclxuICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG4gICAgICAgICAgICAgKiAyLiBge2FycmF5fG9iamVjdH1gIERhdGEgZm9yIHRoZSByb3cgdG8gYmUgcHJvY2Vzc2VkIChzYW1lIGFzIHRoZVxyXG4gICAgICAgICAgICAgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcclxuICAgICAgICAgICAgICogICAgZnJvbSBhIERPTSBkYXRhIHNvdXJjZVxyXG4gICAgICAgICAgICAgKiAzLiBge2ludH1gIFJvdyBpbmRleCAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLmFvRGF0YX0pLCB3aGljaFxyXG4gICAgICAgICAgICAgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICoge2Jvb2xlYW59IEluY2x1ZGUgdGhlIHJvdyBpbiB0aGUgc2VhcmNoZWQgcmVzdWx0IHNldCAodHJ1ZSkgb3Igbm90XHJcbiAgICAgICAgICAgICAqICAgKGZhbHNlKVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgYXMgd2l0aCB0aGUgbWFpbiBzZWFyY2ggYWJpbGl0eSBpbiBEYXRhVGFibGVzLCB0ZWNobmljYWxseSB0aGlzXHJcbiAgICAgICAgICAgICAqIGlzIFwiZmlsdGVyaW5nXCIsIHNpbmNlIGl0IGlzIHN1YnRyYWN0aXZlLiBIb3dldmVyLCBmb3IgY29uc2lzdGVuY3kgaW5cclxuICAgICAgICAgICAgICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXHJcbiAgICAgICAgICAgICAqICAgIC8vIGZvdXJ0aCBjb2x1bW4gKGkuZS4gdGhlIGRhdGFbM10gaW5kZXgpIGJhc2VkIG9uIHR3byBpbnB1dCB2YWx1ZXNcclxuICAgICAgICAgICAgICogICAgLy8gZnJvbSB0aGUgZW5kLXVzZXIsIG1hdGNoaW5nIHRoZSBkYXRhIGluIGEgY2VydGFpbiByYW5nZS5cclxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxyXG4gICAgICAgICAgICAgKiAgICAgIGZ1bmN0aW9uKCBzZXR0aW5ncywgZGF0YSwgZGF0YUluZGV4ICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgdmFyIG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW4nKS52YWx1ZSAqIDE7XHJcbiAgICAgICAgICAgICAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcclxuICAgICAgICAgICAgICogICAgICAgIHZhciB2ZXJzaW9uID0gZGF0YVszXSA9PSBcIi1cIiA/IDAgOiBkYXRhWzNdKjE7XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgKiAgICAgIH1cclxuICAgICAgICAgICAgICogICAgKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNlYXJjaDogW10sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVGhlIGBzZWxlY3RvcmAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGV4dGVuZCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcclxuICAgICAgICAgICAgICogZWFjaCBvZiB0aGUgdGhyZWUgYnVpbHQgaW4gc2VsZWN0b3IgdHlwZXMgb2ZmZXIgKHJvdywgY29sdW1uIGFuZCBjZWxsICtcclxuICAgICAgICAgICAgICogdGhlaXIgcGx1cmFsIGNvdW50ZXJwYXJ0cykuIEZvciBleGFtcGxlIHRoZSBTZWxlY3QgZXh0ZW5zaW9uIHVzZXMgdGhpc1xyXG4gICAgICAgICAgICAgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcclxuICAgICAgICAgICAgICogdGhhdCBoYXZlIGJlZW4gbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHRoZSBlbmQgdXNlciAoYHtzZWxlY3RlZDogdHJ1ZX1gKSxcclxuICAgICAgICAgICAgICogd2hpY2ggY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZXhpc3RpbmcgYnVpbHQgaW4gc2VsZWN0b3JcclxuICAgICAgICAgICAgICogb3B0aW9ucy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogRWFjaCBwcm9wZXJ0eSBpcyBhbiBhcnJheSB0byB3aGljaCBmdW5jdGlvbnMgY2FuIGJlIHB1c2hlZC4gVGhlIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICogU2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgaG9zdCB0YWJsZVxyXG4gICAgICAgICAgICAgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxyXG4gICAgICAgICAgICAgKiAqIEFycmF5IG9mIHNlbGVjdGVkIGl0ZW0gaW5kZXhlc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cclxuICAgICAgICAgICAgICogc2VsZWN0b3IgaGFzIGJlZW4gYXBwbGllZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2VsZWN0b3I6IHtcclxuICAgICAgICAgICAgICAgIGNlbGw6IFtdLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uOiBbXSxcclxuICAgICAgICAgICAgICAgIHJvdzogW11cclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW50ZXJuYWwgZnVuY3Rpb25zLCBleHBvc2VkIGZvciB1c2VkIGluIHBsdWctaW5zLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGUgaW50ZXJuYWwgbWV0aG9kcyBmb3JcclxuICAgICAgICAgICAgICogYW55dGhpbmcgb3RoZXIgdGhhbiBhIHBsdWctaW4gKGFuZCBldmVuIHRoZW4sIHRyeSB0byBhdm9pZCBpZiBwb3NzaWJsZSkuXHJcbiAgICAgICAgICAgICAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbnRlcm5hbDoge30sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XHJcbiAgICAgICAgICAgICAqIGFyZSBhdmFpbGFibGUgaW4gRGF0YVRhYmxlcy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGVnYWN5OiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgKiByZXF1ZXN0c1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBhamF4OiBudWxsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogRWFjaCBlbnRyeSBpbiB0aGlzIG9iamVjdCBpcyBhIGZ1bmN0aW9uIGFuZCBkZWZpbmVzIHdoaWNoIGJ1dHRvbnMgc2hvdWxkXHJcbiAgICAgICAgICAgICAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XHJcbiAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b259LiBUaGUgcmVuZGVyZXIgYWRkcmVzc2VzIGhvdyB0aGVcclxuICAgICAgICAgICAgICogYnV0dG9ucyBhcmUgZGlzcGxheWVkIGluIHRoZSBkb2N1bWVudCwgd2hpbGUgdGhlIGZ1bmN0aW9ucyBoZXJlIHRlbGwgaXRcclxuICAgICAgICAgICAgICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXHJcbiAgICAgICAgICAgICAqIGRlc2NyaXB0aW9ucyAod2hhdCBlYWNoIGJ1dHRvbiB3aWxsIGRvKS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxyXG4gICAgICAgICAgICAgKiBvcHRpb25zIGRlZmluZWQgaGVyZSkgY2FuIGJlIHVzZWQgdGhyb3VnaCB0aGUgYHBhZ2luYXRpb25UeXBlYFxyXG4gICAgICAgICAgICAgKiBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxyXG4gICAgICAgICAgICAgKiAyLiBge2ludH0gcGFnZXNgIFRoZSBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcclxuICAgICAgICAgICAgICogYXJyYXkgY2FuIGJlIG9uZSBvZjpcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXHJcbiAgICAgICAgICAgICAqICogYGxhc3RgIC0gSnVtcCB0byBsYXN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuICAgICAgICAgICAgICogKiBgcHJldmlvdXNgIC0gU2hvdyBwcmV2aW91cyBwYWdlIHdoZW4gYWN0aXZhdGVkXHJcbiAgICAgICAgICAgICAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuICAgICAgICAgICAgICogKiBge2ludH1gIC0gU2hvdyBwYWdlIG9mIHRoZSBpbmRleCBnaXZlblxyXG4gICAgICAgICAgICAgKiAqIGB7YXJyYXl9YCAtIEEgbmVzdGVkIGFycmF5IGNvbnRhaW5pbmcgdGhlIGFib3ZlIGVsZW1lbnRzIHRvIGFkZCBhXHJcbiAgICAgICAgICAgICAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgRGF0YVRhYmxlcyB2MS45LSB1c2VkIHRoaXMgb2JqZWN0IHNsaWdodGx5IGRpZmZlcmVudGx5IHdoZXJlYnlcclxuICAgICAgICAgICAgICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcclxuICAgICAgICAgICAgICogYWJpbGl0eSBpcyBzdGlsbCBzdXBwb3J0ZWQgYnkgRGF0YVRhYmxlcyAxLjEwKyB0byBwcm92aWRlIGJhY2t3YXJkc1xyXG4gICAgICAgICAgICAgKiBjb21wYXRpYmlsaXR5LCBidXQgdGhpcyBvcHRpb24gb2YgdXNlIGlzIG5vdyBkZWNyZW1lbnRlZCBhbmQgbm8gbG9uZ2VyXHJcbiAgICAgICAgICAgICAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcclxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGVFeHQub1BhZ2luYXRpb24uY3VycmVudCA9IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgcmV0dXJuIFsgJ3ByZXZpb3VzJywgcGFnZSwgJ25leHQnIF07XHJcbiAgICAgICAgICAgICAqICAgIH07XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwYWdlcjoge30sXHJcblxyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXI6IHtcclxuICAgICAgICAgICAgICAgIHBhZ2VCdXR0b246IHt9LFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyOiB7fVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogVGhlIGV4dGVuc2lvbiBvcHRpb25zIGZvciBvcmRlcmluZyBvZiBkYXRhIGF2YWlsYWJsZSBoZXJlIGlzIGNvbXBsaW1lbnRhcnlcclxuICAgICAgICAgICAgICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XHJcbiAgICAgICAgICAgICAqIGFsbG93cyBtdWNoIGdyZWF0ZXIgY29udHJvbCBvdmVyIHRoZSB0aGUgZGF0YSB0aGF0IGlzIGJlaW5nIHVzZWQgdG9cclxuICAgICAgICAgICAgICogb3JkZXIgYSBjb2x1bW4sIGJ1dCBpcyBuZWNlc3NhcmlseSB0aGVyZWZvcmUgbW9yZSBjb21wbGV4LlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogVGhpcyB0eXBlIG9mIG9yZGVyaW5nIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBkbyBvcmRlcmluZyBiYXNlZCBvbiBkYXRhXHJcbiAgICAgICAgICAgICAqIGxpdmUgZnJvbSB0aGUgRE9NIChmb3IgZXhhbXBsZSB0aGUgY29udGVudHMgb2YgYW4gJ2lucHV0JyBlbGVtZW50KSByYXRoZXJcclxuICAgICAgICAgICAgICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFRoZSB3YXkgdGhlc2UgcGx1Zy1pbnMgd29yayBpcyB0aGF0IHlvdSBjcmVhdGUgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyB5b3VcclxuICAgICAgICAgICAgICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxyXG4gICAgICAgICAgICAgKiBhcnJheS4gVGhlIGRhdGEgaW4gdGhlIGFycmF5IG11Y2ggYmUgaW4gdGhlIGluZGV4IG9yZGVyIG9mIHRoZSByb3dzIGluXHJcbiAgICAgICAgICAgICAqIHRoZSB0YWJsZSAobm90IHRoZSBjdXJyZW50bHkgb3JkZXJpbmcgb3JkZXIhKS4gV2hpY2ggb3JkZXIgZGF0YSBnYXRoZXJpbmdcclxuICAgICAgICAgICAgICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxyXG4gICAgICAgICAgICAgKiBwYXJhbWV0ZXIgdGhhdCBpcyB1c2VkIGZvciB0aGUgY29sdW1uIChpZiBhbnkpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXHJcbiAgICAgICAgICAgICAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgICAgICogMi4gYHtpbnR9YCBUYXJnZXQgY29sdW1uIGluZGV4XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAqIGB7YXJyYXl9YCBEYXRhIGZvciB0aGUgY29sdW1uIHRvIGJlIG9yZGVyaW5nIHVwb25cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiAgICAvLyBPcmRlcmluZyB1c2luZyBgaW5wdXRgIG5vZGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5vcmRlclsnZG9tLXRleHQnXSA9IGZ1bmN0aW9uICAoIHNldHRpbmdzLCBjb2wgKVxyXG4gICAgICAgICAgICAgKiAgICB7XHJcbiAgICAgICAgICAgICAqICAgICAgcmV0dXJuIHRoaXMuYXBpKCkuY29sdW1uKCBjb2wsIHtvcmRlcjonaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkLCBpICkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuICQoJ2lucHV0JywgdGQpLnZhbCgpO1xyXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuICAgICAgICAgICAgICogICAgfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb3JkZXI6IHt9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcclxuICAgICAgICAgICAgICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxyXG4gICAgICAgICAgICAgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcclxuICAgICAgICAgICAgICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdHlwZToge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUeXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IGFyZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0XHJcbiAgICAgICAgICAgICAgICAgKiBhIGNvbHVtbidzIHR5cGUsIG1ha2luZyBpbml0aWFsaXNhdGlvbiBvZiBEYXRhVGFibGVzIHN1cGVyIGVhc3ksIGV2ZW5cclxuICAgICAgICAgICAgICAgICAqIHdoZW4gY29tcGxleCBkYXRhIGlzIGluIHRoZSB0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxyXG4gICAgICAgICAgICAgICAgICogIDIuIGB7c2V0dGluZ3N9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xyXG4gICAgICAgICAgICAgICAgICogICAgIHBlcmZvcm0gY29udGV4dCBzcGVjaWZpYyB0eXBlIGRldGVjdGlvbiAtIGZvciBleGFtcGxlIGRldGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgcGxhY2UuIEdlbmVyYWxseSBzcGVha2luZyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBzZXR0aW5ncyB3aWxsIG5vdFxyXG4gICAgICAgICAgICAgICAgICogICAgIGJlIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogKiBge3N0cmluZ3xudWxsfWAgRGF0YSB0eXBlIGRldGVjdGVkLCBvciBudWxsIGlmIHVua25vd24gKGFuZCB0aHVzXHJcbiAgICAgICAgICAgICAgICAgKiAgIHBhc3MgaXQgb24gdG8gdGhlIG90aGVyIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgIC8vIEN1cnJlbmN5IHR5cGUgZGV0ZWN0aW9uIHBsdWctaW46XHJcbiAgICAgICAgICAgICAgICAgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QucHVzaChcclxuICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gKCBkYXRhLCBzZXR0aW5ncyApIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAvLyBDaGVjayB0aGUgbnVtZXJpYyBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCAhICQuaXNOdW1lcmljKCBkYXRhLnN1YnN0cmluZygxKSApICkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAvLyBDaGVjayBwcmVmaXhlZCBieSBjdXJyZW5jeVxyXG4gICAgICAgICAgICAgICAgICogICAgICAgIGlmICggZGF0YS5jaGFyQXQoMCkgPT0gJyQnIHx8IGRhdGEuY2hhckF0KDApID09ICcmcG91bmQ7JyApIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiAnY3VycmVuY3knO1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAqICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0OiBbXSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUeXBlIGJhc2VkIHNlYXJjaCBmb3JtYXR0aW5nLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIFRoZSB0eXBlIGJhc2VkIHNlYXJjaGluZyBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgdG8gcHJlLWZvcm1hdCB0aGVcclxuICAgICAgICAgICAgICAgICAqIGRhdGEgdG8gYmUgc2VhcmNoIG9uLiBGb3IgZXhhbXBsZSwgaXQgY2FuIGJlIHVzZWQgdG8gc3RyaXAgSFRNTFxyXG4gICAgICAgICAgICAgICAgICogdGFncyBvciB0byBkZS1mb3JtYXQgdGVsZXBob25lIG51bWJlcnMgZm9yIG51bWVyaWMgb25seSBzZWFyY2hpbmcuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IGlzIGEgc2VhcmNoIGlzIG5vdCBkZWZpbmVkIGZvciBhIGNvbHVtbiBvZiBhIGdpdmVuIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgKiBubyBzZWFyY2ggZm9ybWF0dGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cclxuICAgICAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgICAgICogUHJlLXByb2Nlc3Npbmcgb2Ygc2VhcmNoaW5nIGRhdGEgcGx1Zy1pbnMgLSBXaGVuIHlvdSBhc3NpZ24gdGhlIHNUeXBlXHJcbiAgICAgICAgICAgICAgICAgKiBmb3IgYSBjb2x1bW4gKG9yIGhhdmUgaXQgYXV0b21hdGljYWxseSBkZXRlY3RlZCBmb3IgeW91IGJ5IERhdGFUYWJsZXNcclxuICAgICAgICAgICAgICAgICAqIG9yIGEgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbiksIHlvdSB3aWxsIHR5cGljYWxseSBiZSB1c2luZyB0aGlzIGZvclxyXG4gICAgICAgICAgICAgICAgICogY3VzdG9tIHNvcnRpbmcsIGJ1dCBpdCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGUgY3VzdG9tIHNlYXJjaGluZ1xyXG4gICAgICAgICAgICAgICAgICogYnkgYWxsb3dpbmcgeW91IHRvIHByZS1wcm9jZXNzaW5nIHRoZSBkYXRhIGFuZCByZXR1cm5pbmcgdGhlIGRhdGEgaW5cclxuICAgICAgICAgICAgICAgICAqIHRoZSBmb3JtYXQgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgdXBvbi4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICogZnVuY3Rpb25zIHRoaXMgb2JqZWN0IHdpdGggYSBwYXJhbWV0ZXIgbmFtZSB3aGljaCBtYXRjaGVzIHRoZSBzVHlwZVxyXG4gICAgICAgICAgICAgICAgICogZm9yIHRoYXQgdGFyZ2V0IGNvbHVtbi4gVGhpcyBpcyB0aGUgY29yb2xsYXJ5IG9mIDxpPmFmblNvcnREYXRhPC9pPlxyXG4gICAgICAgICAgICAgICAgICogZm9yIHNlYXJjaGluZyBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlcjpcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xyXG4gICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcclxuICAgICAgICAgICAgICAgICAqICAgIH1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiB7fSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAgICAgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xyXG4gICAgICAgICAgICAgICAgICogdGhpcyBvYmplY3Q6XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcclxuICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXHJcbiAgICAgICAgICAgICAgICAgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcclxuICAgICAgICAgICAgICAgICAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIG9yZGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQW5kIHJldHVybjpcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2A6IEZ1bmN0aW9ucyBhcmUgdHlwaWNhbCBKYXZhc2NyaXB0IHNvcnRcclxuICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAxLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIHNlY29uZCBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEFuZCByZXR1cm5pbmc6XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcclxuICAgICAgICAgICAgICAgICAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxyXG4gICAgICAgICAgICAgICAgICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxyXG4gICAgICAgICAgICAgICAgICogICBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxyXG4gICAgICAgICAgICAgICAgICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xyXG4gICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH1cclxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2RcclxuICAgICAgICAgICAgICAgICAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcclxuICAgICAgICAgICAgICAgICAqICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICogICAgfSApO1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBvcmRlcjoge31cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3VuaXF1ZTogMCxcclxuXHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBEZXByZWNpYXRlZFxyXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJsaXR5IG9ubHkuXHJcbiAgICAgICAgICAgIC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcclxuICAgICAgICAgICAgLy8gdmVyc2lvblxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZuVmVyc2lvbkNoZWNrOiBEYXRhVGFibGUuZm5WZXJzaW9uQ2hlY2ssXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGV4IGZvciB3aGF0ICd0aGlzJyBpbmRleCBBUEkgZnVuY3Rpb25zIHNob3VsZCB1c2VcclxuICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlBcGlJbmRleDogMCxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogalF1ZXJ5IFVJIGNsYXNzIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb0pVSUNsYXNzZXM6IHt9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTb2Z0d2FyZSB2ZXJzaW9uXHJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzVmVyc2lvbjogRGF0YVRhYmxlLnZlcnNpb25cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gQWxpYXMgdG8gcHJlIDEuMTAgSHVuZ2FyaWFuIG5vdGF0aW9uIGNvdW50ZXIgcGFydHNcclxuICAgICAgICAvL1xyXG4gICAgICAgICQuZXh0ZW5kKF9leHQsIHtcclxuICAgICAgICAgICAgYWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcclxuICAgICAgICAgICAgYVR5cGVzOiBfZXh0LnR5cGUuZGV0ZWN0LFxyXG4gICAgICAgICAgICBvZm5TZWFyY2g6IF9leHQudHlwZS5zZWFyY2gsXHJcbiAgICAgICAgICAgIG9Tb3J0OiBfZXh0LnR5cGUub3JkZXIsXHJcbiAgICAgICAgICAgIGFmblNvcnREYXRhOiBfZXh0Lm9yZGVyLFxyXG4gICAgICAgICAgICBhb0ZlYXR1cmVzOiBfZXh0LmZlYXR1cmUsXHJcbiAgICAgICAgICAgIG9BcGk6IF9leHQuaW50ZXJuYWwsXHJcbiAgICAgICAgICAgIG9TdGRDbGFzc2VzOiBfZXh0LmNsYXNzZXMsXHJcbiAgICAgICAgICAgIG9QYWdpbmF0aW9uOiBfZXh0LnBhZ2VyXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcclxuICAgICAgICAgICAgXCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcclxuICAgICAgICAgICAgXCJzTm9Gb290ZXJcIjogXCJuby1mb290ZXJcIixcclxuXHJcbiAgICAgICAgICAgIC8qIFBhZ2luZyBidXR0b25zICovXHJcbiAgICAgICAgICAgIFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b25cIixcclxuICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiBcImN1cnJlbnRcIixcclxuICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkRpc2FibGVkXCI6IFwiZGlzYWJsZWRcIixcclxuXHJcbiAgICAgICAgICAgIC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cclxuICAgICAgICAgICAgXCJzU3RyaXBlT2RkXCI6IFwib2RkXCIsXHJcbiAgICAgICAgICAgIFwic1N0cmlwZUV2ZW5cIjogXCJldmVuXCIsXHJcblxyXG4gICAgICAgICAgICAvKiBFbXB0eSByb3cgKi9cclxuICAgICAgICAgICAgXCJzUm93RW1wdHlcIjogXCJkYXRhVGFibGVzX2VtcHR5XCIsXHJcblxyXG4gICAgICAgICAgICAvKiBGZWF0dXJlcyAqL1xyXG4gICAgICAgICAgICBcInNXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc193cmFwcGVyXCIsXHJcbiAgICAgICAgICAgIFwic0ZpbHRlclwiOiBcImRhdGFUYWJsZXNfZmlsdGVyXCIsXHJcbiAgICAgICAgICAgIFwic0luZm9cIjogXCJkYXRhVGFibGVzX2luZm9cIixcclxuICAgICAgICAgICAgXCJzUGFnaW5nXCI6IFwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cclxuICAgICAgICAgICAgXCJzTGVuZ3RoXCI6IFwiZGF0YVRhYmxlc19sZW5ndGhcIixcclxuICAgICAgICAgICAgXCJzUHJvY2Vzc2luZ1wiOiBcImRhdGFUYWJsZXNfcHJvY2Vzc2luZ1wiLFxyXG5cclxuICAgICAgICAgICAgLyogU29ydGluZyAqL1xyXG4gICAgICAgICAgICBcInNTb3J0QXNjXCI6IFwic29ydGluZ19hc2NcIixcclxuICAgICAgICAgICAgXCJzU29ydERlc2NcIjogXCJzb3J0aW5nX2Rlc2NcIixcclxuICAgICAgICAgICAgXCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xyXG4gICAgICAgICAgICBcInNTb3J0YWJsZUFzY1wiOiBcInNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXHJcbiAgICAgICAgICAgIFwic1NvcnRhYmxlRGVzY1wiOiBcInNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLFxyXG4gICAgICAgICAgICBcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXHJcbiAgICAgICAgICAgIFwic1NvcnRDb2x1bW5cIjogXCJzb3J0aW5nX1wiLCAvKiBOb3RlIHRoYXQgYW4gaW50IGlzIHBvc3RmaXhlZCBmb3IgdGhlIHNvcnRpbmcgb3JkZXIgKi9cclxuXHJcbiAgICAgICAgICAgIC8qIEZpbHRlcmluZyAqL1xyXG4gICAgICAgICAgICBcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxyXG5cclxuICAgICAgICAgICAgLyogUGFnZSBsZW5ndGggKi9cclxuICAgICAgICAgICAgXCJzTGVuZ3RoU2VsZWN0XCI6IFwiXCIsXHJcblxyXG4gICAgICAgICAgICAvKiBTY3JvbGxpbmcgKi9cclxuICAgICAgICAgICAgXCJzU2Nyb2xsV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsXCIsXHJcbiAgICAgICAgICAgIFwic1Njcm9sbEhlYWRcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWRcIixcclxuICAgICAgICAgICAgXCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcclxuICAgICAgICAgICAgXCJzU2Nyb2xsQm9keVwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsQm9keVwiLFxyXG4gICAgICAgICAgICBcInNTY3JvbGxGb290XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290XCIsXHJcbiAgICAgICAgICAgIFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXHJcblxyXG4gICAgICAgICAgICAvKiBNaXNjICovXHJcbiAgICAgICAgICAgIFwic0hlYWRlclRIXCI6IFwiXCIsXHJcbiAgICAgICAgICAgIFwic0Zvb3RlclRIXCI6IFwiXCIsXHJcblxyXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkXHJcbiAgICAgICAgICAgIFwic1NvcnRKVUlBc2NcIjogXCJcIixcclxuICAgICAgICAgICAgXCJzU29ydEpVSURlc2NcIjogXCJcIixcclxuICAgICAgICAgICAgXCJzU29ydEpVSVwiOiBcIlwiLFxyXG4gICAgICAgICAgICBcInNTb3J0SlVJQXNjQWxsb3dlZFwiOiBcIlwiLFxyXG4gICAgICAgICAgICBcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogXCJcIixcclxuICAgICAgICAgICAgXCJzU29ydEpVSVdyYXBwZXJcIjogXCJcIixcclxuICAgICAgICAgICAgXCJzU29ydEljb25cIjogXCJcIixcclxuICAgICAgICAgICAgXCJzSlVJSGVhZGVyXCI6IFwiXCIsXHJcbiAgICAgICAgICAgIFwic0pVSUZvb3RlclwiOiBcIlwiXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB2YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG4gICAgICAgICAgICAgICAgbnVtYmVycyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBoYWxmID0gTWF0aC5mbG9vcihidXR0b25zIC8gMiksXHJcbiAgICAgICAgICAgICAgICBpID0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYWdlcyA8PSBidXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJzID0gX3JhbmdlKDAsIHBhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYWdlIDw9IGhhbGYpIHtcclxuICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UoMCwgYnV0dG9ucyAtIDIpO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKHBhZ2VzIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJzID0gX3JhbmdlKHBhZ2VzIC0gKGJ1dHRvbnMgLSAyKSwgcGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVycy5zcGxpY2UoMCwgMCwgJ2VsbGlwc2lzJyk7IC8vIG5vIHVuc2hpZnQgaW4gaWU2XHJcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UocGFnZSAtIGhhbGYgKyAyLCBwYWdlICsgaGFsZiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKHBhZ2VzIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAnZWxsaXBzaXMnKTtcclxuICAgICAgICAgICAgICAgIG51bWJlcnMuc3BsaWNlKDAsIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBudW1iZXJzLkRUX2VsID0gJ3NwYW4nO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVycztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAkLmV4dGVuZChleHRQYWdpbmF0aW9uLCB7XHJcbiAgICAgICAgICAgIHNpbXBsZTogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydwcmV2aW91cycsICduZXh0J107XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmdWxsOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCddO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW19udW1iZXJzKHBhZ2UsIHBhZ2VzKV07XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnXTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGZ1bGxfbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmaXJzdCcsICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnLCAnbGFzdCddO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZpcnN0JywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbGFzdCddO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxyXG4gICAgICAgICAgICBfbnVtYmVyczogX251bWJlcnMsXHJcblxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgbnVtYmVyIGJ1dHRvbnMgKGluY2x1ZGluZyBlbGxpcHNpcykgdG8gc2hvdy4gX011c3QgYmUgb2RkIV9cclxuICAgICAgICAgICAgbnVtYmVyc19sZW5ndGg6IDdcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcclxuICAgICAgICAgICAgcGFnZUJ1dHRvbjoge1xyXG4gICAgICAgICAgICAgICAgXzogZnVuY3Rpb24gKHNldHRpbmdzLCBob3N0LCBpZHgsIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZyA9IHNldHRpbmdzLm9MYW5ndWFnZS5vUGFnaW5hdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbiwgbm9kZSwgYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGUuZGF0YS5hY3Rpb24sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGJ1dHRvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSAkKCc8JyArIChidXR0b24uRFRfZWwgfHwgJ2RpdicpICsgJy8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoKGlubmVyLCBidXR0b24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzaXMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJlbGxpcHNpc1wiPiYjeDIwMjY7PC9zcGFuPicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaXJzdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5EaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNOZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzIC0gMSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsYXN0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzIC0gMSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IGJ1dHRvbiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IHBhZ2UgPT09IGJ1dHRvbiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zUGFnZUJ1dHRvbkFjdGl2ZSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnRuRGlzcGxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gJCgnPGE+Jywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zUGFnZUJ1dHRvbiArICcgJyArIGJ0bkNsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogYXJpYVtidXR0b25dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZHQtaWR4JzogY291bnRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6IHNldHRpbmdzLmlUYWJJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IGlkeCA9PT0gMCAmJiB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc1RhYmxlSWQgKyAnXycgKyBidXR0b24gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGJ0bkRpc3BsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkJpbmRBY3Rpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLCB7IGFjdGlvbjogYnV0dG9uIH0sIGNsaWNrSGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuIFRyeSAvIGNhdGNoIHRoZSBlcnJvci4gTm90IGdvb2QgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaWJpbGl0eSwgYnV0IG5laXRoZXIgYXJlIGZyYW1lcy5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlRWw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMsIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHNlbGVjdCBidXR0b24gd2hpY2ggaXMgYmFkIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3NpYmlsaXR5LiBTbyB3ZSB3YW50IHRvIHJlc3RvcmUgZm9jdXMgb25jZSB0aGUgZHJhdyBoYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsID0gJChob3N0KS5maW5kKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmRhdGEoJ2R0LWlkeCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaCgkKGhvc3QpLmVtcHR5KCksIGJ1dHRvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGhvc3QpLmZpbmQoJ1tkYXRhLWR0LWlkeD0nICsgYWN0aXZlRWwgKyAnXScpLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gQnVpbHQgaW4gdHlwZSBkZXRlY3Rpb24uIFNlZSBtb2RlbC5leHQuYVR5cGVzIGZvciBpbmZvcm1hdGlvbiBhYm91dFxyXG4gICAgICAgIC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGlzIG1ldGhvZHMuXHJcbiAgICAgICAgJC5leHRlbmQoRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdCwgW1xyXG4gICAgICAgICAgICAvLyBQbGFpbiBudW1iZXJzIC0gZmlyc3Qgc2luY2UgVjggZGV0ZWN0cyBzb21lIHBsYWluIG51bWJlcnMgYXMgZGF0ZXNcclxuICAgICAgICAgICAgLy8gZS5nLiBEYXRlLnBhcnNlKCc1NScpIChidXQgbm90IGFsbCwgZS5nLiBEYXRlLnBhcnNlKCcyMicpLi4uKS5cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfaXNOdW1iZXIoZCwgZGVjaW1hbCkgPyAnbnVtJyArIGRlY2ltYWwgOiBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRGF0ZXMgKG9ubHkgdGhvc2UgcmVjb2duaXNlZCBieSB0aGUgYnJvd3NlcidzIERhdGUucGFyc2UpXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgLy8gVjggdHJpZXMgX3ZlcnlfIGhhcmQgdG8gbWFrZSBhIHN0cmluZyBwYXNzZWQgaW50byBgRGF0ZS5wYXJzZSgpYFxyXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmVnZXggdG8gcmVzdHJpY3QgZGF0ZSBmb3JtYXRzLiBVc2UgYVxyXG4gICAgICAgICAgICAgICAgLy8gcGx1Zy1pbiBmb3IgYW55dGhpbmcgb3RoZXIgdGhhbiBJU084NjAxIHN0eWxlIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIGlmIChkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICFfcmVfZGF0ZS50ZXN0KGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRm9ybWF0dGVkIG51bWJlcnNcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfaXNOdW1iZXIoZCwgZGVjaW1hbCwgdHJ1ZSkgPyAnbnVtLWZtdCcgKyBkZWNpbWFsIDogbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpY1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9odG1sTnVtZXJpYyhkLCBkZWNpbWFsKSA/ICdodG1sLW51bScgKyBkZWNpbWFsIDogbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2h0bWxOdW1lcmljKGQsIGRlY2ltYWwsIHRydWUpID8gJ2h0bWwtbnVtLWZtdCcgKyBkZWNpbWFsIDogbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEhUTUwgKHRoaXMgaXMgc3RyaWN0IGNoZWNraW5nIC0gdGhlcmUgbXVzdCBiZSBodG1sKVxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZCkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cclxuICAgICAgICAgICAgICAgICAgICAnaHRtbCcgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcclxuICAgICAgICAvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhlc2UgbWV0aG9kcy5cclxuICAgICAgICAvLyBcclxuICAgICAgICAvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXHJcbiAgICAgICAgLy8gaHRtbCBmb3JtYXR0ZWQgbnVtYmVycyBieSBgX2FkZE51bWVyaWNTb3J0KClgIHdoZW4gd2Uga25vdyB3aGF0IHRoZSBkZWNpbWFsXHJcbiAgICAgICAgLy8gcGxhY2UgaXNcclxuXHJcblxyXG4gICAgICAgICQuZXh0ZW5kKERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2gsIHtcclxuICAgICAgICAgICAgaHRtbDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZGF0YSkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgOlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9yZV9uZXdfbGluZXMsIFwiIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoX3JlX2h0bWwsIFwiXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VtcHR5KGRhdGEpID9cclxuICAgICAgICAgICAgICAgICAgICBkYXRhIDpcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlcGxhY2UoX3JlX25ld19saW5lcywgXCIgXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBfX251bWVyaWNSZXBsYWNlID0gZnVuY3Rpb24gKGQsIGRlY2ltYWxQbGFjZSwgcmUxLCByZTIpIHtcclxuICAgICAgICAgICAgaWYgKGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgZGVjaW1hbCBwbGFjZSBvdGhlciB0aGFuIGAuYCBpcyB1c2VkLCBpdCBuZWVkcyB0byBiZSBnaXZlbiB0byB0aGVcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gc28gd2UgY2FuIGRldGVjdCBpdCBhbmQgcmVwbGFjZSB3aXRoIGEgYC5gIHdoaWNoIGlzIHRoZSBvbmx5XHJcbiAgICAgICAgICAgIC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgZCA9IF9udW1Ub0RlY2ltYWwoZCwgZGVjaW1hbFBsYWNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGQucmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UocmUxLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UocmUyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkICogMTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1lcmljICdkZWZvcm1hdHRpbmcnIGZ1bmN0aW9ucyBmb3Igc29ydGluZyBhbmQgc2VhcmNoLiBUaGlzIGlzIGRvbmVcclxuICAgICAgICAvLyBpbiBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYW4gZWFzeSBhYmlsaXR5IGZvciB0aGUgbGFuZ3VhZ2Ugb3B0aW9ucyB0byBhZGRcclxuICAgICAgICAvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cclxuICAgICAgICBmdW5jdGlvbiBfYWRkTnVtZXJpY1NvcnQoZGVjaW1hbFBsYWNlKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFpbiBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgXCJudW1cIjogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoZCwgZGVjaW1hbFBsYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIFwibnVtLWZtdFwiOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSFRNTCBudW1lcmljXHJcbiAgICAgICAgICAgICAgICAgICAgXCJodG1sLW51bVwiOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaHRtbC1udW0tZm10XCI6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX251bWVyaWNSZXBsYWNlKGQsIGRlY2ltYWxQbGFjZSwgX3JlX2h0bWwsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXksIGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICBfZXh0LnR5cGUub3JkZXJba2V5ICsgZGVjaW1hbFBsYWNlICsgJy1wcmUnXSA9IGZuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgSFRNTCB0eXBlcyBhZGQgYSBzZWFyY2ggZm9ybWF0dGVyIHRoYXQgd2lsbCBzdHJpcCB0aGUgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkubWF0Y2goL15odG1sXFwtLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dC50eXBlLnNlYXJjaFtrZXkgKyBkZWNpbWFsUGxhY2VdID0gX2V4dC50eXBlLnNlYXJjaC5odG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBEZWZhdWx0IHNvcnQgbWV0aG9kc1xyXG4gICAgICAgICQuZXh0ZW5kKF9leHQudHlwZS5vcmRlciwge1xyXG4gICAgICAgICAgICAvLyBEYXRlc1xyXG4gICAgICAgICAgICBcImRhdGUtcHJlXCI6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZShkKSB8fCAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBodG1sXHJcbiAgICAgICAgICAgIFwiaHRtbC1wcmVcIjogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoYSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICcnIDpcclxuICAgICAgICAgICAgICAgICAgICBhLnJlcGxhY2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnJlcGxhY2UoLzwuKj8+L2csIFwiXCIpLnRvTG93ZXJDYXNlKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhICsgJyc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBzdHJpbmdcclxuICAgICAgICAgICAgXCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGl0dGxlIGNvbXBsZXgsIGJ1dCBmYXN0ZXIgdGhhbiBhbHdheXMgY2FsbGluZyB0b1N0cmluZyxcclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rvc3RyaW5nLXYtY2hlY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoYSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICcnIDpcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnRvTG93ZXJDYXNlKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhYS50b1N0cmluZyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcclxuICAgICAgICAgICAgLy8gc29ydCBtZXRob2RzXHJcbiAgICAgICAgICAgIFwic3RyaW5nLWFzY1wiOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBcInN0cmluZy1kZXNjXCI6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gTnVtZXJpYyBzb3J0aW5nIHR5cGVzIC0gb3JkZXIgZG9lc24ndCBtYXR0ZXIgaGVyZVxyXG4gICAgICAgIF9hZGROdW1lcmljU29ydCgnJyk7XHJcblxyXG5cclxuICAgICAgICAkLmV4dGVuZCh0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XHJcbiAgICAgICAgICAgIGhlYWRlcjoge1xyXG4gICAgICAgICAgICAgICAgXzogZnVuY3Rpb24gKHNldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIHVwZGF0ZSBvbiBzb3J0IC0gbm90ZSB0aGF0IHVzaW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGBEVGAgbmFtZXNwYWNlIHdpbGwgYWxsb3cgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLm9uKCdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uIChlLCBjdHgsIHNvcnRpbmcsIGNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gY29sdW1uLmlkeDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzcyArICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEFzYyArICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydERlc2NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zW2NvbElkeF0gPT0gJ2Rlc2MnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydERlc2MgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAganF1ZXJ5dWk6IGZ1bmN0aW9uIChzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnPGRpdi8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNsYXNzZXMuc1NvcnRKVUlXcmFwcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNlbGwuY29udGVudHMoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbi8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjbGFzc2VzLnNTb3J0SWNvbiArICcgJyArIGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhjZWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxyXG4gICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyAhPT0gY3R4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1NvcnRBc2MgKyBcIiBcIiArIGNsYXNzZXMuc1NvcnREZXNjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNvbHVtbnNbY29sSWR4XSA9PSAnYXNjJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEFzYyA6IGNvbHVtbnNbY29sSWR4XSA9PSAnZGVzYycgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0RGVzYyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zU29ydGluZ0NsYXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3NwYW4uJyArIGNsYXNzZXMuc1NvcnRJY29uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlBc2MgKyBcIiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSURlc2MgKyBcIiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSSArIFwiIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZCArIFwiIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJRGVzY0FsbG93ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlBc2MgOiBjb2x1bW5zW2NvbElkeF0gPT0gJ2Rlc2MnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSURlc2MgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFB1YmxpYyBoZWxwZXIgZnVuY3Rpb25zLiBUaGVzZSBhcmVuJ3QgdXNlZCBpbnRlcm5hbGx5IGJ5IERhdGFUYWJsZXMsIG9yXHJcbiAgICAgICAgICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxyXG4gICAgICAgICAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgICAqIHRvIG1ha2Ugd29ya2luZyB3aXRoIERhdGFUYWJsZXMgYSBsaXR0bGUgYml0IGVhc2llci5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgdmFyIF9faHRtbEVzY2FwZUVudGl0aWVzID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgICAgICBkLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpIDpcclxuICAgICAgICAgICAgICAgIGQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGVscGVycyBmb3IgYGNvbHVtbnMucmVuZGVyYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXHJcbiAgICAgICAgICogb3B0aW9uIHRvIHByb3ZpZGUgYSBkaXNwbGF5IHJlbmRlcmVyLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZDpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxyXG4gICAgICAgICAqICAgZGlzcGxheSwgcmV0YWluaW5nIHRoZSBvcmlnaW5hbCB1bmZvcm1hdHRlZCBkYXRhIGZvciBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICogICBJdCB0YWtlcyA1IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxyXG4gICAgICAgICAqICAgKiBgc3RyaW5nYCAtIERlY2ltYWwgcG9pbnQgaW5kaWNhdG9yXHJcbiAgICAgICAgICogICAqIGBpbnRlZ2VyYCAtIE51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBzaG93XHJcbiAgICAgICAgICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXHJcbiAgICAgICAgICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQb3N0Zml4ICgvc3VmZml4KS5cclxuICAgICAgICAgKiAqIGB0ZXh0YCAtIEVzY2FwZSBIVE1MIHRvIGhlbHAgcHJldmVudCBYU1MgYXR0YWNrcy4gSXQgaGFzIG5vIG9wdGlvbmFsXHJcbiAgICAgICAgICogICBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcclxuICAgICAgICAgKiAgIHtcclxuICAgICAgICAgKiAgICAgZGF0YTogXCJzYWxhcnlcIixcclxuICAgICAgICAgKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxyXG4gICAgICAgICAqICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERhdGFUYWJsZS5yZW5kZXIgPSB7XHJcbiAgICAgICAgICAgIG51bWJlcjogZnVuY3Rpb24gKHRob3VzYW5kcywgZGVjaW1hbCwgcHJlY2lzaW9uLCBwcmVmaXgsIHBvc3RmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxvID0gcGFyc2VGbG9hdChkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIE5hTiB0aGVuIHRoZXJlIGlzbid0IG11Y2ggZm9ybWF0dGluZyB0aGF0IHdlIGNhbiBkbyAtIGp1c3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5LCBlc2NhcGluZyBhbnkgSFRNTCAodGhpcyB3YXMgc3VwcG9zZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgYSBudW1iZXIgYWZ0ZXIgYWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZmxvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9faHRtbEVzY2FwZUVudGl0aWVzKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG8gPSBmbG8udG9GaXhlZChwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5hYnMoZmxvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoZCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgKyAoZCAtIGludFBhcnQpLnRvRml4ZWQocHJlY2lzaW9uKS5zdWJzdHJpbmcoMikgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4IHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0LnRvU3RyaW5nKCkucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0UGFydCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9zdGZpeCB8fCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogX19odG1sRXNjYXBlRW50aXRpZXNcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGlzIGlzIHJlYWxseSBhIGdvb2QgYml0IHJ1YmJpc2ggdGhpcyBtZXRob2Qgb2YgZXhwb3NpbmcgdGhlIGludGVybmFsIG1ldGhvZHNcclxuICAgICAgICAgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxyXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gZm4gQVBJIGZ1bmN0aW9uIG5hbWVcclxuICAgICAgICAgKiAgQHJldHVybnMge2Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXHJcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBfZm5FeHRlcm5BcGlGdW5jKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtfZm5TZXR0aW5nc0Zyb21Ob2RlKHRoaXNbRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhdKV0uY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbFtmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGludGVybmFsIGZ1bmN0aW9ucyBmb3IgdXNlIGJ5IHBsdWctaW4gZGV2ZWxvcGVycy4gTm90ZSB0aGF0XHJcbiAgICAgICAgICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXHJcbiAgICAgICAgICogcHJpdmF0ZS4gSWYgeW91IHVzZSB0aGVzZSBtZXRob2RzLCBiZSBhd2FyZSB0aGF0IHRoZXkgYXJlIGxpYWJsZSB0byBjaGFuZ2VcclxuICAgICAgICAgKiBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gICAgICAgICAqICBAbmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJC5leHRlbmQoRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xyXG4gICAgICAgICAgICBfZm5FeHRlcm5BcGlGdW5jOiBfZm5FeHRlcm5BcGlGdW5jLFxyXG4gICAgICAgICAgICBfZm5CdWlsZEFqYXg6IF9mbkJ1aWxkQWpheCxcclxuICAgICAgICAgICAgX2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcclxuICAgICAgICAgICAgX2ZuQWpheFBhcmFtZXRlcnM6IF9mbkFqYXhQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICBfZm5BamF4VXBkYXRlRHJhdzogX2ZuQWpheFVwZGF0ZURyYXcsXHJcbiAgICAgICAgICAgIF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcclxuICAgICAgICAgICAgX2ZuQWRkQ29sdW1uOiBfZm5BZGRDb2x1bW4sXHJcbiAgICAgICAgICAgIF9mbkNvbHVtbk9wdGlvbnM6IF9mbkNvbHVtbk9wdGlvbnMsXHJcbiAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxyXG4gICAgICAgICAgICBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDogX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsXHJcbiAgICAgICAgICAgIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxcclxuICAgICAgICAgICAgX2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcclxuICAgICAgICAgICAgX2ZuR2V0Q29sdW1uczogX2ZuR2V0Q29sdW1ucyxcclxuICAgICAgICAgICAgX2ZuQ29sdW1uVHlwZXM6IF9mbkNvbHVtblR5cGVzLFxyXG4gICAgICAgICAgICBfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcclxuICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwOiBfZm5IdW5nYXJpYW5NYXAsXHJcbiAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW46IF9mbkNhbWVsVG9IdW5nYXJpYW4sXHJcbiAgICAgICAgICAgIF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcclxuICAgICAgICAgICAgX2ZuQnJvd3NlckRldGVjdDogX2ZuQnJvd3NlckRldGVjdCxcclxuICAgICAgICAgICAgX2ZuQWRkRGF0YTogX2ZuQWRkRGF0YSxcclxuICAgICAgICAgICAgX2ZuQWRkVHI6IF9mbkFkZFRyLFxyXG4gICAgICAgICAgICBfZm5Ob2RlVG9EYXRhSW5kZXg6IF9mbk5vZGVUb0RhdGFJbmRleCxcclxuICAgICAgICAgICAgX2ZuTm9kZVRvQ29sdW1uSW5kZXg6IF9mbk5vZGVUb0NvbHVtbkluZGV4LFxyXG4gICAgICAgICAgICBfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXHJcbiAgICAgICAgICAgIF9mblNldENlbGxEYXRhOiBfZm5TZXRDZWxsRGF0YSxcclxuICAgICAgICAgICAgX2ZuU3BsaXRPYmpOb3RhdGlvbjogX2ZuU3BsaXRPYmpOb3RhdGlvbixcclxuICAgICAgICAgICAgX2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXHJcbiAgICAgICAgICAgIF9mblNldE9iamVjdERhdGFGbjogX2ZuU2V0T2JqZWN0RGF0YUZuLFxyXG4gICAgICAgICAgICBfZm5HZXREYXRhTWFzdGVyOiBfZm5HZXREYXRhTWFzdGVyLFxyXG4gICAgICAgICAgICBfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxyXG4gICAgICAgICAgICBfZm5EZWxldGVJbmRleDogX2ZuRGVsZXRlSW5kZXgsXHJcbiAgICAgICAgICAgIF9mbkludmFsaWRhdGU6IF9mbkludmFsaWRhdGUsXHJcbiAgICAgICAgICAgIF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcclxuICAgICAgICAgICAgX2ZuQ3JlYXRlVHI6IF9mbkNyZWF0ZVRyLFxyXG4gICAgICAgICAgICBfZm5CdWlsZEhlYWQ6IF9mbkJ1aWxkSGVhZCxcclxuICAgICAgICAgICAgX2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxyXG4gICAgICAgICAgICBfZm5EcmF3OiBfZm5EcmF3LFxyXG4gICAgICAgICAgICBfZm5SZURyYXc6IF9mblJlRHJhdyxcclxuICAgICAgICAgICAgX2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxyXG4gICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXI6IF9mbkRldGVjdEhlYWRlcixcclxuICAgICAgICAgICAgX2ZuR2V0VW5pcXVlVGhzOiBfZm5HZXRVbmlxdWVUaHMsXHJcbiAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcclxuICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGU6IF9mbkZpbHRlckNvbXBsZXRlLFxyXG4gICAgICAgICAgICBfZm5GaWx0ZXJDdXN0b206IF9mbkZpbHRlckN1c3RvbSxcclxuICAgICAgICAgICAgX2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXHJcbiAgICAgICAgICAgIF9mbkZpbHRlcjogX2ZuRmlsdGVyLFxyXG4gICAgICAgICAgICBfZm5GaWx0ZXJDcmVhdGVTZWFyY2g6IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxcclxuICAgICAgICAgICAgX2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxyXG4gICAgICAgICAgICBfZm5GaWx0ZXJEYXRhOiBfZm5GaWx0ZXJEYXRhLFxyXG4gICAgICAgICAgICBfZm5GZWF0dXJlSHRtbEluZm86IF9mbkZlYXR1cmVIdG1sSW5mbyxcclxuICAgICAgICAgICAgX2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcclxuICAgICAgICAgICAgX2ZuSW5mb01hY3JvczogX2ZuSW5mb01hY3JvcyxcclxuICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZTogX2ZuSW5pdGlhbGlzZSxcclxuICAgICAgICAgICAgX2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXHJcbiAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZTogX2ZuTGVuZ3RoQ2hhbmdlLFxyXG4gICAgICAgICAgICBfZm5GZWF0dXJlSHRtbExlbmd0aDogX2ZuRmVhdHVyZUh0bWxMZW5ndGgsXHJcbiAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXHJcbiAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2U6IF9mblBhZ2VDaGFuZ2UsXHJcbiAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZzogX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nLFxyXG4gICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXHJcbiAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sVGFibGU6IF9mbkZlYXR1cmVIdG1sVGFibGUsXHJcbiAgICAgICAgICAgIF9mblNjcm9sbERyYXc6IF9mblNjcm9sbERyYXcsXHJcbiAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxyXG4gICAgICAgICAgICBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHM6IF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxcclxuICAgICAgICAgICAgX2ZuVGhyb3R0bGU6IF9mblRocm90dGxlLFxyXG4gICAgICAgICAgICBfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXHJcbiAgICAgICAgICAgIF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXHJcbiAgICAgICAgICAgIF9mbkdldE1heExlblN0cmluZzogX2ZuR2V0TWF4TGVuU3RyaW5nLFxyXG4gICAgICAgICAgICBfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXHJcbiAgICAgICAgICAgIF9mblNvcnRGbGF0dGVuOiBfZm5Tb3J0RmxhdHRlbixcclxuICAgICAgICAgICAgX2ZuU29ydDogX2ZuU29ydCxcclxuICAgICAgICAgICAgX2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxyXG4gICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXI6IF9mblNvcnRMaXN0ZW5lcixcclxuICAgICAgICAgICAgX2ZuU29ydEF0dGFjaExpc3RlbmVyOiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsXHJcbiAgICAgICAgICAgIF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3NlcyxcclxuICAgICAgICAgICAgX2ZuU29ydERhdGE6IF9mblNvcnREYXRhLFxyXG4gICAgICAgICAgICBfZm5TYXZlU3RhdGU6IF9mblNhdmVTdGF0ZSxcclxuICAgICAgICAgICAgX2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXHJcbiAgICAgICAgICAgIF9mblNldHRpbmdzRnJvbU5vZGU6IF9mblNldHRpbmdzRnJvbU5vZGUsXHJcbiAgICAgICAgICAgIF9mbkxvZzogX2ZuTG9nLFxyXG4gICAgICAgICAgICBfZm5NYXA6IF9mbk1hcCxcclxuICAgICAgICAgICAgX2ZuQmluZEFjdGlvbjogX2ZuQmluZEFjdGlvbixcclxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWc6IF9mbkNhbGxiYWNrUmVnLFxyXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcclxuICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3c6IF9mbkxlbmd0aE92ZXJmbG93LFxyXG4gICAgICAgICAgICBfZm5SZW5kZXJlcjogX2ZuUmVuZGVyZXIsXHJcbiAgICAgICAgICAgIF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXHJcbiAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXM6IF9mblJvd0F0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUVuZDogZnVuY3Rpb24gKCkgeyB9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcclxuICAgICAgICAgICAgLy8gaW4gMS4xMCwgc28gdGhpcyBkZWFkLWVuZCBmdW5jdGlvbiBpc1xyXG4gICAgICAgICAgICAvLyBhZGRlZCB0byBwcmV2ZW50IGVycm9yc1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8galF1ZXJ5IGFjY2Vzc1xyXG4gICAgICAgICQuZm4uZGF0YVRhYmxlID0gRGF0YVRhYmxlO1xyXG5cclxuICAgICAgICAvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXHJcbiAgICAgICAgRGF0YVRhYmxlLiQgPSAkO1xyXG5cclxuICAgICAgICAvLyBMZWdhY3kgYWxpYXNlc1xyXG4gICAgICAgICQuZm4uZGF0YVRhYmxlU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XHJcbiAgICAgICAgJC5mbi5kYXRhVGFibGVFeHQgPSBEYXRhVGFibGUuZXh0O1xyXG5cclxuICAgICAgICAvLyBXaXRoIGEgY2FwaXRhbCBgRGAgd2UgcmV0dXJuIGEgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2UgcmF0aGVyIHRoYW4gYVxyXG4gICAgICAgIC8vIGpRdWVyeSBvYmplY3RcclxuICAgICAgICAkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRhdGFUYWJsZShvcHRzKS5hcGkoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcclxuICAgICAgICAvLyBhdmFpbGFibGUgb24gJC5mbi5EYXRhVGFibGVcclxuICAgICAgICAkLmVhY2goRGF0YVRhYmxlLCBmdW5jdGlvbiAocHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICQuZm4uRGF0YVRhYmxlW3Byb3BdID0gdmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgZXZlbnRzIGZpcmVkIGJ5IERhdGFUYWJsZXMgLSBmb3IgZG9jdW1lbnRhdGlvbi5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3IGV2ZW50LCBmaXJlZCB3aGVuZXZlciB0aGUgdGFibGUgaXMgcmVkcmF3biBvbiB0aGUgcGFnZSwgYXQgdGhlIHNhbWVcclxuICAgICAgICAgKiBwb2ludCBhcyBmbkRyYXdDYWxsYmFjay4gVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBiaW5kaW5nIGV2ZW50cyBvclxyXG4gICAgICAgICAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxyXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjZHJhdy5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VhcmNoIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBzZWFyY2hpbmcgYXBwbGllZCB0byB0aGUgdGFibGUgKHVzaW5nIHRoZVxyXG4gICAgICAgICAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxyXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc2VhcmNoLmR0XHJcbiAgICAgICAgICogIEBldmVudFxyXG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWdlIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgcGFnaW5nIG9mIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxyXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjcGFnZS5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3JkZXIgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIG9yZGVyaW5nIGFwcGxpZWQgdG8gdGhlIHRhYmxlIGlzIGFsdGVyZWQuXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNvcmRlci5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcclxuICAgICAgICAgKiBkcmF3biwgaW5jbHVkaW5nIEFqYXggZGF0YSBsb2FkZWQsIGlmIEFqYXggZGF0YSBpcyByZXF1aXJlZC5cclxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2luaXQuZHRcclxuICAgICAgICAgKiAgQGV2ZW50XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcclxuICAgICAgICAgKiAgICBwcmVzZW50IGlmIGNsaWVudC1zaWRlIEFqYXggc291cmNlZCBkYXRhIGlzIHVzZWQ8L2xpPjwvb2w+XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXRlIHNhdmUgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHRhYmxlIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmVcclxuICAgICAgICAgKiBpcyByZXF1aXJlZC4gVGhpcyBldmVudCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0XHJcbiAgICAgICAgICogcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvciBvdGhlciBzdGF0ZVxyXG4gICAgICAgICAqIHByb3BlcnRpZXMgKGZvciBwbHVnLWlucykgb3IgbW9kaWZpY2F0aW9uIG9mIGEgRGF0YVRhYmxlcyBjb3JlIHByb3BlcnR5LlxyXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVTYXZlUGFyYW1zLmR0XHJcbiAgICAgICAgICogIEBldmVudFxyXG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc3RhdGUgaW5mb3JtYXRpb24gdG8gYmUgc2F2ZWRcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhdGUgbG9hZCBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWRcclxuICAgICAgICAgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcclxuICAgICAgICAgKiAtIGFsbG93aW5nIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgaXMgcmVxdWlyZWQgb3IgbG9hZGluZyBvZlxyXG4gICAgICAgICAqIHN0YXRlIGZvciBhIHBsdWctaW4uXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcclxuICAgICAgICAgKiAgQGV2ZW50XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGF0ZSBsb2FkZWQgZXZlbnQsIGZpcmVkIHdoZW4gc3RhdGUgaGFzIGJlZW4gbG9hZGVkIGZyb20gc3RvcmVkIGRhdGEgYW5kXHJcbiAgICAgICAgICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRlZC5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3NpbmcgZXZlbnQsIGZpcmVkIHdoZW4gRGF0YVRhYmxlcyBpcyBkb2luZyBzb21lIGtpbmQgb2YgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAqIChiZSBpdCwgb3JkZXIsIHNlYXJjZyBvciBhbnl0aGluZyBlbHNlKS4gSXQgY2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgdG9cclxuICAgICAgICAgKiB0aGUgZW5kIHVzZXIgdGhhdCB0aGVyZSBpcyBzb21ldGhpbmcgaGFwcGVuaW5nLCBvciB0aGF0IHNvbWV0aGluZyBoYXNcclxuICAgICAgICAgKiBmaW5pc2hlZC5cclxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3Byb2Nlc3NpbmcuZHRcclxuICAgICAgICAgKiAgQGV2ZW50XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gYlNob3cgRmxhZyBmb3IgaWYgRGF0YVRhYmxlcyBpcyBkb2luZyBwcm9jZXNzaW5nIG9yIG5vdFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxyXG4gICAgICAgICAqIHJlcXVlc3QgdG8gbWFkZSB0byB0aGUgc2VydmVyIGZvciBuZXcgZGF0YS4gVGhpcyBldmVudCBpcyBjYWxsZWQgYmVmb3JlXHJcbiAgICAgICAgICogRGF0YVRhYmxlcyBwcm9jZXNzZWQgdGhlIHJldHVybmVkIGRhdGEsIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJlLVxyXG4gICAgICAgICAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyB0cmlnZ2VyIGlzIGNhbGxlZCBpbiBgZm5TZXJ2ZXJEYXRhYCwgaWYgeW91IG92ZXJyaWRlXHJcbiAgICAgICAgICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxyXG4gICAgICAgICAqIHN1Y2Nlc3MgZnVuY3Rpb24uXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSN4aHIuZHRcclxuICAgICAgICAgKiAgQGV2ZW50XHJcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XHJcbiAgICAgICAgICogICAgICQoJyN0YWJsZScpLmRhdGFUYWJsZSgpLm9uKCd4aHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcclxuICAgICAgICAgKiAgICAgICAkKCcjc3RhdHVzJykuaHRtbCgganNvbi5zdGF0dXMgKTtcclxuICAgICAgICAgKiAgICAgfSApO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICAgICAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XHJcbiAgICAgICAgICogICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24uYWFEYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xyXG4gICAgICAgICAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xyXG4gICAgICAgICAqICAgICAgIH1cclxuICAgICAgICAgKiAgICAgICAvLyBOb3RlIG5vIHJldHVybiAtIG1hbmlwdWxhdGUgdGhlIGRhdGEgZGlyZWN0bHkgaW4gdGhlIEpTT04gb2JqZWN0LlxyXG4gICAgICAgICAqICAgICB9ICk7XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc3Ryb3kgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIERhdGFUYWJsZSBpcyBkZXN0cm95ZWQgYnkgY2FsbGluZyBmbkRlc3Ryb3lcclxuICAgICAgICAgKiBvciBwYXNzaW5nIHRoZSBiRGVzdHJveTp0cnVlIHBhcmFtZXRlciBpbiB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0LiBUaGlzXHJcbiAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNkZXN0cm95LmR0XHJcbiAgICAgICAgICogIEBldmVudFxyXG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWdlIGxlbmd0aCBjaGFuZ2UgZXZlbnQsIGZpcmVkIHdoZW4gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2hvdyBvbiBlYWNoXHJcbiAgICAgICAgICogcGFnZSAodGhlIGxlbmd0aCkgaXMgY2hhbmdlZC5cclxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2xlbmd0aC5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnRlZ2VyfSBsZW4gTmV3IGxlbmd0aFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjY29sdW1uLXNpemluZy5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sdW1uIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxyXG4gICAgICAgICAqICBAZXZlbnRcclxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbHVtbiBDb2x1bW4gaW5kZXhcclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSB2aXMgYGZhbHNlYCBpZiBjb2x1bW4gbm93IGhpZGRlbiwgb3IgYHRydWVgIGlmIHZpc2libGVcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgcmV0dXJuICQuZm4uZGF0YVRhYmxlO1xyXG4gICAgfSkpOyIsIi8qISBCdXR0b25zIGZvciBEYXRhVGFibGVzIDEuNS4xXHJcbiAqIMKpMjAxNi0yMDE3IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1EXHJcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICgkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQsIHdpbmRvdywgZG9jdW1lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gQ29tbW9uSlNcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XHJcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHdpbmRvdztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCEkIHx8ICEkLmZuLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgJCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoJCwgcm9vdCwgcm9vdC5kb2N1bWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXJcclxuICAgICAgICBmYWN0b3J5KGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbn0oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIERhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xyXG5cclxuXHJcbiAgICAvLyBVc2VkIGZvciBuYW1lc3BhY2luZyBldmVudHMgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGJ5IGVhY2ggaW5zdGFuY2UsIHNvIHRoZXlcclxuICAgIC8vIGNhbiBiZSByZW1vdmVkIG9uIGRlc3Ryb3lcclxuICAgIHZhciBfaW5zdENvdW50ZXIgPSAwO1xyXG5cclxuICAgIC8vIEJ1dHRvbiBuYW1lc3BhY2luZyBjb3VudGVyIGZvciBuYW1lc3BhY2luZyBldmVudHMgb24gaW5kaXZpZHVhbCBidXR0b25zXHJcbiAgICB2YXIgX2J1dHRvbkNvdW50ZXIgPSAwO1xyXG5cclxuICAgIHZhciBfZHRCdXR0b25zID0gRGF0YVRhYmxlLmV4dC5idXR0b25zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogW0J1dHRvbnMgZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfVxyXG4gICAgICovXHJcbiAgICB2YXIgQnV0dG9ucyA9IGZ1bmN0aW9uIChkdCwgY29uZmlnKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY29uZmlnIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3RcclxuICAgICAgICBpZiAodHlwZW9mIChjb25maWcpID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBjb25maWcgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGEgYm9vbGVhbiB0cnVlIGZvciBkZWZhdWx0c1xyXG4gICAgICAgIGlmIChjb25maWcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29uZmlnID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGb3IgZWFzeSBjb25maWd1cmF0aW9uIG9mIGJ1dHRvbnMgYW4gYXJyYXkgY2FuIGJlIGdpdmVuXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShjb25maWcpKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgYnV0dG9uczogY29uZmlnIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgQnV0dG9ucy5kZWZhdWx0cywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCBhIGRlZXAgY29weSBmb3IgdGhlIGJ1dHRvbnNcclxuICAgICAgICBpZiAoY29uZmlnLmJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jLmJ1dHRvbnMgPSBjb25maWcuYnV0dG9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucyA9IHtcclxuICAgICAgICAgICAgZHQ6IG5ldyBEYXRhVGFibGUuQXBpKGR0KSxcclxuICAgICAgICAgICAgYnV0dG9uczogW10sXHJcbiAgICAgICAgICAgIGxpc3RlbktleXM6ICcnLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdkdGInICsgKF9pbnN0Q291bnRlcisrKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZG9tID0ge1xyXG4gICAgICAgICAgICBjb250YWluZXI6ICQoJzwnICsgdGhpcy5jLmRvbS5jb250YWluZXIudGFnICsgJy8+JylcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmMuZG9tLmNvbnRhaW5lci5jbGFzc05hbWUpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29uc3RydWN0b3IoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgICQuZXh0ZW5kKEJ1dHRvbnMucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICAgICAqIFB1YmxpYyBtZXRob2RzXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYWN0aW9uIG9mIGEgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtICB7aW50fHN0cmluZ30gQnV0dG9uIGluZGV4XHJcbiAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259XHJcbiAgICAgICAgICovLyoqXHJcbiAgICAgICAgKiBTZXQgdGhlIGFjdGlvbiBvZiBhIGJ1dHRvblxyXG4gICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gZWxlbWVudFxyXG4gICAgICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjdGlvbiBGdW5jdGlvbiB0byBzZXRcclxuICAgICAgICAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgKi9cclxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChub2RlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbihub2RlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbi5jb25mLmFjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnV0dG9uLmNvbmYuYWN0aW9uID0gYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGFuIGFjdGl2ZSBjbGFzcyB0byB0aGUgYnV0dG9uIHRvIG1ha2UgdG8gbG9vayBhY3RpdmUgb3IgZ2V0IGN1cnJlbnRcclxuICAgICAgICAgKiBhY3RpdmUgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtmbGFnXSBFbmFibGUgLyBkaXNhYmxlIGZsYWdcclxuICAgICAgICAgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZyBvciBib29sZWFuIGZvciBnZXR0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uIChub2RlLCBmbGFnKSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24obm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBrbGFzcyA9IHRoaXMuYy5kb20uYnV0dG9uLmFjdGl2ZTtcclxuICAgICAgICAgICAgdmFyIGpxTm9kZSA9ICQoYnV0dG9uLm5vZGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxTm9kZS5oYXNDbGFzcyhrbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGpxTm9kZS50b2dnbGVDbGFzcyhrbGFzcywgZmxhZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZsYWcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgbmV3IGJ1dHRvblxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgQnV0dG9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBiYXNlIHN0cmluZyBuYW1lIG9yIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR8c3RyaW5nfSBbaWR4XSBCdXR0b24gaW5kZXggZm9yIHdoZXJlIHRvIGluc2VydCB0aGUgYnV0dG9uXHJcbiAgICAgICAgICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjb25maWcsIGlkeCkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMucy5idXR0b25zO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZHggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBpZHguc3BsaXQoJy0nKTtcclxuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5zO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzcGxpdC5sZW5ndGggLSAxOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5idXR0b25zW3NwbGl0W2ldICogMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IGJhc2UuYnV0dG9ucztcclxuICAgICAgICAgICAgICAgIGlkeCA9IHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDFdICogMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fZXhwYW5kQnV0dG9uKGJ1dHRvbnMsIGNvbmZpZywgZmFsc2UsIGlkeCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXcoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY29udGFpbmVyIG5vZGUgZm9yIHRoZSBidXR0b25zXHJcbiAgICAgICAgICogQHJldHVybiB7alF1ZXJ5fSBCdXR0b25zIG5vZGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlIGEgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbihub2RlKTtcclxuXHJcbiAgICAgICAgICAgICQoYnV0dG9uLm5vZGUpLmFkZENsYXNzKHRoaXMuYy5kb20uYnV0dG9uLmRpc2FibGVkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc3Ryb3kgdGhlIGluc3RhbmNlLCBjbGVhbmluZyB1cCBldmVudCBoYW5kbGVycyBhbmQgcmVtb3ZpbmcgRE9NXHJcbiAgICAgICAgICogZWxlbWVudHNcclxuICAgICAgICAgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gS2V5IGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgICAgICQoJ2JvZHknKS5vZmYoJ2tleXVwLicgKyB0aGlzLnMubmFtZXNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZGl2aWR1YWwgYnV0dG9uIGRlc3Ryb3kgKHNvIHRoZXkgY2FuIHJlbW92ZSB0aGVpciBvd24gZXZlbnRzIGlmXHJcbiAgICAgICAgICAgIC8vIG5lZWRlZCkuIFRha2UgYSBjb3B5IGFzIHRoZSBhcnJheSBpcyBtb2RpZmllZCBieSBgcmVtb3ZlYFxyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMucy5idXR0b25zLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBpLCBpZW47XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShidXR0b25zW2ldLm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb250YWluZXJcclxuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgIHZhciBidXR0b25JbnN0cyA9IHRoaXMucy5kdC5zZXR0aW5ncygpWzBdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYnV0dG9uSW5zdHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25JbnN0cy5pbnN0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5zdHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUgLyBkaXNhYmxlIGEgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxyXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtmbGFnPXRydWVdIEVuYWJsZSAvIGRpc2FibGUgZmxhZ1xyXG4gICAgICAgICAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiAobm9kZSwgZmxhZykge1xyXG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24obm9kZSk7XHJcbiAgICAgICAgICAgICQoYnV0dG9uLm5vZGUpLnJlbW92ZUNsYXNzKHRoaXMuYy5kb20uYnV0dG9uLmRpc2FibGVkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgaW5zdGFuY2UgbmFtZSBmb3IgdGhlIGJ1dHRvbiBzZXQgc2VsZWN0b3JcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEluc3RhbmNlIG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmMubmFtZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYSBidXR0b24ncyBub2RlXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2pRdWVyeX0gQnV0dG9uIGVsZW1lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBub2RlOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gJChidXR0b24ubm9kZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IC8gZ2V0IGEgcHJvY2Vzc2luZyBjbGFzcyBvbiB0aGUgc2VsZWN0ZWQgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmxhZyB0cnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLCB1bmRlZmluZWQgdG8gZ2V0XHJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbnxCdXR0b25zfSBHZXR0ZXIgdmFsdWUgb3IgdGhpcyBpZiBhIHNldHRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcm9jZXNzaW5nOiBmdW5jdGlvbiAobm9kZSwgZmxhZykge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoYnV0dG9uLm5vZGUpLmhhc0NsYXNzKCdwcm9jZXNzaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICQoYnV0dG9uLm5vZGUpLnRvZ2dsZUNsYXNzKCdwcm9jZXNzaW5nJywgZmxhZyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmUgYSBidXR0b24uXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgaG9zdCA9IHRoaXMuX25vZGVUb0hvc3Qobm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgY2hpbGQgYnV0dG9ucyBmaXJzdFxyXG4gICAgICAgICAgICBpZiAoYnV0dG9uLmJ1dHRvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYnV0dG9uLmJ1dHRvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShidXR0b24uYnV0dG9uc1tpXS5ub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGJ1dHRvbiB0byByZW1vdmUgZXZlbnQgaGFuZGxlcnMsIGV0Y1xyXG4gICAgICAgICAgICBpZiAoYnV0dG9uLmNvbmYuZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uLmNvbmYuZGVzdHJveS5jYWxsKGR0LmJ1dHRvbihub2RlKSwgZHQsICQobm9kZSksIGJ1dHRvbi5jb25mKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlS2V5KGJ1dHRvbi5jb25mKTtcclxuXHJcbiAgICAgICAgICAgICQoYnV0dG9uLm5vZGUpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheShidXR0b24sIGhvc3QpO1xyXG4gICAgICAgICAgICBob3N0LnNwbGljZShpZHgsIDEpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSB0ZXh0IGZvciBhIGJ1dHRvblxyXG4gICAgICAgICAqIEBwYXJhbSAge2ludHxzdHJpbmd9IG5vZGUgQnV0dG9uIGluZGV4XHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCdXR0b24gdGV4dFxyXG4gICAgICAgICAqLy8qKlxyXG4gICAgICAgICogU2V0IHRoZSB0ZXh0IGZvciBhIGJ1dHRvblxyXG4gICAgICAgICogQHBhcmFtICB7aW50fHN0cmluZ3xmdW5jdGlvbn0gbm9kZSBCdXR0b24gaW5kZXhcclxuICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGFiZWwgVGV4dFxyXG4gICAgICAgICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIChub2RlLCBsYWJlbCkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uTGluZXIgPSB0aGlzLmMuZG9tLmNvbGxlY3Rpb24uYnV0dG9uTGluZXI7XHJcbiAgICAgICAgICAgIHZhciBsaW5lclRhZyA9IGJ1dHRvbi5pbkNvbGxlY3Rpb24gJiYgYnV0dG9uTGluZXIgJiYgYnV0dG9uTGluZXIudGFnID9cclxuICAgICAgICAgICAgICAgIGJ1dHRvbkxpbmVyLnRhZyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmMuZG9tLmJ1dHRvbkxpbmVyLnRhZztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIganFOb2RlID0gJChidXR0b24ubm9kZSk7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdChkdCwganFOb2RlLCBidXR0b24uY29uZikgOlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dChidXR0b24uY29uZi50ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnV0dG9uLmNvbmYudGV4dCA9IGxhYmVsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxpbmVyVGFnKSB7XHJcbiAgICAgICAgICAgICAgICBqcU5vZGUuY2hpbGRyZW4obGluZXJUYWcpLmh0bWwodGV4dChsYWJlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAganFOb2RlLmh0bWwodGV4dChsYWJlbCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICAgICAqIENvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1dHRvbnMgY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuICAgICAgICAgICAgdmFyIGR0U2V0dGluZ3MgPSBkdC5zZXR0aW5ncygpWzBdO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuYy5idXR0b25zO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkdFNldHRpbmdzLl9idXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBkdFNldHRpbmdzLl9idXR0b25zID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGR0U2V0dGluZ3MuX2J1dHRvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpbnN0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5jLm5hbWVcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoYnV0dG9uc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGR0Lm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gR2xvYmFsIGtleSBldmVudCBiaW5kaW5nIHRvIGxpc3RlbiBmb3IgYnV0dG9uIGtleXNcclxuICAgICAgICAgICAgJCgnYm9keScpLm9uKCdrZXl1cC4nICsgdGhpcy5zLm5hbWVzcGFjZSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU1VzZSBhIHN0cmluZyBvZiBjaGFyYWN0ZXJzIGZvciBmYXN0IGxvb2t1cCBvZiBpZiB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnMubGlzdGVuS2V5cy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoY2hhcmFjdGVyKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fa2V5cHJlc3MoY2hhcmFjdGVyLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcbiAgICAgICAgICogUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIG5ldyBidXR0b24gdG8gdGhlIGtleSBwcmVzcyBsaXN0ZW5lclxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25mIFJlc29sdmVkIGJ1dHRvbiBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FkZEtleTogZnVuY3Rpb24gKGNvbmYpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmYua2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnMubGlzdGVuS2V5cyArPSAkLmlzUGxhaW5PYmplY3QoY29uZi5rZXkpID9cclxuICAgICAgICAgICAgICAgICAgICBjb25mLmtleS5rZXkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmYua2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0IHRoZSBidXR0b25zIGludG8gdGhlIGNvbnRhaW5lci4gQ2FsbCB3aXRob3V0IHBhcmFtZXRlcnMhXHJcbiAgICAgICAgICogQHBhcmFtICB7bm9kZX0gW2NvbnRhaW5lcl0gUmVjdXJzaXZlIG9ubHkgLSBJbnNlcnQgcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gW2J1dHRvbnNdIFJlY3Vyc2l2ZSBvbmx5IC0gQnV0dG9ucyBhcnJheVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2RyYXc6IGZ1bmN0aW9uIChjb250YWluZXIsIGJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuZG9tLmNvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSB0aGlzLnMuYnV0dG9ucztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuKCkuZGV0YWNoKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChidXR0b25zW2ldLmluc2VydGVyKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQoJyAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uc1tpXS5idXR0b25zICYmIGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3KGJ1dHRvbnNbaV0uY29sbGVjdGlvbiwgYnV0dG9uc1tpXS5idXR0b25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBidXR0b25zIGZyb20gYW4gYXJyYXkgb2YgYnV0dG9uc1xyXG4gICAgICAgICAqIEBwYXJhbSAge2FycmF5fSBhdHRhY2hUbyBCdXR0b25zIGFycmF5IHRvIGF0dGFjaCB0b1xyXG4gICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gYnV0dG9uIEJ1dHRvbiBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gaW5Db2xsZWN0aW9uIHRydWUgaWYgdGhlIGJ1dHRvbiBpcyBpbiBhIGNvbGxlY3Rpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9leHBhbmRCdXR0b246IGZ1bmN0aW9uIChhdHRhY2hUbywgYnV0dG9uLCBpbkNvbGxlY3Rpb24sIGF0dGFjaFBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9ICEkLmlzQXJyYXkoYnV0dG9uKSA/XHJcbiAgICAgICAgICAgICAgICBbYnV0dG9uXSA6XHJcbiAgICAgICAgICAgICAgICBidXR0b247XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmYgPSB0aGlzLl9yZXNvbHZlRXh0ZW5kcyhidXR0b25zW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBhbiBhcnJheSwgdGhlbiBleHBhbmQgdGhlIGJ1dHRvbnMgYXQgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gcG9pbnRcclxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoY29uZikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRCdXR0b24oYXR0YWNoVG8sIGNvbmYsIGluQ29sbGVjdGlvbiwgYXR0YWNoUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBidWlsdCA9IHRoaXMuX2J1aWxkQnV0dG9uKGNvbmYsIGluQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaFBvaW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hUby5zcGxpY2UoYXR0YWNoUG9pbnQsIDAsIGJ1aWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQb2ludCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoVG8ucHVzaChidWlsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0LmNvbmYuYnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uRG9tID0gdGhpcy5jLmRvbS5jb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWx0LmNvbGxlY3Rpb24gPSAkKCc8JyArIGNvbGxlY3Rpb25Eb20udGFnICsgJy8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNvbGxlY3Rpb25Eb20uY2xhc3NOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncm9sZScsICdtZW51Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbHQuY29uZi5fY29sbGVjdGlvbiA9IGJ1aWx0LmNvbGxlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZEJ1dHRvbihidWlsdC5idXR0b25zLCBidWlsdC5jb25mLmJ1dHRvbnMsIHRydWUsIGF0dGFjaFBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0IGNhbGwgaXMgbWFkZSBoZXJlLCByYXRoZXIgdGhhbiBidWlsZEJ1dHRvbiBhcyBpdCBuZWVkcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gYmUgc2VsZWN0YWJsZSwgYW5kIGZvciB0aGF0IGl0IG5lZWRzIHRvIGJlIGluIHRoZSBidXR0b25zIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZi5pbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZi5pbml0LmNhbGwoZHQuYnV0dG9uKGJ1aWx0Lm5vZGUpLCBkdCwgJChidWlsdC5ub2RlKSwgY29uZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ291bnRlcisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuIGluZGl2aWR1YWwgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgICAgICAgICAgICBSZXNvbHZlZCBidXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGluQ29sbGVjdGlvbiBgdHJ1ZWAgaWYgYSBjb2xsZWN0aW9uIGJ1dHRvblxyXG4gICAgICAgICAqIEByZXR1cm4ge2pRdWVyeX0gQ3JlYXRlZCBidXR0b24gbm9kZSAoalF1ZXJ5KVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2J1aWxkQnV0dG9uOiBmdW5jdGlvbiAoY29uZmlnLCBpbkNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkRvbSA9IHRoaXMuYy5kb20uYnV0dG9uO1xyXG4gICAgICAgICAgICB2YXIgbGluZXJEb20gPSB0aGlzLmMuZG9tLmJ1dHRvbkxpbmVyO1xyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbkRvbSA9IHRoaXMuYy5kb20uY29sbGVjdGlvbjtcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgICAgICAgICBvcHQoZHQsIGJ1dHRvbiwgY29uZmlnKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGluQ29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uRG9tLmJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uRG9tID0gY29sbGVjdGlvbkRvbS5idXR0b247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbkNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbkRvbS5idXR0b25MaW5lcikge1xyXG4gICAgICAgICAgICAgICAgbGluZXJEb20gPSBjb2xsZWN0aW9uRG9tLmJ1dHRvbkxpbmVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgYnV0dG9uIGlzIGF2YWlsYWJsZSBiYXNlZCBvbiB3aGF0ZXZlciByZXF1aXJlbWVudHNcclxuICAgICAgICAgICAgLy8gaXQgaGFzLiBGb3IgZXhhbXBsZSwgRmxhc2ggYnV0dG9ucyByZXF1aXJlIEZsYXNoXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuYXZhaWxhYmxlICYmICFjb25maWcuYXZhaWxhYmxlKGR0LCBjb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmdW5jdGlvbiAoZSwgZHQsIGJ1dHRvbiwgY29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuYWN0aW9uLmNhbGwoZHQuYnV0dG9uKGJ1dHRvbiksIGUsIGR0LCBidXR0b24sIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgJChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoJ2J1dHRvbnMtYWN0aW9uLmR0JywgW1xyXG4gICAgICAgICAgICAgICAgICAgIGR0LmJ1dHRvbihidXR0b24pLCBkdCwgYnV0dG9uLCBjb25maWdcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJzwnICsgYnV0dG9uRG9tLnRhZyArICcvPicpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYnV0dG9uRG9tLmNsYXNzTmFtZSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLmlUYWJJbmRleClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGhpcy5zLmR0LnRhYmxlKCkubm9kZSgpLmlkKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljay5kdGInLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidXR0b24uaGFzQ2xhc3MoYnV0dG9uRG9tLmRpc2FibGVkKSAmJiBjb25maWcuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbihlLCBkdCwgYnV0dG9uLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJsdXIoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2tleXVwLmR0YicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidXR0b24uaGFzQ2xhc3MoYnV0dG9uRG9tLmRpc2FibGVkKSAmJiBjb25maWcuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24oZSwgZHQsIGJ1dHRvbiwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBgYWAgdGFncyBhY3QgbGlrZSBhIGxpbmtcclxuICAgICAgICAgICAgaWYgKGJ1dHRvbkRvbS50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b24uYXR0cignaHJlZicsICcjJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsaW5lckRvbS50YWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lciA9ICQoJzwnICsgbGluZXJEb20udGFnICsgJy8+JylcclxuICAgICAgICAgICAgICAgICAgICAuaHRtbCh0ZXh0KGNvbmZpZy50ZXh0KSlcclxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MobGluZXJEb20uY2xhc3NOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGluZXJEb20udGFnLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVyLmF0dHIoJ2hyZWYnLCAnIycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5hcHBlbmQobGluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uLmh0bWwodGV4dChjb25maWcudGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmVuYWJsZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b24uYWRkQ2xhc3MoYnV0dG9uRG9tLmRpc2FibGVkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRDbGFzcyhjb25maWcuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy50aXRsZUF0dHIpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5hdHRyKCd0aXRsZScsIHRleHQoY29uZmlnLnRpdGxlQXR0cikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmF0dHIpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5hdHRyKGNvbmZpZy5hdHRyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcubmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcubmFtZXNwYWNlID0gJy5kdC1idXR0b24tJyArIChfYnV0dG9uQ291bnRlcisrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IHRoaXMuYy5kb20uYnV0dG9uQ29udGFpbmVyO1xyXG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZXI7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25Db250YWluZXIgJiYgYnV0dG9uQ29udGFpbmVyLnRhZykge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZXIgPSAkKCc8JyArIGJ1dHRvbkNvbnRhaW5lci50YWcgKyAnLz4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhidXR0b25Db250YWluZXIuY2xhc3NOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoYnV0dG9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluc2VydGVyID0gYnV0dG9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hZGRLZXkoY29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb25mOiBjb25maWcsXHJcbiAgICAgICAgICAgICAgICBub2RlOiBidXR0b24uZ2V0KDApLFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZXI6IGluc2VydGVyLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uczogW10sXHJcbiAgICAgICAgICAgICAgICBpbkNvbGxlY3Rpb246IGluQ29sbGVjdGlvbixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGJ1dHRvbiBvYmplY3QgZnJvbSBhIG5vZGUgKHJlY3Vyc2l2ZSlcclxuICAgICAgICAgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBub2RlXHJcbiAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IFtidXR0b25zXSBCdXR0b24gYXJyYXksIHVzZXMgYmFzZSBpZiBub3QgZGVmaW5lZFxyXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gQnV0dG9uIG9iamVjdFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX25vZGVUb0J1dHRvbjogZnVuY3Rpb24gKG5vZGUsIGJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFidXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25zID0gdGhpcy5zLmJ1dHRvbnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uc1tpXS5ub2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbnNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5fbm9kZVRvQnV0dG9uKG5vZGUsIGJ1dHRvbnNbaV0uYnV0dG9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIGFycmF5IGZvciBhIGJ1dHRvbiBmcm9tIGEgYnV0dG9uIG5vZGUgKHJlY3Vyc2l2ZSlcclxuICAgICAgICAgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBub2RlXHJcbiAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IFtidXR0b25zXSBCdXR0b24gYXJyYXksIHVzZXMgYmFzZSBpZiBub3QgZGVmaW5lZFxyXG4gICAgICAgICAqIEByZXR1cm4ge2FycmF5fSBCdXR0b24ncyBob3N0IGFycmF5XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfbm9kZVRvSG9zdDogZnVuY3Rpb24gKG5vZGUsIGJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFidXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25zID0gdGhpcy5zLmJ1dHRvbnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uc1tpXS5ub2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5fbm9kZVRvSG9zdChub2RlLCBidXR0b25zW2ldLmJ1dHRvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGEga2V5IHByZXNzIC0gZGV0ZXJtaW5lIGlmIGFueSBidXR0b24ncyBrZXkgY29uZmlndXJlZCBtYXRjaGVzXHJcbiAgICAgICAgICogd2hhdCB3YXMgdHlwZWQgYW5kIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiBzby5cclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNoYXJhY3RlciBUaGUgY2hhcmFjdGVyIHByZXNzZWRcclxuICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgS2V5IGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2FsbFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2tleXByZXNzOiBmdW5jdGlvbiAoY2hhcmFjdGVyLCBlKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgYnV0dG9uIHByZXNzIGFscmVhZHkgYWN0aXZhdGVkIG9uIGFub3RoZXIgaW5zdGFuY2Ugb2YgQnV0dG9uc1xyXG4gICAgICAgICAgICBpZiAoZS5fYnV0dG9uc0hhbmRsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChjb25mLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmYua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb25mLmtleSA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5fYnV0dG9uc0hhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICQobm9kZSkuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChjb25mLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZi5rZXkua2V5ICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmYua2V5LnNoaWZ0S2V5ICYmICFlLnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25mLmtleS5hbHRLZXkgJiYgIWUuYWx0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25mLmtleS5jdHJsS2V5ICYmICFlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmYua2V5Lm1ldGFLZXkgJiYgIWUubWV0YUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWRlIGl0IHRoaXMgZmFyIC0gaXQgaXMgZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIGUuX2J1dHRvbnNIYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAkKG5vZGUpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bihhW2ldLmNvbmYsIGFbaV0ubm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhW2ldLmJ1dHRvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UoYVtpXS5idXR0b25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZWN1cnNlKHRoaXMucy5idXR0b25zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmUgYSBrZXkgZnJvbSB0aGUga2V5IGxpc3RlbmVyIGZvciB0aGlzIGluc3RhbmNlICh0byBiZSB1c2VkIHdoZW4gYVxyXG4gICAgICAgICAqIGJ1dHRvbiBpcyByZW1vdmVkKVxyXG4gICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gY29uZiBCdXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3JlbW92ZUtleTogZnVuY3Rpb24gKGNvbmYpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmYua2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gJC5pc1BsYWluT2JqZWN0KGNvbmYua2V5KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZi5rZXkua2V5IDpcclxuICAgICAgICAgICAgICAgICAgICBjb25mLmtleTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25seSBvbmUgY2hhcmFjdGVyLCBhcyBtdWx0aXBsZSBidXR0b25zIGNvdWxkIGhhdmUgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGxpc3RlbmluZyBrZXlcclxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5zLmxpc3RlbktleXMuc3BsaXQoJycpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheShjaGFyYWN0ZXIsIGEpO1xyXG4gICAgICAgICAgICAgICAgYS5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucy5saXN0ZW5LZXlzID0gYS5qb2luKCcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdmUgYSBidXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R9IGNvbmYgQnV0dG9uIGNvbmZpZyB0byByZXNvbHZlXHJcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBCdXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Jlc29sdmVFeHRlbmRzOiBmdW5jdGlvbiAoY29uZikge1xyXG4gICAgICAgICAgICB2YXIgZHQgPSB0aGlzLnMuZHQ7XHJcbiAgICAgICAgICAgIHZhciBpLCBpZW47XHJcbiAgICAgICAgICAgIHZhciB0b0NvbmZPYmplY3QgPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvb3AgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvb3AgdW50aWwgd2UgaGF2ZSByZXNvbHZlZCB0byBhIGJ1dHRvbiBjb25maWd1cmF0aW9uLCBvciBhblxyXG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgYnV0dG9uIGNvbmZpZ3VyYXRpb25zICh3aGljaCB3aWxsIGJlIGl0ZXJhdGVkXHJcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWx5KVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCEkLmlzUGxhaW5PYmplY3QoYmFzZSkgJiYgISQuaXNBcnJheShiYXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlKGR0LCBjb25mKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kdEJ1dHRvbnNbYmFzZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJ1dHRvbiB0eXBlOiAnICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IF9kdEJ1dHRvbnNbYmFzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsb29wKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb3AgPiAzMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgbWlzY29uZmlndXJhdGlvbiBraWxsaW5nIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdCdXR0b25zOiBUb28gbWFueSBpdGVyYXRpb25zJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQuaXNBcnJheShiYXNlKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoe30sIGJhc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uZiA9IHRvQ29uZk9iamVjdChjb25mKTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChjb25mICYmIGNvbmYuZXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgYHRvQ29uZk9iamVjdGAgaW4gY2FzZSB0aGUgYnV0dG9uIGRlZmluaXRpb24gYmVpbmcgZXh0ZW5kZWRcclxuICAgICAgICAgICAgICAgIC8vIGlzIGl0c2VsZiBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIV9kdEJ1dHRvbnNbY29uZi5leHRlbmRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBleHRlbmQgdW5rbm93biBidXR0b24gdHlwZTogJyArIGNvbmYuZXh0ZW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvYmpBcnJheSA9IHRvQ29uZk9iamVjdChfZHRCdXR0b25zW2NvbmYuZXh0ZW5kXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KG9iakFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpBcnJheTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvYmpBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgYnJ1dGFsIGFzIGl0IG1pZ2h0IGJlIHBvc3NpYmxlIHRvIGhhdmUgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkIGJ1dHRvbiB3aXRob3V0IHRoZSBleHRlbmQsIGJ1dCBpZiB0aGVyZSBpcyBubyBleHRlbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBob3N0IGJ1dHRvbiB3b3VsZCBiZSBhY3RpbmcgaW4gYW4gdW5kZWZpbmVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXNoIHRoZSBjdXJyZW50IGNsYXNzIG5hbWVcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbENsYXNzTmFtZSA9IG9iakFycmF5LmNsYXNzTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25mID0gJC5leHRlbmQoe30sIG9iakFycmF5LCBjb25mKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXh0ZW5kIHdpbGwgaGF2ZSBvdmVyd3JpdHRlbiB0aGUgb3JpZ2luYWwgY2xhc3MgbmFtZSBpZiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGBjb25mYCBvYmplY3QgYWxzbyBhc3NpZ25lZCBhIGNsYXNzLCBidXQgd2Ugd2FudCB0byBjb25jYXRlbmF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBzbyB0aGV5IGFyZSBsaXN0IHRoYXQgaXMgY29tYmluZWQgZnJvbSBhbGwgZXh0ZW5kZWQgYnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2xhc3NOYW1lICYmIGNvbmYuY2xhc3NOYW1lICE9PSBvcmlnaW5hbENsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY2xhc3NOYW1lID0gb3JpZ2luYWxDbGFzc05hbWUgKyAnICcgKyBjb25mLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdXR0b25zIHRvIGJlIGFkZGVkIHRvIGEgY29sbGVjdGlvbiAgLWdpdmVzIHRoZSBhYmlsaXR5IHRvIGRlZmluZVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgYnV0dG9ucyBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgIHZhciBwb3N0Zml4QnV0dG9ucyA9IGNvbmYucG9zdGZpeEJ1dHRvbnM7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zdGZpeEJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmYuYnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHBvc3RmaXhCdXR0b25zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmYuYnV0dG9ucy5wdXNoKHBvc3RmaXhCdXR0b25zW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmYucG9zdGZpeEJ1dHRvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcmVmaXhCdXR0b25zID0gY29uZi5wcmVmaXhCdXR0b25zO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeEJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmYuYnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHByZWZpeEJ1dHRvbnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZi5idXR0b25zLnNwbGljZShpLCAwLCBwcmVmaXhCdXR0b25zW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmYucHJlZml4QnV0dG9ucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggd2Ugd2FudCB0aGUgYGNvbmZgIG9iamVjdCB0byBvdmVyd3JpdGUgYWxtb3N0IGFsbCBvZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBiZWluZyBleHRlbmRlZCwgdGhlIGBleHRlbmRgXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBzaG91bGQgY29tZSBmcm9tIHRoZSBvYmplY3QgYmVpbmcgZXh0ZW5kZWRcclxuICAgICAgICAgICAgICAgIGNvbmYuZXh0ZW5kID0gb2JqQXJyYXkuZXh0ZW5kO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29uZjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcclxuICAgICAqIFN0YXRpY3NcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyAvIGhpZGUgYSBiYWNrZ3JvdW5kIGxheWVyIGJlaGluZCBhIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGJhY2tncm91bmQgc2hvdWxkIGJlIHNob3duIG9yXHJcbiAgICAgKiAgIGhpZGRlbiBcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gQ2xhc3MgdG8gYXNzaWduIHRvIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnMuYmFja2dyb3VuZCA9IGZ1bmN0aW9uIChzaG93LCBjbGFzc05hbWUsIGZhZGUpIHtcclxuICAgICAgICBpZiAoZmFkZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZhZGUgPSA0MDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICAkKCc8ZGl2Lz4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGNsYXNzTmFtZSlcclxuICAgICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKVxyXG4gICAgICAgICAgICAgICAgLmZhZGVJbihmYWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICQoJ2JvZHkgPiBkaXYuJyArIGNsYXNzTmFtZSlcclxuICAgICAgICAgICAgICAgIC5mYWRlT3V0KGZhZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW5jZSBzZWxlY3RvciAtIHNlbGVjdCBCdXR0b25zIGluc3RhbmNlcyBiYXNlZCBvbiBhbiBpbnN0YW5jZSBzZWxlY3RvclxyXG4gICAgICogdmFsdWUgZnJvbSB0aGUgYnV0dG9ucyBhc3NpZ25lZCB0byBhIERhdGFUYWJsZS4gVGhpcyBpcyBvbmx5IHVzZWZ1bCBpZlxyXG4gICAgICogbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBhdHRhY2hlZCB0byBhIERhdGFUYWJsZS5cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ3xpbnR8YXJyYXl9IEluc3RhbmNlIHNlbGVjdG9yIC0gc2VlIGBpbnN0YW5jZS1zZWxlY3RvcmBcclxuICAgICAqICAgZG9jdW1lbnRhdGlvbiBvbiB0aGUgRGF0YVRhYmxlcyBzaXRlXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQnV0dG9uIGluc3RhbmNlIGFycmF5IHRoYXQgd2FzIGF0dGFjaGVkIHRvIHRoZSBEYXRhVGFibGVzXHJcbiAgICAgKiAgIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICogQHJldHVybiB7YXJyYXl9IEJ1dHRvbnMgaW5zdGFuY2VzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnMuaW5zdGFuY2VTZWxlY3RvciA9IGZ1bmN0aW9uIChncm91cCwgYnV0dG9ucykge1xyXG4gICAgICAgIGlmICghZ3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuICQubWFwKGJ1dHRvbnMsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5pbnN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXQgPSBbXTtcclxuICAgICAgICB2YXIgbmFtZXMgPSAkLm1hcChidXR0b25zLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdi5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBncm91cCBzZWxlY3RvciBpbnRvIGFuIGFycmF5IG9mIHNpbmdsZSBvcHRpb25zXHJcbiAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBpbnB1dC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoaW5wdXRbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmluZGV4T2YoJywnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgc2VsZWN0b3IsIGxpc3Qgb2YgbmFtZXNcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGlucHV0LnNwbGl0KCcsJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHNlbGVjdG9yIGluZGl2aWR1YWwgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAkLmluQXJyYXkoJC50cmltKGlucHV0KSwgbmFtZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChidXR0b25zW2lkeF0uaW5zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluZGV4IHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICByZXQucHVzaChidXR0b25zW2lucHV0XS5pbnN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHByb2Nlc3MoZ3JvdXApO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1dHRvbiBzZWxlY3RvciAtIHNlbGVjdCBvbmUgb3IgbW9yZSBidXR0b25zIGZyb20gYSBzZWxlY3RvciBpbnB1dCBzbyBzb21lXHJcbiAgICAgKiBvcGVyYXRpb24gY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGVtLlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEJ1dHRvbiBpbnN0YW5jZXMgYXJyYXkgdGhhdCB0aGUgc2VsZWN0b3Igc2hvdWxkIG9wZXJhdGUgb25cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ3xpbnR8bm9kZXxqUXVlcnl8YXJyYXl9IEJ1dHRvbiBzZWxlY3RvciAtIHNlZVxyXG4gICAgICogICBgYnV0dG9uLXNlbGVjdG9yYCBkb2N1bWVudGF0aW9uIG9uIHRoZSBEYXRhVGFibGVzIHNpdGVcclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYGluc3RgIGFuZCBgaWR4YCBwcm9wZXJ0aWVzIG9mXHJcbiAgICAgKiAgIHRoZSBzZWxlY3RlZCBidXR0b25zIHNvIHlvdSBrbm93IHdoaWNoIGluc3RhbmNlIGVhY2ggYnV0dG9uIGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnMuYnV0dG9uU2VsZWN0b3IgPSBmdW5jdGlvbiAoaW5zdHMsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IFtdO1xyXG4gICAgICAgIHZhciBub2RlQnVpbGRlciA9IGZ1bmN0aW9uIChhLCBidXR0b25zLCBiYXNlSWR4KSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b247XHJcbiAgICAgICAgICAgIHZhciBpZHg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gYmFzZUlkeCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUlkeCArIGkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICsgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGJ1dHRvbi5ub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBidXR0b24uY29uZi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IGlkeFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uLmJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUJ1aWxkZXIoYSwgYnV0dG9uLmJ1dHRvbnMsIGlkeCArICctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChzZWxlY3RvciwgaW5zdCkge1xyXG4gICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IFtdO1xyXG4gICAgICAgICAgICBub2RlQnVpbGRlcihidXR0b25zLCBpbnN0LnMuYnV0dG9ucyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSAkLm1hcChidXR0b25zLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYubm9kZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KHNlbGVjdG9yKSB8fCBzZWxlY3RvciBpbnN0YW5jZW9mICQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNlbGVjdG9yLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVuKHNlbGVjdG9yW2ldLCBpbnN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBudWxsIHx8IHNlbGVjdG9yID09PSB1bmRlZmluZWQgfHwgc2VsZWN0b3IgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IGFsbFxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdDogaW5zdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogYnV0dG9uc1tpXS5ub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gTWFpbiBidXR0b24gaW5kZXggc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0OiBpbnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGluc3Qucy5idXR0b25zW3NlbGVjdG9yXS5ub2RlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuaW5kZXhPZignLCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBzZWxlY3Rvci5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bigkLnRyaW0oYVtpXSksIGluc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLm1hdGNoKC9eXFxkKyhcXC1cXGQrKSokLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdWItYnV0dG9uIGluZGV4IHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSAkLm1hcChidXR0b25zLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5pZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdDogaW5zdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogYnV0dG9uc1skLmluQXJyYXkoc2VsZWN0b3IsIGluZGV4ZXMpXS5ub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rvci5pbmRleE9mKCc6bmFtZScpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dHRvbiBuYW1lIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzZWxlY3Rvci5yZXBsYWNlKCc6bmFtZScsICcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uc1tpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdDogaW5zdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBidXR0b25zW2ldLm5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICQobm9kZXMpLmZpbHRlcihzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3Q6IGluc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcgJiYgc2VsZWN0b3Iubm9kZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSAkLmluQXJyYXkoc2VsZWN0b3IsIG5vZGVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdDogaW5zdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZXNbaWR4XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBpbnN0cy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW5zdCA9IGluc3RzW2ldO1xyXG5cclxuICAgICAgICAgICAgcnVuKHNlbGVjdG9yLCBpbnN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1dHRvbnMgZGVmYXVsdHMuIEZvciBmdWxsIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9vcHRpb25cclxuICAgICAqIGRpcmVjdG9yeSBvciB0aGUgRGF0YVRhYmxlcyBzaXRlLlxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQnV0dG9ucy5kZWZhdWx0cyA9IHtcclxuICAgICAgICBidXR0b25zOiBbJ2NvcHknLCAnZXhjZWwnLCAnY3N2JywgJ3BkZicsICdwcmludCddLFxyXG4gICAgICAgIG5hbWU6ICdtYWluJyxcclxuICAgICAgICB0YWJJbmRleDogMCxcclxuICAgICAgICBkb206IHtcclxuICAgICAgICAgICAgY29udGFpbmVyOiB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtYnV0dG9ucydcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnZGl2JyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWJ1dHRvbi1jb2xsZWN0aW9uJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBidXR0b246IHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2J1dHRvbicsXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkdC1idXR0b24nLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOiAnYWN0aXZlJyxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJ1dHRvbkxpbmVyOiB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJzaW9uIGluZm9ybWF0aW9uXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCdXR0b25zLnZlcnNpb24gPSAnMS41LjEnO1xyXG5cclxuXHJcbiAgICAkLmV4dGVuZChfZHRCdXR0b25zLCB7XHJcbiAgICAgICAgY29sbGVjdGlvbjoge1xyXG4gICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdidXR0b25zLmNvbGxlY3Rpb24nLCAnQ29sbGVjdGlvbicpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdidXR0b25zLWNvbGxlY3Rpb24nLFxyXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChlLCBkdCwgYnV0dG9uLCBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBob3N0ID0gYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25QYXJlbnQgPSAkKGJ1dHRvbikucGFyZW50cygnZGl2LmR0LWJ1dHRvbi1jb2xsZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9zdFBvc2l0aW9uID0gaG9zdC5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlQ29udGFpbmVyID0gJChkdC50YWJsZSgpLmNvbnRhaW5lcigpKTtcclxuICAgICAgICAgICAgICAgIHZhciBtdWx0aUxldmVsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0UG9pbnQgPSBob3N0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgb2xkIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uUGFyZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHRpTGV2ZWwgPSAkKCcuZHQtYnV0dG9uLWNvbGxlY3Rpb24nKS5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFBvaW50ID0gY29sbGVjdGlvblBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAkKCdib2R5JykudHJpZ2dlcignY2xpY2suZHRiLWNvbGxlY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2NvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY29uZmlnLmNvbGxlY3Rpb25MYXlvdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNzcygnZGlzcGxheScsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWZ0ZXIoaW5zZXJ0UG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZhZGVJbihjb25maWcuZmFkZSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGNvbmZpZy5fY29sbGVjdGlvbi5jc3MoJ3Bvc2l0aW9uJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpTGV2ZWwgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2NvbGxlY3Rpb24uY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBtdWx0aUxldmVsLnRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbXVsdGlMZXZlbC5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fY29sbGVjdGlvbi5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGhvc3RQb3NpdGlvbi50b3AgKyBob3N0Lm91dGVySGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGhvc3RQb3NpdGlvbi5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBvdmVyZmxvdyB3aGVuIHBvc2l0aW9uZWQgYmVuZWF0aFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUJvdHRvbSA9IHRhYmxlQ29udGFpbmVyLm9mZnNldCgpLnRvcCArIHRhYmxlQ29udGFpbmVyLmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0Qm90dG9tID0gaG9zdFBvc2l0aW9uLnRvcCArIGhvc3Qub3V0ZXJIZWlnaHQoKSArIGNvbmZpZy5fY29sbGVjdGlvbi5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21PdmVyZmxvdyA9IGxpc3RCb3R0b20gLSB0YWJsZUJvdHRvbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG92ZXJmbG93IHdoZW4gcG9zaXRpb25lZCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0VG9wID0gaG9zdFBvc2l0aW9uLnRvcCAtIGNvbmZpZy5fY29sbGVjdGlvbi5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZVRvcCA9IHRhYmxlQ29udGFpbmVyLm9mZnNldCgpLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wT3ZlcmZsb3cgPSB0YWJsZVRvcCAtIGxpc3RUb3A7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGJvdHRvbSBvdmVyZmxvdyBpcyBsYXJnZXIsIG1vdmUgdG8gdGhlIHRvcCBiZWNhdXNlIGl0IGZpdHMgYmV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbU92ZXJmbG93ID4gdG9wT3ZlcmZsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9jb2xsZWN0aW9uLmNzcygndG9wJywgaG9zdFBvc2l0aW9uLnRvcCAtIGNvbmZpZy5fY29sbGVjdGlvbi5vdXRlckhlaWdodCgpIC0gNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdFJpZ2h0ID0gaG9zdFBvc2l0aW9uLmxlZnQgKyBjb25maWcuX2NvbGxlY3Rpb24ub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZVJpZ2h0ID0gdGFibGVDb250YWluZXIub2Zmc2V0KCkubGVmdCArIHRhYmxlQ29udGFpbmVyLndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RSaWdodCA+IHRhYmxlUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9jb2xsZWN0aW9uLmNzcygnbGVmdCcsIGhvc3RQb3NpdGlvbi5sZWZ0IC0gKGxpc3RSaWdodCAtIHRhYmxlUmlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXggcG9zaXRpb24gLSBjZW50cmUgb24gc2NyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IGNvbmZpZy5fY29sbGVjdGlvbi5oZWlnaHQoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA+ICQod2luZG93KS5oZWlnaHQoKSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gJCh3aW5kb3cpLmhlaWdodCgpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fY29sbGVjdGlvbi5jc3MoJ21hcmdpblRvcCcsIHRvcCAqIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBCdXR0b25zLmJhY2tncm91bmQodHJ1ZSwgY29uZmlnLmJhY2tncm91bmRDbGFzc05hbWUsIGNvbmZpZy5mYWRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGJyZWFrIHRoZSAndGhyZWFkJyBmb3IgdGhlIGNvbGxlY3Rpb24gYnV0dG9uIGJlaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgYnkgYSBjbGljayAtIGl0IHdvdWxkIGFsc28gdHJpZ2dlciB0aGlzIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGJvbmtlcnMsIGJ1dCBpZiB3ZSBkb24ndCBoYXZlIGEgY2xpY2sgbGlzdGVuZXIgb24gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBlbGVtZW50LCBpT1MgU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBib2R5IGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuZXIgYmVsb3cuIEFuIGVtcHR5IGZ1bmN0aW9uIGhlcmUgaXMgYWxsIHRoYXQgaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCB0byBtYWtlIGl0IHdvcmsuLi5cclxuICAgICAgICAgICAgICAgICAgICAkKCdkaXYuZHQtYnV0dG9uLWJhY2tncm91bmQnKS5vbignY2xpY2suZHRiLWNvbGxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrLmR0Yi1jb2xsZWN0aW9uJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kU2VsZiBpcyBkZXByZWNhdGVkIGluIGpRMS44LCBidXQgd2Ugd2FudCAxLjcgY29tcGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYWNrID0gJC5mbi5hZGRCYWNrID8gJ2FkZEJhY2snIDogJ2FuZFNlbGYnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5wYXJlbnRzKClbYmFja10oKS5maWx0ZXIoY29uZmlnLl9jb2xsZWN0aW9uKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWRlT3V0KGNvbmZpZy5mYWRlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fY29sbGVjdGlvbi5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCdkaXYuZHQtYnV0dG9uLWJhY2tncm91bmQnKS5vZmYoJ2NsaWNrLmR0Yi1jb2xsZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdXR0b25zLmJhY2tncm91bmQoZmFsc2UsIGNvbmZpZy5iYWNrZ3JvdW5kQ2xhc3NOYW1lLCBjb25maWcuZmFkZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLm9mZignY2xpY2suZHRiLWNvbGxlY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0Lm9mZignYnV0dG9ucy1hY3Rpb24uYi1pbnRlcm5hbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5hdXRvQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkdC5vbignYnV0dG9ucy1hY3Rpb24uYi1pbnRlcm5hbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnZGl2LmR0LWJ1dHRvbi1iYWNrZ3JvdW5kJykuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbkxheW91dDogJycsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDbGFzc05hbWU6ICdkdC1idXR0b24tYmFja2dyb3VuZCcsXHJcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGZhZGU6IDQwMCxcclxuICAgICAgICAgICAgYXR0cjoge1xyXG4gICAgICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChkdCwgY29uZikge1xyXG4gICAgICAgICAgICBpZiAoX2R0QnV0dG9ucy5jb3B5SHRtbDUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnY29weUh0bWw1JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX2R0QnV0dG9ucy5jb3B5Rmxhc2ggJiYgX2R0QnV0dG9ucy5jb3B5Rmxhc2guYXZhaWxhYmxlKGR0LCBjb25mKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb3B5Rmxhc2gnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjc3Y6IGZ1bmN0aW9uIChkdCwgY29uZikge1xyXG4gICAgICAgICAgICAvLyBDb21tb24gb3B0aW9uIHRoYXQgd2lsbCB1c2UgdGhlIEhUTUw1IG9yIEZsYXNoIGV4cG9ydCBidXR0b25zXHJcbiAgICAgICAgICAgIGlmIChfZHRCdXR0b25zLmNzdkh0bWw1ICYmIF9kdEJ1dHRvbnMuY3N2SHRtbDUuYXZhaWxhYmxlKGR0LCBjb25mKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjc3ZIdG1sNSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9kdEJ1dHRvbnMuY3N2Rmxhc2ggJiYgX2R0QnV0dG9ucy5jc3ZGbGFzaC5hdmFpbGFibGUoZHQsIGNvbmYpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NzdkZsYXNoJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjZWw6IGZ1bmN0aW9uIChkdCwgY29uZikge1xyXG4gICAgICAgICAgICAvLyBDb21tb24gb3B0aW9uIHRoYXQgd2lsbCB1c2UgdGhlIEhUTUw1IG9yIEZsYXNoIGV4cG9ydCBidXR0b25zXHJcbiAgICAgICAgICAgIGlmIChfZHRCdXR0b25zLmV4Y2VsSHRtbDUgJiYgX2R0QnV0dG9ucy5leGNlbEh0bWw1LmF2YWlsYWJsZShkdCwgY29uZikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZXhjZWxIdG1sNSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9kdEJ1dHRvbnMuZXhjZWxGbGFzaCAmJiBfZHRCdXR0b25zLmV4Y2VsRmxhc2guYXZhaWxhYmxlKGR0LCBjb25mKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdleGNlbEZsYXNoJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGRmOiBmdW5jdGlvbiAoZHQsIGNvbmYpIHtcclxuICAgICAgICAgICAgLy8gQ29tbW9uIG9wdGlvbiB0aGF0IHdpbGwgdXNlIHRoZSBIVE1MNSBvciBGbGFzaCBleHBvcnQgYnV0dG9uc1xyXG4gICAgICAgICAgICBpZiAoX2R0QnV0dG9ucy5wZGZIdG1sNSAmJiBfZHRCdXR0b25zLnBkZkh0bWw1LmF2YWlsYWJsZShkdCwgY29uZikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAncGRmSHRtbDUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfZHRCdXR0b25zLnBkZkZsYXNoICYmIF9kdEJ1dHRvbnMucGRmRmxhc2guYXZhaWxhYmxlKGR0LCBjb25mKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdwZGZGbGFzaCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhZ2VMZW5ndGg6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoTWVudSA9IGR0LnNldHRpbmdzKClbMF0uYUxlbmd0aE1lbnU7XHJcbiAgICAgICAgICAgIHZhciB2YWxzID0gJC5pc0FycmF5KGxlbmd0aE1lbnVbMF0pID8gbGVuZ3RoTWVudVswXSA6IGxlbmd0aE1lbnU7XHJcbiAgICAgICAgICAgIHZhciBsYW5nID0gJC5pc0FycmF5KGxlbmd0aE1lbnVbMF0pID8gbGVuZ3RoTWVudVsxXSA6IGxlbmd0aE1lbnU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignYnV0dG9ucy5wYWdlTGVuZ3RoJywge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiLTFcIjogJ1Nob3cgYWxsIHJvd3MnLFxyXG4gICAgICAgICAgICAgICAgICAgIF86ICdTaG93ICVkIHJvd3MnXHJcbiAgICAgICAgICAgICAgICB9LCBkdC5wYWdlLmxlbigpKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQ6ICdjb2xsZWN0aW9uJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidXR0b25zLXBhZ2UtbGVuZ3RoJyxcclxuICAgICAgICAgICAgICAgIGF1dG9DbG9zZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICQubWFwKHZhbHMsIGZ1bmN0aW9uICh2YWwsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYW5nW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidXR0b24tcGFnZS1sZW5ndGgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChlLCBkdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHQucGFnZS5sZW4odmFsKS5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChkdCwgbm9kZSwgY29uZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWN0aXZlKGR0LnBhZ2UubGVuKCkgPT09IHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0Lm9uKCdsZW5ndGguZHQnICsgY29uZi5uYW1lc3BhY2UsIGZuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChkdCwgbm9kZSwgY29uZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHQub2ZmKCdsZW5ndGguZHQnICsgY29uZi5uYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGR0LCBub2RlLCBjb25mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGR0Lm9uKCdsZW5ndGguZHQnICsgY29uZi5uYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50ZXh0KHRleHQoZHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZHQsIG5vZGUsIGNvbmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBkdC5vZmYoJ2xlbmd0aC5kdCcgKyBjb25mLm5hbWVzcGFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcbiAgICAgKiBEYXRhVGFibGVzIEFQSVxyXG4gICAgICpcclxuICAgICAqIEZvciBjb21wbGV0ZSBkb2N1bWVudGF0aW9uLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3MvYXBpIGRpcmVjdG9yeSBvciB0aGVcclxuICAgICAqIERhdGFUYWJsZXMgc2l0ZVxyXG4gICAgICovXHJcblxyXG4gICAgLy8gQnV0dG9ucyBncm91cCBhbmQgaW5kaXZpZHVhbCBidXR0b24gc2VsZWN0b3JcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoJ2J1dHRvbnMoKScsIGZ1bmN0aW9uIChncm91cCwgc2VsZWN0b3IpIHtcclxuICAgICAgICAvLyBBcmd1bWVudCBzaGlmdGluZ1xyXG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yID0gZ3JvdXA7XHJcbiAgICAgICAgICAgIGdyb3VwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5idXR0b25Hcm91cCA9IGdyb3VwO1xyXG5cclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5pdGVyYXRvcih0cnVlLCAndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguX2J1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCdXR0b25zLmJ1dHRvblNlbGVjdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIEJ1dHRvbnMuaW5zdGFuY2VTZWxlY3Rvcihncm91cCwgY3R4Ll9idXR0b25zKSxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICByZXMuX2dyb3VwU2VsZWN0b3IgPSBncm91cDtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5kaXZpZHVhbCBidXR0b24gc2VsZWN0b3JcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoJ2J1dHRvbigpJywgZnVuY3Rpb24gKGdyb3VwLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIC8vIGp1c3QgcnVuIGJ1dHRvbnMoKSBhbmQgdHJ1bmNhdGVcclxuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuYnV0dG9ucyhncm91cCwgc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICBpZiAoYnV0dG9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbnMuc3BsaWNlKDEsIGJ1dHRvbnMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBidXR0b25zO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0aXZlIGJ1dHRvbnNcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoJ2J1dHRvbnMoKS5hY3RpdmUoKScsICdidXR0b24oKS5hY3RpdmUoKScsIGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgICAgaWYgKGZsYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5pbnN0LmFjdGl2ZShzZXQubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHNldC5pbnN0LmFjdGl2ZShzZXQubm9kZSwgZmxhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZXQgLyBzZXQgYnV0dG9uIGFjdGlvblxyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCgnYnV0dG9ucygpLmFjdGlvbigpJywgJ2J1dHRvbigpLmFjdGlvbigpJywgZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIGlmIChhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5pbnN0LmFjdGlvbihzZXQubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHNldC5pbnN0LmFjdGlvbihzZXQubm9kZSwgYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVuYWJsZSAvIGRpc2FibGUgYnV0dG9uc1xyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcihbJ2J1dHRvbnMoKS5lbmFibGUoKScsICdidXR0b24oKS5lbmFibGUoKSddLCBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICBzZXQuaW5zdC5lbmFibGUoc2V0Lm5vZGUsIGZsYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRGlzYWJsZSBidXR0b25zXHJcbiAgICBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKFsnYnV0dG9ucygpLmRpc2FibGUoKScsICdidXR0b24oKS5kaXNhYmxlKCknXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICBzZXQuaW5zdC5kaXNhYmxlKHNldC5ub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdldCBidXR0b24gbm9kZXNcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoJ2J1dHRvbnMoKS5ub2RlcygpJywgJ2J1dHRvbigpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIganEgPSAkKCk7XHJcblxyXG4gICAgICAgIC8vIGpRdWVyeSB3aWxsIGF1dG9tYXRpY2FsbHkgcmVkdWNlIGR1cGxpY2F0ZXMgdG8gYSBzaW5nbGUgZW50cnlcclxuICAgICAgICAkKHRoaXMuZWFjaChmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIGpxID0ganEuYWRkKHNldC5pbnN0Lm5vZGUoc2V0Lm5vZGUpKTtcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHJldHVybiBqcTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdldCAvIHNldCBidXR0b24gcHJvY2Vzc2luZyBzdGF0ZVxyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCgnYnV0dG9ucygpLnByb2Nlc3NpbmcoKScsICdidXR0b24oKS5wcm9jZXNzaW5nKCknLCBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICAgIGlmIChmbGFnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQuaW5zdC5wcm9jZXNzaW5nKHNldC5ub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgc2V0Lmluc3QucHJvY2Vzc2luZyhzZXQubm9kZSwgZmxhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZXQgLyBzZXQgYnV0dG9uIHRleHQgKGkuZS4gdGhlIGJ1dHRvbiBsYWJlbHMpXHJcbiAgICBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCdidXR0b25zKCkudGV4dCgpJywgJ2J1dHRvbigpLnRleHQoKScsIGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgIGlmIChsYWJlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0Lmluc3QudGV4dChzZXQubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHNldC5pbnN0LnRleHQoc2V0Lm5vZGUsIGxhYmVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFRyaWdnZXIgYSBidXR0b24ncyBhY3Rpb25cclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoJ2J1dHRvbnMoKS50cmlnZ2VyKCknLCAnYnV0dG9uKCkudHJpZ2dlcigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICBzZXQuaW5zdC5ub2RlKHNldC5ub2RlKS50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBjb250YWluZXIgZWxlbWVudHNcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoJ2J1dHRvbnMoKS5jb250YWluZXJzKCknLCAnYnV0dG9ucygpLmNvbnRhaW5lcigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBqcSA9ICQoKTtcclxuICAgICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBncm91cCBzZWxlY3RvciBkaXJlY3RseSwgc2luY2UgaWYgdGhlcmUgYXJlIG5vIGJ1dHRvbnNcclxuICAgICAgICAvLyB0aGUgcmVzdWx0IHNldCB3aWxsIGJlIGVtcHR5XHJcbiAgICAgICAgdGhpcy5pdGVyYXRvcih0cnVlLCAndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguX2J1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnN0cyA9IEJ1dHRvbnMuaW5zdGFuY2VTZWxlY3Rvcihncm91cFNlbGVjdG9yLCBjdHguX2J1dHRvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBpbnN0cy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGpxID0ganEuYWRkKGluc3RzW2ldLmNvbnRhaW5lcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ganE7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgYSBuZXcgYnV0dG9uXHJcbiAgICBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCdidXR0b24oKS5hZGQoKScsIGZ1bmN0aW9uIChpZHgsIGNvbmYpIHtcclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAvLyBEb24ndCB1c2UgYHRoaXNgIGFzIGl0IGNvdWxkIGJlIGVtcHR5IC0gc2VsZWN0IHRoZSBpbnN0YW5jZXMgZGlyZWN0bHlcclxuICAgICAgICBpZiAoY3R4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaW5zdCA9IEJ1dHRvbnMuaW5zdGFuY2VTZWxlY3Rvcih0aGlzLl9ncm91cFNlbGVjdG9yLCBjdHhbMF0uX2J1dHRvbnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0WzBdLmFkZChjb25mLCBpZHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5idXR0b24odGhpcy5fZ3JvdXBTZWxlY3RvciwgaWR4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIERlc3Ryb3kgdGhlIGJ1dHRvbiBzZXRzIHNlbGVjdGVkXHJcbiAgICBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCdidXR0b25zKCkuZGVzdHJveSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGx1Y2soJ2luc3QnKS51bmlxdWUoKS5lYWNoKGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICAgICAgICAgIGluc3QuZGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBhIGJ1dHRvblxyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCgnYnV0dG9ucygpLnJlbW92ZSgpJywgJ2J1dHRvbnMoKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICBzZXQuaW5zdC5yZW1vdmUoc2V0Lm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluZm9ybWF0aW9uIGJveCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGJ1dHRvbnNcclxuICAgIHZhciBfaW5mb1RpbWVyO1xyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcignYnV0dG9ucy5pbmZvKCknLCBmdW5jdGlvbiAodGl0bGUsIG1lc3NhZ2UsIHRpbWUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICh0aXRsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgJCgnI2RhdGF0YWJsZXNfYnV0dG9uc19pbmZvJykuZmFkZU91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9pbmZvVGltZXIpO1xyXG4gICAgICAgICAgICBfaW5mb1RpbWVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9pbmZvVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9pbmZvVGltZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCQoJyNkYXRhdGFibGVzX2J1dHRvbnNfaW5mbycpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAkKCcjZGF0YXRhYmxlc19idXR0b25zX2luZm8nKS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRpdGxlID0gdGl0bGUgPyAnPGgyPicgKyB0aXRsZSArICc8L2gyPicgOiAnJztcclxuXHJcbiAgICAgICAgJCgnPGRpdiBpZD1cImRhdGF0YWJsZXNfYnV0dG9uc19pbmZvXCIgY2xhc3M9XCJkdC1idXR0b24taW5mb1wiLz4nKVxyXG4gICAgICAgICAgICAuaHRtbCh0aXRsZSlcclxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8ZGl2Lz4nKVt0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJ10obWVzc2FnZSkpXHJcbiAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpXHJcbiAgICAgICAgICAgIC5mYWRlSW4oKTtcclxuXHJcbiAgICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCAmJiB0aW1lICE9PSAwKSB7XHJcbiAgICAgICAgICAgIF9pbmZvVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYnV0dG9ucy5pbmZvKGZhbHNlKTtcclxuICAgICAgICAgICAgfSwgdGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdldCBkYXRhIGZyb20gdGhlIHRhYmxlIGZvciBleHBvcnQgLSB0aGlzIGlzIGNvbW1vbiB0byBhIG51bWJlciBvZiBwbHVnLWluXHJcbiAgICAvLyBidXR0b25zIHNvIGl0IGlzIGluY2x1ZGVkIGluIHRoZSBCdXR0b25zIGNvcmUgbGlicmFyeVxyXG4gICAgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcignYnV0dG9ucy5leHBvcnREYXRhKCknLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZXhwb3J0RGF0YShuZXcgRGF0YVRhYmxlLkFwaSh0aGlzLmNvbnRleHRbMF0pLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4cG9ydCB0aGF0IGlzIGNvbW1vbiB0byBtYW55IG9mIHRoZSBleHBvcnQgZGF0YVxyXG4gICAgLy8gdHlwZXMgKERSWSlcclxuICAgIERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoJ2J1dHRvbnMuZXhwb3J0SW5mbygpJywgZnVuY3Rpb24gKGNvbmYpIHtcclxuICAgICAgICBpZiAoIWNvbmYpIHtcclxuICAgICAgICAgICAgY29uZiA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsZW5hbWU6IF9maWxlbmFtZShjb25mKSxcclxuICAgICAgICAgICAgdGl0bGU6IF90aXRsZShjb25mKSxcclxuICAgICAgICAgICAgbWVzc2FnZVRvcDogX21lc3NhZ2UodGhpcywgY29uZi5tZXNzYWdlIHx8IGNvbmYubWVzc2FnZVRvcCwgJ3RvcCcpLFxyXG4gICAgICAgICAgICBtZXNzYWdlQm90dG9tOiBfbWVzc2FnZSh0aGlzLCBjb25mLm1lc3NhZ2VCb3R0b20sICdib3R0b20nKVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBmaWxlIG5hbWUgZm9yIGFuIGV4cG9ydGVkIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9XHRjb25maWcgQnV0dG9uIGNvbmZpZ3VyYXRpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jRXh0ZW5zaW9uIEluY2x1ZGUgdGhlIGZpbGUgbmFtZSBleHRlbnNpb25cclxuICAgICAqL1xyXG4gICAgdmFyIF9maWxlbmFtZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGNvbmZpZy5maWxlbmFtZSA9PT0gJyonICYmIGNvbmZpZy50aXRsZSAhPT0gJyonICYmIGNvbmZpZy50aXRsZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy50aXRsZSAhPT0gbnVsbCAmJiBjb25maWcudGl0bGUgIT09ICcnID9cclxuICAgICAgICAgICAgY29uZmlnLnRpdGxlIDpcclxuICAgICAgICAgICAgY29uZmlnLmZpbGVuYW1lO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWxlbmFtZSA9PT0gdW5kZWZpbmVkIHx8IGZpbGVuYW1lID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZmlsZW5hbWUgPSAkLnRyaW0oZmlsZW5hbWUucmVwbGFjZSgnKicsICQoJ2hlYWQgPiB0aXRsZScpLnRleHQoKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RyaXAgY2hhcmFjdGVycyB3aGljaCB0aGUgT1Mgd2lsbCBvYmplY3QgdG9cclxuICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05X1xcdTAwQTEtXFx1RkZGRlxcLixcXC1fICFcXChcXCldL2csIFwiXCIpO1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gX3N0cmluZ09yRnVuY3Rpb24oY29uZmlnLmV4dGVuc2lvbik7XHJcbiAgICAgICAgaWYgKCFleHRlbnNpb24pIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9uID0gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmlsZW5hbWUgKyBleHRlbnNpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGx5IHV0aWxpdHkgbWV0aG9kIHRvIGFsbG93IHBhcmFtZXRlcnMgdG8gYmUgZ2l2ZW4gYXMgYSBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfHN0cmluZ3xmdW5jdGlvbn0gb3B0aW9uIE9wdGlvblxyXG4gICAgICogQHJldHVybiB7bnVsbHxzdHJpbmd9IFJlc29sdmVkIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHZhciBfc3RyaW5nT3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICBpZiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRpdGxlIGZvciBhbiBleHBvcnRlZCBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcdEJ1dHRvbiBjb25maWd1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBfdGl0bGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHRpdGxlID0gX3N0cmluZ09yRnVuY3Rpb24oY29uZmlnLnRpdGxlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRpdGxlID09PSBudWxsID9cclxuICAgICAgICAgICAgbnVsbCA6IHRpdGxlLmluZGV4T2YoJyonKSAhPT0gLTEgP1xyXG4gICAgICAgICAgICAgICAgdGl0bGUucmVwbGFjZSgnKicsICQoJ2hlYWQgPiB0aXRsZScpLnRleHQoKSB8fCAnRXhwb3J0ZWQgZGF0YScpIDpcclxuICAgICAgICAgICAgICAgIHRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX21lc3NhZ2UgPSBmdW5jdGlvbiAoZHQsIG9wdGlvbiwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IF9zdHJpbmdPckZ1bmN0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2FwdGlvbiA9ICQoJ2NhcHRpb24nLCBkdC50YWJsZSgpLmNvbnRhaW5lcigpKS5lcSgwKTtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gY2FwdGlvbi5jc3MoJ2NhcHRpb24tc2lkZScpO1xyXG4gICAgICAgICAgICBpZiAoc2lkZSAhPT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FwdGlvbi5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgY2FwdGlvbi50ZXh0KCkgOlxyXG4gICAgICAgICAgICAgICAgJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIF9leHBvcnRUZXh0YXJlYSA9ICQoJzx0ZXh0YXJlYS8+JylbMF07XHJcbiAgICB2YXIgX2V4cG9ydERhdGEgPSBmdW5jdGlvbiAoZHQsIGluT3B0cykge1xyXG4gICAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh0cnVlLCB7fSwge1xyXG4gICAgICAgICAgICByb3dzOiBudWxsLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiAnJyxcclxuICAgICAgICAgICAgbW9kaWZpZXI6IHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaDogJ2FwcGxpZWQnLFxyXG4gICAgICAgICAgICAgICAgb3JkZXI6ICdhcHBsaWVkJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcnRob2dvbmFsOiAnZGlzcGxheScsXHJcbiAgICAgICAgICAgIHN0cmlwSHRtbDogdHJ1ZSxcclxuICAgICAgICAgICAgc3RyaXBOZXdsaW5lczogdHJ1ZSxcclxuICAgICAgICAgICAgZGVjb2RlRW50aXRpZXM6IHRydWUsXHJcbiAgICAgICAgICAgIHRyaW06IHRydWUsXHJcbiAgICAgICAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcChkKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmb290ZXI6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKGQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaW5PcHRzKTtcclxuXHJcbiAgICAgICAgdmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyByZW1vdmUgc2NyaXB0IHRhZ3NcclxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksICcnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuc3RyaXBIdG1sKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvPFtePl0qPi9nLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudHJpbSkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdHJpcE5ld2xpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxuL2csICcgJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVjb2RlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgICAgIF9leHBvcnRUZXh0YXJlYS5pbm5lckhUTUwgPSBzdHI7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBfZXhwb3J0VGV4dGFyZWEudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHZhciBoZWFkZXIgPSBkdC5jb2x1bW5zKGNvbmZpZy5jb2x1bW5zKS5pbmRleGVzKCkubWFwKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gZHQuY29sdW1uKGlkeCkuaGVhZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZm9ybWF0LmhlYWRlcihlbC5pbm5lckhUTUwsIGlkeCwgZWwpO1xyXG4gICAgICAgIH0pLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgdmFyIGZvb3RlciA9IGR0LnRhYmxlKCkuZm9vdGVyKCkgP1xyXG4gICAgICAgICAgICBkdC5jb2x1bW5zKGNvbmZpZy5jb2x1bW5zKS5pbmRleGVzKCkubWFwKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9IGR0LmNvbHVtbihpZHgpLmZvb3RlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5mb3JtYXQuZm9vdGVyKGVsID8gZWwuaW5uZXJIVE1MIDogJycsIGlkeCwgZWwpO1xyXG4gICAgICAgICAgICB9KS50b0FycmF5KCkgOlxyXG4gICAgICAgICAgICBudWxsO1xyXG5cclxuICAgICAgICAvLyBJZiBTZWxlY3QgaXMgYXZhaWxhYmxlIG9uIHRoaXMgdGFibGUsIGFuZCBhbnkgcm93cyBhcmUgc2VsZWN0ZWQsIGxpbWl0IHRoZSBleHBvcnRcclxuICAgICAgICAvLyB0byB0aGUgc2VsZWN0ZWQgcm93cy4gSWYgbm8gcm93cyBhcmUgc2VsZWN0ZWQsIGFsbCByb3dzIHdpbGwgYmUgZXhwb3J0ZWQuIFNwZWNpZnlcclxuICAgICAgICAvLyBhIGBzZWxlY3RlZGAgbW9kaWZpZXIgdG8gY29udHJvbCBkaXJlY3RseS5cclxuICAgICAgICB2YXIgbW9kaWZpZXIgPSAkLmV4dGVuZCh7fSwgY29uZmlnLm1vZGlmaWVyKTtcclxuICAgICAgICBpZiAoZHQuc2VsZWN0ICYmIHR5cGVvZiBkdC5zZWxlY3QuaW5mbyA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2RpZmllci5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChkdC5yb3dzKGNvbmZpZy5yb3dzLCAkLmV4dGVuZCh7IHNlbGVjdGVkOiB0cnVlIH0sIG1vZGlmaWVyKSkuYW55KCkpIHtcclxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKG1vZGlmaWVyLCB7IHNlbGVjdGVkOiB0cnVlIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByb3dJbmRleGVzID0gZHQucm93cyhjb25maWcucm93cywgbW9kaWZpZXIpLmluZGV4ZXMoKS50b0FycmF5KCk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkQ2VsbHMgPSBkdC5jZWxscyhyb3dJbmRleGVzLCBjb25maWcuY29sdW1ucyk7XHJcbiAgICAgICAgdmFyIGNlbGxzID0gc2VsZWN0ZWRDZWxsc1xyXG4gICAgICAgICAgICAucmVuZGVyKGNvbmZpZy5vcnRob2dvbmFsKVxyXG4gICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgIHZhciBjZWxsTm9kZXMgPSBzZWxlY3RlZENlbGxzXHJcbiAgICAgICAgICAgIC5ub2RlcygpXHJcbiAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIHZhciBjb2x1bW5zID0gaGVhZGVyLmxlbmd0aDtcclxuICAgICAgICB2YXIgcm93cyA9IGNvbHVtbnMgPiAwID8gY2VsbHMubGVuZ3RoIC8gY29sdW1ucyA6IDA7XHJcbiAgICAgICAgdmFyIGJvZHkgPSBbcm93c107XHJcbiAgICAgICAgdmFyIGNlbGxDb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHJvd3M7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gW2NvbHVtbnNdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHJvd1tqXSA9IGNvbmZpZy5mb3JtYXQuYm9keShjZWxsc1tjZWxsQ291bnRlcl0sIGksIGosIGNlbGxOb2Rlc1tjZWxsQ291bnRlcl0pO1xyXG4gICAgICAgICAgICAgICAgY2VsbENvdW50ZXIrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm9keVtpXSA9IHJvdztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlYWRlcjogaGVhZGVyLFxyXG4gICAgICAgICAgICBmb290ZXI6IGZvb3RlcixcclxuICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICogRGF0YVRhYmxlcyBpbnRlcmZhY2VcclxuICAgICAqL1xyXG5cclxuICAgIC8vIEF0dGFjaCB0byBEYXRhVGFibGVzIG9iamVjdHMgZm9yIGdsb2JhbCBhY2Nlc3NcclxuICAgICQuZm4uZGF0YVRhYmxlLkJ1dHRvbnMgPSBCdXR0b25zO1xyXG4gICAgJC5mbi5EYXRhVGFibGUuQnV0dG9ucyA9IEJ1dHRvbnM7XHJcblxyXG5cclxuXHJcbiAgICAvLyBEYXRhVGFibGVzIGNyZWF0aW9uIC0gY2hlY2sgaWYgdGhlIGJ1dHRvbnMgaGF2ZSBiZWVuIGRlZmluZWQgZm9yIHRoaXMgdGFibGUsXHJcbiAgICAvLyB0aGV5IHdpbGwgaGF2ZSBiZWVuIGlmIHRoZSBgQmAgb3B0aW9uIHdhcyB1c2VkIGluIGBkb21gLCBvdGhlcndpc2Ugd2Ugc2hvdWxkXHJcbiAgICAvLyBjcmVhdGUgdGhlIGJ1dHRvbnMgaW5zdGFuY2UgaGVyZSBzbyB0aGV5IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBkb2N1bWVudFxyXG4gICAgLy8gdXNpbmcgdGhlIEFQSS4gTGlzdGVuIGZvciBgaW5pdGAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUgMS4xMC4xMCwgYnV0IHRvXHJcbiAgICAvLyBiZSByZW1vdmVkIGluIGZ1dHVyZS5cclxuICAgICQoZG9jdW1lbnQpLm9uKCdpbml0LmR0IHBsdWdpbi1pbml0LmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKGUubmFtZXNwYWNlICE9PSAnZHQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvcHRzID0gc2V0dGluZ3Mub0luaXQuYnV0dG9ucyB8fCBEYXRhVGFibGUuZGVmYXVsdHMuYnV0dG9ucztcclxuXHJcbiAgICAgICAgaWYgKG9wdHMgJiYgIXNldHRpbmdzLl9idXR0b25zKSB7XHJcbiAgICAgICAgICAgIG5ldyBCdXR0b25zKHNldHRpbmdzLCBvcHRzKS5jb250YWluZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEYXRhVGFibGVzIGBkb21gIGZlYXR1cmUgb3B0aW9uXHJcbiAgICBEYXRhVGFibGUuZXh0LmZlYXR1cmUucHVzaCh7XHJcbiAgICAgICAgZm5Jbml0OiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdmFyIG9wdHMgPSBhcGkuaW5pdCgpLmJ1dHRvbnMgfHwgRGF0YVRhYmxlLmRlZmF1bHRzLmJ1dHRvbnM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1dHRvbnMoYXBpLCBvcHRzKS5jb250YWluZXIoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNGZWF0dXJlOiBcIkJcIlxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHJldHVybiBCdXR0b25zO1xyXG59KSk7IiwiLyohXHJcblxyXG5KU1ppcCAtIEEgSmF2YXNjcmlwdCBjbGFzcyBmb3IgZ2VuZXJhdGluZyBhbmQgcmVhZGluZyB6aXAgZmlsZXNcclxuPGh0dHA6Ly9zdHVhcnRrLmNvbS9qc3ppcD5cclxuXHJcbihjKSAyMDA5LTIwMTQgU3R1YXJ0IEtuaWdodGxleSA8c3R1YXJ0IFthdF0gc3R1YXJ0ay5jb20+XHJcbkR1YWwgbGljZW5jZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIG9yIEdQTHYzLiBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9TdHVrL2pzemlwL21hc3Rlci9MSUNFTlNFLm1hcmtkb3duLlxyXG5cclxuSlNaaXAgdXNlcyB0aGUgbGlicmFyeSBwYWtvIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSA6XHJcbmh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiovXHJcbiFmdW5jdGlvbihhKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1hKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGEpO2Vsc2V7dmFyIGI7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9iPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2I9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoYj1zZWxmKSxiLkpTWmlwPWEoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGEoYixjLGQpe2Z1bmN0aW9uIGUoZyxoKXtpZighY1tnXSl7aWYoIWJbZ10pe3ZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWgmJmkpcmV0dXJuIGkoZywhMCk7aWYoZilyZXR1cm4gZihnLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2crXCInXCIpfXZhciBqPWNbZ109e2V4cG9ydHM6e319O2JbZ11bMF0uY2FsbChqLmV4cG9ydHMsZnVuY3Rpb24oYSl7dmFyIGM9YltnXVsxXVthXTtyZXR1cm4gZShjP2M6YSl9LGosai5leHBvcnRzLGEsYixjLGQpfXJldHVybiBjW2ddLmV4cG9ydHN9Zm9yKHZhciBmPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsZz0wO2c8ZC5sZW5ndGg7ZysrKWUoZFtnXSk7cmV0dXJuIGV9KHsxOltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGQ9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO2MuZW5jb2RlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjLGUsZixnLGgsaSxqPVwiXCIsaz0wO2s8YS5sZW5ndGg7KWI9YS5jaGFyQ29kZUF0KGsrKyksYz1hLmNoYXJDb2RlQXQoaysrKSxlPWEuY2hhckNvZGVBdChrKyspLGY9Yj4+MixnPSgzJmIpPDw0fGM+PjQsaD0oMTUmYyk8PDJ8ZT4+NixpPTYzJmUsaXNOYU4oYyk/aD1pPTY0OmlzTmFOKGUpJiYoaT02NCksaj1qK2QuY2hhckF0KGYpK2QuY2hhckF0KGcpK2QuY2hhckF0KGgpK2QuY2hhckF0KGkpO3JldHVybiBqfSxjLmRlY29kZT1mdW5jdGlvbihhKXt2YXIgYixjLGUsZixnLGgsaSxqPVwiXCIsaz0wO2ZvcihhPWEucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csXCJcIik7azxhLmxlbmd0aDspZj1kLmluZGV4T2YoYS5jaGFyQXQoaysrKSksZz1kLmluZGV4T2YoYS5jaGFyQXQoaysrKSksaD1kLmluZGV4T2YoYS5jaGFyQXQoaysrKSksaT1kLmluZGV4T2YoYS5jaGFyQXQoaysrKSksYj1mPDwyfGc+PjQsYz0oMTUmZyk8PDR8aD4+MixlPSgzJmgpPDw2fGksais9U3RyaW5nLmZyb21DaGFyQ29kZShiKSw2NCE9aCYmKGorPVN0cmluZy5mcm9tQ2hhckNvZGUoYykpLDY0IT1pJiYoais9U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7cmV0dXJuIGp9fSx7fV0sMjpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKCl7dGhpcy5jb21wcmVzc2VkU2l6ZT0wLHRoaXMudW5jb21wcmVzc2VkU2l6ZT0wLHRoaXMuY3JjMzI9MCx0aGlzLmNvbXByZXNzaW9uTWV0aG9kPW51bGwsdGhpcy5jb21wcmVzc2VkQ29udGVudD1udWxsfWMucHJvdG90eXBlPXtnZXRDb250ZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGdldENvbXByZXNzZWRDb250ZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fSxiLmV4cG9ydHM9Y30se31dLDM6W2Z1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtjLlNUT1JFPXttYWdpYzpcIlxceDAwXFx4MDBcIixjb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gYX0sdW5jb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gYX0sY29tcHJlc3NJbnB1dFR5cGU6bnVsbCx1bmNvbXByZXNzSW5wdXRUeXBlOm51bGx9LGMuREVGTEFURT1hKFwiLi9mbGF0ZVwiKX0se1wiLi9mbGF0ZVwiOjh9XSw0OltmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO3ZhciBjPWEoXCIuL3V0aWxzXCIpLGQ9WzAsMTk5Njk1OTg5NCwzOTkzOTE5Nzg4LDI1Njc1MjQ3OTQsMTI0NjM0MTM3LDE4ODYwNTc2MTUsMzkxNTYyMTY4NSwyNjU3MzkyMDM1LDI0OTI2ODI3NCwyMDQ0NTA4MzI0LDM3NzIxMTUyMzAsMjU0NzE3Nzg2NCwxNjI5NDE5OTUsMjEyNTU2MTAyMSwzODg3NjA3MDQ3LDI0Mjg0NDQwNDksNDk4NTM2NTQ4LDE3ODk5Mjc2NjYsNDA4OTAxNjY0OCwyMjI3MDYxMjE0LDQ1MDU0ODg2MSwxODQzMjU4NjAzLDQxMDc1ODA3NTMsMjIxMTY3NzYzOSwzMjU4ODM5OTAsMTY4NDc3NzE1Miw0MjUxMTIyMDQyLDIzMjE5MjY2MzYsMzM1NjMzNDg3LDE2NjEzNjU0NjUsNDE5NTMwMjc1NSwyMzY2MTE1MzE3LDk5NzA3MzA5NiwxMjgxOTUzODg2LDM1Nzk4NTUzMzIsMjcyNDY4ODI0MiwxMDA2ODg4MTQ1LDEyNTg2MDc2ODcsMzUyNDEwMTYyOSwyNzY4OTQyNDQzLDkwMTA5NzcyMiwxMTE5MDAwNjg0LDM2ODY1MTcyMDYsMjg5ODA2NTcyOCw4NTMwNDQ0NTEsMTE3MjI2NjEwMSwzNzA1MDE1NzU5LDI4ODI2MTY2NjUsNjUxNzY3OTgwLDEzNzM1MDM1NDYsMzM2OTU1NDMwNCwzMjE4MTA0NTk4LDU2NTUwNzI1MywxNDU0NjIxNzMxLDM0ODUxMTE3MDUsMzA5OTQzNjMwMyw2NzEyNjY5NzQsMTU5NDE5ODAyNCwzMzIyNzMwOTMwLDI5NzAzNDc4MTIsNzk1ODM1NTI3LDE0ODMyMzAyMjUsMzI0NDM2NzI3NSwzMDYwMTQ5NTY1LDE5OTQxNDYxOTIsMzExNTg1MzQsMjU2MzkwNzc3Miw0MDIzNzE3OTMwLDE5MDc0NTk0NjUsMTEyNjM3MjE1LDI2ODAxNTMyNTMsMzkwNDQyNzA1OSwyMDEzNzc2MjkwLDI1MTcyMjAzNiwyNTE3MjE1Mzc0LDM3NzU4MzAwNDAsMjEzNzY1Njc2MywxNDEzNzY4MTMsMjQzOTI3NzcxOSwzODY1MjcxMjk3LDE4MDIxOTU0NDQsNDc2ODY0ODY2LDIyMzgwMDEzNjgsNDA2NjUwODg3OCwxODEyMzcwOTI1LDQ1MzA5MjczMSwyMTgxNjI1MDI1LDQxMTE0NTEyMjMsMTcwNjA4ODkwMiwzMTQwNDI3MDQsMjM0NDUzMjIwMiw0MjQwMDE3NTMyLDE2NTg2NTgyNzEsMzY2NjE5OTc3LDIzNjI2NzAzMjMsNDIyNDk5NDQwNSwxMzAzNTM1OTYwLDk4NDk2MTQ4NiwyNzQ3MDA3MDkyLDM1NjkwMzc1MzgsMTI1NjE3MDgxNywxMDM3NjA0MzExLDI3NjUyMTA3MzMsMzU1NDA3OTk5NSwxMTMxMDE0NTA2LDg3OTY3OTk5NiwyOTA5MjQzNDYyLDM2NjM3NzE4NTYsMTE0MTEyNDQ2Nyw4NTU4NDIyNzcsMjg1MjgwMTYzMSwzNzA4NjQ4NjQ5LDEzNDI1MzM5NDgsNjU0NDU5MzA2LDMxODgzOTYwNDgsMzM3MzAxNTE3NCwxNDY2NDc5OTA5LDU0NDE3OTYzNSwzMTEwNTIzOTEzLDM0NjI1MjIwMTUsMTU5MTY3MTA1NCw3MDIxMzg3NzYsMjk2NjQ2MDQ1MCwzMzUyNzk5NDEyLDE1MDQ5MTg4MDcsNzgzNTUxODczLDMwODI2NDA0NDMsMzIzMzQ0Mjk4OSwzOTg4MjkyMzg0LDI1OTYyNTQ2NDYsNjIzMTcwNjgsMTk1NzgxMDg0MiwzOTM5ODQ1OTQ1LDI2NDc4MTYxMTEsODE0NzA5OTcsMTk0MzgwMzUyMywzODE0OTE4OTMwLDI0ODk1OTY4MDQsMjI1Mjc0NDMwLDIwNTM3OTAzNzYsMzgyNjE3NTc1NSwyNDY2OTA2MDEzLDE2NzgxNjc0MywyMDk3NjUxMzc3LDQwMjc1NTI1ODAsMjI2NTQ5MDM4Niw1MDM0NDQwNzIsMTc2MjA1MDgxNCw0MTUwNDE3MjQ1LDIxNTQxMjkzNTUsNDI2NTIyMjI1LDE4NTI1MDc4NzksNDI3NTMxMzUyNiwyMzEyMzE3OTIwLDI4Mjc1MzYyNiwxNzQyNTU1ODUyLDQxODk3MDgxNDMsMjM5NDg3Nzk0NSwzOTc5MTc3NjMsMTYyMjE4MzYzNywzNjA0MzkwODg4LDI3MTQ4NjY1NTgsOTUzNzI5NzMyLDEzNDAwNzY2MjYsMzUxODcxOTk4NSwyNzk3MzYwOTk5LDEwNjg4MjgzODEsMTIxOTYzODg1OSwzNjI0NzQxODUwLDI5MzY2NzUxNDgsOTA2MTg1NDYyLDEwOTA4MTI1MTIsMzc0NzY3MjAwMywyODI1Mzc5NjY5LDgyOTMyOTEzNSwxMTgxMzM1MTYxLDM0MTIxNzc4MDQsMzE2MDgzNDg0Miw2MjgwODU0MDgsMTM4MjYwNTM2NiwzNDIzMzY5MTA5LDMxMzgwNzg0NjcsNTcwNTYyMjMzLDE0MjY0MDA4MTUsMzMxNzMxNjU0MiwyOTk4NzMzNjA4LDczMzIzOTk1NCwxNTU1MjYxOTU2LDMyNjg5MzU1OTEsMzA1MDM2MDYyNSw3NTI0NTk0MDMsMTU0MTMyMDIyMSwyNjA3MDcxOTIwLDM5NjU5NzMwMzAsMTk2OTkyMjk3Miw0MDczNTQ5OCwyNjE3ODM3MjI1LDM5NDM1NzcxNTEsMTkxMzA4Nzg3Nyw4MzkwODM3MSwyNTEyMzQxNjM0LDM4MDM3NDA2OTIsMjA3NTIwODYyMiwyMTMyNjExMTIsMjQ2MzI3MjYwMywzODU1OTkwMjg1LDIwOTQ4NTQwNzEsMTk4OTU4ODgxLDIyNjIwMjkwMTIsNDA1NzI2MDYxMCwxNzU5MzU5OTkyLDUzNDQxNDE5MCwyMTc2NzE4NTQxLDQxMzkzMjkxMTUsMTg3MzgzNjAwMSw0MTQ2NjQ1NjcsMjI4MjI0ODkzNCw0Mjc5MjAwMzY4LDE3MTE2ODQ1NTQsMjg1MjgxMTE2LDI0MDU4MDE3MjcsNDE2NzIxNjc0NSwxNjM0NDY3Nzk1LDM3NjIyOTcwMSwyNjg1MDY3ODk2LDM2MDgwMDc0MDYsMTMwODkxODYxMiw5NTY1NDM5MzgsMjgwODU1NTEwNSwzNDk1OTU4MjYzLDEyMzE2MzYzMDEsMTA0NzQyNzAzNSwyOTMyOTU5ODE4LDM2NTQ3MDM4MzYsMTA4ODM1OTI3MCw5MzY5MThlMywyODQ3NzE0ODk5LDM3MzY4Mzc4MjksMTIwMjkwMDg2Myw4MTcyMzM4OTcsMzE4MzM0MjEwOCwzNDAxMjM3MTMwLDE0MDQyNzc1NTIsNjE1ODE4MTUwLDMxMzQyMDc0OTMsMzQ1MzQyMTIwMywxNDIzODU3NDQ5LDYwMTQ1MDQzMSwzMDA5ODM3NjE0LDMyOTQ3MTA0NTYsMTU2NzEwMzc0Niw3MTE5Mjg3MjQsMzAyMDY2ODQ3MSwzMjcyMzgwMDY1LDE1MTAzMzQyMzUsNzU1MTY3MTE3XTtiLmV4cG9ydHM9ZnVuY3Rpb24oYSxiKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgYXx8IWEubGVuZ3RoKXJldHVybiAwO3ZhciBlPVwic3RyaW5nXCIhPT1jLmdldFR5cGVPZihhKTtcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9MCk7dmFyIGY9MCxnPTAsaD0wO2I9LTFeYjtmb3IodmFyIGk9MCxqPWEubGVuZ3RoO2o+aTtpKyspaD1lP2FbaV06YS5jaGFyQ29kZUF0KGkpLGc9MjU1JihiXmgpLGY9ZFtnXSxiPWI+Pj44XmY7cmV0dXJuLTFeYn19LHtcIi4vdXRpbHNcIjoyMX1dLDU6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYygpe3RoaXMuZGF0YT1udWxsLHRoaXMubGVuZ3RoPTAsdGhpcy5pbmRleD0wfXZhciBkPWEoXCIuL3V0aWxzXCIpO2MucHJvdG90eXBlPXtjaGVja09mZnNldDpmdW5jdGlvbihhKXt0aGlzLmNoZWNrSW5kZXgodGhpcy5pbmRleCthKX0sY2hlY2tJbmRleDpmdW5jdGlvbihhKXtpZih0aGlzLmxlbmd0aDxhfHwwPmEpdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIit0aGlzLmxlbmd0aCtcIiwgYXNrZWQgaW5kZXggPSBcIithK1wiKS4gQ29ycnVwdGVkIHppcCA/XCIpfSxzZXRJbmRleDpmdW5jdGlvbihhKXt0aGlzLmNoZWNrSW5kZXgoYSksdGhpcy5pbmRleD1hfSxza2lwOmZ1bmN0aW9uKGEpe3RoaXMuc2V0SW5kZXgodGhpcy5pbmRleCthKX0sYnl0ZUF0OmZ1bmN0aW9uKCl7fSxyZWFkSW50OmZ1bmN0aW9uKGEpe3ZhciBiLGM9MDtmb3IodGhpcy5jaGVja09mZnNldChhKSxiPXRoaXMuaW5kZXgrYS0xO2I+PXRoaXMuaW5kZXg7Yi0tKWM9KGM8PDgpK3RoaXMuYnl0ZUF0KGIpO3JldHVybiB0aGlzLmluZGV4Kz1hLGN9LHJlYWRTdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuIGQudHJhbnNmb3JtVG8oXCJzdHJpbmdcIix0aGlzLnJlYWREYXRhKGEpKX0scmVhZERhdGE6ZnVuY3Rpb24oKXt9LGxhc3RJbmRleE9mU2lnbmF0dXJlOmZ1bmN0aW9uKCl7fSxyZWFkRGF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMucmVhZEludCg0KTtyZXR1cm4gbmV3IERhdGUoKGE+PjI1JjEyNykrMTk4MCwoYT4+MjEmMTUpLTEsYT4+MTYmMzEsYT4+MTEmMzEsYT4+NSY2MywoMzEmYSk8PDEpfX0sYi5leHBvcnRzPWN9LHtcIi4vdXRpbHNcIjoyMX1dLDY6W2Z1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtjLmJhc2U2ND0hMSxjLmJpbmFyeT0hMSxjLmRpcj0hMSxjLmNyZWF0ZUZvbGRlcnM9ITEsYy5kYXRlPW51bGwsYy5jb21wcmVzc2lvbj1udWxsLGMuY29tcHJlc3Npb25PcHRpb25zPW51bGwsYy5jb21tZW50PW51bGwsYy51bml4UGVybWlzc2lvbnM9bnVsbCxjLmRvc1Blcm1pc3Npb25zPW51bGx9LHt9XSw3OltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGQ9YShcIi4vdXRpbHNcIik7Yy5zdHJpbmcyYmluYXJ5PWZ1bmN0aW9uKGEpe3JldHVybiBkLnN0cmluZzJiaW5hcnkoYSl9LGMuc3RyaW5nMlVpbnQ4QXJyYXk9ZnVuY3Rpb24oYSl7cmV0dXJuIGQudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsYSl9LGMudWludDhBcnJheTJTdHJpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIGQudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixhKX0sYy5zdHJpbmcyQmxvYj1mdW5jdGlvbihhKXt2YXIgYj1kLnRyYW5zZm9ybVRvKFwiYXJyYXlidWZmZXJcIixhKTtyZXR1cm4gZC5hcnJheUJ1ZmZlcjJCbG9iKGIpfSxjLmFycmF5QnVmZmVyMkJsb2I9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuYXJyYXlCdWZmZXIyQmxvYihhKX0sYy50cmFuc2Zvcm1Ubz1mdW5jdGlvbihhLGIpe3JldHVybiBkLnRyYW5zZm9ybVRvKGEsYil9LGMuZ2V0VHlwZU9mPWZ1bmN0aW9uKGEpe3JldHVybiBkLmdldFR5cGVPZihhKX0sYy5jaGVja1N1cHBvcnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuY2hlY2tTdXBwb3J0KGEpfSxjLk1BWF9WQUxVRV8xNkJJVFM9ZC5NQVhfVkFMVUVfMTZCSVRTLGMuTUFYX1ZBTFVFXzMyQklUUz1kLk1BWF9WQUxVRV8zMkJJVFMsYy5wcmV0dHk9ZnVuY3Rpb24oYSl7cmV0dXJuIGQucHJldHR5KGEpfSxjLmZpbmRDb21wcmVzc2lvbj1mdW5jdGlvbihhKXtyZXR1cm4gZC5maW5kQ29tcHJlc3Npb24oYSl9LGMuaXNSZWdFeHA9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuaXNSZWdFeHAoYSl9fSx7XCIuL3V0aWxzXCI6MjF9XSw4OltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50MTZBcnJheSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQzMkFycmF5LGU9YShcInBha29cIik7Yy51bmNvbXByZXNzSW5wdXRUeXBlPWQ/XCJ1aW50OGFycmF5XCI6XCJhcnJheVwiLGMuY29tcHJlc3NJbnB1dFR5cGU9ZD9cInVpbnQ4YXJyYXlcIjpcImFycmF5XCIsYy5tYWdpYz1cIlxcYlxceDAwXCIsYy5jb21wcmVzcz1mdW5jdGlvbihhLGIpe3JldHVybiBlLmRlZmxhdGVSYXcoYSx7bGV2ZWw6Yi5sZXZlbHx8LTF9KX0sYy51bmNvbXByZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBlLmluZmxhdGVSYXcoYSl9fSx7cGFrbzoyNH1dLDk6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhLGIpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgYz8odGhpcy5maWxlcz17fSx0aGlzLmNvbW1lbnQ9bnVsbCx0aGlzLnJvb3Q9XCJcIixhJiZ0aGlzLmxvYWQoYSxiKSx2b2lkKHRoaXMuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgYztmb3IodmFyIGIgaW4gdGhpcylcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2JdJiYoYVtiXT10aGlzW2JdKTtyZXR1cm4gYX0pKTpuZXcgYyhhLGIpfXZhciBkPWEoXCIuL2Jhc2U2NFwiKTtjLnByb3RvdHlwZT1hKFwiLi9vYmplY3RcIiksYy5wcm90b3R5cGUubG9hZD1hKFwiLi9sb2FkXCIpLGMuc3VwcG9ydD1hKFwiLi9zdXBwb3J0XCIpLGMuZGVmYXVsdHM9YShcIi4vZGVmYXVsdHNcIiksYy51dGlscz1hKFwiLi9kZXByZWNhdGVkUHVibGljVXRpbHNcIiksYy5iYXNlNjQ9e2VuY29kZTpmdW5jdGlvbihhKXtyZXR1cm4gZC5lbmNvZGUoYSl9LGRlY29kZTpmdW5jdGlvbihhKXtyZXR1cm4gZC5kZWNvZGUoYSl9fSxjLmNvbXByZXNzaW9ucz1hKFwiLi9jb21wcmVzc2lvbnNcIiksYi5leHBvcnRzPWN9LHtcIi4vYmFzZTY0XCI6MSxcIi4vY29tcHJlc3Npb25zXCI6MyxcIi4vZGVmYXVsdHNcIjo2LFwiLi9kZXByZWNhdGVkUHVibGljVXRpbHNcIjo3LFwiLi9sb2FkXCI6MTAsXCIuL29iamVjdFwiOjEzLFwiLi9zdXBwb3J0XCI6MTd9XSwxMDpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1hKFwiLi9iYXNlNjRcIiksZD1hKFwiLi96aXBFbnRyaWVzXCIpO2IuZXhwb3J0cz1mdW5jdGlvbihhLGIpe3ZhciBlLGYsZyxoO2ZvcihiPWJ8fHt9LGIuYmFzZTY0JiYoYT1jLmRlY29kZShhKSksZj1uZXcgZChhLGIpLGU9Zi5maWxlcyxnPTA7ZzxlLmxlbmd0aDtnKyspaD1lW2ddLHRoaXMuZmlsZShoLmZpbGVOYW1lLGguZGVjb21wcmVzc2VkLHtiaW5hcnk6ITAsb3B0aW1pemVkQmluYXJ5U3RyaW5nOiEwLGRhdGU6aC5kYXRlLGRpcjpoLmRpcixjb21tZW50OmguZmlsZUNvbW1lbnQubGVuZ3RoP2guZmlsZUNvbW1lbnQ6bnVsbCx1bml4UGVybWlzc2lvbnM6aC51bml4UGVybWlzc2lvbnMsZG9zUGVybWlzc2lvbnM6aC5kb3NQZXJtaXNzaW9ucyxjcmVhdGVGb2xkZXJzOmIuY3JlYXRlRm9sZGVyc30pO3JldHVybiBmLnppcENvbW1lbnQubGVuZ3RoJiYodGhpcy5jb21tZW50PWYuemlwQ29tbWVudCksdGhpc319LHtcIi4vYmFzZTY0XCI6MSxcIi4vemlwRW50cmllc1wiOjIyfV0sMTE6W2Z1bmN0aW9uKGEsYil7KGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2IuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiBuZXcgYShiLGMpfSxiLmV4cG9ydHMudGVzdD1mdW5jdGlvbihiKXtyZXR1cm4gYS5pc0J1ZmZlcihiKX19KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlcj9CdWZmZXI6dm9pZCAwKX0se31dLDEyOltmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGMoYSl7dGhpcy5kYXRhPWEsdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmluZGV4PTB9dmFyIGQ9YShcIi4vdWludDhBcnJheVJlYWRlclwiKTtjLnByb3RvdHlwZT1uZXcgZCxjLnByb3RvdHlwZS5yZWFkRGF0YT1mdW5jdGlvbihhKXt0aGlzLmNoZWNrT2Zmc2V0KGEpO3ZhciBiPXRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LHRoaXMuaW5kZXgrYSk7cmV0dXJuIHRoaXMuaW5kZXgrPWEsYn0sYi5leHBvcnRzPWN9LHtcIi4vdWludDhBcnJheVJlYWRlclwiOjE4fV0sMTM6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9YShcIi4vc3VwcG9ydFwiKSxkPWEoXCIuL3V0aWxzXCIpLGU9YShcIi4vY3JjMzJcIiksZj1hKFwiLi9zaWduYXR1cmVcIiksZz1hKFwiLi9kZWZhdWx0c1wiKSxoPWEoXCIuL2Jhc2U2NFwiKSxpPWEoXCIuL2NvbXByZXNzaW9uc1wiKSxqPWEoXCIuL2NvbXByZXNzZWRPYmplY3RcIiksaz1hKFwiLi9ub2RlQnVmZmVyXCIpLGw9YShcIi4vdXRmOFwiKSxtPWEoXCIuL3N0cmluZ1dyaXRlclwiKSxuPWEoXCIuL3VpbnQ4QXJyYXlXcml0ZXJcIiksbz1mdW5jdGlvbihhKXtpZihhLl9kYXRhIGluc3RhbmNlb2YgaiYmKGEuX2RhdGE9YS5fZGF0YS5nZXRDb250ZW50KCksYS5vcHRpb25zLmJpbmFyeT0hMCxhLm9wdGlvbnMuYmFzZTY0PSExLFwidWludDhhcnJheVwiPT09ZC5nZXRUeXBlT2YoYS5fZGF0YSkpKXt2YXIgYj1hLl9kYXRhO2EuX2RhdGE9bmV3IFVpbnQ4QXJyYXkoYi5sZW5ndGgpLDAhPT1iLmxlbmd0aCYmYS5fZGF0YS5zZXQoYiwwKX1yZXR1cm4gYS5fZGF0YX0scD1mdW5jdGlvbihhKXt2YXIgYj1vKGEpLGU9ZC5nZXRUeXBlT2YoYik7cmV0dXJuXCJzdHJpbmdcIj09PWU/IWEub3B0aW9ucy5iaW5hcnkmJmMubm9kZWJ1ZmZlcj9rKGIsXCJ1dGYtOFwiKTphLmFzQmluYXJ5KCk6Yn0scT1mdW5jdGlvbihhKXt2YXIgYj1vKHRoaXMpO3JldHVybiBudWxsPT09Ynx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGI/XCJcIjoodGhpcy5vcHRpb25zLmJhc2U2NCYmKGI9aC5kZWNvZGUoYikpLGI9YSYmdGhpcy5vcHRpb25zLmJpbmFyeT9ELnV0ZjhkZWNvZGUoYik6ZC50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLGIpLGF8fHRoaXMub3B0aW9ucy5iaW5hcnl8fChiPWQudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixELnV0ZjhlbmNvZGUoYikpKSxiKX0scj1mdW5jdGlvbihhLGIsYyl7dGhpcy5uYW1lPWEsdGhpcy5kaXI9Yy5kaXIsdGhpcy5kYXRlPWMuZGF0ZSx0aGlzLmNvbW1lbnQ9Yy5jb21tZW50LHRoaXMudW5peFBlcm1pc3Npb25zPWMudW5peFBlcm1pc3Npb25zLHRoaXMuZG9zUGVybWlzc2lvbnM9Yy5kb3NQZXJtaXNzaW9ucyx0aGlzLl9kYXRhPWIsdGhpcy5vcHRpb25zPWMsdGhpcy5faW5pdGlhbE1ldGFkYXRhPXtkaXI6Yy5kaXIsZGF0ZTpjLmRhdGV9fTtyLnByb3RvdHlwZT17YXNUZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHEuY2FsbCh0aGlzLCEwKX0sYXNCaW5hcnk6ZnVuY3Rpb24oKXtyZXR1cm4gcS5jYWxsKHRoaXMsITEpfSxhc05vZGVCdWZmZXI6ZnVuY3Rpb24oKXt2YXIgYT1wKHRoaXMpO3JldHVybiBkLnRyYW5zZm9ybVRvKFwibm9kZWJ1ZmZlclwiLGEpfSxhc1VpbnQ4QXJyYXk6ZnVuY3Rpb24oKXt2YXIgYT1wKHRoaXMpO3JldHVybiBkLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLGEpfSxhc0FycmF5QnVmZmVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNVaW50OEFycmF5KCkuYnVmZmVyfX07dmFyIHM9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVwiXCI7Zm9yKGM9MDtiPmM7YysrKWQrPVN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmEpLGE+Pj49ODtyZXR1cm4gZH0sdD1mdW5jdGlvbigpe3ZhciBhLGIsYz17fTtmb3IoYT0wO2E8YXJndW1lbnRzLmxlbmd0aDthKyspZm9yKGIgaW4gYXJndW1lbnRzW2FdKWFyZ3VtZW50c1thXS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNbYl0mJihjW2JdPWFyZ3VtZW50c1thXVtiXSk7cmV0dXJuIGN9LHU9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YXx8e30sYS5iYXNlNjQhPT0hMHx8bnVsbCE9PWEuYmluYXJ5JiZ2b2lkIDAhPT1hLmJpbmFyeXx8KGEuYmluYXJ5PSEwKSxhPXQoYSxnKSxhLmRhdGU9YS5kYXRlfHxuZXcgRGF0ZSxudWxsIT09YS5jb21wcmVzc2lvbiYmKGEuY29tcHJlc3Npb249YS5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpKSxhfSx2PWZ1bmN0aW9uKGEsYixjKXt2YXIgZSxmPWQuZ2V0VHlwZU9mKGIpO2lmKGM9dShjKSxcInN0cmluZ1wiPT10eXBlb2YgYy51bml4UGVybWlzc2lvbnMmJihjLnVuaXhQZXJtaXNzaW9ucz1wYXJzZUludChjLnVuaXhQZXJtaXNzaW9ucyw4KSksYy51bml4UGVybWlzc2lvbnMmJjE2Mzg0JmMudW5peFBlcm1pc3Npb25zJiYoYy5kaXI9ITApLGMuZG9zUGVybWlzc2lvbnMmJjE2JmMuZG9zUGVybWlzc2lvbnMmJihjLmRpcj0hMCksYy5kaXImJihhPXgoYSkpLGMuY3JlYXRlRm9sZGVycyYmKGU9dyhhKSkmJnkuY2FsbCh0aGlzLGUsITApLGMuZGlyfHxudWxsPT09Ynx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGIpYy5iYXNlNjQ9ITEsYy5iaW5hcnk9ITEsYj1udWxsLGY9bnVsbDtlbHNlIGlmKFwic3RyaW5nXCI9PT1mKWMuYmluYXJ5JiYhYy5iYXNlNjQmJmMub3B0aW1pemVkQmluYXJ5U3RyaW5nIT09ITAmJihiPWQuc3RyaW5nMmJpbmFyeShiKSk7ZWxzZXtpZihjLmJhc2U2ND0hMSxjLmJpbmFyeT0hMCwhKGZ8fGIgaW5zdGFuY2VvZiBqKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBvZiAnXCIrYStcIicgaXMgaW4gYW4gdW5zdXBwb3J0ZWQgZm9ybWF0ICFcIik7XCJhcnJheWJ1ZmZlclwiPT09ZiYmKGI9ZC50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIixiKSl9dmFyIGc9bmV3IHIoYSxiLGMpO3JldHVybiB0aGlzLmZpbGVzW2FdPWcsZ30sdz1mdW5jdGlvbihhKXtcIi9cIj09YS5zbGljZSgtMSkmJihhPWEuc3Vic3RyaW5nKDAsYS5sZW5ndGgtMSkpO3ZhciBiPWEubGFzdEluZGV4T2YoXCIvXCIpO3JldHVybiBiPjA/YS5zdWJzdHJpbmcoMCxiKTpcIlwifSx4PWZ1bmN0aW9uKGEpe3JldHVyblwiL1wiIT1hLnNsaWNlKC0xKSYmKGErPVwiL1wiKSxhfSx5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGI/YjohMSxhPXgoYSksdGhpcy5maWxlc1thXXx8di5jYWxsKHRoaXMsYSxudWxsLHtkaXI6ITAsY3JlYXRlRm9sZGVyczpifSksdGhpcy5maWxlc1thXX0sej1mdW5jdGlvbihhLGIsYyl7dmFyIGYsZz1uZXcgajtyZXR1cm4gYS5fZGF0YSBpbnN0YW5jZW9mIGo/KGcudW5jb21wcmVzc2VkU2l6ZT1hLl9kYXRhLnVuY29tcHJlc3NlZFNpemUsZy5jcmMzMj1hLl9kYXRhLmNyYzMyLDA9PT1nLnVuY29tcHJlc3NlZFNpemV8fGEuZGlyPyhiPWkuU1RPUkUsZy5jb21wcmVzc2VkQ29udGVudD1cIlwiLGcuY3JjMzI9MCk6YS5fZGF0YS5jb21wcmVzc2lvbk1ldGhvZD09PWIubWFnaWM/Zy5jb21wcmVzc2VkQ29udGVudD1hLl9kYXRhLmdldENvbXByZXNzZWRDb250ZW50KCk6KGY9YS5fZGF0YS5nZXRDb250ZW50KCksZy5jb21wcmVzc2VkQ29udGVudD1iLmNvbXByZXNzKGQudHJhbnNmb3JtVG8oYi5jb21wcmVzc0lucHV0VHlwZSxmKSxjKSkpOihmPXAoYSksKCFmfHwwPT09Zi5sZW5ndGh8fGEuZGlyKSYmKGI9aS5TVE9SRSxmPVwiXCIpLGcudW5jb21wcmVzc2VkU2l6ZT1mLmxlbmd0aCxnLmNyYzMyPWUoZiksZy5jb21wcmVzc2VkQ29udGVudD1iLmNvbXByZXNzKGQudHJhbnNmb3JtVG8oYi5jb21wcmVzc0lucHV0VHlwZSxmKSxjKSksZy5jb21wcmVzc2VkU2l6ZT1nLmNvbXByZXNzZWRDb250ZW50Lmxlbmd0aCxnLmNvbXByZXNzaW9uTWV0aG9kPWIubWFnaWMsZ30sQT1mdW5jdGlvbihhLGIpe3ZhciBjPWE7cmV0dXJuIGF8fChjPWI/MTY4OTM6MzMyMDQpLCg2NTUzNSZjKTw8MTZ9LEI9ZnVuY3Rpb24oYSl7cmV0dXJuIDYzJihhfHwwKX0sQz1mdW5jdGlvbihhLGIsYyxnLGgpe3ZhciBpLGosayxtLG49KGMuY29tcHJlc3NlZENvbnRlbnQsZC50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLGwudXRmOGVuY29kZShiLm5hbWUpKSksbz1iLmNvbW1lbnR8fFwiXCIscD1kLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsbC51dGY4ZW5jb2RlKG8pKSxxPW4ubGVuZ3RoIT09Yi5uYW1lLmxlbmd0aCxyPXAubGVuZ3RoIT09by5sZW5ndGgsdD1iLm9wdGlvbnMsdT1cIlwiLHY9XCJcIix3PVwiXCI7az1iLl9pbml0aWFsTWV0YWRhdGEuZGlyIT09Yi5kaXI/Yi5kaXI6dC5kaXIsbT1iLl9pbml0aWFsTWV0YWRhdGEuZGF0ZSE9PWIuZGF0ZT9iLmRhdGU6dC5kYXRlO3ZhciB4PTAseT0wO2smJih4fD0xNiksXCJVTklYXCI9PT1oPyh5PTc5OCx4fD1BKGIudW5peFBlcm1pc3Npb25zLGspKTooeT0yMCx4fD1CKGIuZG9zUGVybWlzc2lvbnMsaykpLGk9bS5nZXRIb3VycygpLGk8PD02LGl8PW0uZ2V0TWludXRlcygpLGk8PD01LGl8PW0uZ2V0U2Vjb25kcygpLzIsaj1tLmdldEZ1bGxZZWFyKCktMTk4MCxqPDw9NCxqfD1tLmdldE1vbnRoKCkrMSxqPDw9NSxqfD1tLmdldERhdGUoKSxxJiYodj1zKDEsMSkrcyhlKG4pLDQpK24sdSs9XCJ1cFwiK3Modi5sZW5ndGgsMikrdiksciYmKHc9cygxLDEpK3ModGhpcy5jcmMzMihwKSw0KStwLHUrPVwidWNcIitzKHcubGVuZ3RoLDIpK3cpO3ZhciB6PVwiXCI7eis9XCJcXG5cXHgwMFwiLHorPXF8fHI/XCJcXHgwMFxcYlwiOlwiXFx4MDBcXHgwMFwiLHorPWMuY29tcHJlc3Npb25NZXRob2Qseis9cyhpLDIpLHorPXMoaiwyKSx6Kz1zKGMuY3JjMzIsNCkseis9cyhjLmNvbXByZXNzZWRTaXplLDQpLHorPXMoYy51bmNvbXByZXNzZWRTaXplLDQpLHorPXMobi5sZW5ndGgsMikseis9cyh1Lmxlbmd0aCwyKTt2YXIgQz1mLkxPQ0FMX0ZJTEVfSEVBREVSK3orbit1LEQ9Zi5DRU5UUkFMX0ZJTEVfSEVBREVSK3MoeSwyKSt6K3MocC5sZW5ndGgsMikrXCJcXHgwMFxceDAwXFx4MDBcXHgwMFwiK3MoeCw0KStzKGcsNCkrbit1K3A7cmV0dXJue2ZpbGVSZWNvcmQ6QyxkaXJSZWNvcmQ6RCxjb21wcmVzc2VkT2JqZWN0OmN9fSxEPXtsb2FkOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTG9hZCBtZXRob2QgaXMgbm90IGRlZmluZWQuIElzIHRoZSBmaWxlIGpzemlwLWxvYWQuanMgaW5jbHVkZWQgP1wiKX0sZmlsdGVyOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGY9W107Zm9yKGIgaW4gdGhpcy5maWxlcyl0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGIpJiYoZD10aGlzLmZpbGVzW2JdLGU9bmV3IHIoZC5uYW1lLGQuX2RhdGEsdChkLm9wdGlvbnMpKSxjPWIuc2xpY2UodGhpcy5yb290Lmxlbmd0aCxiLmxlbmd0aCksYi5zbGljZSgwLHRoaXMucm9vdC5sZW5ndGgpPT09dGhpcy5yb290JiZhKGMsZSkmJmYucHVzaChlKSk7cmV0dXJuIGZ9LGZpbGU6ZnVuY3Rpb24oYSxiLGMpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihkLmlzUmVnRXhwKGEpKXt2YXIgZT1hO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihhLGIpe3JldHVybiFiLmRpciYmZS50ZXN0KGEpfSl9cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGIsYyl7cmV0dXJuIWMuZGlyJiZiPT09YX0pWzBdfHxudWxsfXJldHVybiBhPXRoaXMucm9vdCthLHYuY2FsbCh0aGlzLGEsYixjKSx0aGlzfSxmb2xkZXI6ZnVuY3Rpb24oYSl7aWYoIWEpcmV0dXJuIHRoaXM7aWYoZC5pc1JlZ0V4cChhKSlyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oYixjKXtyZXR1cm4gYy5kaXImJmEudGVzdChiKX0pO3ZhciBiPXRoaXMucm9vdCthLGM9eS5jYWxsKHRoaXMsYiksZT10aGlzLmNsb25lKCk7cmV0dXJuIGUucm9vdD1jLm5hbWUsZX0scmVtb3ZlOmZ1bmN0aW9uKGEpe2E9dGhpcy5yb290K2E7dmFyIGI9dGhpcy5maWxlc1thXTtpZihifHwoXCIvXCIhPWEuc2xpY2UoLTEpJiYoYSs9XCIvXCIpLGI9dGhpcy5maWxlc1thXSksYiYmIWIuZGlyKWRlbGV0ZSB0aGlzLmZpbGVzW2FdO2Vsc2UgZm9yKHZhciBjPXRoaXMuZmlsdGVyKGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGMubmFtZS5zbGljZSgwLGEubGVuZ3RoKT09PWF9KSxkPTA7ZDxjLmxlbmd0aDtkKyspZGVsZXRlIHRoaXMuZmlsZXNbY1tkXS5uYW1lXTtyZXR1cm4gdGhpc30sZ2VuZXJhdGU6ZnVuY3Rpb24oYSl7YT10KGF8fHt9LHtiYXNlNjQ6ITAsY29tcHJlc3Npb246XCJTVE9SRVwiLGNvbXByZXNzaW9uT3B0aW9uczpudWxsLHR5cGU6XCJiYXNlNjRcIixwbGF0Zm9ybTpcIkRPU1wiLGNvbW1lbnQ6bnVsbCxtaW1lVHlwZTpcImFwcGxpY2F0aW9uL3ppcFwifSksZC5jaGVja1N1cHBvcnQoYS50eXBlKSwoXCJkYXJ3aW5cIj09PWEucGxhdGZvcm18fFwiZnJlZWJzZFwiPT09YS5wbGF0Zm9ybXx8XCJsaW51eFwiPT09YS5wbGF0Zm9ybXx8XCJzdW5vc1wiPT09YS5wbGF0Zm9ybSkmJihhLnBsYXRmb3JtPVwiVU5JWFwiKSxcIndpbjMyXCI9PT1hLnBsYXRmb3JtJiYoYS5wbGF0Zm9ybT1cIkRPU1wiKTt2YXIgYixjLGU9W10sZz0wLGo9MCxrPWQudHJhbnNmb3JtVG8oXCJzdHJpbmdcIix0aGlzLnV0ZjhlbmNvZGUoYS5jb21tZW50fHx0aGlzLmNvbW1lbnR8fFwiXCIpKTtmb3IodmFyIGwgaW4gdGhpcy5maWxlcylpZih0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGwpKXt2YXIgbz10aGlzLmZpbGVzW2xdLHA9by5vcHRpb25zLmNvbXByZXNzaW9ufHxhLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCkscT1pW3BdO2lmKCFxKXRocm93IG5ldyBFcnJvcihwK1wiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO3ZhciByPW8ub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnN8fGEuY29tcHJlc3Npb25PcHRpb25zfHx7fSx1PXouY2FsbCh0aGlzLG8scSxyKSx2PUMuY2FsbCh0aGlzLGwsbyx1LGcsYS5wbGF0Zm9ybSk7Zys9di5maWxlUmVjb3JkLmxlbmd0aCt1LmNvbXByZXNzZWRTaXplLGorPXYuZGlyUmVjb3JkLmxlbmd0aCxlLnB1c2godil9dmFyIHc9XCJcIjt3PWYuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EK1wiXFx4MDBcXHgwMFxceDAwXFx4MDBcIitzKGUubGVuZ3RoLDIpK3MoZS5sZW5ndGgsMikrcyhqLDQpK3MoZyw0KStzKGsubGVuZ3RoLDIpK2s7dmFyIHg9YS50eXBlLnRvTG93ZXJDYXNlKCk7Zm9yKGI9XCJ1aW50OGFycmF5XCI9PT14fHxcImFycmF5YnVmZmVyXCI9PT14fHxcImJsb2JcIj09PXh8fFwibm9kZWJ1ZmZlclwiPT09eD9uZXcgbihnK2ordy5sZW5ndGgpOm5ldyBtKGcrait3Lmxlbmd0aCksYz0wO2M8ZS5sZW5ndGg7YysrKWIuYXBwZW5kKGVbY10uZmlsZVJlY29yZCksYi5hcHBlbmQoZVtjXS5jb21wcmVzc2VkT2JqZWN0LmNvbXByZXNzZWRDb250ZW50KTtmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKWIuYXBwZW5kKGVbY10uZGlyUmVjb3JkKTtiLmFwcGVuZCh3KTt2YXIgeT1iLmZpbmFsaXplKCk7c3dpdGNoKGEudHlwZS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJ1aW50OGFycmF5XCI6Y2FzZVwiYXJyYXlidWZmZXJcIjpjYXNlXCJub2RlYnVmZmVyXCI6cmV0dXJuIGQudHJhbnNmb3JtVG8oYS50eXBlLnRvTG93ZXJDYXNlKCkseSk7Y2FzZVwiYmxvYlwiOnJldHVybiBkLmFycmF5QnVmZmVyMkJsb2IoZC50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIseSksYS5taW1lVHlwZSk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGEuYmFzZTY0P2guZW5jb2RlKHkpOnk7ZGVmYXVsdDpyZXR1cm4geX19LGNyYzMyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGUoYSxiKX0sdXRmOGVuY29kZTpmdW5jdGlvbihhKXtyZXR1cm4gZC50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLGwudXRmOGVuY29kZShhKSl9LHV0ZjhkZWNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuIGwudXRmOGRlY29kZShhKX19O2IuZXhwb3J0cz1EfSx7XCIuL2Jhc2U2NFwiOjEsXCIuL2NvbXByZXNzZWRPYmplY3RcIjoyLFwiLi9jb21wcmVzc2lvbnNcIjozLFwiLi9jcmMzMlwiOjQsXCIuL2RlZmF1bHRzXCI6NixcIi4vbm9kZUJ1ZmZlclwiOjExLFwiLi9zaWduYXR1cmVcIjoxNCxcIi4vc3RyaW5nV3JpdGVyXCI6MTYsXCIuL3N1cHBvcnRcIjoxNyxcIi4vdWludDhBcnJheVdyaXRlclwiOjE5LFwiLi91dGY4XCI6MjAsXCIuL3V0aWxzXCI6MjF9XSwxNDpbZnVuY3Rpb24oYSxiLGMpe1widXNlIHN0cmljdFwiO2MuTE9DQUxfRklMRV9IRUFERVI9XCJQS1x1MDAwM1x1MDAwNFwiLGMuQ0VOVFJBTF9GSUxFX0hFQURFUj1cIlBLXHUwMDAxXHUwMDAyXCIsYy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQ9XCJQS1x1MDAwNVx1MDAwNlwiLGMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUj1cIlBLXHUwMDA2XHUwMDA3XCIsYy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQ9XCJQS1x1MDAwNlx1MDAwNlwiLGMuREFUQV9ERVNDUklQVE9SPVwiUEtcdTAwMDdcXGJcIn0se31dLDE1OltmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGMoYSxiKXt0aGlzLmRhdGE9YSxifHwodGhpcy5kYXRhPWUuc3RyaW5nMmJpbmFyeSh0aGlzLmRhdGEpKSx0aGlzLmxlbmd0aD10aGlzLmRhdGEubGVuZ3RoLHRoaXMuaW5kZXg9MH12YXIgZD1hKFwiLi9kYXRhUmVhZGVyXCIpLGU9YShcIi4vdXRpbHNcIik7Yy5wcm90b3R5cGU9bmV3IGQsYy5wcm90b3R5cGUuYnl0ZUF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdChhKX0sYy5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZGF0YS5sYXN0SW5kZXhPZihhKX0sYy5wcm90b3R5cGUucmVhZERhdGE9ZnVuY3Rpb24oYSl7dGhpcy5jaGVja09mZnNldChhKTt2YXIgYj10aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCx0aGlzLmluZGV4K2EpO3JldHVybiB0aGlzLmluZGV4Kz1hLGJ9LGIuZXhwb3J0cz1jfSx7XCIuL2RhdGFSZWFkZXJcIjo1LFwiLi91dGlsc1wiOjIxfV0sMTY6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9YShcIi4vdXRpbHNcIiksZD1mdW5jdGlvbigpe3RoaXMuZGF0YT1bXX07ZC5wcm90b3R5cGU9e2FwcGVuZDpmdW5jdGlvbihhKXthPWMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixhKSx0aGlzLmRhdGEucHVzaChhKX0sZmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLmpvaW4oXCJcIil9fSxiLmV4cG9ydHM9ZH0se1wiLi91dGlsc1wiOjIxfV0sMTc6W2Z1bmN0aW9uKGEsYixjKXsoZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7aWYoYy5iYXNlNjQ9ITAsYy5hcnJheT0hMCxjLnN0cmluZz0hMCxjLmFycmF5YnVmZmVyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXksYy5ub2RlYnVmZmVyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLGMudWludDhhcnJheT1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheSxcInVuZGVmaW5lZFwiPT10eXBlb2YgQXJyYXlCdWZmZXIpYy5ibG9iPSExO2Vsc2V7dmFyIGI9bmV3IEFycmF5QnVmZmVyKDApO3RyeXtjLmJsb2I9MD09PW5ldyBCbG9iKFtiXSx7dHlwZTpcImFwcGxpY2F0aW9uL3ppcFwifSkuc2l6ZX1jYXRjaChkKXt0cnl7dmFyIGU9d2luZG93LkJsb2JCdWlsZGVyfHx3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXJ8fHdpbmRvdy5Nb3pCbG9iQnVpbGRlcnx8d2luZG93Lk1TQmxvYkJ1aWxkZXIsZj1uZXcgZTtmLmFwcGVuZChiKSxjLmJsb2I9MD09PWYuZ2V0QmxvYihcImFwcGxpY2F0aW9uL3ppcFwiKS5zaXplfWNhdGNoKGQpe2MuYmxvYj0hMX19fX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyP0J1ZmZlcjp2b2lkIDApfSx7fV0sMTg6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhKXthJiYodGhpcy5kYXRhPWEsdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmluZGV4PTApfXZhciBkPWEoXCIuL2RhdGFSZWFkZXJcIik7Yy5wcm90b3R5cGU9bmV3IGQsYy5wcm90b3R5cGUuYnl0ZUF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmRhdGFbYV19LGMucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmNoYXJDb2RlQXQoMCksYz1hLmNoYXJDb2RlQXQoMSksZD1hLmNoYXJDb2RlQXQoMiksZT1hLmNoYXJDb2RlQXQoMyksZj10aGlzLmxlbmd0aC00O2Y+PTA7LS1mKWlmKHRoaXMuZGF0YVtmXT09PWImJnRoaXMuZGF0YVtmKzFdPT09YyYmdGhpcy5kYXRhW2YrMl09PT1kJiZ0aGlzLmRhdGFbZiszXT09PWUpcmV0dXJuIGY7cmV0dXJuLTF9LGMucHJvdG90eXBlLnJlYWREYXRhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY2hlY2tPZmZzZXQoYSksMD09PWEpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO3ZhciBiPXRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LHRoaXMuaW5kZXgrYSk7cmV0dXJuIHRoaXMuaW5kZXgrPWEsYn0sYi5leHBvcnRzPWN9LHtcIi4vZGF0YVJlYWRlclwiOjV9XSwxOTpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1hKFwiLi91dGlsc1wiKSxkPWZ1bmN0aW9uKGEpe3RoaXMuZGF0YT1uZXcgVWludDhBcnJheShhKSx0aGlzLmluZGV4PTB9O2QucHJvdG90eXBlPXthcHBlbmQ6ZnVuY3Rpb24oYSl7MCE9PWEubGVuZ3RoJiYoYT1jLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLGEpLHRoaXMuZGF0YS5zZXQoYSx0aGlzLmluZGV4KSx0aGlzLmluZGV4Kz1hLmxlbmd0aCl9LGZpbmFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX19LGIuZXhwb3J0cz1kfSx7XCIuL3V0aWxzXCI6MjF9XSwyMDpbZnVuY3Rpb24oYSxiLGMpe1widXNlIHN0cmljdFwiO2Zvcih2YXIgZD1hKFwiLi91dGlsc1wiKSxlPWEoXCIuL3N1cHBvcnRcIiksZj1hKFwiLi9ub2RlQnVmZmVyXCIpLGc9bmV3IEFycmF5KDI1NiksaD0wOzI1Nj5oO2grKylnW2hdPWg+PTI1Mj82Omg+PTI0OD81Omg+PTI0MD80Omg+PTIyND8zOmg+PTE5Mj8yOjE7Z1syNTRdPWdbMjU0XT0xO3ZhciBpPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxmLGcsaD1hLmxlbmd0aCxpPTA7Zm9yKGY9MDtoPmY7ZisrKWM9YS5jaGFyQ29kZUF0KGYpLDU1Mjk2PT09KDY0NTEyJmMpJiZoPmYrMSYmKGQ9YS5jaGFyQ29kZUF0KGYrMSksNTYzMjA9PT0oNjQ1MTImZCkmJihjPTY1NTM2KyhjLTU1Mjk2PDwxMCkrKGQtNTYzMjApLGYrKykpLGkrPTEyOD5jPzE6MjA0OD5jPzI6NjU1MzY+Yz8zOjQ7Zm9yKGI9ZS51aW50OGFycmF5P25ldyBVaW50OEFycmF5KGkpOm5ldyBBcnJheShpKSxnPTAsZj0wO2k+ZztmKyspYz1hLmNoYXJDb2RlQXQoZiksNTUyOTY9PT0oNjQ1MTImYykmJmg+ZisxJiYoZD1hLmNoYXJDb2RlQXQoZisxKSw1NjMyMD09PSg2NDUxMiZkKSYmKGM9NjU1MzYrKGMtNTUyOTY8PDEwKSsoZC01NjMyMCksZisrKSksMTI4PmM/YltnKytdPWM6MjA0OD5jPyhiW2crK109MTkyfGM+Pj42LGJbZysrXT0xMjh8NjMmYyk6NjU1MzY+Yz8oYltnKytdPTIyNHxjPj4+MTIsYltnKytdPTEyOHxjPj4+NiY2MyxiW2crK109MTI4fDYzJmMpOihiW2crK109MjQwfGM+Pj4xOCxiW2crK109MTI4fGM+Pj4xMiY2MyxiW2crK109MTI4fGM+Pj42JjYzLGJbZysrXT0xMjh8NjMmYyk7cmV0dXJuIGJ9LGo9ZnVuY3Rpb24oYSxiKXt2YXIgYztmb3IoYj1ifHxhLmxlbmd0aCxiPmEubGVuZ3RoJiYoYj1hLmxlbmd0aCksYz1iLTE7Yz49MCYmMTI4PT09KDE5MiZhW2NdKTspYy0tO3JldHVybiAwPmM/YjowPT09Yz9iOmMrZ1thW2NdXT5iP2M6Yn0saz1mdW5jdGlvbihhKXt2YXIgYixjLGUsZixoPWEubGVuZ3RoLGk9bmV3IEFycmF5KDIqaCk7Zm9yKGM9MCxiPTA7aD5iOylpZihlPWFbYisrXSwxMjg+ZSlpW2MrK109ZTtlbHNlIGlmKGY9Z1tlXSxmPjQpaVtjKytdPTY1NTMzLGIrPWYtMTtlbHNle2ZvcihlJj0yPT09Zj8zMTozPT09Zj8xNTo3O2Y+MSYmaD5iOyllPWU8PDZ8NjMmYVtiKytdLGYtLTtmPjE/aVtjKytdPTY1NTMzOjY1NTM2PmU/aVtjKytdPWU6KGUtPTY1NTM2LGlbYysrXT01NTI5NnxlPj4xMCYxMDIzLGlbYysrXT01NjMyMHwxMDIzJmUpfXJldHVybiBpLmxlbmd0aCE9PWMmJihpLnN1YmFycmF5P2k9aS5zdWJhcnJheSgwLGMpOmkubGVuZ3RoPWMpLGQuYXBwbHlGcm9tQ2hhckNvZGUoaSl9O2MudXRmOGVuY29kZT1mdW5jdGlvbihhKXtyZXR1cm4gZS5ub2RlYnVmZmVyP2YoYSxcInV0Zi04XCIpOmkoYSl9LGMudXRmOGRlY29kZT1mdW5jdGlvbihhKXtpZihlLm5vZGVidWZmZXIpcmV0dXJuIGQudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsYSkudG9TdHJpbmcoXCJ1dGYtOFwiKTthPWQudHJhbnNmb3JtVG8oZS51aW50OGFycmF5P1widWludDhhcnJheVwiOlwiYXJyYXlcIixhKTtmb3IodmFyIGI9W10sYz0wLGY9YS5sZW5ndGgsZz02NTUzNjtmPmM7KXt2YXIgaD1qKGEsTWF0aC5taW4oYytnLGYpKTtiLnB1c2goZS51aW50OGFycmF5P2soYS5zdWJhcnJheShjLGgpKTprKGEuc2xpY2UoYyxoKSkpLGM9aH1yZXR1cm4gYi5qb2luKFwiXCIpfX0se1wiLi9ub2RlQnVmZmVyXCI6MTEsXCIuL3N1cHBvcnRcIjoxNyxcIi4vdXRpbHNcIjoyMX1dLDIxOltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZChhKXtyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDsrK2MpYltjXT0yNTUmYS5jaGFyQ29kZUF0KGMpO3JldHVybiBifWZ1bmN0aW9uIGYoYSl7dmFyIGI9NjU1MzYsZD1bXSxlPWEubGVuZ3RoLGY9Yy5nZXRUeXBlT2YoYSksZz0wLGg9ITA7dHJ5e3N3aXRjaChmKXtjYXNlXCJ1aW50OGFycmF5XCI6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KDApKTticmVhaztjYXNlXCJub2RlYnVmZmVyXCI6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGooMCkpfX1jYXRjaChpKXtoPSExfWlmKCFoKXtmb3IodmFyIGs9XCJcIixsPTA7bDxhLmxlbmd0aDtsKyspays9U3RyaW5nLmZyb21DaGFyQ29kZShhW2xdKTtyZXR1cm4ga31mb3IoO2U+ZyYmYj4xOyl0cnl7ZC5wdXNoKFwiYXJyYXlcIj09PWZ8fFwibm9kZWJ1ZmZlclwiPT09Zj9TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsYS5zbGljZShnLE1hdGgubWluKGcrYixlKSkpOlN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxhLnN1YmFycmF5KGcsTWF0aC5taW4oZytiLGUpKSkpLGcrPWJ9Y2F0Y2goaSl7Yj1NYXRoLmZsb29yKGIvMil9cmV0dXJuIGQuam9pbihcIlwiKX1mdW5jdGlvbiBnKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYltjXT1hW2NdO3JldHVybiBifXZhciBoPWEoXCIuL3N1cHBvcnRcIiksaT1hKFwiLi9jb21wcmVzc2lvbnNcIiksaj1hKFwiLi9ub2RlQnVmZmVyXCIpO2Muc3RyaW5nMmJpbmFyeT1mdW5jdGlvbihhKXtmb3IodmFyIGI9XCJcIixjPTA7YzxhLmxlbmd0aDtjKyspYis9U3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmYS5jaGFyQ29kZUF0KGMpKTtyZXR1cm4gYn0sYy5hcnJheUJ1ZmZlcjJCbG9iPWZ1bmN0aW9uKGEsYil7Yy5jaGVja1N1cHBvcnQoXCJibG9iXCIpLGI9Ynx8XCJhcHBsaWNhdGlvbi96aXBcIjt0cnl7cmV0dXJuIG5ldyBCbG9iKFthXSx7dHlwZTpifSl9Y2F0Y2goZCl7dHJ5e3ZhciBlPXdpbmRvdy5CbG9iQnVpbGRlcnx8d2luZG93LldlYktpdEJsb2JCdWlsZGVyfHx3aW5kb3cuTW96QmxvYkJ1aWxkZXJ8fHdpbmRvdy5NU0Jsb2JCdWlsZGVyLGY9bmV3IGU7cmV0dXJuIGYuYXBwZW5kKGEpLGYuZ2V0QmxvYihiKX1jYXRjaChkKXt0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiBjYW4ndCBjb25zdHJ1Y3QgdGhlIEJsb2IuXCIpfX19LGMuYXBwbHlGcm9tQ2hhckNvZGU9Zjt2YXIgaz17fTtrLnN0cmluZz17c3RyaW5nOmQsYXJyYXk6ZnVuY3Rpb24oYSl7cmV0dXJuIGUoYSxuZXcgQXJyYXkoYS5sZW5ndGgpKX0sYXJyYXlidWZmZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGsuc3RyaW5nLnVpbnQ4YXJyYXkoYSkuYnVmZmVyfSx1aW50OGFycmF5OmZ1bmN0aW9uKGEpe3JldHVybiBlKGEsbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpKX0sbm9kZWJ1ZmZlcjpmdW5jdGlvbihhKXtyZXR1cm4gZShhLGooYS5sZW5ndGgpKX19LGsuYXJyYXk9e3N0cmluZzpmLGFycmF5OmQsYXJyYXlidWZmZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGEpLmJ1ZmZlcn0sdWludDhhcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSl9LG5vZGVidWZmZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGooYSl9fSxrLmFycmF5YnVmZmVyPXtzdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuIGYobmV3IFVpbnQ4QXJyYXkoYSkpfSxhcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gZyhuZXcgVWludDhBcnJheShhKSxuZXcgQXJyYXkoYS5ieXRlTGVuZ3RoKSl9LGFycmF5YnVmZmVyOmQsdWludDhhcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSl9LG5vZGVidWZmZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGoobmV3IFVpbnQ4QXJyYXkoYSkpfX0say51aW50OGFycmF5PXtzdHJpbmc6ZixhcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gZyhhLG5ldyBBcnJheShhLmxlbmd0aCkpfSxhcnJheWJ1ZmZlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5idWZmZXJ9LHVpbnQ4YXJyYXk6ZCxub2RlYnVmZmVyOmZ1bmN0aW9uKGEpe3JldHVybiBqKGEpfX0say5ub2RlYnVmZmVyPXtzdHJpbmc6ZixhcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gZyhhLG5ldyBBcnJheShhLmxlbmd0aCkpfSxhcnJheWJ1ZmZlcjpmdW5jdGlvbihhKXtyZXR1cm4gay5ub2RlYnVmZmVyLnVpbnQ4YXJyYXkoYSkuYnVmZmVyfSx1aW50OGFycmF5OmZ1bmN0aW9uKGEpe3JldHVybiBnKGEsbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpKX0sbm9kZWJ1ZmZlcjpkfSxjLnRyYW5zZm9ybVRvPWZ1bmN0aW9uKGEsYil7aWYoYnx8KGI9XCJcIiksIWEpcmV0dXJuIGI7Yy5jaGVja1N1cHBvcnQoYSk7dmFyIGQ9Yy5nZXRUeXBlT2YoYiksZT1rW2RdW2FdKGIpO3JldHVybiBlfSxjLmdldFR5cGVPZj1mdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT9cInN0cmluZ1wiOlwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKT9cImFycmF5XCI6aC5ub2RlYnVmZmVyJiZqLnRlc3QoYSk/XCJub2RlYnVmZmVyXCI6aC51aW50OGFycmF5JiZhIGluc3RhbmNlb2YgVWludDhBcnJheT9cInVpbnQ4YXJyYXlcIjpoLmFycmF5YnVmZmVyJiZhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/XCJhcnJheWJ1ZmZlclwiOnZvaWQgMH0sYy5jaGVja1N1cHBvcnQ9ZnVuY3Rpb24oYSl7dmFyIGI9aFthLnRvTG93ZXJDYXNlKCldO2lmKCFiKXRocm93IG5ldyBFcnJvcihhK1wiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXCIpfSxjLk1BWF9WQUxVRV8xNkJJVFM9NjU1MzUsYy5NQVhfVkFMVUVfMzJCSVRTPS0xLGMucHJldHR5PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD1cIlwiO2ZvcihjPTA7YzwoYXx8XCJcIikubGVuZ3RoO2MrKyliPWEuY2hhckNvZGVBdChjKSxkKz1cIlxcXFx4XCIrKDE2PmI/XCIwXCI6XCJcIikrYi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtyZXR1cm4gZH0sYy5maW5kQ29tcHJlc3Npb249ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIGkpaWYoaS5oYXNPd25Qcm9wZXJ0eShiKSYmaVtiXS5tYWdpYz09PWEpcmV0dXJuIGlbYl07cmV0dXJuIG51bGx9LGMuaXNSZWdFeHA9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IFJlZ0V4cF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKX19LHtcIi4vY29tcHJlc3Npb25zXCI6MyxcIi4vbm9kZUJ1ZmZlclwiOjExLFwiLi9zdXBwb3J0XCI6MTd9XSwyMjpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKGEsYil7dGhpcy5maWxlcz1bXSx0aGlzLmxvYWRPcHRpb25zPWIsYSYmdGhpcy5sb2FkKGEpfXZhciBkPWEoXCIuL3N0cmluZ1JlYWRlclwiKSxlPWEoXCIuL25vZGVCdWZmZXJSZWFkZXJcIiksZj1hKFwiLi91aW50OEFycmF5UmVhZGVyXCIpLGc9YShcIi4vdXRpbHNcIiksaD1hKFwiLi9zaWduYXR1cmVcIiksaT1hKFwiLi96aXBFbnRyeVwiKSxqPWEoXCIuL3N1cHBvcnRcIiksaz1hKFwiLi9vYmplY3RcIik7Yy5wcm90b3R5cGU9e2NoZWNrU2lnbmF0dXJlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7aWYoYiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWcgOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSAoXCIrZy5wcmV0dHkoYikrXCIsIGV4cGVjdGVkIFwiK2cucHJldHR5KGEpK1wiKVwiKX0scmVhZEJsb2NrRW5kT2ZDZW50cmFsOmZ1bmN0aW9uKCl7dGhpcy5kaXNrTnVtYmVyPXRoaXMucmVhZGVyLnJlYWRJbnQoMiksdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydD10aGlzLnJlYWRlci5yZWFkSW50KDIpLHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrPXRoaXMucmVhZGVyLnJlYWRJbnQoMiksdGhpcy5jZW50cmFsRGlyUmVjb3Jkcz10aGlzLnJlYWRlci5yZWFkSW50KDIpLHRoaXMuY2VudHJhbERpclNpemU9dGhpcy5yZWFkZXIucmVhZEludCg0KSx0aGlzLmNlbnRyYWxEaXJPZmZzZXQ9dGhpcy5yZWFkZXIucmVhZEludCg0KSx0aGlzLnppcENvbW1lbnRMZW5ndGg9dGhpcy5yZWFkZXIucmVhZEludCgyKSx0aGlzLnppcENvbW1lbnQ9dGhpcy5yZWFkZXIucmVhZFN0cmluZyh0aGlzLnppcENvbW1lbnRMZW5ndGgpLHRoaXMuemlwQ29tbWVudD1rLnV0ZjhkZWNvZGUodGhpcy56aXBDb21tZW50KX0scmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6ZnVuY3Rpb24oKXt0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZT10aGlzLnJlYWRlci5yZWFkSW50KDgpLHRoaXMudmVyc2lvbk1hZGVCeT10aGlzLnJlYWRlci5yZWFkU3RyaW5nKDIpLHRoaXMudmVyc2lvbk5lZWRlZD10aGlzLnJlYWRlci5yZWFkSW50KDIpLHRoaXMuZGlza051bWJlcj10aGlzLnJlYWRlci5yZWFkSW50KDQpLHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQ9dGhpcy5yZWFkZXIucmVhZEludCg0KSx0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzaz10aGlzLnJlYWRlci5yZWFkSW50KDgpLHRoaXMuY2VudHJhbERpclJlY29yZHM9dGhpcy5yZWFkZXIucmVhZEludCg4KSx0aGlzLmNlbnRyYWxEaXJTaXplPXRoaXMucmVhZGVyLnJlYWRJbnQoOCksdGhpcy5jZW50cmFsRGlyT2Zmc2V0PXRoaXMucmVhZGVyLnJlYWRJbnQoOCksdGhpcy56aXA2NEV4dGVuc2libGVEYXRhPXt9O2Zvcih2YXIgYSxiLGMsZD10aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZS00NCxlPTA7ZD5lOylhPXRoaXMucmVhZGVyLnJlYWRJbnQoMiksYj10aGlzLnJlYWRlci5yZWFkSW50KDQpLGM9dGhpcy5yZWFkZXIucmVhZFN0cmluZyhiKSx0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbYV09e2lkOmEsbGVuZ3RoOmIsdmFsdWU6Y319LHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjpmdW5jdGlvbigpe2lmKHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydD10aGlzLnJlYWRlci5yZWFkSW50KDQpLHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcj10aGlzLnJlYWRlci5yZWFkSW50KDgpLHRoaXMuZGlza3NDb3VudD10aGlzLnJlYWRlci5yZWFkSW50KDQpLHRoaXMuZGlza3NDb3VudD4xKXRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpfSxyZWFkTG9jYWxGaWxlczpmdW5jdGlvbigpe3ZhciBhLGI7Zm9yKGE9MDthPHRoaXMuZmlsZXMubGVuZ3RoO2ErKyliPXRoaXMuZmlsZXNbYV0sdGhpcy5yZWFkZXIuc2V0SW5kZXgoYi5sb2NhbEhlYWRlck9mZnNldCksdGhpcy5jaGVja1NpZ25hdHVyZShoLkxPQ0FMX0ZJTEVfSEVBREVSKSxiLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpLGIuaGFuZGxlVVRGOCgpLGIucHJvY2Vzc0F0dHJpYnV0ZXMoKX0scmVhZENlbnRyYWxEaXI6ZnVuY3Rpb24oKXt2YXIgYTtmb3IodGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTt0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpPT09aC5DRU5UUkFMX0ZJTEVfSEVBREVSOylhPW5ldyBpKHt6aXA2NDp0aGlzLnppcDY0fSx0aGlzLmxvYWRPcHRpb25zKSxhLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlciksdGhpcy5maWxlcy5wdXNoKGEpfSxyZWFkRW5kT2ZDZW50cmFsOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoaC5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO2lmKC0xPT09YSl7dmFyIGI9ITA7dHJ5e3RoaXMucmVhZGVyLnNldEluZGV4KDApLHRoaXMuY2hlY2tTaWduYXR1cmUoaC5MT0NBTF9GSUxFX0hFQURFUiksYj0hMX1jYXRjaChjKXt9dGhyb3cgbmV3IEVycm9yKGI/XCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IElmIGl0IGlzLCBzZWUgaHR0cDovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiOlwiQ29ycnVwdGVkIHppcCA6IGNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpfWlmKHRoaXMucmVhZGVyLnNldEluZGV4KGEpLHRoaXMuY2hlY2tTaWduYXR1cmUoaC5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpLHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCksdGhpcy5kaXNrTnVtYmVyPT09Zy5NQVhfVkFMVUVfMTZCSVRTfHx0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0PT09Zy5NQVhfVkFMVUVfMTZCSVRTfHx0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzaz09PWcuTUFYX1ZBTFVFXzE2QklUU3x8dGhpcy5jZW50cmFsRGlyUmVjb3Jkcz09PWcuTUFYX1ZBTFVFXzE2QklUU3x8dGhpcy5jZW50cmFsRGlyU2l6ZT09PWcuTUFYX1ZBTFVFXzMyQklUU3x8dGhpcy5jZW50cmFsRGlyT2Zmc2V0PT09Zy5NQVhfVkFMVUVfMzJCSVRTKXtpZih0aGlzLnppcDY0PSEwLGE9dGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoaC5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKSwtMT09PWEpdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO3RoaXMucmVhZGVyLnNldEluZGV4KGEpLHRoaXMuY2hlY2tTaWduYXR1cmUoaC5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKSx0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcigpLHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciksdGhpcy5jaGVja1NpZ25hdHVyZShoLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCksdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpfX0scHJlcGFyZVJlYWRlcjpmdW5jdGlvbihhKXt2YXIgYj1nLmdldFR5cGVPZihhKTt0aGlzLnJlYWRlcj1cInN0cmluZ1wiIT09Ynx8ai51aW50OGFycmF5P1wibm9kZWJ1ZmZlclwiPT09Yj9uZXcgZShhKTpuZXcgZihnLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLGEpKTpuZXcgZChhLHRoaXMubG9hZE9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nKX0sbG9hZDpmdW5jdGlvbihhKXt0aGlzLnByZXBhcmVSZWFkZXIoYSksdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCksdGhpcy5yZWFkQ2VudHJhbERpcigpLHRoaXMucmVhZExvY2FsRmlsZXMoKX19LGIuZXhwb3J0cz1jfSx7XCIuL25vZGVCdWZmZXJSZWFkZXJcIjoxMixcIi4vb2JqZWN0XCI6MTMsXCIuL3NpZ25hdHVyZVwiOjE0LFwiLi9zdHJpbmdSZWFkZXJcIjoxNSxcIi4vc3VwcG9ydFwiOjE3LFwiLi91aW50OEFycmF5UmVhZGVyXCI6MTgsXCIuL3V0aWxzXCI6MjEsXCIuL3ppcEVudHJ5XCI6MjN9XSwyMzpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKGEsYil7dGhpcy5vcHRpb25zPWEsdGhpcy5sb2FkT3B0aW9ucz1ifXZhciBkPWEoXCIuL3N0cmluZ1JlYWRlclwiKSxlPWEoXCIuL3V0aWxzXCIpLGY9YShcIi4vY29tcHJlc3NlZE9iamVjdFwiKSxnPWEoXCIuL29iamVjdFwiKSxoPTAsaT0zO2MucHJvdG90eXBlPXtpc0VuY3J5cHRlZDpmdW5jdGlvbigpe3JldHVybiAxPT09KDEmdGhpcy5iaXRGbGFnKX0sdXNlVVRGODpmdW5jdGlvbigpe3JldHVybiAyMDQ4PT09KDIwNDgmdGhpcy5iaXRGbGFnKX0scHJlcGFyZUNvbXByZXNzZWRDb250ZW50OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZD1hLmluZGV4O2Euc2V0SW5kZXgoYik7dmFyIGU9YS5yZWFkRGF0YShjKTtyZXR1cm4gYS5zZXRJbmRleChkKSxlfX0scHJlcGFyZUNvbnRlbnQ6ZnVuY3Rpb24oYSxiLGMsZCxmKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYT1lLnRyYW5zZm9ybVRvKGQudW5jb21wcmVzc0lucHV0VHlwZSx0aGlzLmdldENvbXByZXNzZWRDb250ZW50KCkpLGI9ZC51bmNvbXByZXNzKGEpO2lmKGIubGVuZ3RoIT09Zil0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO3JldHVybiBifX0scmVhZExvY2FsUGFydDpmdW5jdGlvbihhKXt2YXIgYixjO2lmKGEuc2tpcCgyMiksdGhpcy5maWxlTmFtZUxlbmd0aD1hLnJlYWRJbnQoMiksYz1hLnJlYWRJbnQoMiksdGhpcy5maWxlTmFtZT1hLnJlYWRTdHJpbmcodGhpcy5maWxlTmFtZUxlbmd0aCksYS5za2lwKGMpLC0xPT10aGlzLmNvbXByZXNzZWRTaXplfHwtMT09dGhpcy51bmNvbXByZXNzZWRTaXplKXRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IChjb21wcmVzc2VkU2l6ZSA9PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09IC0xKVwiKTtpZihiPWUuZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpLG51bGw9PT1iKXRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIitlLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKStcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIrdGhpcy5maWxlTmFtZStcIilcIik7aWYodGhpcy5kZWNvbXByZXNzZWQ9bmV3IGYsdGhpcy5kZWNvbXByZXNzZWQuY29tcHJlc3NlZFNpemU9dGhpcy5jb21wcmVzc2VkU2l6ZSx0aGlzLmRlY29tcHJlc3NlZC51bmNvbXByZXNzZWRTaXplPXRoaXMudW5jb21wcmVzc2VkU2l6ZSx0aGlzLmRlY29tcHJlc3NlZC5jcmMzMj10aGlzLmNyYzMyLHRoaXMuZGVjb21wcmVzc2VkLmNvbXByZXNzaW9uTWV0aG9kPXRoaXMuY29tcHJlc3Npb25NZXRob2QsdGhpcy5kZWNvbXByZXNzZWQuZ2V0Q29tcHJlc3NlZENvbnRlbnQ9dGhpcy5wcmVwYXJlQ29tcHJlc3NlZENvbnRlbnQoYSxhLmluZGV4LHRoaXMuY29tcHJlc3NlZFNpemUsYiksdGhpcy5kZWNvbXByZXNzZWQuZ2V0Q29udGVudD10aGlzLnByZXBhcmVDb250ZW50KGEsYS5pbmRleCx0aGlzLmNvbXByZXNzZWRTaXplLGIsdGhpcy51bmNvbXByZXNzZWRTaXplKSx0aGlzLmxvYWRPcHRpb25zLmNoZWNrQ1JDMzImJih0aGlzLmRlY29tcHJlc3NlZD1lLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsdGhpcy5kZWNvbXByZXNzZWQuZ2V0Q29udGVudCgpKSxnLmNyYzMyKHRoaXMuZGVjb21wcmVzc2VkKSE9PXRoaXMuY3JjMzIpKXRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKX0scmVhZENlbnRyYWxQYXJ0OmZ1bmN0aW9uKGEpe2lmKHRoaXMudmVyc2lvbk1hZGVCeT1hLnJlYWRJbnQoMiksdGhpcy52ZXJzaW9uTmVlZGVkPWEucmVhZEludCgyKSx0aGlzLmJpdEZsYWc9YS5yZWFkSW50KDIpLHRoaXMuY29tcHJlc3Npb25NZXRob2Q9YS5yZWFkU3RyaW5nKDIpLHRoaXMuZGF0ZT1hLnJlYWREYXRlKCksdGhpcy5jcmMzMj1hLnJlYWRJbnQoNCksdGhpcy5jb21wcmVzc2VkU2l6ZT1hLnJlYWRJbnQoNCksdGhpcy51bmNvbXByZXNzZWRTaXplPWEucmVhZEludCg0KSx0aGlzLmZpbGVOYW1lTGVuZ3RoPWEucmVhZEludCgyKSx0aGlzLmV4dHJhRmllbGRzTGVuZ3RoPWEucmVhZEludCgyKSx0aGlzLmZpbGVDb21tZW50TGVuZ3RoPWEucmVhZEludCgyKSx0aGlzLmRpc2tOdW1iZXJTdGFydD1hLnJlYWRJbnQoMiksdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzPWEucmVhZEludCgyKSx0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXM9YS5yZWFkSW50KDQpLHRoaXMubG9jYWxIZWFkZXJPZmZzZXQ9YS5yZWFkSW50KDQpLHRoaXMuaXNFbmNyeXB0ZWQoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO3RoaXMuZmlsZU5hbWU9YS5yZWFkU3RyaW5nKHRoaXMuZmlsZU5hbWVMZW5ndGgpLHRoaXMucmVhZEV4dHJhRmllbGRzKGEpLHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQoYSksdGhpcy5maWxlQ29tbWVudD1hLnJlYWRTdHJpbmcodGhpcy5maWxlQ29tbWVudExlbmd0aCl9LHByb2Nlc3NBdHRyaWJ1dGVzOmZ1bmN0aW9uKCl7dGhpcy51bml4UGVybWlzc2lvbnM9bnVsbCx0aGlzLmRvc1Blcm1pc3Npb25zPW51bGw7dmFyIGE9dGhpcy52ZXJzaW9uTWFkZUJ5Pj44O3RoaXMuZGlyPTE2JnRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcz8hMDohMSxhPT09aCYmKHRoaXMuZG9zUGVybWlzc2lvbnM9NjMmdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzKSxhPT09aSYmKHRoaXMudW5peFBlcm1pc3Npb25zPXRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcz4+MTYmNjU1MzUpLHRoaXMuZGlyfHxcIi9cIiE9PXRoaXMuZmlsZU5hbWUuc2xpY2UoLTEpfHwodGhpcy5kaXI9ITApfSxwYXJzZVpJUDY0RXh0cmFGaWVsZDpmdW5jdGlvbigpe2lmKHRoaXMuZXh0cmFGaWVsZHNbMV0pe3ZhciBhPW5ldyBkKHRoaXMuZXh0cmFGaWVsZHNbMV0udmFsdWUpO3RoaXMudW5jb21wcmVzc2VkU2l6ZT09PWUuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMudW5jb21wcmVzc2VkU2l6ZT1hLnJlYWRJbnQoOCkpLHRoaXMuY29tcHJlc3NlZFNpemU9PT1lLk1BWF9WQUxVRV8zMkJJVFMmJih0aGlzLmNvbXByZXNzZWRTaXplPWEucmVhZEludCg4KSksdGhpcy5sb2NhbEhlYWRlck9mZnNldD09PWUuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQ9YS5yZWFkSW50KDgpKSx0aGlzLmRpc2tOdW1iZXJTdGFydD09PWUuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMuZGlza051bWJlclN0YXJ0PWEucmVhZEludCg0KSl9fSxyZWFkRXh0cmFGaWVsZHM6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9YS5pbmRleDtmb3IodGhpcy5leHRyYUZpZWxkcz10aGlzLmV4dHJhRmllbGRzfHx7fTthLmluZGV4PGUrdGhpcy5leHRyYUZpZWxkc0xlbmd0aDspYj1hLnJlYWRJbnQoMiksYz1hLnJlYWRJbnQoMiksZD1hLnJlYWRTdHJpbmcoYyksdGhpcy5leHRyYUZpZWxkc1tiXT17aWQ6YixsZW5ndGg6Yyx2YWx1ZTpkfX0saGFuZGxlVVRGODpmdW5jdGlvbigpe2lmKHRoaXMudXNlVVRGOCgpKXRoaXMuZmlsZU5hbWU9Zy51dGY4ZGVjb2RlKHRoaXMuZmlsZU5hbWUpLHRoaXMuZmlsZUNvbW1lbnQ9Zy51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO2Vsc2V7dmFyIGE9dGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7bnVsbCE9PWEmJih0aGlzLmZpbGVOYW1lPWEpO3ZhciBiPXRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO251bGwhPT1iJiYodGhpcy5maWxlQ29tbWVudD1iKX19LGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmV4dHJhRmllbGRzWzI4Nzg5XTtpZihhKXt2YXIgYj1uZXcgZChhLnZhbHVlKTtyZXR1cm4gMSE9PWIucmVhZEludCgxKT9udWxsOmcuY3JjMzIodGhpcy5maWxlTmFtZSkhPT1iLnJlYWRJbnQoNCk/bnVsbDpnLnV0ZjhkZWNvZGUoYi5yZWFkU3RyaW5nKGEubGVuZ3RoLTUpKVxyXG59cmV0dXJuIG51bGx9LGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmV4dHJhRmllbGRzWzI1NDYxXTtpZihhKXt2YXIgYj1uZXcgZChhLnZhbHVlKTtyZXR1cm4gMSE9PWIucmVhZEludCgxKT9udWxsOmcuY3JjMzIodGhpcy5maWxlQ29tbWVudCkhPT1iLnJlYWRJbnQoNCk/bnVsbDpnLnV0ZjhkZWNvZGUoYi5yZWFkU3RyaW5nKGEubGVuZ3RoLTUpKX1yZXR1cm4gbnVsbH19LGIuZXhwb3J0cz1jfSx7XCIuL2NvbXByZXNzZWRPYmplY3RcIjoyLFwiLi9vYmplY3RcIjoxMyxcIi4vc3RyaW5nUmVhZGVyXCI6MTUsXCIuL3V0aWxzXCI6MjF9XSwyNDpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1hKFwiLi9saWIvdXRpbHMvY29tbW9uXCIpLmFzc2lnbixkPWEoXCIuL2xpYi9kZWZsYXRlXCIpLGU9YShcIi4vbGliL2luZmxhdGVcIiksZj1hKFwiLi9saWIvemxpYi9jb25zdGFudHNcIiksZz17fTtjKGcsZCxlLGYpLGIuZXhwb3J0cz1nfSx7XCIuL2xpYi9kZWZsYXRlXCI6MjUsXCIuL2xpYi9pbmZsYXRlXCI6MjYsXCIuL2xpYi91dGlscy9jb21tb25cIjoyNyxcIi4vbGliL3psaWIvY29uc3RhbnRzXCI6MzB9XSwyNTpbZnVuY3Rpb24oYSxiLGMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGQoYSxiKXt2YXIgYz1uZXcgcyhiKTtpZihjLnB1c2goYSwhMCksYy5lcnIpdGhyb3cgYy5tc2c7cmV0dXJuIGMucmVzdWx0fWZ1bmN0aW9uIGUoYSxiKXtyZXR1cm4gYj1ifHx7fSxiLnJhdz0hMCxkKGEsYil9ZnVuY3Rpb24gZihhLGIpe3JldHVybiBiPWJ8fHt9LGIuZ3ppcD0hMCxkKGEsYil9dmFyIGc9YShcIi4vemxpYi9kZWZsYXRlLmpzXCIpLGg9YShcIi4vdXRpbHMvY29tbW9uXCIpLGk9YShcIi4vdXRpbHMvc3RyaW5nc1wiKSxqPWEoXCIuL3psaWIvbWVzc2FnZXNcIiksaz1hKFwiLi96bGliL3pzdHJlYW1cIiksbD0wLG09NCxuPTAsbz0xLHA9LTEscT0wLHI9OCxzPWZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz1oLmFzc2lnbih7bGV2ZWw6cCxtZXRob2Q6cixjaHVua1NpemU6MTYzODQsd2luZG93Qml0czoxNSxtZW1MZXZlbDo4LHN0cmF0ZWd5OnEsdG86XCJcIn0sYXx8e30pO3ZhciBiPXRoaXMub3B0aW9ucztiLnJhdyYmYi53aW5kb3dCaXRzPjA/Yi53aW5kb3dCaXRzPS1iLndpbmRvd0JpdHM6Yi5nemlwJiZiLndpbmRvd0JpdHM+MCYmYi53aW5kb3dCaXRzPDE2JiYoYi53aW5kb3dCaXRzKz0xNiksdGhpcy5lcnI9MCx0aGlzLm1zZz1cIlwiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyBrLHRoaXMuc3RybS5hdmFpbF9vdXQ9MDt2YXIgYz1nLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sYi5sZXZlbCxiLm1ldGhvZCxiLndpbmRvd0JpdHMsYi5tZW1MZXZlbCxiLnN0cmF0ZWd5KTtpZihjIT09bil0aHJvdyBuZXcgRXJyb3IoaltjXSk7Yi5oZWFkZXImJmcuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sYi5oZWFkZXIpfTtzLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPXRoaXMuc3RybSxmPXRoaXMub3B0aW9ucy5jaHVua1NpemU7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtkPWI9PT1+fmI/YjpiPT09ITA/bTpsLGUuaW5wdXQ9XCJzdHJpbmdcIj09dHlwZW9mIGE/aS5zdHJpbmcyYnVmKGEpOmEsZS5uZXh0X2luPTAsZS5hdmFpbF9pbj1lLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09ZS5hdmFpbF9vdXQmJihlLm91dHB1dD1uZXcgaC5CdWY4KGYpLGUubmV4dF9vdXQ9MCxlLmF2YWlsX291dD1mKSxjPWcuZGVmbGF0ZShlLGQpLGMhPT1vJiZjIT09bilyZXR1cm4gdGhpcy5vbkVuZChjKSx0aGlzLmVuZGVkPSEwLCExOygwPT09ZS5hdmFpbF9vdXR8fDA9PT1lLmF2YWlsX2luJiZkPT09bSkmJnRoaXMub25EYXRhKFwic3RyaW5nXCI9PT10aGlzLm9wdGlvbnMudG8/aS5idWYyYmluc3RyaW5nKGguc2hyaW5rQnVmKGUub3V0cHV0LGUubmV4dF9vdXQpKTpoLnNocmlua0J1ZihlLm91dHB1dCxlLm5leHRfb3V0KSl9d2hpbGUoKGUuYXZhaWxfaW4+MHx8MD09PWUuYXZhaWxfb3V0KSYmYyE9PW8pO3JldHVybiBkPT09bT8oYz1nLmRlZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKGMpLHRoaXMuZW5kZWQ9ITAsYz09PW4pOiEwfSxzLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oYSl7dGhpcy5jaHVua3MucHVzaChhKX0scy5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24oYSl7YT09PW4mJih0aGlzLnJlc3VsdD1cInN0cmluZ1wiPT09dGhpcy5vcHRpb25zLnRvP3RoaXMuY2h1bmtzLmpvaW4oXCJcIik6aC5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9YSx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfSxjLkRlZmxhdGU9cyxjLmRlZmxhdGU9ZCxjLmRlZmxhdGVSYXc9ZSxjLmd6aXA9Zn0se1wiLi91dGlscy9jb21tb25cIjoyNyxcIi4vdXRpbHMvc3RyaW5nc1wiOjI4LFwiLi96bGliL2RlZmxhdGUuanNcIjozMixcIi4vemxpYi9tZXNzYWdlc1wiOjM3LFwiLi96bGliL3pzdHJlYW1cIjozOX1dLDI2OltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZChhLGIpe3ZhciBjPW5ldyBtKGIpO2lmKGMucHVzaChhLCEwKSxjLmVycil0aHJvdyBjLm1zZztyZXR1cm4gYy5yZXN1bHR9ZnVuY3Rpb24gZShhLGIpe3JldHVybiBiPWJ8fHt9LGIucmF3PSEwLGQoYSxiKX12YXIgZj1hKFwiLi96bGliL2luZmxhdGUuanNcIiksZz1hKFwiLi91dGlscy9jb21tb25cIiksaD1hKFwiLi91dGlscy9zdHJpbmdzXCIpLGk9YShcIi4vemxpYi9jb25zdGFudHNcIiksaj1hKFwiLi96bGliL21lc3NhZ2VzXCIpLGs9YShcIi4vemxpYi96c3RyZWFtXCIpLGw9YShcIi4vemxpYi9nemhlYWRlclwiKSxtPWZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz1nLmFzc2lnbih7Y2h1bmtTaXplOjE2Mzg0LHdpbmRvd0JpdHM6MCx0bzpcIlwifSxhfHx7fSk7dmFyIGI9dGhpcy5vcHRpb25zO2IucmF3JiZiLndpbmRvd0JpdHM+PTAmJmIud2luZG93Qml0czwxNiYmKGIud2luZG93Qml0cz0tYi53aW5kb3dCaXRzLDA9PT1iLndpbmRvd0JpdHMmJihiLndpbmRvd0JpdHM9LTE1KSksIShiLndpbmRvd0JpdHM+PTAmJmIud2luZG93Qml0czwxNil8fGEmJmEud2luZG93Qml0c3x8KGIud2luZG93Qml0cys9MzIpLGIud2luZG93Qml0cz4xNSYmYi53aW5kb3dCaXRzPDQ4JiYwPT09KDE1JmIud2luZG93Qml0cykmJihiLndpbmRvd0JpdHN8PTE1KSx0aGlzLmVycj0wLHRoaXMubXNnPVwiXCIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IGssdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBjPWYuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSxiLndpbmRvd0JpdHMpO2lmKGMhPT1pLlpfT0spdGhyb3cgbmV3IEVycm9yKGpbY10pO3RoaXMuaGVhZGVyPW5ldyBsLGYuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpfTttLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGosayxsPXRoaXMuc3RybSxtPXRoaXMub3B0aW9ucy5jaHVua1NpemU7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtkPWI9PT1+fmI/YjpiPT09ITA/aS5aX0ZJTklTSDppLlpfTk9fRkxVU0gsbC5pbnB1dD1cInN0cmluZ1wiPT10eXBlb2YgYT9oLmJpbnN0cmluZzJidWYoYSk6YSxsLm5leHRfaW49MCxsLmF2YWlsX2luPWwuaW5wdXQubGVuZ3RoO2Rve2lmKDA9PT1sLmF2YWlsX291dCYmKGwub3V0cHV0PW5ldyBnLkJ1ZjgobSksbC5uZXh0X291dD0wLGwuYXZhaWxfb3V0PW0pLGM9Zi5pbmZsYXRlKGwsaS5aX05PX0ZMVVNIKSxjIT09aS5aX1NUUkVBTV9FTkQmJmMhPT1pLlpfT0spcmV0dXJuIHRoaXMub25FbmQoYyksdGhpcy5lbmRlZD0hMCwhMTtsLm5leHRfb3V0JiYoMD09PWwuYXZhaWxfb3V0fHxjPT09aS5aX1NUUkVBTV9FTkR8fDA9PT1sLmF2YWlsX2luJiZkPT09aS5aX0ZJTklTSCkmJihcInN0cmluZ1wiPT09dGhpcy5vcHRpb25zLnRvPyhlPWgudXRmOGJvcmRlcihsLm91dHB1dCxsLm5leHRfb3V0KSxqPWwubmV4dF9vdXQtZSxrPWguYnVmMnN0cmluZyhsLm91dHB1dCxlKSxsLm5leHRfb3V0PWosbC5hdmFpbF9vdXQ9bS1qLGomJmcuYXJyYXlTZXQobC5vdXRwdXQsbC5vdXRwdXQsZSxqLDApLHRoaXMub25EYXRhKGspKTp0aGlzLm9uRGF0YShnLnNocmlua0J1ZihsLm91dHB1dCxsLm5leHRfb3V0KSkpfXdoaWxlKGwuYXZhaWxfaW4+MCYmYyE9PWkuWl9TVFJFQU1fRU5EKTtyZXR1cm4gYz09PWkuWl9TVFJFQU1fRU5EJiYoZD1pLlpfRklOSVNIKSxkPT09aS5aX0ZJTklTSD8oYz1mLmluZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKGMpLHRoaXMuZW5kZWQ9ITAsYz09PWkuWl9PSyk6ITB9LG0ucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihhKXt0aGlzLmNodW5rcy5wdXNoKGEpfSxtLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbihhKXthPT09aS5aX09LJiYodGhpcy5yZXN1bHQ9XCJzdHJpbmdcIj09PXRoaXMub3B0aW9ucy50bz90aGlzLmNodW5rcy5qb2luKFwiXCIpOmcuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPWEsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ30sYy5JbmZsYXRlPW0sYy5pbmZsYXRlPWQsYy5pbmZsYXRlUmF3PWUsYy51bmd6aXA9ZH0se1wiLi91dGlscy9jb21tb25cIjoyNyxcIi4vdXRpbHMvc3RyaW5nc1wiOjI4LFwiLi96bGliL2NvbnN0YW50c1wiOjMwLFwiLi96bGliL2d6aGVhZGVyXCI6MzMsXCIuL3psaWIvaW5mbGF0ZS5qc1wiOjM1LFwiLi96bGliL21lc3NhZ2VzXCI6MzcsXCIuL3psaWIvenN0cmVhbVwiOjM5fV0sMjc6W2Z1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjt2YXIgZD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgSW50MzJBcnJheTtjLmFzc2lnbj1mdW5jdGlvbihhKXtmb3IodmFyIGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2IubGVuZ3RoOyl7dmFyIGM9Yi5zaGlmdCgpO2lmKGMpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBjKXRocm93IG5ldyBUeXBlRXJyb3IoYytcIm11c3QgYmUgbm9uLW9iamVjdFwiKTtmb3IodmFyIGQgaW4gYyljLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1jW2RdKX19cmV0dXJuIGF9LGMuc2hyaW5rQnVmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEubGVuZ3RoPT09Yj9hOmEuc3ViYXJyYXk/YS5zdWJhcnJheSgwLGIpOihhLmxlbmd0aD1iLGEpfTt2YXIgZT17YXJyYXlTZXQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihiLnN1YmFycmF5JiZhLnN1YmFycmF5KXJldHVybiB2b2lkIGEuc2V0KGIuc3ViYXJyYXkoYyxjK2QpLGUpO2Zvcih2YXIgZj0wO2Q+ZjtmKyspYVtlK2ZdPWJbYytmXX0sZmxhdHRlbkNodW5rczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGc7Zm9yKGQ9MCxiPTAsYz1hLmxlbmd0aDtjPmI7YisrKWQrPWFbYl0ubGVuZ3RoO2ZvcihnPW5ldyBVaW50OEFycmF5KGQpLGU9MCxiPTAsYz1hLmxlbmd0aDtjPmI7YisrKWY9YVtiXSxnLnNldChmLGUpLGUrPWYubGVuZ3RoO3JldHVybiBnfX0sZj17YXJyYXlTZXQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtmb3IodmFyIGY9MDtkPmY7ZisrKWFbZStmXT1iW2MrZl19LGZsYXR0ZW5DaHVua3M6ZnVuY3Rpb24oYSl7cmV0dXJuW10uY29uY2F0LmFwcGx5KFtdLGEpfX07Yy5zZXRUeXBlZD1mdW5jdGlvbihhKXthPyhjLkJ1Zjg9VWludDhBcnJheSxjLkJ1ZjE2PVVpbnQxNkFycmF5LGMuQnVmMzI9SW50MzJBcnJheSxjLmFzc2lnbihjLGUpKTooYy5CdWY4PUFycmF5LGMuQnVmMTY9QXJyYXksYy5CdWYzMj1BcnJheSxjLmFzc2lnbihjLGYpKX0sYy5zZXRUeXBlZChkKX0se31dLDI4OltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZChhLGIpe2lmKDY1NTM3PmImJihhLnN1YmFycmF5JiZnfHwhYS5zdWJhcnJheSYmZikpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlLnNocmlua0J1ZihhLGIpKTtmb3IodmFyIGM9XCJcIixkPTA7Yj5kO2QrKyljKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGFbZF0pO3JldHVybiBjfXZhciBlPWEoXCIuL2NvbW1vblwiKSxmPSEwLGc9ITA7dHJ5e1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxbMF0pfWNhdGNoKGgpe2Y9ITF9dHJ5e1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheSgxKSl9Y2F0Y2goaCl7Zz0hMX1mb3IodmFyIGk9bmV3IGUuQnVmOCgyNTYpLGo9MDsyNTY+ajtqKyspaVtqXT1qPj0yNTI/NjpqPj0yNDg/NTpqPj0yNDA/NDpqPj0yMjQ/MzpqPj0xOTI/MjoxO2lbMjU0XT1pWzI1NF09MSxjLnN0cmluZzJidWY9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGYsZyxoPWEubGVuZ3RoLGk9MDtmb3IoZj0wO2g+ZjtmKyspYz1hLmNoYXJDb2RlQXQoZiksNTUyOTY9PT0oNjQ1MTImYykmJmg+ZisxJiYoZD1hLmNoYXJDb2RlQXQoZisxKSw1NjMyMD09PSg2NDUxMiZkKSYmKGM9NjU1MzYrKGMtNTUyOTY8PDEwKSsoZC01NjMyMCksZisrKSksaSs9MTI4PmM/MToyMDQ4PmM/Mjo2NTUzNj5jPzM6NDtmb3IoYj1uZXcgZS5CdWY4KGkpLGc9MCxmPTA7aT5nO2YrKyljPWEuY2hhckNvZGVBdChmKSw1NTI5Nj09PSg2NDUxMiZjKSYmaD5mKzEmJihkPWEuY2hhckNvZGVBdChmKzEpLDU2MzIwPT09KDY0NTEyJmQpJiYoYz02NTUzNisoYy01NTI5Njw8MTApKyhkLTU2MzIwKSxmKyspKSwxMjg+Yz9iW2crK109YzoyMDQ4PmM/KGJbZysrXT0xOTJ8Yz4+PjYsYltnKytdPTEyOHw2MyZjKTo2NTUzNj5jPyhiW2crK109MjI0fGM+Pj4xMixiW2crK109MTI4fGM+Pj42JjYzLGJbZysrXT0xMjh8NjMmYyk6KGJbZysrXT0yNDB8Yz4+PjE4LGJbZysrXT0xMjh8Yz4+PjEyJjYzLGJbZysrXT0xMjh8Yz4+PjYmNjMsYltnKytdPTEyOHw2MyZjKTtyZXR1cm4gYn0sYy5idWYyYmluc3RyaW5nPWZ1bmN0aW9uKGEpe3JldHVybiBkKGEsYS5sZW5ndGgpfSxjLmJpbnN0cmluZzJidWY9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBlLkJ1ZjgoYS5sZW5ndGgpLGM9MCxkPWIubGVuZ3RoO2Q+YztjKyspYltjXT1hLmNoYXJDb2RlQXQoYyk7cmV0dXJuIGJ9LGMuYnVmMnN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjLGUsZixnLGg9Ynx8YS5sZW5ndGgsaj1uZXcgQXJyYXkoMipoKTtmb3IoZT0wLGM9MDtoPmM7KWlmKGY9YVtjKytdLDEyOD5mKWpbZSsrXT1mO2Vsc2UgaWYoZz1pW2ZdLGc+NClqW2UrK109NjU1MzMsYys9Zy0xO2Vsc2V7Zm9yKGYmPTI9PT1nPzMxOjM9PT1nPzE1Ojc7Zz4xJiZoPmM7KWY9Zjw8Nnw2MyZhW2MrK10sZy0tO2c+MT9qW2UrK109NjU1MzM6NjU1MzY+Zj9qW2UrK109ZjooZi09NjU1MzYsaltlKytdPTU1Mjk2fGY+PjEwJjEwMjMsaltlKytdPTU2MzIwfDEwMjMmZil9cmV0dXJuIGQoaixlKX0sYy51dGY4Ym9yZGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM7Zm9yKGI9Ynx8YS5sZW5ndGgsYj5hLmxlbmd0aCYmKGI9YS5sZW5ndGgpLGM9Yi0xO2M+PTAmJjEyOD09PSgxOTImYVtjXSk7KWMtLTtyZXR1cm4gMD5jP2I6MD09PWM/YjpjK2lbYVtjXV0+Yj9jOmJ9fSx7XCIuL2NvbW1vblwiOjI3fV0sMjk6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhLGIsYyxkKXtmb3IodmFyIGU9NjU1MzUmYXwwLGY9YT4+PjE2JjY1NTM1fDAsZz0wOzAhPT1jOyl7Zz1jPjJlMz8yZTM6YyxjLT1nO2RvIGU9ZStiW2QrK118MCxmPWYrZXwwO3doaWxlKC0tZyk7ZSU9NjU1MjEsZiU9NjU1MjF9cmV0dXJuIGV8Zjw8MTZ8MH1iLmV4cG9ydHM9Y30se31dLDMwOltmdW5jdGlvbihhLGIpe2IuZXhwb3J0cz17Wl9OT19GTFVTSDowLFpfUEFSVElBTF9GTFVTSDoxLFpfU1lOQ19GTFVTSDoyLFpfRlVMTF9GTFVTSDozLFpfRklOSVNIOjQsWl9CTE9DSzo1LFpfVFJFRVM6NixaX09LOjAsWl9TVFJFQU1fRU5EOjEsWl9ORUVEX0RJQ1Q6MixaX0VSUk5POi0xLFpfU1RSRUFNX0VSUk9SOi0yLFpfREFUQV9FUlJPUjotMyxaX0JVRl9FUlJPUjotNSxaX05PX0NPTVBSRVNTSU9OOjAsWl9CRVNUX1NQRUVEOjEsWl9CRVNUX0NPTVBSRVNTSU9OOjksWl9ERUZBVUxUX0NPTVBSRVNTSU9OOi0xLFpfRklMVEVSRUQ6MSxaX0hVRkZNQU5fT05MWToyLFpfUkxFOjMsWl9GSVhFRDo0LFpfREVGQVVMVF9TVFJBVEVHWTowLFpfQklOQVJZOjAsWl9URVhUOjEsWl9VTktOT1dOOjIsWl9ERUZMQVRFRDo4fX0se31dLDMxOltmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGMoKXtmb3IodmFyIGEsYj1bXSxjPTA7MjU2PmM7YysrKXthPWM7Zm9yKHZhciBkPTA7OD5kO2QrKylhPTEmYT8zOTg4MjkyMzg0XmE+Pj4xOmE+Pj4xO2JbY109YX1yZXR1cm4gYn1mdW5jdGlvbiBkKGEsYixjLGQpe3ZhciBmPWUsZz1kK2M7YT0tMV5hO2Zvcih2YXIgaD1kO2c+aDtoKyspYT1hPj4+OF5mWzI1NSYoYV5iW2hdKV07cmV0dXJuLTFeYX12YXIgZT1jKCk7Yi5leHBvcnRzPWR9LHt9XSwzMjpbZnVuY3Rpb24oYSxiLGMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGQoYSxiKXtyZXR1cm4gYS5tc2c9R1tiXSxifWZ1bmN0aW9uIGUoYSl7cmV0dXJuKGE8PDEpLShhPjQ/OTowKX1mdW5jdGlvbiBmKGEpe2Zvcih2YXIgYj1hLmxlbmd0aDstLWI+PTA7KWFbYl09MH1mdW5jdGlvbiBnKGEpe3ZhciBiPWEuc3RhdGUsYz1iLnBlbmRpbmc7Yz5hLmF2YWlsX291dCYmKGM9YS5hdmFpbF9vdXQpLDAhPT1jJiYoQy5hcnJheVNldChhLm91dHB1dCxiLnBlbmRpbmdfYnVmLGIucGVuZGluZ19vdXQsYyxhLm5leHRfb3V0KSxhLm5leHRfb3V0Kz1jLGIucGVuZGluZ19vdXQrPWMsYS50b3RhbF9vdXQrPWMsYS5hdmFpbF9vdXQtPWMsYi5wZW5kaW5nLT1jLDA9PT1iLnBlbmRpbmcmJihiLnBlbmRpbmdfb3V0PTApKX1mdW5jdGlvbiBoKGEsYil7RC5fdHJfZmx1c2hfYmxvY2soYSxhLmJsb2NrX3N0YXJ0Pj0wP2EuYmxvY2tfc3RhcnQ6LTEsYS5zdHJzdGFydC1hLmJsb2NrX3N0YXJ0LGIpLGEuYmxvY2tfc3RhcnQ9YS5zdHJzdGFydCxnKGEuc3RybSl9ZnVuY3Rpb24gaShhLGIpe2EucGVuZGluZ19idWZbYS5wZW5kaW5nKytdPWJ9ZnVuY3Rpb24gaihhLGIpe2EucGVuZGluZ19idWZbYS5wZW5kaW5nKytdPWI+Pj44JjI1NSxhLnBlbmRpbmdfYnVmW2EucGVuZGluZysrXT0yNTUmYn1mdW5jdGlvbiBrKGEsYixjLGQpe3ZhciBlPWEuYXZhaWxfaW47cmV0dXJuIGU+ZCYmKGU9ZCksMD09PWU/MDooYS5hdmFpbF9pbi09ZSxDLmFycmF5U2V0KGIsYS5pbnB1dCxhLm5leHRfaW4sZSxjKSwxPT09YS5zdGF0ZS53cmFwP2EuYWRsZXI9RShhLmFkbGVyLGIsZSxjKToyPT09YS5zdGF0ZS53cmFwJiYoYS5hZGxlcj1GKGEuYWRsZXIsYixlLGMpKSxhLm5leHRfaW4rPWUsYS50b3RhbF9pbis9ZSxlKX1mdW5jdGlvbiBsKGEsYil7dmFyIGMsZCxlPWEubWF4X2NoYWluX2xlbmd0aCxmPWEuc3Ryc3RhcnQsZz1hLnByZXZfbGVuZ3RoLGg9YS5uaWNlX21hdGNoLGk9YS5zdHJzdGFydD5hLndfc2l6ZS1qYj9hLnN0cnN0YXJ0LShhLndfc2l6ZS1qYik6MCxqPWEud2luZG93LGs9YS53X21hc2ssbD1hLnByZXYsbT1hLnN0cnN0YXJ0K2liLG49altmK2ctMV0sbz1qW2YrZ107YS5wcmV2X2xlbmd0aD49YS5nb29kX21hdGNoJiYoZT4+PTIpLGg+YS5sb29rYWhlYWQmJihoPWEubG9va2FoZWFkKTtkbyBpZihjPWIsaltjK2ddPT09byYmaltjK2ctMV09PT1uJiZqW2NdPT09altmXSYmalsrK2NdPT09altmKzFdKXtmKz0yLGMrKztkbzt3aGlsZShqWysrZl09PT1qWysrY10mJmpbKytmXT09PWpbKytjXSYmalsrK2ZdPT09alsrK2NdJiZqWysrZl09PT1qWysrY10mJmpbKytmXT09PWpbKytjXSYmalsrK2ZdPT09alsrK2NdJiZqWysrZl09PT1qWysrY10mJmpbKytmXT09PWpbKytjXSYmbT5mKTtpZihkPWliLShtLWYpLGY9bS1pYixkPmcpe2lmKGEubWF0Y2hfc3RhcnQ9YixnPWQsZD49aClicmVhaztuPWpbZitnLTFdLG89altmK2ddfX13aGlsZSgoYj1sW2Ima10pPmkmJjAhPT0tLWUpO3JldHVybiBnPD1hLmxvb2thaGVhZD9nOmEubG9va2FoZWFkfWZ1bmN0aW9uIG0oYSl7dmFyIGIsYyxkLGUsZixnPWEud19zaXplO2Rve2lmKGU9YS53aW5kb3dfc2l6ZS1hLmxvb2thaGVhZC1hLnN0cnN0YXJ0LGEuc3Ryc3RhcnQ+PWcrKGctamIpKXtDLmFycmF5U2V0KGEud2luZG93LGEud2luZG93LGcsZywwKSxhLm1hdGNoX3N0YXJ0LT1nLGEuc3Ryc3RhcnQtPWcsYS5ibG9ja19zdGFydC09ZyxjPWEuaGFzaF9zaXplLGI9YztkbyBkPWEuaGVhZFstLWJdLGEuaGVhZFtiXT1kPj1nP2QtZzowO3doaWxlKC0tYyk7Yz1nLGI9YztkbyBkPWEucHJldlstLWJdLGEucHJldltiXT1kPj1nP2QtZzowO3doaWxlKC0tYyk7ZSs9Z31pZigwPT09YS5zdHJtLmF2YWlsX2luKWJyZWFrO2lmKGM9ayhhLnN0cm0sYS53aW5kb3csYS5zdHJzdGFydCthLmxvb2thaGVhZCxlKSxhLmxvb2thaGVhZCs9YyxhLmxvb2thaGVhZCthLmluc2VydD49aGIpZm9yKGY9YS5zdHJzdGFydC1hLmluc2VydCxhLmluc19oPWEud2luZG93W2ZdLGEuaW5zX2g9KGEuaW5zX2g8PGEuaGFzaF9zaGlmdF5hLndpbmRvd1tmKzFdKSZhLmhhc2hfbWFzazthLmluc2VydCYmKGEuaW5zX2g9KGEuaW5zX2g8PGEuaGFzaF9zaGlmdF5hLndpbmRvd1tmK2hiLTFdKSZhLmhhc2hfbWFzayxhLnByZXZbZiZhLndfbWFza109YS5oZWFkW2EuaW5zX2hdLGEuaGVhZFthLmluc19oXT1mLGYrKyxhLmluc2VydC0tLCEoYS5sb29rYWhlYWQrYS5pbnNlcnQ8aGIpKTspO313aGlsZShhLmxvb2thaGVhZDxqYiYmMCE9PWEuc3RybS5hdmFpbF9pbil9ZnVuY3Rpb24gbihhLGIpe3ZhciBjPTY1NTM1O2ZvcihjPmEucGVuZGluZ19idWZfc2l6ZS01JiYoYz1hLnBlbmRpbmdfYnVmX3NpemUtNSk7Oyl7aWYoYS5sb29rYWhlYWQ8PTEpe2lmKG0oYSksMD09PWEubG9va2FoZWFkJiZiPT09SClyZXR1cm4gc2I7aWYoMD09PWEubG9va2FoZWFkKWJyZWFrfWEuc3Ryc3RhcnQrPWEubG9va2FoZWFkLGEubG9va2FoZWFkPTA7dmFyIGQ9YS5ibG9ja19zdGFydCtjO2lmKCgwPT09YS5zdHJzdGFydHx8YS5zdHJzdGFydD49ZCkmJihhLmxvb2thaGVhZD1hLnN0cnN0YXJ0LWQsYS5zdHJzdGFydD1kLGgoYSwhMSksMD09PWEuc3RybS5hdmFpbF9vdXQpKXJldHVybiBzYjtpZihhLnN0cnN0YXJ0LWEuYmxvY2tfc3RhcnQ+PWEud19zaXplLWpiJiYoaChhLCExKSwwPT09YS5zdHJtLmF2YWlsX291dCkpcmV0dXJuIHNifXJldHVybiBhLmluc2VydD0wLGI9PT1LPyhoKGEsITApLDA9PT1hLnN0cm0uYXZhaWxfb3V0P3ViOnZiKTphLnN0cnN0YXJ0PmEuYmxvY2tfc3RhcnQmJihoKGEsITEpLDA9PT1hLnN0cm0uYXZhaWxfb3V0KT9zYjpzYn1mdW5jdGlvbiBvKGEsYil7Zm9yKHZhciBjLGQ7Oyl7aWYoYS5sb29rYWhlYWQ8amIpe2lmKG0oYSksYS5sb29rYWhlYWQ8amImJmI9PT1IKXJldHVybiBzYjtpZigwPT09YS5sb29rYWhlYWQpYnJlYWt9aWYoYz0wLGEubG9va2FoZWFkPj1oYiYmKGEuaW5zX2g9KGEuaW5zX2g8PGEuaGFzaF9zaGlmdF5hLndpbmRvd1thLnN0cnN0YXJ0K2hiLTFdKSZhLmhhc2hfbWFzayxjPWEucHJldlthLnN0cnN0YXJ0JmEud19tYXNrXT1hLmhlYWRbYS5pbnNfaF0sYS5oZWFkW2EuaW5zX2hdPWEuc3Ryc3RhcnQpLDAhPT1jJiZhLnN0cnN0YXJ0LWM8PWEud19zaXplLWpiJiYoYS5tYXRjaF9sZW5ndGg9bChhLGMpKSxhLm1hdGNoX2xlbmd0aD49aGIpaWYoZD1ELl90cl90YWxseShhLGEuc3Ryc3RhcnQtYS5tYXRjaF9zdGFydCxhLm1hdGNoX2xlbmd0aC1oYiksYS5sb29rYWhlYWQtPWEubWF0Y2hfbGVuZ3RoLGEubWF0Y2hfbGVuZ3RoPD1hLm1heF9sYXp5X21hdGNoJiZhLmxvb2thaGVhZD49aGIpe2EubWF0Y2hfbGVuZ3RoLS07ZG8gYS5zdHJzdGFydCsrLGEuaW5zX2g9KGEuaW5zX2g8PGEuaGFzaF9zaGlmdF5hLndpbmRvd1thLnN0cnN0YXJ0K2hiLTFdKSZhLmhhc2hfbWFzayxjPWEucHJldlthLnN0cnN0YXJ0JmEud19tYXNrXT1hLmhlYWRbYS5pbnNfaF0sYS5oZWFkW2EuaW5zX2hdPWEuc3Ryc3RhcnQ7d2hpbGUoMCE9PS0tYS5tYXRjaF9sZW5ndGgpO2Euc3Ryc3RhcnQrK31lbHNlIGEuc3Ryc3RhcnQrPWEubWF0Y2hfbGVuZ3RoLGEubWF0Y2hfbGVuZ3RoPTAsYS5pbnNfaD1hLndpbmRvd1thLnN0cnN0YXJ0XSxhLmluc19oPShhLmluc19oPDxhLmhhc2hfc2hpZnReYS53aW5kb3dbYS5zdHJzdGFydCsxXSkmYS5oYXNoX21hc2s7ZWxzZSBkPUQuX3RyX3RhbGx5KGEsMCxhLndpbmRvd1thLnN0cnN0YXJ0XSksYS5sb29rYWhlYWQtLSxhLnN0cnN0YXJ0Kys7aWYoZCYmKGgoYSwhMSksMD09PWEuc3RybS5hdmFpbF9vdXQpKXJldHVybiBzYn1yZXR1cm4gYS5pbnNlcnQ9YS5zdHJzdGFydDxoYi0xP2Euc3Ryc3RhcnQ6aGItMSxiPT09Sz8oaChhLCEwKSwwPT09YS5zdHJtLmF2YWlsX291dD91Yjp2Yik6YS5sYXN0X2xpdCYmKGgoYSwhMSksMD09PWEuc3RybS5hdmFpbF9vdXQpP3NiOnRifWZ1bmN0aW9uIHAoYSxiKXtmb3IodmFyIGMsZCxlOzspe2lmKGEubG9va2FoZWFkPGpiKXtpZihtKGEpLGEubG9va2FoZWFkPGpiJiZiPT09SClyZXR1cm4gc2I7aWYoMD09PWEubG9va2FoZWFkKWJyZWFrfWlmKGM9MCxhLmxvb2thaGVhZD49aGImJihhLmluc19oPShhLmluc19oPDxhLmhhc2hfc2hpZnReYS53aW5kb3dbYS5zdHJzdGFydCtoYi0xXSkmYS5oYXNoX21hc2ssYz1hLnByZXZbYS5zdHJzdGFydCZhLndfbWFza109YS5oZWFkW2EuaW5zX2hdLGEuaGVhZFthLmluc19oXT1hLnN0cnN0YXJ0KSxhLnByZXZfbGVuZ3RoPWEubWF0Y2hfbGVuZ3RoLGEucHJldl9tYXRjaD1hLm1hdGNoX3N0YXJ0LGEubWF0Y2hfbGVuZ3RoPWhiLTEsMCE9PWMmJmEucHJldl9sZW5ndGg8YS5tYXhfbGF6eV9tYXRjaCYmYS5zdHJzdGFydC1jPD1hLndfc2l6ZS1qYiYmKGEubWF0Y2hfbGVuZ3RoPWwoYSxjKSxhLm1hdGNoX2xlbmd0aDw9NSYmKGEuc3RyYXRlZ3k9PT1TfHxhLm1hdGNoX2xlbmd0aD09PWhiJiZhLnN0cnN0YXJ0LWEubWF0Y2hfc3RhcnQ+NDA5NikmJihhLm1hdGNoX2xlbmd0aD1oYi0xKSksYS5wcmV2X2xlbmd0aD49aGImJmEubWF0Y2hfbGVuZ3RoPD1hLnByZXZfbGVuZ3RoKXtlPWEuc3Ryc3RhcnQrYS5sb29rYWhlYWQtaGIsZD1ELl90cl90YWxseShhLGEuc3Ryc3RhcnQtMS1hLnByZXZfbWF0Y2gsYS5wcmV2X2xlbmd0aC1oYiksYS5sb29rYWhlYWQtPWEucHJldl9sZW5ndGgtMSxhLnByZXZfbGVuZ3RoLT0yO2RvKythLnN0cnN0YXJ0PD1lJiYoYS5pbnNfaD0oYS5pbnNfaDw8YS5oYXNoX3NoaWZ0XmEud2luZG93W2Euc3Ryc3RhcnQraGItMV0pJmEuaGFzaF9tYXNrLGM9YS5wcmV2W2Euc3Ryc3RhcnQmYS53X21hc2tdPWEuaGVhZFthLmluc19oXSxhLmhlYWRbYS5pbnNfaF09YS5zdHJzdGFydCk7d2hpbGUoMCE9PS0tYS5wcmV2X2xlbmd0aCk7aWYoYS5tYXRjaF9hdmFpbGFibGU9MCxhLm1hdGNoX2xlbmd0aD1oYi0xLGEuc3Ryc3RhcnQrKyxkJiYoaChhLCExKSwwPT09YS5zdHJtLmF2YWlsX291dCkpcmV0dXJuIHNifWVsc2UgaWYoYS5tYXRjaF9hdmFpbGFibGUpe2lmKGQ9RC5fdHJfdGFsbHkoYSwwLGEud2luZG93W2Euc3Ryc3RhcnQtMV0pLGQmJmgoYSwhMSksYS5zdHJzdGFydCsrLGEubG9va2FoZWFkLS0sMD09PWEuc3RybS5hdmFpbF9vdXQpcmV0dXJuIHNifWVsc2UgYS5tYXRjaF9hdmFpbGFibGU9MSxhLnN0cnN0YXJ0KyssYS5sb29rYWhlYWQtLX1yZXR1cm4gYS5tYXRjaF9hdmFpbGFibGUmJihkPUQuX3RyX3RhbGx5KGEsMCxhLndpbmRvd1thLnN0cnN0YXJ0LTFdKSxhLm1hdGNoX2F2YWlsYWJsZT0wKSxhLmluc2VydD1hLnN0cnN0YXJ0PGhiLTE/YS5zdHJzdGFydDpoYi0xLGI9PT1LPyhoKGEsITApLDA9PT1hLnN0cm0uYXZhaWxfb3V0P3ViOnZiKTphLmxhc3RfbGl0JiYoaChhLCExKSwwPT09YS5zdHJtLmF2YWlsX291dCk/c2I6dGJ9ZnVuY3Rpb24gcShhLGIpe2Zvcih2YXIgYyxkLGUsZixnPWEud2luZG93Ozspe2lmKGEubG9va2FoZWFkPD1pYil7aWYobShhKSxhLmxvb2thaGVhZDw9aWImJmI9PT1IKXJldHVybiBzYjtpZigwPT09YS5sb29rYWhlYWQpYnJlYWt9aWYoYS5tYXRjaF9sZW5ndGg9MCxhLmxvb2thaGVhZD49aGImJmEuc3Ryc3RhcnQ+MCYmKGU9YS5zdHJzdGFydC0xLGQ9Z1tlXSxkPT09Z1srK2VdJiZkPT09Z1srK2VdJiZkPT09Z1srK2VdKSl7Zj1hLnN0cnN0YXJ0K2liO2RvO3doaWxlKGQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmQ9PT1nWysrZV0mJmY+ZSk7YS5tYXRjaF9sZW5ndGg9aWItKGYtZSksYS5tYXRjaF9sZW5ndGg+YS5sb29rYWhlYWQmJihhLm1hdGNoX2xlbmd0aD1hLmxvb2thaGVhZCl9aWYoYS5tYXRjaF9sZW5ndGg+PWhiPyhjPUQuX3RyX3RhbGx5KGEsMSxhLm1hdGNoX2xlbmd0aC1oYiksYS5sb29rYWhlYWQtPWEubWF0Y2hfbGVuZ3RoLGEuc3Ryc3RhcnQrPWEubWF0Y2hfbGVuZ3RoLGEubWF0Y2hfbGVuZ3RoPTApOihjPUQuX3RyX3RhbGx5KGEsMCxhLndpbmRvd1thLnN0cnN0YXJ0XSksYS5sb29rYWhlYWQtLSxhLnN0cnN0YXJ0KyspLGMmJihoKGEsITEpLDA9PT1hLnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gc2J9cmV0dXJuIGEuaW5zZXJ0PTAsYj09PUs/KGgoYSwhMCksMD09PWEuc3RybS5hdmFpbF9vdXQ/dWI6dmIpOmEubGFzdF9saXQmJihoKGEsITEpLDA9PT1hLnN0cm0uYXZhaWxfb3V0KT9zYjp0Yn1mdW5jdGlvbiByKGEsYil7Zm9yKHZhciBjOzspe2lmKDA9PT1hLmxvb2thaGVhZCYmKG0oYSksMD09PWEubG9va2FoZWFkKSl7aWYoYj09PUgpcmV0dXJuIHNiO2JyZWFrfWlmKGEubWF0Y2hfbGVuZ3RoPTAsYz1ELl90cl90YWxseShhLDAsYS53aW5kb3dbYS5zdHJzdGFydF0pLGEubG9va2FoZWFkLS0sYS5zdHJzdGFydCsrLGMmJihoKGEsITEpLDA9PT1hLnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gc2J9cmV0dXJuIGEuaW5zZXJ0PTAsYj09PUs/KGgoYSwhMCksMD09PWEuc3RybS5hdmFpbF9vdXQ/dWI6dmIpOmEubGFzdF9saXQmJihoKGEsITEpLDA9PT1hLnN0cm0uYXZhaWxfb3V0KT9zYjp0Yn1mdW5jdGlvbiBzKGEpe2Eud2luZG93X3NpemU9MiphLndfc2l6ZSxmKGEuaGVhZCksYS5tYXhfbGF6eV9tYXRjaD1CW2EubGV2ZWxdLm1heF9sYXp5LGEuZ29vZF9tYXRjaD1CW2EubGV2ZWxdLmdvb2RfbGVuZ3RoLGEubmljZV9tYXRjaD1CW2EubGV2ZWxdLm5pY2VfbGVuZ3RoLGEubWF4X2NoYWluX2xlbmd0aD1CW2EubGV2ZWxdLm1heF9jaGFpbixhLnN0cnN0YXJ0PTAsYS5ibG9ja19zdGFydD0wLGEubG9va2FoZWFkPTAsYS5pbnNlcnQ9MCxhLm1hdGNoX2xlbmd0aD1hLnByZXZfbGVuZ3RoPWhiLTEsYS5tYXRjaF9hdmFpbGFibGU9MCxhLmluc19oPTB9ZnVuY3Rpb24gdCgpe3RoaXMuc3RybT1udWxsLHRoaXMuc3RhdHVzPTAsdGhpcy5wZW5kaW5nX2J1Zj1udWxsLHRoaXMucGVuZGluZ19idWZfc2l6ZT0wLHRoaXMucGVuZGluZ19vdXQ9MCx0aGlzLnBlbmRpbmc9MCx0aGlzLndyYXA9MCx0aGlzLmd6aGVhZD1udWxsLHRoaXMuZ3ppbmRleD0wLHRoaXMubWV0aG9kPVksdGhpcy5sYXN0X2ZsdXNoPS0xLHRoaXMud19zaXplPTAsdGhpcy53X2JpdHM9MCx0aGlzLndfbWFzaz0wLHRoaXMud2luZG93PW51bGwsdGhpcy53aW5kb3dfc2l6ZT0wLHRoaXMucHJldj1udWxsLHRoaXMuaGVhZD1udWxsLHRoaXMuaW5zX2g9MCx0aGlzLmhhc2hfc2l6ZT0wLHRoaXMuaGFzaF9iaXRzPTAsdGhpcy5oYXNoX21hc2s9MCx0aGlzLmhhc2hfc2hpZnQ9MCx0aGlzLmJsb2NrX3N0YXJ0PTAsdGhpcy5tYXRjaF9sZW5ndGg9MCx0aGlzLnByZXZfbWF0Y2g9MCx0aGlzLm1hdGNoX2F2YWlsYWJsZT0wLHRoaXMuc3Ryc3RhcnQ9MCx0aGlzLm1hdGNoX3N0YXJ0PTAsdGhpcy5sb29rYWhlYWQ9MCx0aGlzLnByZXZfbGVuZ3RoPTAsdGhpcy5tYXhfY2hhaW5fbGVuZ3RoPTAsdGhpcy5tYXhfbGF6eV9tYXRjaD0wLHRoaXMubGV2ZWw9MCx0aGlzLnN0cmF0ZWd5PTAsdGhpcy5nb29kX21hdGNoPTAsdGhpcy5uaWNlX21hdGNoPTAsdGhpcy5keW5fbHRyZWU9bmV3IEMuQnVmMTYoMipmYiksdGhpcy5keW5fZHRyZWU9bmV3IEMuQnVmMTYoMiooMipkYisxKSksdGhpcy5ibF90cmVlPW5ldyBDLkJ1ZjE2KDIqKDIqZWIrMSkpLGYodGhpcy5keW5fbHRyZWUpLGYodGhpcy5keW5fZHRyZWUpLGYodGhpcy5ibF90cmVlKSx0aGlzLmxfZGVzYz1udWxsLHRoaXMuZF9kZXNjPW51bGwsdGhpcy5ibF9kZXNjPW51bGwsdGhpcy5ibF9jb3VudD1uZXcgQy5CdWYxNihnYisxKSx0aGlzLmhlYXA9bmV3IEMuQnVmMTYoMipjYisxKSxmKHRoaXMuaGVhcCksdGhpcy5oZWFwX2xlbj0wLHRoaXMuaGVhcF9tYXg9MCx0aGlzLmRlcHRoPW5ldyBDLkJ1ZjE2KDIqY2IrMSksZih0aGlzLmRlcHRoKSx0aGlzLmxfYnVmPTAsdGhpcy5saXRfYnVmc2l6ZT0wLHRoaXMubGFzdF9saXQ9MCx0aGlzLmRfYnVmPTAsdGhpcy5vcHRfbGVuPTAsdGhpcy5zdGF0aWNfbGVuPTAsdGhpcy5tYXRjaGVzPTAsdGhpcy5pbnNlcnQ9MCx0aGlzLmJpX2J1Zj0wLHRoaXMuYmlfdmFsaWQ9MH1mdW5jdGlvbiB1KGEpe3ZhciBiO3JldHVybiBhJiZhLnN0YXRlPyhhLnRvdGFsX2luPWEudG90YWxfb3V0PTAsYS5kYXRhX3R5cGU9WCxiPWEuc3RhdGUsYi5wZW5kaW5nPTAsYi5wZW5kaW5nX291dD0wLGIud3JhcDwwJiYoYi53cmFwPS1iLndyYXApLGIuc3RhdHVzPWIud3JhcD9sYjpxYixhLmFkbGVyPTI9PT1iLndyYXA/MDoxLGIubGFzdF9mbHVzaD1ILEQuX3RyX2luaXQoYiksTSk6ZChhLE8pfWZ1bmN0aW9uIHYoYSl7dmFyIGI9dShhKTtyZXR1cm4gYj09PU0mJnMoYS5zdGF0ZSksYn1mdW5jdGlvbiB3KGEsYil7cmV0dXJuIGEmJmEuc3RhdGU/MiE9PWEuc3RhdGUud3JhcD9POihhLnN0YXRlLmd6aGVhZD1iLE0pOk99ZnVuY3Rpb24geChhLGIsYyxlLGYsZyl7aWYoIWEpcmV0dXJuIE87dmFyIGg9MTtpZihiPT09UiYmKGI9NiksMD5lPyhoPTAsZT0tZSk6ZT4xNSYmKGg9MixlLT0xNiksMT5mfHxmPlp8fGMhPT1ZfHw4PmV8fGU+MTV8fDA+Ynx8Yj45fHwwPmd8fGc+VilyZXR1cm4gZChhLE8pOzg9PT1lJiYoZT05KTt2YXIgaT1uZXcgdDtyZXR1cm4gYS5zdGF0ZT1pLGkuc3RybT1hLGkud3JhcD1oLGkuZ3poZWFkPW51bGwsaS53X2JpdHM9ZSxpLndfc2l6ZT0xPDxpLndfYml0cyxpLndfbWFzaz1pLndfc2l6ZS0xLGkuaGFzaF9iaXRzPWYrNyxpLmhhc2hfc2l6ZT0xPDxpLmhhc2hfYml0cyxpLmhhc2hfbWFzaz1pLmhhc2hfc2l6ZS0xLGkuaGFzaF9zaGlmdD1+figoaS5oYXNoX2JpdHMraGItMSkvaGIpLGkud2luZG93PW5ldyBDLkJ1ZjgoMippLndfc2l6ZSksaS5oZWFkPW5ldyBDLkJ1ZjE2KGkuaGFzaF9zaXplKSxpLnByZXY9bmV3IEMuQnVmMTYoaS53X3NpemUpLGkubGl0X2J1ZnNpemU9MTw8Zis2LGkucGVuZGluZ19idWZfc2l6ZT00KmkubGl0X2J1ZnNpemUsaS5wZW5kaW5nX2J1Zj1uZXcgQy5CdWY4KGkucGVuZGluZ19idWZfc2l6ZSksaS5kX2J1Zj1pLmxpdF9idWZzaXplPj4xLGkubF9idWY9MyppLmxpdF9idWZzaXplLGkubGV2ZWw9YixpLnN0cmF0ZWd5PWcsaS5tZXRob2Q9Yyx2KGEpfWZ1bmN0aW9uIHkoYSxiKXtyZXR1cm4geChhLGIsWSwkLF8sVyl9ZnVuY3Rpb24geihhLGIpe3ZhciBjLGgsayxsO2lmKCFhfHwhYS5zdGF0ZXx8Yj5MfHwwPmIpcmV0dXJuIGE/ZChhLE8pOk87aWYoaD1hLnN0YXRlLCFhLm91dHB1dHx8IWEuaW5wdXQmJjAhPT1hLmF2YWlsX2lufHxoLnN0YXR1cz09PXJiJiZiIT09SylyZXR1cm4gZChhLDA9PT1hLmF2YWlsX291dD9ROk8pO2lmKGguc3RybT1hLGM9aC5sYXN0X2ZsdXNoLGgubGFzdF9mbHVzaD1iLGguc3RhdHVzPT09bGIpaWYoMj09PWgud3JhcClhLmFkbGVyPTAsaShoLDMxKSxpKGgsMTM5KSxpKGgsOCksaC5nemhlYWQ/KGkoaCwoaC5nemhlYWQudGV4dD8xOjApKyhoLmd6aGVhZC5oY3JjPzI6MCkrKGguZ3poZWFkLmV4dHJhPzQ6MCkrKGguZ3poZWFkLm5hbWU/ODowKSsoaC5nemhlYWQuY29tbWVudD8xNjowKSksaShoLDI1NSZoLmd6aGVhZC50aW1lKSxpKGgsaC5nemhlYWQudGltZT4+OCYyNTUpLGkoaCxoLmd6aGVhZC50aW1lPj4xNiYyNTUpLGkoaCxoLmd6aGVhZC50aW1lPj4yNCYyNTUpLGkoaCw5PT09aC5sZXZlbD8yOmguc3RyYXRlZ3k+PVR8fGgubGV2ZWw8Mj80OjApLGkoaCwyNTUmaC5nemhlYWQub3MpLGguZ3poZWFkLmV4dHJhJiZoLmd6aGVhZC5leHRyYS5sZW5ndGgmJihpKGgsMjU1JmguZ3poZWFkLmV4dHJhLmxlbmd0aCksaShoLGguZ3poZWFkLmV4dHJhLmxlbmd0aD4+OCYyNTUpKSxoLmd6aGVhZC5oY3JjJiYoYS5hZGxlcj1GKGEuYWRsZXIsaC5wZW5kaW5nX2J1ZixoLnBlbmRpbmcsMCkpLGguZ3ppbmRleD0wLGguc3RhdHVzPW1iKTooaShoLDApLGkoaCwwKSxpKGgsMCksaShoLDApLGkoaCwwKSxpKGgsOT09PWgubGV2ZWw/MjpoLnN0cmF0ZWd5Pj1UfHxoLmxldmVsPDI/NDowKSxpKGgsd2IpLGguc3RhdHVzPXFiKTtlbHNle3ZhciBtPVkrKGgud19iaXRzLTg8PDQpPDw4LG49LTE7bj1oLnN0cmF0ZWd5Pj1UfHxoLmxldmVsPDI/MDpoLmxldmVsPDY/MTo2PT09aC5sZXZlbD8yOjMsbXw9bjw8NiwwIT09aC5zdHJzdGFydCYmKG18PWtiKSxtKz0zMS1tJTMxLGguc3RhdHVzPXFiLGooaCxtKSwwIT09aC5zdHJzdGFydCYmKGooaCxhLmFkbGVyPj4+MTYpLGooaCw2NTUzNSZhLmFkbGVyKSksYS5hZGxlcj0xfWlmKGguc3RhdHVzPT09bWIpaWYoaC5nemhlYWQuZXh0cmEpe2ZvcihrPWgucGVuZGluZztoLmd6aW5kZXg8KDY1NTM1JmguZ3poZWFkLmV4dHJhLmxlbmd0aCkmJihoLnBlbmRpbmchPT1oLnBlbmRpbmdfYnVmX3NpemV8fChoLmd6aGVhZC5oY3JjJiZoLnBlbmRpbmc+ayYmKGEuYWRsZXI9RihhLmFkbGVyLGgucGVuZGluZ19idWYsaC5wZW5kaW5nLWssaykpLGcoYSksaz1oLnBlbmRpbmcsaC5wZW5kaW5nIT09aC5wZW5kaW5nX2J1Zl9zaXplKSk7KWkoaCwyNTUmaC5nemhlYWQuZXh0cmFbaC5nemluZGV4XSksaC5nemluZGV4Kys7aC5nemhlYWQuaGNyYyYmaC5wZW5kaW5nPmsmJihhLmFkbGVyPUYoYS5hZGxlcixoLnBlbmRpbmdfYnVmLGgucGVuZGluZy1rLGspKSxoLmd6aW5kZXg9PT1oLmd6aGVhZC5leHRyYS5sZW5ndGgmJihoLmd6aW5kZXg9MCxoLnN0YXR1cz1uYil9ZWxzZSBoLnN0YXR1cz1uYjtpZihoLnN0YXR1cz09PW5iKWlmKGguZ3poZWFkLm5hbWUpe2s9aC5wZW5kaW5nO2Rve2lmKGgucGVuZGluZz09PWgucGVuZGluZ19idWZfc2l6ZSYmKGguZ3poZWFkLmhjcmMmJmgucGVuZGluZz5rJiYoYS5hZGxlcj1GKGEuYWRsZXIsaC5wZW5kaW5nX2J1ZixoLnBlbmRpbmctayxrKSksZyhhKSxrPWgucGVuZGluZyxoLnBlbmRpbmc9PT1oLnBlbmRpbmdfYnVmX3NpemUpKXtsPTE7YnJlYWt9bD1oLmd6aW5kZXg8aC5nemhlYWQubmFtZS5sZW5ndGg/MjU1JmguZ3poZWFkLm5hbWUuY2hhckNvZGVBdChoLmd6aW5kZXgrKyk6MCxpKGgsbCl9d2hpbGUoMCE9PWwpO2guZ3poZWFkLmhjcmMmJmgucGVuZGluZz5rJiYoYS5hZGxlcj1GKGEuYWRsZXIsaC5wZW5kaW5nX2J1ZixoLnBlbmRpbmctayxrKSksMD09PWwmJihoLmd6aW5kZXg9MCxoLnN0YXR1cz1vYil9ZWxzZSBoLnN0YXR1cz1vYjtpZihoLnN0YXR1cz09PW9iKWlmKGguZ3poZWFkLmNvbW1lbnQpe2s9aC5wZW5kaW5nO2Rve2lmKGgucGVuZGluZz09PWgucGVuZGluZ19idWZfc2l6ZSYmKGguZ3poZWFkLmhjcmMmJmgucGVuZGluZz5rJiYoYS5hZGxlcj1GKGEuYWRsZXIsaC5wZW5kaW5nX2J1ZixoLnBlbmRpbmctayxrKSksZyhhKSxrPWgucGVuZGluZyxoLnBlbmRpbmc9PT1oLnBlbmRpbmdfYnVmX3NpemUpKXtsPTE7YnJlYWt9bD1oLmd6aW5kZXg8aC5nemhlYWQuY29tbWVudC5sZW5ndGg/MjU1JmguZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChoLmd6aW5kZXgrKyk6MCxpKGgsbCl9d2hpbGUoMCE9PWwpO2guZ3poZWFkLmhjcmMmJmgucGVuZGluZz5rJiYoYS5hZGxlcj1GKGEuYWRsZXIsaC5wZW5kaW5nX2J1ZixoLnBlbmRpbmctayxrKSksMD09PWwmJihoLnN0YXR1cz1wYil9ZWxzZSBoLnN0YXR1cz1wYjtpZihoLnN0YXR1cz09PXBiJiYoaC5nemhlYWQuaGNyYz8oaC5wZW5kaW5nKzI+aC5wZW5kaW5nX2J1Zl9zaXplJiZnKGEpLGgucGVuZGluZysyPD1oLnBlbmRpbmdfYnVmX3NpemUmJihpKGgsMjU1JmEuYWRsZXIpLGkoaCxhLmFkbGVyPj44JjI1NSksYS5hZGxlcj0wLGguc3RhdHVzPXFiKSk6aC5zdGF0dXM9cWIpLDAhPT1oLnBlbmRpbmcpe2lmKGcoYSksMD09PWEuYXZhaWxfb3V0KXJldHVybiBoLmxhc3RfZmx1c2g9LTEsTX1lbHNlIGlmKDA9PT1hLmF2YWlsX2luJiZlKGIpPD1lKGMpJiZiIT09SylyZXR1cm4gZChhLFEpO2lmKGguc3RhdHVzPT09cmImJjAhPT1hLmF2YWlsX2luKXJldHVybiBkKGEsUSk7aWYoMCE9PWEuYXZhaWxfaW58fDAhPT1oLmxvb2thaGVhZHx8YiE9PUgmJmguc3RhdHVzIT09cmIpe3ZhciBvPWguc3RyYXRlZ3k9PT1UP3IoaCxiKTpoLnN0cmF0ZWd5PT09VT9xKGgsYik6QltoLmxldmVsXS5mdW5jKGgsYik7aWYoKG89PT11Ynx8bz09PXZiKSYmKGguc3RhdHVzPXJiKSxvPT09c2J8fG89PT11YilyZXR1cm4gMD09PWEuYXZhaWxfb3V0JiYoaC5sYXN0X2ZsdXNoPS0xKSxNO2lmKG89PT10YiYmKGI9PT1JP0QuX3RyX2FsaWduKGgpOmIhPT1MJiYoRC5fdHJfc3RvcmVkX2Jsb2NrKGgsMCwwLCExKSxiPT09SiYmKGYoaC5oZWFkKSwwPT09aC5sb29rYWhlYWQmJihoLnN0cnN0YXJ0PTAsaC5ibG9ja19zdGFydD0wLGguaW5zZXJ0PTApKSksZyhhKSwwPT09YS5hdmFpbF9vdXQpKXJldHVybiBoLmxhc3RfZmx1c2g9LTEsTX1yZXR1cm4gYiE9PUs/TTpoLndyYXA8PTA/TjooMj09PWgud3JhcD8oaShoLDI1NSZhLmFkbGVyKSxpKGgsYS5hZGxlcj4+OCYyNTUpLGkoaCxhLmFkbGVyPj4xNiYyNTUpLGkoaCxhLmFkbGVyPj4yNCYyNTUpLGkoaCwyNTUmYS50b3RhbF9pbiksaShoLGEudG90YWxfaW4+PjgmMjU1KSxpKGgsYS50b3RhbF9pbj4+MTYmMjU1KSxpKGgsYS50b3RhbF9pbj4+MjQmMjU1KSk6KGooaCxhLmFkbGVyPj4+MTYpLGooaCw2NTUzNSZhLmFkbGVyKSksZyhhKSxoLndyYXA+MCYmKGgud3JhcD0taC53cmFwKSwwIT09aC5wZW5kaW5nP006Til9ZnVuY3Rpb24gQShhKXt2YXIgYjtyZXR1cm4gYSYmYS5zdGF0ZT8oYj1hLnN0YXRlLnN0YXR1cyxiIT09bGImJmIhPT1tYiYmYiE9PW5iJiZiIT09b2ImJmIhPT1wYiYmYiE9PXFiJiZiIT09cmI/ZChhLE8pOihhLnN0YXRlPW51bGwsYj09PXFiP2QoYSxQKTpNKSk6T312YXIgQixDPWEoXCIuLi91dGlscy9jb21tb25cIiksRD1hKFwiLi90cmVlc1wiKSxFPWEoXCIuL2FkbGVyMzJcIiksRj1hKFwiLi9jcmMzMlwiKSxHPWEoXCIuL21lc3NhZ2VzXCIpLEg9MCxJPTEsSj0zLEs9NCxMPTUsTT0wLE49MSxPPS0yLFA9LTMsUT0tNSxSPS0xLFM9MSxUPTIsVT0zLFY9NCxXPTAsWD0yLFk9OCxaPTksJD0xNSxfPTgsYWI9MjksYmI9MjU2LGNiPWJiKzErYWIsZGI9MzAsZWI9MTksZmI9MipjYisxLGdiPTE1LGhiPTMsaWI9MjU4LGpiPWliK2hiKzEsa2I9MzIsbGI9NDIsbWI9NjksbmI9NzMsb2I9OTEscGI9MTAzLHFiPTExMyxyYj02NjYsc2I9MSx0Yj0yLHViPTMsdmI9NCx3Yj0zLHhiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5nb29kX2xlbmd0aD1hLHRoaXMubWF4X2xhenk9Yix0aGlzLm5pY2VfbGVuZ3RoPWMsdGhpcy5tYXhfY2hhaW49ZCx0aGlzLmZ1bmM9ZX07Qj1bbmV3IHhiKDAsMCwwLDAsbiksbmV3IHhiKDQsNCw4LDQsbyksbmV3IHhiKDQsNSwxNiw4LG8pLG5ldyB4Yig0LDYsMzIsMzIsbyksbmV3IHhiKDQsNCwxNiwxNixwKSxuZXcgeGIoOCwxNiwzMiwzMixwKSxuZXcgeGIoOCwxNiwxMjgsMTI4LHApLG5ldyB4Yig4LDMyLDEyOCwyNTYscCksbmV3IHhiKDMyLDEyOCwyNTgsMTAyNCxwKSxuZXcgeGIoMzIsMjU4LDI1OCw0MDk2LHApXSxjLmRlZmxhdGVJbml0PXksYy5kZWZsYXRlSW5pdDI9eCxjLmRlZmxhdGVSZXNldD12LGMuZGVmbGF0ZVJlc2V0S2VlcD11LGMuZGVmbGF0ZVNldEhlYWRlcj13LGMuZGVmbGF0ZT16LGMuZGVmbGF0ZUVuZD1BLGMuZGVmbGF0ZUluZm89XCJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpXCJ9LHtcIi4uL3V0aWxzL2NvbW1vblwiOjI3LFwiLi9hZGxlcjMyXCI6MjksXCIuL2NyYzMyXCI6MzEsXCIuL21lc3NhZ2VzXCI6MzcsXCIuL3RyZWVzXCI6Mzh9XSwzMzpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPVwiXCIsdGhpcy5jb21tZW50PVwiXCIsdGhpcy5oY3JjPTAsdGhpcy5kb25lPSExfWIuZXhwb3J0cz1jfSx7fV0sMzQ6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9MzAsZD0xMjtiLmV4cG9ydHM9ZnVuY3Rpb24oYSxiKXt2YXIgZSxmLGcsaCxpLGosayxsLG0sbixvLHAscSxyLHMsdCx1LHYsdyx4LHkseixBLEIsQztlPWEuc3RhdGUsZj1hLm5leHRfaW4sQj1hLmlucHV0LGc9ZisoYS5hdmFpbF9pbi01KSxoPWEubmV4dF9vdXQsQz1hLm91dHB1dCxpPWgtKGItYS5hdmFpbF9vdXQpLGo9aCsoYS5hdmFpbF9vdXQtMjU3KSxrPWUuZG1heCxsPWUud3NpemUsbT1lLndoYXZlLG49ZS53bmV4dCxvPWUud2luZG93LHA9ZS5ob2xkLHE9ZS5iaXRzLHI9ZS5sZW5jb2RlLHM9ZS5kaXN0Y29kZSx0PSgxPDxlLmxlbmJpdHMpLTEsdT0oMTw8ZS5kaXN0Yml0cyktMTthOmRvezE1PnEmJihwKz1CW2YrK108PHEscSs9OCxwKz1CW2YrK108PHEscSs9OCksdj1yW3AmdF07Yjpmb3IoOzspe2lmKHc9dj4+PjI0LHA+Pj49dyxxLT13LHc9dj4+PjE2JjI1NSwwPT09dylDW2grK109NjU1MzUmdjtlbHNle2lmKCEoMTYmdykpe2lmKDA9PT0oNjQmdykpe3Y9clsoNjU1MzUmdikrKHAmKDE8PHcpLTEpXTtjb250aW51ZSBifWlmKDMyJncpe2UubW9kZT1kO2JyZWFrIGF9YS5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIixlLm1vZGU9YzticmVhayBhfXg9NjU1MzUmdix3Jj0xNSx3JiYodz5xJiYocCs9QltmKytdPDxxLHErPTgpLHgrPXAmKDE8PHcpLTEscD4+Pj13LHEtPXcpLDE1PnEmJihwKz1CW2YrK108PHEscSs9OCxwKz1CW2YrK108PHEscSs9OCksdj1zW3AmdV07Yzpmb3IoOzspe2lmKHc9dj4+PjI0LHA+Pj49dyxxLT13LHc9dj4+PjE2JjI1NSwhKDE2JncpKXtpZigwPT09KDY0JncpKXt2PXNbKDY1NTM1JnYpKyhwJigxPDx3KS0xKV07Y29udGludWUgY31hLm1zZz1cImludmFsaWQgZGlzdGFuY2UgY29kZVwiLGUubW9kZT1jO2JyZWFrIGF9aWYoeT02NTUzNSZ2LHcmPTE1LHc+cSYmKHArPUJbZisrXTw8cSxxKz04LHc+cSYmKHArPUJbZisrXTw8cSxxKz04KSkseSs9cCYoMTw8dyktMSx5Pmspe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixlLm1vZGU9YzticmVhayBhfWlmKHA+Pj49dyxxLT13LHc9aC1pLHk+dyl7aWYodz15LXcsdz5tJiZlLnNhbmUpe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixlLm1vZGU9YzticmVhayBhfWlmKHo9MCxBPW8sMD09PW4pe2lmKHorPWwtdyx4Pncpe3gtPXc7ZG8gQ1toKytdPW9beisrXTt3aGlsZSgtLXcpO3o9aC15LEE9Q319ZWxzZSBpZih3Pm4pe2lmKHorPWwrbi13LHctPW4seD53KXt4LT13O2RvIENbaCsrXT1vW3orK107d2hpbGUoLS13KTtpZih6PTAseD5uKXt3PW4seC09dztkbyBDW2grK109b1t6KytdO3doaWxlKC0tdyk7ej1oLXksQT1DfX19ZWxzZSBpZih6Kz1uLXcseD53KXt4LT13O2RvIENbaCsrXT1vW3orK107d2hpbGUoLS13KTt6PWgteSxBPUN9Zm9yKDt4PjI7KUNbaCsrXT1BW3orK10sQ1toKytdPUFbeisrXSxDW2grK109QVt6KytdLHgtPTM7eCYmKENbaCsrXT1BW3orK10seD4xJiYoQ1toKytdPUFbeisrXSkpfWVsc2V7ej1oLXk7ZG8gQ1toKytdPUNbeisrXSxDW2grK109Q1t6KytdLENbaCsrXT1DW3orK10seC09Mzt3aGlsZSh4PjIpO3gmJihDW2grK109Q1t6KytdLHg+MSYmKENbaCsrXT1DW3orK10pKX1icmVha319YnJlYWt9fXdoaWxlKGc+ZiYmaj5oKTt4PXE+PjMsZi09eCxxLT14PDwzLHAmPSgxPDxxKS0xLGEubmV4dF9pbj1mLGEubmV4dF9vdXQ9aCxhLmF2YWlsX2luPWc+Zj81KyhnLWYpOjUtKGYtZyksYS5hdmFpbF9vdXQ9aj5oPzI1Nysoai1oKToyNTctKGgtaiksZS5ob2xkPXAsZS5iaXRzPXF9fSx7fV0sMzU6W2Z1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBkKGEpe3JldHVybihhPj4+MjQmMjU1KSsoYT4+PjgmNjUyODApKygoNjUyODAmYSk8PDgpKygoMjU1JmEpPDwyNCl9ZnVuY3Rpb24gZSgpe3RoaXMubW9kZT0wLHRoaXMubGFzdD0hMSx0aGlzLndyYXA9MCx0aGlzLmhhdmVkaWN0PSExLHRoaXMuZmxhZ3M9MCx0aGlzLmRtYXg9MCx0aGlzLmNoZWNrPTAsdGhpcy50b3RhbD0wLHRoaXMuaGVhZD1udWxsLHRoaXMud2JpdHM9MCx0aGlzLndzaXplPTAsdGhpcy53aGF2ZT0wLHRoaXMud25leHQ9MCx0aGlzLndpbmRvdz1udWxsLHRoaXMuaG9sZD0wLHRoaXMuYml0cz0wLHRoaXMubGVuZ3RoPTAsdGhpcy5vZmZzZXQ9MCx0aGlzLmV4dHJhPTAsdGhpcy5sZW5jb2RlPW51bGwsdGhpcy5kaXN0Y29kZT1udWxsLHRoaXMubGVuYml0cz0wLHRoaXMuZGlzdGJpdHM9MCx0aGlzLm5jb2RlPTAsdGhpcy5ubGVuPTAsdGhpcy5uZGlzdD0wLHRoaXMuaGF2ZT0wLHRoaXMubmV4dD1udWxsLHRoaXMubGVucz1uZXcgci5CdWYxNigzMjApLHRoaXMud29yaz1uZXcgci5CdWYxNigyODgpLHRoaXMubGVuZHluPW51bGwsdGhpcy5kaXN0ZHluPW51bGwsdGhpcy5zYW5lPTAsdGhpcy5iYWNrPTAsdGhpcy53YXM9MH1mdW5jdGlvbiBmKGEpe3ZhciBiO3JldHVybiBhJiZhLnN0YXRlPyhiPWEuc3RhdGUsYS50b3RhbF9pbj1hLnRvdGFsX291dD1iLnRvdGFsPTAsYS5tc2c9XCJcIixiLndyYXAmJihhLmFkbGVyPTEmYi53cmFwKSxiLm1vZGU9SyxiLmxhc3Q9MCxiLmhhdmVkaWN0PTAsYi5kbWF4PTMyNzY4LGIuaGVhZD1udWxsLGIuaG9sZD0wLGIuYml0cz0wLGIubGVuY29kZT1iLmxlbmR5bj1uZXcgci5CdWYzMihvYiksYi5kaXN0Y29kZT1iLmRpc3RkeW49bmV3IHIuQnVmMzIocGIpLGIuc2FuZT0xLGIuYmFjaz0tMSxDKTpGfWZ1bmN0aW9uIGcoYSl7dmFyIGI7cmV0dXJuIGEmJmEuc3RhdGU/KGI9YS5zdGF0ZSxiLndzaXplPTAsYi53aGF2ZT0wLGIud25leHQ9MCxmKGEpKTpGfWZ1bmN0aW9uIGgoYSxiKXt2YXIgYyxkO3JldHVybiBhJiZhLnN0YXRlPyhkPWEuc3RhdGUsMD5iPyhjPTAsYj0tYik6KGM9KGI+PjQpKzEsNDg+YiYmKGImPTE1KSksYiYmKDg+Ynx8Yj4xNSk/RjoobnVsbCE9PWQud2luZG93JiZkLndiaXRzIT09YiYmKGQud2luZG93PW51bGwpLGQud3JhcD1jLGQud2JpdHM9YixnKGEpKSk6Rn1mdW5jdGlvbiBpKGEsYil7dmFyIGMsZDtyZXR1cm4gYT8oZD1uZXcgZSxhLnN0YXRlPWQsZC53aW5kb3c9bnVsbCxjPWgoYSxiKSxjIT09QyYmKGEuc3RhdGU9bnVsbCksYyk6Rn1mdW5jdGlvbiBqKGEpe3JldHVybiBpKGEscmIpfWZ1bmN0aW9uIGsoYSl7aWYoc2Ipe3ZhciBiO2ZvcihwPW5ldyByLkJ1ZjMyKDUxMikscT1uZXcgci5CdWYzMigzMiksYj0wOzE0ND5iOylhLmxlbnNbYisrXT04O2Zvcig7MjU2PmI7KWEubGVuc1tiKytdPTk7Zm9yKDsyODA+YjspYS5sZW5zW2IrK109Nztmb3IoOzI4OD5iOylhLmxlbnNbYisrXT04O2Zvcih2KHgsYS5sZW5zLDAsMjg4LHAsMCxhLndvcmsse2JpdHM6OX0pLGI9MDszMj5iOylhLmxlbnNbYisrXT01O3YoeSxhLmxlbnMsMCwzMixxLDAsYS53b3JrLHtiaXRzOjV9KSxzYj0hMX1hLmxlbmNvZGU9cCxhLmxlbmJpdHM9OSxhLmRpc3Rjb2RlPXEsYS5kaXN0Yml0cz01fWZ1bmN0aW9uIGwoYSxiLGMsZCl7dmFyIGUsZj1hLnN0YXRlO3JldHVybiBudWxsPT09Zi53aW5kb3cmJihmLndzaXplPTE8PGYud2JpdHMsZi53bmV4dD0wLGYud2hhdmU9MCxmLndpbmRvdz1uZXcgci5CdWY4KGYud3NpemUpKSxkPj1mLndzaXplPyhyLmFycmF5U2V0KGYud2luZG93LGIsYy1mLndzaXplLGYud3NpemUsMCksZi53bmV4dD0wLGYud2hhdmU9Zi53c2l6ZSk6KGU9Zi53c2l6ZS1mLnduZXh0LGU+ZCYmKGU9ZCksci5hcnJheVNldChmLndpbmRvdyxiLGMtZCxlLGYud25leHQpLGQtPWUsZD8oci5hcnJheVNldChmLndpbmRvdyxiLGMtZCxkLDApLGYud25leHQ9ZCxmLndoYXZlPWYud3NpemUpOihmLnduZXh0Kz1lLGYud25leHQ9PT1mLndzaXplJiYoZi53bmV4dD0wKSxmLndoYXZlPGYud3NpemUmJihmLndoYXZlKz1lKSkpLDB9ZnVuY3Rpb24gbShhLGIpe3ZhciBjLGUsZixnLGgsaSxqLG0sbixvLHAscSxvYixwYixxYixyYixzYix0Yix1Yix2Yix3Yix4Yix5Yix6YixBYj0wLEJiPW5ldyByLkJ1ZjgoNCksQ2I9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO2lmKCFhfHwhYS5zdGF0ZXx8IWEub3V0cHV0fHwhYS5pbnB1dCYmMCE9PWEuYXZhaWxfaW4pcmV0dXJuIEY7Yz1hLnN0YXRlLGMubW9kZT09PVYmJihjLm1vZGU9VyksaD1hLm5leHRfb3V0LGY9YS5vdXRwdXQsaj1hLmF2YWlsX291dCxnPWEubmV4dF9pbixlPWEuaW5wdXQsaT1hLmF2YWlsX2luLG09Yy5ob2xkLG49Yy5iaXRzLG89aSxwPWoseGI9QzthOmZvcig7Oylzd2l0Y2goYy5tb2RlKXtjYXNlIEs6aWYoMD09PWMud3JhcCl7Yy5tb2RlPVc7YnJlYWt9Zm9yKDsxNj5uOyl7aWYoMD09PWkpYnJlYWsgYTtpLS0sbSs9ZVtnKytdPDxuLG4rPTh9aWYoMiZjLndyYXAmJjM1NjE1PT09bSl7Yy5jaGVjaz0wLEJiWzBdPTI1NSZtLEJiWzFdPW0+Pj44JjI1NSxjLmNoZWNrPXQoYy5jaGVjayxCYiwyLDApLG09MCxuPTAsYy5tb2RlPUw7YnJlYWt9aWYoYy5mbGFncz0wLGMuaGVhZCYmKGMuaGVhZC5kb25lPSExKSwhKDEmYy53cmFwKXx8KCgoMjU1Jm0pPDw4KSsobT4+OCkpJTMxKXthLm1zZz1cImluY29ycmVjdCBoZWFkZXIgY2hlY2tcIixjLm1vZGU9bGI7YnJlYWt9aWYoKDE1Jm0pIT09Sil7YS5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiLGMubW9kZT1sYjticmVha31pZihtPj4+PTQsbi09NCx3Yj0oMTUmbSkrOCwwPT09Yy53Yml0cyljLndiaXRzPXdiO2Vsc2UgaWYod2I+Yy53Yml0cyl7YS5tc2c9XCJpbnZhbGlkIHdpbmRvdyBzaXplXCIsYy5tb2RlPWxiO2JyZWFrfWMuZG1heD0xPDx3YixhLmFkbGVyPWMuY2hlY2s9MSxjLm1vZGU9NTEyJm0/VDpWLG09MCxuPTA7YnJlYWs7Y2FzZSBMOmZvcig7MTY+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKGMuZmxhZ3M9bSwoMjU1JmMuZmxhZ3MpIT09Sil7YS5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiLGMubW9kZT1sYjticmVha31pZig1NzM0NCZjLmZsYWdzKXthLm1zZz1cInVua25vd24gaGVhZGVyIGZsYWdzIHNldFwiLGMubW9kZT1sYjticmVha31jLmhlYWQmJihjLmhlYWQudGV4dD1tPj44JjEpLDUxMiZjLmZsYWdzJiYoQmJbMF09MjU1Jm0sQmJbMV09bT4+PjgmMjU1LGMuY2hlY2s9dChjLmNoZWNrLEJiLDIsMCkpLG09MCxuPTAsYy5tb2RlPU07Y2FzZSBNOmZvcig7MzI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWMuaGVhZCYmKGMuaGVhZC50aW1lPW0pLDUxMiZjLmZsYWdzJiYoQmJbMF09MjU1Jm0sQmJbMV09bT4+PjgmMjU1LEJiWzJdPW0+Pj4xNiYyNTUsQmJbM109bT4+PjI0JjI1NSxjLmNoZWNrPXQoYy5jaGVjayxCYiw0LDApKSxtPTAsbj0wLGMubW9kZT1OO2Nhc2UgTjpmb3IoOzE2Pm47KXtpZigwPT09aSlicmVhayBhO2ktLSxtKz1lW2crK108PG4sbis9OH1jLmhlYWQmJihjLmhlYWQueGZsYWdzPTI1NSZtLGMuaGVhZC5vcz1tPj44KSw1MTImYy5mbGFncyYmKEJiWzBdPTI1NSZtLEJiWzFdPW0+Pj44JjI1NSxjLmNoZWNrPXQoYy5jaGVjayxCYiwyLDApKSxtPTAsbj0wLGMubW9kZT1PO2Nhc2UgTzppZigxMDI0JmMuZmxhZ3Mpe2Zvcig7MTY+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWMubGVuZ3RoPW0sYy5oZWFkJiYoYy5oZWFkLmV4dHJhX2xlbj1tKSw1MTImYy5mbGFncyYmKEJiWzBdPTI1NSZtLEJiWzFdPW0+Pj44JjI1NSxjLmNoZWNrPXQoYy5jaGVjayxCYiwyLDApKSxtPTAsbj0wfWVsc2UgYy5oZWFkJiYoYy5oZWFkLmV4dHJhPW51bGwpO2MubW9kZT1QO2Nhc2UgUDppZigxMDI0JmMuZmxhZ3MmJihxPWMubGVuZ3RoLHE+aSYmKHE9aSkscSYmKGMuaGVhZCYmKHdiPWMuaGVhZC5leHRyYV9sZW4tYy5sZW5ndGgsYy5oZWFkLmV4dHJhfHwoYy5oZWFkLmV4dHJhPW5ldyBBcnJheShjLmhlYWQuZXh0cmFfbGVuKSksci5hcnJheVNldChjLmhlYWQuZXh0cmEsZSxnLHEsd2IpKSw1MTImYy5mbGFncyYmKGMuY2hlY2s9dChjLmNoZWNrLGUscSxnKSksaS09cSxnKz1xLGMubGVuZ3RoLT1xKSxjLmxlbmd0aCkpYnJlYWsgYTtjLmxlbmd0aD0wLGMubW9kZT1RO2Nhc2UgUTppZigyMDQ4JmMuZmxhZ3Mpe2lmKDA9PT1pKWJyZWFrIGE7cT0wO2RvIHdiPWVbZytxKytdLGMuaGVhZCYmd2ImJmMubGVuZ3RoPDY1NTM2JiYoYy5oZWFkLm5hbWUrPVN0cmluZy5mcm9tQ2hhckNvZGUod2IpKTt3aGlsZSh3YiYmaT5xKTtpZig1MTImYy5mbGFncyYmKGMuY2hlY2s9dChjLmNoZWNrLGUscSxnKSksaS09cSxnKz1xLHdiKWJyZWFrIGF9ZWxzZSBjLmhlYWQmJihjLmhlYWQubmFtZT1udWxsKTtjLmxlbmd0aD0wLGMubW9kZT1SO2Nhc2UgUjppZig0MDk2JmMuZmxhZ3Mpe2lmKDA9PT1pKWJyZWFrIGE7cT0wO2RvIHdiPWVbZytxKytdLGMuaGVhZCYmd2ImJmMubGVuZ3RoPDY1NTM2JiYoYy5oZWFkLmNvbW1lbnQrPVN0cmluZy5mcm9tQ2hhckNvZGUod2IpKTt3aGlsZSh3YiYmaT5xKTtpZig1MTImYy5mbGFncyYmKGMuY2hlY2s9dChjLmNoZWNrLGUscSxnKSksaS09cSxnKz1xLHdiKWJyZWFrIGF9ZWxzZSBjLmhlYWQmJihjLmhlYWQuY29tbWVudD1udWxsKTtjLm1vZGU9UztjYXNlIFM6aWYoNTEyJmMuZmxhZ3Mpe2Zvcig7MTY+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKG0hPT0oNjU1MzUmYy5jaGVjaykpe2EubXNnPVwiaGVhZGVyIGNyYyBtaXNtYXRjaFwiLGMubW9kZT1sYjticmVha31tPTAsbj0wfWMuaGVhZCYmKGMuaGVhZC5oY3JjPWMuZmxhZ3M+PjkmMSxjLmhlYWQuZG9uZT0hMCksYS5hZGxlcj1jLmNoZWNrPTAsYy5tb2RlPVY7YnJlYWs7Y2FzZSBUOmZvcig7MzI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWEuYWRsZXI9Yy5jaGVjaz1kKG0pLG09MCxuPTAsYy5tb2RlPVU7Y2FzZSBVOmlmKDA9PT1jLmhhdmVkaWN0KXJldHVybiBhLm5leHRfb3V0PWgsYS5hdmFpbF9vdXQ9aixhLm5leHRfaW49ZyxhLmF2YWlsX2luPWksYy5ob2xkPW0sYy5iaXRzPW4sRTthLmFkbGVyPWMuY2hlY2s9MSxjLm1vZGU9VjtjYXNlIFY6aWYoYj09PUF8fGI9PT1CKWJyZWFrIGE7Y2FzZSBXOmlmKGMubGFzdCl7bT4+Pj03Jm4sbi09NyZuLGMubW9kZT1pYjticmVha31mb3IoOzM+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fXN3aXRjaChjLmxhc3Q9MSZtLG0+Pj49MSxuLT0xLDMmbSl7Y2FzZSAwOmMubW9kZT1YO2JyZWFrO2Nhc2UgMTppZihrKGMpLGMubW9kZT1iYixiPT09Qil7bT4+Pj0yLG4tPTI7YnJlYWsgYX1icmVhaztjYXNlIDI6Yy5tb2RlPSQ7YnJlYWs7Y2FzZSAzOmEubXNnPVwiaW52YWxpZCBibG9jayB0eXBlXCIsYy5tb2RlPWxifW0+Pj49MixuLT0yO2JyZWFrO2Nhc2UgWDpmb3IobT4+Pj03Jm4sbi09NyZuOzMyPm47KXtpZigwPT09aSlicmVhayBhO2ktLSxtKz1lW2crK108PG4sbis9OH1pZigoNjU1MzUmbSkhPT0obT4+PjE2XjY1NTM1KSl7YS5tc2c9XCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXCIsYy5tb2RlPWxiO2JyZWFrfWlmKGMubGVuZ3RoPTY1NTM1Jm0sbT0wLG49MCxjLm1vZGU9WSxiPT09QilicmVhayBhO2Nhc2UgWTpjLm1vZGU9WjtjYXNlIFo6aWYocT1jLmxlbmd0aCl7aWYocT5pJiYocT1pKSxxPmomJihxPWopLDA9PT1xKWJyZWFrIGE7ci5hcnJheVNldChmLGUsZyxxLGgpLGktPXEsZys9cSxqLT1xLGgrPXEsYy5sZW5ndGgtPXE7YnJlYWt9Yy5tb2RlPVY7YnJlYWs7Y2FzZSAkOmZvcig7MTQ+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKGMubmxlbj0oMzEmbSkrMjU3LG0+Pj49NSxuLT01LGMubmRpc3Q9KDMxJm0pKzEsbT4+Pj01LG4tPTUsYy5uY29kZT0oMTUmbSkrNCxtPj4+PTQsbi09NCxjLm5sZW4+Mjg2fHxjLm5kaXN0PjMwKXthLm1zZz1cInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCIsYy5tb2RlPWxiO2JyZWFrfWMuaGF2ZT0wLGMubW9kZT1fO2Nhc2UgXzpmb3IoO2MuaGF2ZTxjLm5jb2RlOyl7Zm9yKDszPm47KXtpZigwPT09aSlicmVhayBhO2ktLSxtKz1lW2crK108PG4sbis9OH1jLmxlbnNbQ2JbYy5oYXZlKytdXT03Jm0sbT4+Pj0zLG4tPTN9Zm9yKDtjLmhhdmU8MTk7KWMubGVuc1tDYltjLmhhdmUrK11dPTA7aWYoYy5sZW5jb2RlPWMubGVuZHluLGMubGVuYml0cz03LHliPXtiaXRzOmMubGVuYml0c30seGI9dih3LGMubGVucywwLDE5LGMubGVuY29kZSwwLGMud29yayx5YiksYy5sZW5iaXRzPXliLmJpdHMseGIpe2EubXNnPVwiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0XCIsYy5tb2RlPWxiO2JyZWFrfWMuaGF2ZT0wLGMubW9kZT1hYjtjYXNlIGFiOmZvcig7Yy5oYXZlPGMubmxlbitjLm5kaXN0Oyl7Zm9yKDtBYj1jLmxlbmNvZGVbbSYoMTw8Yy5sZW5iaXRzKS0xXSxxYj1BYj4+PjI0LHJiPUFiPj4+MTYmMjU1LHNiPTY1NTM1JkFiLCEobj49cWIpOyl7aWYoMD09PWkpYnJlYWsgYTtpLS0sbSs9ZVtnKytdPDxuLG4rPTh9aWYoMTY+c2IpbT4+Pj1xYixuLT1xYixjLmxlbnNbYy5oYXZlKytdPXNiO2Vsc2V7aWYoMTY9PT1zYil7Zm9yKHpiPXFiKzI7emI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKG0+Pj49cWIsbi09cWIsMD09PWMuaGF2ZSl7YS5tc2c9XCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCIsYy5tb2RlPWxiO2JyZWFrfXdiPWMubGVuc1tjLmhhdmUtMV0scT0zKygzJm0pLG0+Pj49MixuLT0yfWVsc2UgaWYoMTc9PT1zYil7Zm9yKHpiPXFiKzM7emI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fW0+Pj49cWIsbi09cWIsd2I9MCxxPTMrKDcmbSksbT4+Pj0zLG4tPTN9ZWxzZXtmb3IoemI9cWIrNzt6Yj5uOyl7aWYoMD09PWkpYnJlYWsgYTtpLS0sbSs9ZVtnKytdPDxuLG4rPTh9bT4+Pj1xYixuLT1xYix3Yj0wLHE9MTErKDEyNyZtKSxtPj4+PTcsbi09N31pZihjLmhhdmUrcT5jLm5sZW4rYy5uZGlzdCl7YS5tc2c9XCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCIsYy5tb2RlPWxiO2JyZWFrfWZvcig7cS0tOyljLmxlbnNbYy5oYXZlKytdPXdifX1pZihjLm1vZGU9PT1sYilicmVhaztpZigwPT09Yy5sZW5zWzI1Nl0pe2EubXNnPVwiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrXCIsYy5tb2RlPWxiO2JyZWFrfWlmKGMubGVuYml0cz05LHliPXtiaXRzOmMubGVuYml0c30seGI9dih4LGMubGVucywwLGMubmxlbixjLmxlbmNvZGUsMCxjLndvcmsseWIpLGMubGVuYml0cz15Yi5iaXRzLHhiKXthLm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldFwiLGMubW9kZT1sYjticmVha31pZihjLmRpc3RiaXRzPTYsYy5kaXN0Y29kZT1jLmRpc3RkeW4seWI9e2JpdHM6Yy5kaXN0Yml0c30seGI9dih5LGMubGVucyxjLm5sZW4sYy5uZGlzdCxjLmRpc3Rjb2RlLDAsYy53b3JrLHliKSxjLmRpc3RiaXRzPXliLmJpdHMseGIpe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZXMgc2V0XCIsYy5tb2RlPWxiO2JyZWFrfWlmKGMubW9kZT1iYixiPT09QilicmVhayBhO2Nhc2UgYmI6Yy5tb2RlPWNiO2Nhc2UgY2I6aWYoaT49NiYmaj49MjU4KXthLm5leHRfb3V0PWgsYS5hdmFpbF9vdXQ9aixhLm5leHRfaW49ZyxhLmF2YWlsX2luPWksYy5ob2xkPW0sYy5iaXRzPW4sdShhLHApLGg9YS5uZXh0X291dCxmPWEub3V0cHV0LGo9YS5hdmFpbF9vdXQsZz1hLm5leHRfaW4sZT1hLmlucHV0LGk9YS5hdmFpbF9pbixtPWMuaG9sZCxuPWMuYml0cyxjLm1vZGU9PT1WJiYoYy5iYWNrPS0xKTtcclxuYnJlYWt9Zm9yKGMuYmFjaz0wO0FiPWMubGVuY29kZVttJigxPDxjLmxlbmJpdHMpLTFdLHFiPUFiPj4+MjQscmI9QWI+Pj4xNiYyNTUsc2I9NjU1MzUmQWIsIShuPj1xYik7KXtpZigwPT09aSlicmVhayBhO2ktLSxtKz1lW2crK108PG4sbis9OH1pZihyYiYmMD09PSgyNDAmcmIpKXtmb3IodGI9cWIsdWI9cmIsdmI9c2I7QWI9Yy5sZW5jb2RlW3ZiKygobSYoMTw8dGIrdWIpLTEpPj50YildLHFiPUFiPj4+MjQscmI9QWI+Pj4xNiYyNTUsc2I9NjU1MzUmQWIsIShuPj10YitxYik7KXtpZigwPT09aSlicmVhayBhO2ktLSxtKz1lW2crK108PG4sbis9OH1tPj4+PXRiLG4tPXRiLGMuYmFjays9dGJ9aWYobT4+Pj1xYixuLT1xYixjLmJhY2srPXFiLGMubGVuZ3RoPXNiLDA9PT1yYil7Yy5tb2RlPWhiO2JyZWFrfWlmKDMyJnJiKXtjLmJhY2s9LTEsYy5tb2RlPVY7YnJlYWt9aWYoNjQmcmIpe2EubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCIsYy5tb2RlPWxiO2JyZWFrfWMuZXh0cmE9MTUmcmIsYy5tb2RlPWRiO2Nhc2UgZGI6aWYoYy5leHRyYSl7Zm9yKHpiPWMuZXh0cmE7emI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWMubGVuZ3RoKz1tJigxPDxjLmV4dHJhKS0xLG0+Pj49Yy5leHRyYSxuLT1jLmV4dHJhLGMuYmFjays9Yy5leHRyYX1jLndhcz1jLmxlbmd0aCxjLm1vZGU9ZWI7Y2FzZSBlYjpmb3IoO0FiPWMuZGlzdGNvZGVbbSYoMTw8Yy5kaXN0Yml0cyktMV0scWI9QWI+Pj4yNCxyYj1BYj4+PjE2JjI1NSxzYj02NTUzNSZBYiwhKG4+PXFiKTspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKDA9PT0oMjQwJnJiKSl7Zm9yKHRiPXFiLHViPXJiLHZiPXNiO0FiPWMuZGlzdGNvZGVbdmIrKChtJigxPDx0Yit1YiktMSk+PnRiKV0scWI9QWI+Pj4yNCxyYj1BYj4+PjE2JjI1NSxzYj02NTUzNSZBYiwhKG4+PXRiK3FiKTspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fW0+Pj49dGIsbi09dGIsYy5iYWNrKz10Yn1pZihtPj4+PXFiLG4tPXFiLGMuYmFjays9cWIsNjQmcmIpe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsYy5tb2RlPWxiO2JyZWFrfWMub2Zmc2V0PXNiLGMuZXh0cmE9MTUmcmIsYy5tb2RlPWZiO2Nhc2UgZmI6aWYoYy5leHRyYSl7Zm9yKHpiPWMuZXh0cmE7emI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWMub2Zmc2V0Kz1tJigxPDxjLmV4dHJhKS0xLG0+Pj49Yy5leHRyYSxuLT1jLmV4dHJhLGMuYmFjays9Yy5leHRyYX1pZihjLm9mZnNldD5jLmRtYXgpe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixjLm1vZGU9bGI7YnJlYWt9Yy5tb2RlPWdiO2Nhc2UgZ2I6aWYoMD09PWopYnJlYWsgYTtpZihxPXAtaixjLm9mZnNldD5xKXtpZihxPWMub2Zmc2V0LXEscT5jLndoYXZlJiZjLnNhbmUpe2EubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixjLm1vZGU9bGI7YnJlYWt9cT5jLnduZXh0PyhxLT1jLnduZXh0LG9iPWMud3NpemUtcSk6b2I9Yy53bmV4dC1xLHE+Yy5sZW5ndGgmJihxPWMubGVuZ3RoKSxwYj1jLndpbmRvd31lbHNlIHBiPWYsb2I9aC1jLm9mZnNldCxxPWMubGVuZ3RoO3E+aiYmKHE9aiksai09cSxjLmxlbmd0aC09cTtkbyBmW2grK109cGJbb2IrK107d2hpbGUoLS1xKTswPT09Yy5sZW5ndGgmJihjLm1vZGU9Y2IpO2JyZWFrO2Nhc2UgaGI6aWYoMD09PWopYnJlYWsgYTtmW2grK109Yy5sZW5ndGgsai0tLGMubW9kZT1jYjticmVhaztjYXNlIGliOmlmKGMud3JhcCl7Zm9yKDszMj5uOyl7aWYoMD09PWkpYnJlYWsgYTtpLS0sbXw9ZVtnKytdPDxuLG4rPTh9aWYocC09aixhLnRvdGFsX291dCs9cCxjLnRvdGFsKz1wLHAmJihhLmFkbGVyPWMuY2hlY2s9Yy5mbGFncz90KGMuY2hlY2ssZixwLGgtcCk6cyhjLmNoZWNrLGYscCxoLXApKSxwPWosKGMuZmxhZ3M/bTpkKG0pKSE9PWMuY2hlY2spe2EubXNnPVwiaW5jb3JyZWN0IGRhdGEgY2hlY2tcIixjLm1vZGU9bGI7YnJlYWt9bT0wLG49MH1jLm1vZGU9amI7Y2FzZSBqYjppZihjLndyYXAmJmMuZmxhZ3Mpe2Zvcig7MzI+bjspe2lmKDA9PT1pKWJyZWFrIGE7aS0tLG0rPWVbZysrXTw8bixuKz04fWlmKG0hPT0oNDI5NDk2NzI5NSZjLnRvdGFsKSl7YS5tc2c9XCJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrXCIsYy5tb2RlPWxiO2JyZWFrfW09MCxuPTB9Yy5tb2RlPWtiO2Nhc2Uga2I6eGI9RDticmVhayBhO2Nhc2UgbGI6eGI9RzticmVhayBhO2Nhc2UgbWI6cmV0dXJuIEg7Y2FzZSBuYjpkZWZhdWx0OnJldHVybiBGfXJldHVybiBhLm5leHRfb3V0PWgsYS5hdmFpbF9vdXQ9aixhLm5leHRfaW49ZyxhLmF2YWlsX2luPWksYy5ob2xkPW0sYy5iaXRzPW4sKGMud3NpemV8fHAhPT1hLmF2YWlsX291dCYmYy5tb2RlPGxiJiYoYy5tb2RlPGlifHxiIT09eikpJiZsKGEsYS5vdXRwdXQsYS5uZXh0X291dCxwLWEuYXZhaWxfb3V0KT8oYy5tb2RlPW1iLEgpOihvLT1hLmF2YWlsX2luLHAtPWEuYXZhaWxfb3V0LGEudG90YWxfaW4rPW8sYS50b3RhbF9vdXQrPXAsYy50b3RhbCs9cCxjLndyYXAmJnAmJihhLmFkbGVyPWMuY2hlY2s9Yy5mbGFncz90KGMuY2hlY2ssZixwLGEubmV4dF9vdXQtcCk6cyhjLmNoZWNrLGYscCxhLm5leHRfb3V0LXApKSxhLmRhdGFfdHlwZT1jLmJpdHMrKGMubGFzdD82NDowKSsoYy5tb2RlPT09Vj8xMjg6MCkrKGMubW9kZT09PWJifHxjLm1vZGU9PT1ZPzI1NjowKSwoMD09PW8mJjA9PT1wfHxiPT09eikmJnhiPT09QyYmKHhiPUkpLHhiKX1mdW5jdGlvbiBuKGEpe2lmKCFhfHwhYS5zdGF0ZSlyZXR1cm4gRjt2YXIgYj1hLnN0YXRlO3JldHVybiBiLndpbmRvdyYmKGIud2luZG93PW51bGwpLGEuc3RhdGU9bnVsbCxDfWZ1bmN0aW9uIG8oYSxiKXt2YXIgYztyZXR1cm4gYSYmYS5zdGF0ZT8oYz1hLnN0YXRlLDA9PT0oMiZjLndyYXApP0Y6KGMuaGVhZD1iLGIuZG9uZT0hMSxDKSk6Rn12YXIgcCxxLHI9YShcIi4uL3V0aWxzL2NvbW1vblwiKSxzPWEoXCIuL2FkbGVyMzJcIiksdD1hKFwiLi9jcmMzMlwiKSx1PWEoXCIuL2luZmZhc3RcIiksdj1hKFwiLi9pbmZ0cmVlc1wiKSx3PTAseD0xLHk9Mix6PTQsQT01LEI9NixDPTAsRD0xLEU9MixGPS0yLEc9LTMsSD0tNCxJPS01LEo9OCxLPTEsTD0yLE09MyxOPTQsTz01LFA9NixRPTcsUj04LFM9OSxUPTEwLFU9MTEsVj0xMixXPTEzLFg9MTQsWT0xNSxaPTE2LCQ9MTcsXz0xOCxhYj0xOSxiYj0yMCxjYj0yMSxkYj0yMixlYj0yMyxmYj0yNCxnYj0yNSxoYj0yNixpYj0yNyxqYj0yOCxrYj0yOSxsYj0zMCxtYj0zMSxuYj0zMixvYj04NTIscGI9NTkyLHFiPTE1LHJiPXFiLHNiPSEwO2MuaW5mbGF0ZVJlc2V0PWcsYy5pbmZsYXRlUmVzZXQyPWgsYy5pbmZsYXRlUmVzZXRLZWVwPWYsYy5pbmZsYXRlSW5pdD1qLGMuaW5mbGF0ZUluaXQyPWksYy5pbmZsYXRlPW0sYy5pbmZsYXRlRW5kPW4sYy5pbmZsYXRlR2V0SGVhZGVyPW8sYy5pbmZsYXRlSW5mbz1cInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdClcIn0se1wiLi4vdXRpbHMvY29tbW9uXCI6MjcsXCIuL2FkbGVyMzJcIjoyOSxcIi4vY3JjMzJcIjozMSxcIi4vaW5mZmFzdFwiOjM0LFwiLi9pbmZ0cmVlc1wiOjM2fV0sMzY6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9YShcIi4uL3V0aWxzL2NvbW1vblwiKSxkPTE1LGU9ODUyLGY9NTkyLGc9MCxoPTEsaT0yLGo9WzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsMCwwXSxrPVsxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNywxNywxNywxNywxOCwxOCwxOCwxOCwxOSwxOSwxOSwxOSwyMCwyMCwyMCwyMCwyMSwyMSwyMSwyMSwxNiw3Miw3OF0sbD1bMSwyLDMsNCw1LDcsOSwxMywxNywyNSwzMyw0OSw2NSw5NywxMjksMTkzLDI1NywzODUsNTEzLDc2OSwxMDI1LDE1MzcsMjA0OSwzMDczLDQwOTcsNjE0NSw4MTkzLDEyMjg5LDE2Mzg1LDI0NTc3LDAsMF0sbT1bMTYsMTYsMTYsMTYsMTcsMTcsMTgsMTgsMTksMTksMjAsMjAsMjEsMjEsMjIsMjIsMjMsMjMsMjQsMjQsMjUsMjUsMjYsMjYsMjcsMjcsMjgsMjgsMjksMjksNjQsNjRdO2IuZXhwb3J0cz1mdW5jdGlvbihhLGIsbixvLHAscSxyLHMpe3ZhciB0LHUsdix3LHgseSx6LEEsQixDPXMuYml0cyxEPTAsRT0wLEY9MCxHPTAsSD0wLEk9MCxKPTAsSz0wLEw9MCxNPTAsTj1udWxsLE89MCxQPW5ldyBjLkJ1ZjE2KGQrMSksUT1uZXcgYy5CdWYxNihkKzEpLFI9bnVsbCxTPTA7Zm9yKEQ9MDtkPj1EO0QrKylQW0RdPTA7Zm9yKEU9MDtvPkU7RSsrKVBbYltuK0VdXSsrO2ZvcihIPUMsRz1kO0c+PTEmJjA9PT1QW0ddO0ctLSk7aWYoSD5HJiYoSD1HKSwwPT09RylyZXR1cm4gcFtxKytdPTIwOTcxNTIwLHBbcSsrXT0yMDk3MTUyMCxzLmJpdHM9MSwwO2ZvcihGPTE7Rz5GJiYwPT09UFtGXTtGKyspO2ZvcihGPkgmJihIPUYpLEs9MSxEPTE7ZD49RDtEKyspaWYoSzw8PTEsSy09UFtEXSwwPkspcmV0dXJuLTE7aWYoSz4wJiYoYT09PWd8fDEhPT1HKSlyZXR1cm4tMTtmb3IoUVsxXT0wLEQ9MTtkPkQ7RCsrKVFbRCsxXT1RW0RdK1BbRF07Zm9yKEU9MDtvPkU7RSsrKTAhPT1iW24rRV0mJihyW1FbYltuK0VdXSsrXT1FKTtpZihhPT09Zz8oTj1SPXIseT0xOSk6YT09PWg/KE49aixPLT0yNTcsUj1rLFMtPTI1Nyx5PTI1Nik6KE49bCxSPW0seT0tMSksTT0wLEU9MCxEPUYseD1xLEk9SCxKPTAsdj0tMSxMPTE8PEgsdz1MLTEsYT09PWgmJkw+ZXx8YT09PWkmJkw+ZilyZXR1cm4gMTtmb3IodmFyIFQ9MDs7KXtUKyssej1ELUoscltFXTx5PyhBPTAsQj1yW0VdKTpyW0VdPnk/KEE9UltTK3JbRV1dLEI9TltPK3JbRV1dKTooQT05NixCPTApLHQ9MTw8RC1KLHU9MTw8SSxGPXU7ZG8gdS09dCxwW3grKE0+PkopK3VdPXo8PDI0fEE8PDE2fEJ8MDt3aGlsZSgwIT09dSk7Zm9yKHQ9MTw8RC0xO00mdDspdD4+PTE7aWYoMCE9PXQ/KE0mPXQtMSxNKz10KTpNPTAsRSsrLDA9PT0tLVBbRF0pe2lmKEQ9PT1HKWJyZWFrO0Q9YltuK3JbRV1dfWlmKEQ+SCYmKE0mdykhPT12KXtmb3IoMD09PUomJihKPUgpLHgrPUYsST1ELUosSz0xPDxJO0c+SStKJiYoSy09UFtJK0pdLCEoMD49SykpOylJKyssSzw8PTE7aWYoTCs9MTw8SSxhPT09aCYmTD5lfHxhPT09aSYmTD5mKXJldHVybiAxO3Y9TSZ3LHBbdl09SDw8MjR8STw8MTZ8eC1xfDB9fXJldHVybiAwIT09TSYmKHBbeCtNXT1ELUo8PDI0fDY0PDwxNnwwKSxzLmJpdHM9SCwwfX0se1wiLi4vdXRpbHMvY29tbW9uXCI6Mjd9XSwzNzpbZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtiLmV4cG9ydHM9ezI6XCJuZWVkIGRpY3Rpb25hcnlcIiwxOlwic3RyZWFtIGVuZFwiLDA6XCJcIixcIi0xXCI6XCJmaWxlIGVycm9yXCIsXCItMlwiOlwic3RyZWFtIGVycm9yXCIsXCItM1wiOlwiZGF0YSBlcnJvclwiLFwiLTRcIjpcImluc3VmZmljaWVudCBtZW1vcnlcIixcIi01XCI6XCJidWZmZXIgZXJyb3JcIixcIi02XCI6XCJpbmNvbXBhdGlibGUgdmVyc2lvblwifX0se31dLDM4OltmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZChhKXtmb3IodmFyIGI9YS5sZW5ndGg7LS1iPj0wOylhW2JdPTB9ZnVuY3Rpb24gZShhKXtyZXR1cm4gMjU2PmE/Z2JbYV06Z2JbMjU2KyhhPj4+NyldfWZ1bmN0aW9uIGYoYSxiKXthLnBlbmRpbmdfYnVmW2EucGVuZGluZysrXT0yNTUmYixhLnBlbmRpbmdfYnVmW2EucGVuZGluZysrXT1iPj4+OCYyNTV9ZnVuY3Rpb24gZyhhLGIsYyl7YS5iaV92YWxpZD5WLWM/KGEuYmlfYnVmfD1iPDxhLmJpX3ZhbGlkJjY1NTM1LGYoYSxhLmJpX2J1ZiksYS5iaV9idWY9Yj4+Vi1hLmJpX3ZhbGlkLGEuYmlfdmFsaWQrPWMtVik6KGEuYmlfYnVmfD1iPDxhLmJpX3ZhbGlkJjY1NTM1LGEuYmlfdmFsaWQrPWMpfWZ1bmN0aW9uIGgoYSxiLGMpe2coYSxjWzIqYl0sY1syKmIrMV0pfWZ1bmN0aW9uIGkoYSxiKXt2YXIgYz0wO2RvIGN8PTEmYSxhPj4+PTEsYzw8PTE7d2hpbGUoLS1iPjApO3JldHVybiBjPj4+MX1mdW5jdGlvbiBqKGEpezE2PT09YS5iaV92YWxpZD8oZihhLGEuYmlfYnVmKSxhLmJpX2J1Zj0wLGEuYmlfdmFsaWQ9MCk6YS5iaV92YWxpZD49OCYmKGEucGVuZGluZ19idWZbYS5wZW5kaW5nKytdPTI1NSZhLmJpX2J1ZixhLmJpX2J1Zj4+PTgsYS5iaV92YWxpZC09OCl9ZnVuY3Rpb24gayhhLGIpe3ZhciBjLGQsZSxmLGcsaCxpPWIuZHluX3RyZWUsaj1iLm1heF9jb2RlLGs9Yi5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsbD1iLnN0YXRfZGVzYy5oYXNfc3RyZWUsbT1iLnN0YXRfZGVzYy5leHRyYV9iaXRzLG49Yi5zdGF0X2Rlc2MuZXh0cmFfYmFzZSxvPWIuc3RhdF9kZXNjLm1heF9sZW5ndGgscD0wO2ZvcihmPTA7VT49ZjtmKyspYS5ibF9jb3VudFtmXT0wO2ZvcihpWzIqYS5oZWFwW2EuaGVhcF9tYXhdKzFdPTAsYz1hLmhlYXBfbWF4KzE7VD5jO2MrKylkPWEuaGVhcFtjXSxmPWlbMippWzIqZCsxXSsxXSsxLGY+byYmKGY9byxwKyspLGlbMipkKzFdPWYsZD5qfHwoYS5ibF9jb3VudFtmXSsrLGc9MCxkPj1uJiYoZz1tW2Qtbl0pLGg9aVsyKmRdLGEub3B0X2xlbis9aCooZitnKSxsJiYoYS5zdGF0aWNfbGVuKz1oKihrWzIqZCsxXStnKSkpO2lmKDAhPT1wKXtkb3tmb3IoZj1vLTE7MD09PWEuYmxfY291bnRbZl07KWYtLTthLmJsX2NvdW50W2ZdLS0sYS5ibF9jb3VudFtmKzFdKz0yLGEuYmxfY291bnRbb10tLSxwLT0yfXdoaWxlKHA+MCk7Zm9yKGY9bzswIT09ZjtmLS0pZm9yKGQ9YS5ibF9jb3VudFtmXTswIT09ZDspZT1hLmhlYXBbLS1jXSxlPmp8fChpWzIqZSsxXSE9PWYmJihhLm9wdF9sZW4rPShmLWlbMiplKzFdKSppWzIqZV0saVsyKmUrMV09ZiksZC0tKX19ZnVuY3Rpb24gbChhLGIsYyl7dmFyIGQsZSxmPW5ldyBBcnJheShVKzEpLGc9MDtmb3IoZD0xO1U+PWQ7ZCsrKWZbZF09Zz1nK2NbZC0xXTw8MTtmb3IoZT0wO2I+PWU7ZSsrKXt2YXIgaD1hWzIqZSsxXTswIT09aCYmKGFbMiplXT1pKGZbaF0rKyxoKSl9fWZ1bmN0aW9uIG0oKXt2YXIgYSxiLGMsZCxlLGY9bmV3IEFycmF5KFUrMSk7Zm9yKGM9MCxkPTA7Ty0xPmQ7ZCsrKWZvcihpYltkXT1jLGE9MDthPDE8PF9bZF07YSsrKWhiW2MrK109ZDtmb3IoaGJbYy0xXT1kLGU9MCxkPTA7MTY+ZDtkKyspZm9yKGpiW2RdPWUsYT0wO2E8MTw8YWJbZF07YSsrKWdiW2UrK109ZDtmb3IoZT4+PTc7Uj5kO2QrKylmb3IoamJbZF09ZTw8NyxhPTA7YTwxPDxhYltkXS03O2ErKylnYlsyNTYrZSsrXT1kO2ZvcihiPTA7VT49YjtiKyspZltiXT0wO2ZvcihhPTA7MTQzPj1hOyllYlsyKmErMV09OCxhKyssZls4XSsrO2Zvcig7MjU1Pj1hOyllYlsyKmErMV09OSxhKyssZls5XSsrO2Zvcig7Mjc5Pj1hOyllYlsyKmErMV09NyxhKyssZls3XSsrO2Zvcig7Mjg3Pj1hOyllYlsyKmErMV09OCxhKyssZls4XSsrO2ZvcihsKGViLFErMSxmKSxhPTA7Uj5hO2ErKylmYlsyKmErMV09NSxmYlsyKmFdPWkoYSw1KTtrYj1uZXcgbmIoZWIsXyxQKzEsUSxVKSxsYj1uZXcgbmIoZmIsYWIsMCxSLFUpLG1iPW5ldyBuYihuZXcgQXJyYXkoMCksYmIsMCxTLFcpfWZ1bmN0aW9uIG4oYSl7dmFyIGI7Zm9yKGI9MDtRPmI7YisrKWEuZHluX2x0cmVlWzIqYl09MDtmb3IoYj0wO1I+YjtiKyspYS5keW5fZHRyZWVbMipiXT0wO2ZvcihiPTA7Uz5iO2IrKylhLmJsX3RyZWVbMipiXT0wO2EuZHluX2x0cmVlWzIqWF09MSxhLm9wdF9sZW49YS5zdGF0aWNfbGVuPTAsYS5sYXN0X2xpdD1hLm1hdGNoZXM9MH1mdW5jdGlvbiBvKGEpe2EuYmlfdmFsaWQ+OD9mKGEsYS5iaV9idWYpOmEuYmlfdmFsaWQ+MCYmKGEucGVuZGluZ19idWZbYS5wZW5kaW5nKytdPWEuYmlfYnVmKSxhLmJpX2J1Zj0wLGEuYmlfdmFsaWQ9MH1mdW5jdGlvbiBwKGEsYixjLGQpe28oYSksZCYmKGYoYSxjKSxmKGEsfmMpKSxFLmFycmF5U2V0KGEucGVuZGluZ19idWYsYS53aW5kb3csYixjLGEucGVuZGluZyksYS5wZW5kaW5nKz1jfWZ1bmN0aW9uIHEoYSxiLGMsZCl7dmFyIGU9MipiLGY9MipjO3JldHVybiBhW2VdPGFbZl18fGFbZV09PT1hW2ZdJiZkW2JdPD1kW2NdfWZ1bmN0aW9uIHIoYSxiLGMpe2Zvcih2YXIgZD1hLmhlYXBbY10sZT1jPDwxO2U8PWEuaGVhcF9sZW4mJihlPGEuaGVhcF9sZW4mJnEoYixhLmhlYXBbZSsxXSxhLmhlYXBbZV0sYS5kZXB0aCkmJmUrKywhcShiLGQsYS5oZWFwW2VdLGEuZGVwdGgpKTspYS5oZWFwW2NdPWEuaGVhcFtlXSxjPWUsZTw8PTE7YS5oZWFwW2NdPWR9ZnVuY3Rpb24gcyhhLGIsYyl7dmFyIGQsZixpLGosaz0wO2lmKDAhPT1hLmxhc3RfbGl0KWRvIGQ9YS5wZW5kaW5nX2J1ZlthLmRfYnVmKzIqa108PDh8YS5wZW5kaW5nX2J1ZlthLmRfYnVmKzIqaysxXSxmPWEucGVuZGluZ19idWZbYS5sX2J1ZitrXSxrKyssMD09PWQ/aChhLGYsYik6KGk9aGJbZl0saChhLGkrUCsxLGIpLGo9X1tpXSwwIT09aiYmKGYtPWliW2ldLGcoYSxmLGopKSxkLS0saT1lKGQpLGgoYSxpLGMpLGo9YWJbaV0sMCE9PWomJihkLT1qYltpXSxnKGEsZCxqKSkpO3doaWxlKGs8YS5sYXN0X2xpdCk7aChhLFgsYil9ZnVuY3Rpb24gdChhLGIpe3ZhciBjLGQsZSxmPWIuZHluX3RyZWUsZz1iLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxoPWIuc3RhdF9kZXNjLmhhc19zdHJlZSxpPWIuc3RhdF9kZXNjLmVsZW1zLGo9LTE7Zm9yKGEuaGVhcF9sZW49MCxhLmhlYXBfbWF4PVQsYz0wO2k+YztjKyspMCE9PWZbMipjXT8oYS5oZWFwWysrYS5oZWFwX2xlbl09aj1jLGEuZGVwdGhbY109MCk6ZlsyKmMrMV09MDtmb3IoO2EuaGVhcF9sZW48MjspZT1hLmhlYXBbKythLmhlYXBfbGVuXT0yPmo/KytqOjAsZlsyKmVdPTEsYS5kZXB0aFtlXT0wLGEub3B0X2xlbi0tLGgmJihhLnN0YXRpY19sZW4tPWdbMiplKzFdKTtmb3IoYi5tYXhfY29kZT1qLGM9YS5oZWFwX2xlbj4+MTtjPj0xO2MtLSlyKGEsZixjKTtlPWk7ZG8gYz1hLmhlYXBbMV0sYS5oZWFwWzFdPWEuaGVhcFthLmhlYXBfbGVuLS1dLHIoYSxmLDEpLGQ9YS5oZWFwWzFdLGEuaGVhcFstLWEuaGVhcF9tYXhdPWMsYS5oZWFwWy0tYS5oZWFwX21heF09ZCxmWzIqZV09ZlsyKmNdK2ZbMipkXSxhLmRlcHRoW2VdPShhLmRlcHRoW2NdPj1hLmRlcHRoW2RdP2EuZGVwdGhbY106YS5kZXB0aFtkXSkrMSxmWzIqYysxXT1mWzIqZCsxXT1lLGEuaGVhcFsxXT1lKysscihhLGYsMSk7d2hpbGUoYS5oZWFwX2xlbj49Mik7YS5oZWFwWy0tYS5oZWFwX21heF09YS5oZWFwWzFdLGsoYSxiKSxsKGYsaixhLmJsX2NvdW50KX1mdW5jdGlvbiB1KGEsYixjKXt2YXIgZCxlLGY9LTEsZz1iWzFdLGg9MCxpPTcsaj00O2ZvcigwPT09ZyYmKGk9MTM4LGo9MyksYlsyKihjKzEpKzFdPTY1NTM1LGQ9MDtjPj1kO2QrKyllPWcsZz1iWzIqKGQrMSkrMV0sKytoPGkmJmU9PT1nfHwoaj5oP2EuYmxfdHJlZVsyKmVdKz1oOjAhPT1lPyhlIT09ZiYmYS5ibF90cmVlWzIqZV0rKyxhLmJsX3RyZWVbMipZXSsrKToxMD49aD9hLmJsX3RyZWVbMipaXSsrOmEuYmxfdHJlZVsyKiRdKyssaD0wLGY9ZSwwPT09Zz8oaT0xMzgsaj0zKTplPT09Zz8oaT02LGo9Myk6KGk9NyxqPTQpKX1mdW5jdGlvbiB2KGEsYixjKXt2YXIgZCxlLGY9LTEsaT1iWzFdLGo9MCxrPTcsbD00O2ZvcigwPT09aSYmKGs9MTM4LGw9MyksZD0wO2M+PWQ7ZCsrKWlmKGU9aSxpPWJbMiooZCsxKSsxXSwhKCsrajxrJiZlPT09aSkpe2lmKGw+ail7ZG8gaChhLGUsYS5ibF90cmVlKTt3aGlsZSgwIT09LS1qKX1lbHNlIDAhPT1lPyhlIT09ZiYmKGgoYSxlLGEuYmxfdHJlZSksai0tKSxoKGEsWSxhLmJsX3RyZWUpLGcoYSxqLTMsMikpOjEwPj1qPyhoKGEsWixhLmJsX3RyZWUpLGcoYSxqLTMsMykpOihoKGEsJCxhLmJsX3RyZWUpLGcoYSxqLTExLDcpKTtqPTAsZj1lLDA9PT1pPyhrPTEzOCxsPTMpOmU9PT1pPyhrPTYsbD0zKTooaz03LGw9NCl9fWZ1bmN0aW9uIHcoYSl7dmFyIGI7Zm9yKHUoYSxhLmR5bl9sdHJlZSxhLmxfZGVzYy5tYXhfY29kZSksdShhLGEuZHluX2R0cmVlLGEuZF9kZXNjLm1heF9jb2RlKSx0KGEsYS5ibF9kZXNjKSxiPVMtMTtiPj0zJiYwPT09YS5ibF90cmVlWzIqY2JbYl0rMV07Yi0tKTtyZXR1cm4gYS5vcHRfbGVuKz0zKihiKzEpKzUrNSs0LGJ9ZnVuY3Rpb24geChhLGIsYyxkKXt2YXIgZTtmb3IoZyhhLGItMjU3LDUpLGcoYSxjLTEsNSksZyhhLGQtNCw0KSxlPTA7ZD5lO2UrKylnKGEsYS5ibF90cmVlWzIqY2JbZV0rMV0sMyk7dihhLGEuZHluX2x0cmVlLGItMSksdihhLGEuZHluX2R0cmVlLGMtMSl9ZnVuY3Rpb24geShhKXt2YXIgYixjPTQwOTM2MjQ0NDc7Zm9yKGI9MDszMT49YjtiKyssYz4+Pj0xKWlmKDEmYyYmMCE9PWEuZHluX2x0cmVlWzIqYl0pcmV0dXJuIEc7aWYoMCE9PWEuZHluX2x0cmVlWzE4XXx8MCE9PWEuZHluX2x0cmVlWzIwXXx8MCE9PWEuZHluX2x0cmVlWzI2XSlyZXR1cm4gSDtmb3IoYj0zMjtQPmI7YisrKWlmKDAhPT1hLmR5bl9sdHJlZVsyKmJdKXJldHVybiBIO3JldHVybiBHfWZ1bmN0aW9uIHooYSl7cGJ8fChtKCkscGI9ITApLGEubF9kZXNjPW5ldyBvYihhLmR5bl9sdHJlZSxrYiksYS5kX2Rlc2M9bmV3IG9iKGEuZHluX2R0cmVlLGxiKSxhLmJsX2Rlc2M9bmV3IG9iKGEuYmxfdHJlZSxtYiksYS5iaV9idWY9MCxhLmJpX3ZhbGlkPTAsbihhKX1mdW5jdGlvbiBBKGEsYixjLGQpe2coYSwoSjw8MSkrKGQ/MTowKSwzKSxwKGEsYixjLCEwKX1mdW5jdGlvbiBCKGEpe2coYSxLPDwxLDMpLGgoYSxYLGViKSxqKGEpfWZ1bmN0aW9uIEMoYSxiLGMsZCl7dmFyIGUsZixoPTA7YS5sZXZlbD4wPyhhLnN0cm0uZGF0YV90eXBlPT09SSYmKGEuc3RybS5kYXRhX3R5cGU9eShhKSksdChhLGEubF9kZXNjKSx0KGEsYS5kX2Rlc2MpLGg9dyhhKSxlPWEub3B0X2xlbiszKzc+Pj4zLGY9YS5zdGF0aWNfbGVuKzMrNz4+PjMsZT49ZiYmKGU9ZikpOmU9Zj1jKzUsZT49Yys0JiYtMSE9PWI/QShhLGIsYyxkKTphLnN0cmF0ZWd5PT09Rnx8Zj09PWU/KGcoYSwoSzw8MSkrKGQ/MTowKSwzKSxzKGEsZWIsZmIpKTooZyhhLChMPDwxKSsoZD8xOjApLDMpLHgoYSxhLmxfZGVzYy5tYXhfY29kZSsxLGEuZF9kZXNjLm1heF9jb2RlKzEsaCsxKSxzKGEsYS5keW5fbHRyZWUsYS5keW5fZHRyZWUpKSxuKGEpLGQmJm8oYSl9ZnVuY3Rpb24gRChhLGIsYyl7cmV0dXJuIGEucGVuZGluZ19idWZbYS5kX2J1ZisyKmEubGFzdF9saXRdPWI+Pj44JjI1NSxhLnBlbmRpbmdfYnVmW2EuZF9idWYrMiphLmxhc3RfbGl0KzFdPTI1NSZiLGEucGVuZGluZ19idWZbYS5sX2J1ZithLmxhc3RfbGl0XT0yNTUmYyxhLmxhc3RfbGl0KyssMD09PWI/YS5keW5fbHRyZWVbMipjXSsrOihhLm1hdGNoZXMrKyxiLS0sYS5keW5fbHRyZWVbMiooaGJbY10rUCsxKV0rKyxhLmR5bl9kdHJlZVsyKmUoYildKyspLGEubGFzdF9saXQ9PT1hLmxpdF9idWZzaXplLTF9dmFyIEU9YShcIi4uL3V0aWxzL2NvbW1vblwiKSxGPTQsRz0wLEg9MSxJPTIsSj0wLEs9MSxMPTIsTT0zLE49MjU4LE89MjksUD0yNTYsUT1QKzErTyxSPTMwLFM9MTksVD0yKlErMSxVPTE1LFY9MTYsVz03LFg9MjU2LFk9MTYsWj0xNywkPTE4LF89WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0sYWI9WzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdLGJiPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSxjYj1bMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0sZGI9NTEyLGViPW5ldyBBcnJheSgyKihRKzIpKTtkKGViKTt2YXIgZmI9bmV3IEFycmF5KDIqUik7ZChmYik7dmFyIGdiPW5ldyBBcnJheShkYik7ZChnYik7dmFyIGhiPW5ldyBBcnJheShOLU0rMSk7ZChoYik7dmFyIGliPW5ldyBBcnJheShPKTtkKGliKTt2YXIgamI9bmV3IEFycmF5KFIpO2QoamIpO3ZhciBrYixsYixtYixuYj1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuc3RhdGljX3RyZWU9YSx0aGlzLmV4dHJhX2JpdHM9Yix0aGlzLmV4dHJhX2Jhc2U9Yyx0aGlzLmVsZW1zPWQsdGhpcy5tYXhfbGVuZ3RoPWUsdGhpcy5oYXNfc3RyZWU9YSYmYS5sZW5ndGh9LG9iPWZ1bmN0aW9uKGEsYil7dGhpcy5keW5fdHJlZT1hLHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz1ifSxwYj0hMTtjLl90cl9pbml0PXosYy5fdHJfc3RvcmVkX2Jsb2NrPUEsYy5fdHJfZmx1c2hfYmxvY2s9QyxjLl90cl90YWxseT1ELGMuX3RyX2FsaWduPUJ9LHtcIi4uL3V0aWxzL2NvbW1vblwiOjI3fV0sMzk6W2Z1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYygpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz1cIlwiLHRoaXMuc3RhdGU9bnVsbCx0aGlzLmRhdGFfdHlwZT0yLHRoaXMuYWRsZXI9MH1iLmV4cG9ydHM9Y30se31dfSx7fSxbOV0pKDkpfSk7IiwiLyohXHJcbiAqIEhUTUw1IGV4cG9ydCBidXR0b25zIGZvciBCdXR0b25zIGFuZCBEYXRhVGFibGVzLlxyXG4gKiAyMDE2IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcbiAqXHJcbiAqIEZpbGVTYXZlci5qcyAoMS4zLjMpIC0gTUlUIGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IMKpIDIwMTYgRWxpIEdyZXkgLSBodHRwOi8vZWxpZ3JleS5jb21cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICAvLyBBTURcclxuICAgICAgICBkZWZpbmUoWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnLCAnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucyddLCBmdW5jdGlvbiAoJCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCB3aW5kb3csIGRvY3VtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIENvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCwganN6aXAsIHBkZm1ha2UpIHtcclxuICAgICAgICAgICAgaWYgKCFyb290KSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gd2luZG93O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoISQgfHwgISQuZm4uZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQnKShyb290LCAkKS4kO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoISQuZm4uZGF0YVRhYmxlLkJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMnKShyb290LCAkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoJCwgcm9vdCwgcm9vdC5kb2N1bWVudCwganN6aXAsIHBkZm1ha2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyXHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG59KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCBqc3ppcCwgcGRmbWFrZSwgdW5kZWZpbmVkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgRGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XHJcblxyXG4gICAgLy8gQWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIHBhc3MgaW4gSlNaaXAgYW5kIFBERk1ha2UgZnJvbSBleHRlcm5hbCByZXF1aXJlcy5cclxuICAgIC8vIE90aGVyd2lzZSwgdXNlIGdsb2JhbGx5IGRlZmluZWQgdmFyaWFibGVzLCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXHJcbiAgICBmdW5jdGlvbiBfanNaaXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGpzemlwIHx8IHdpbmRvdy5KU1ppcDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9wZGZNYWtlKCkge1xyXG4gICAgICAgIHJldHVybiBwZGZtYWtlIHx8IHdpbmRvdy5wZGZNYWtlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcclxuICAgICAqIEZpbGVTYXZlci5qcyBkZXBlbmRlbmN5XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlLCBpbmRlbnQ6IDQsIGxheGJyZWFrOiB0cnVlLCBsYXhjb21tYTogdHJ1ZSwgc21hcnR0YWJzOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSAqL1xyXG5cclxuICAgIHZhciBfc2F2ZUFzID0gKGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgLy8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcclxuICAgICAgICBpZiAodHlwZW9mIHZpZXcgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICBkb2MgPSB2aWV3LmRvY3VtZW50XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZ2V0IFVSTCB3aGVuIG5lY2Vzc2FyeSBpbiBjYXNlIEJsb2IuanMgaGFzbid0IG92ZXJyaWRkZW4gaXQgeWV0XHJcbiAgICAgICAgICAgICwgZ2V0X1VSTCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwgc2F2ZV9saW5rID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXHJcbiAgICAgICAgICAgICwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXHJcbiAgICAgICAgICAgICwgY2xpY2sgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLCBpc19zYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHZpZXcuSFRNTEVsZW1lbnQpIHx8IHZpZXcuc2FmYXJpXHJcbiAgICAgICAgICAgICwgaXNfY2hyb21lX2lvcyA9IC9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxyXG4gICAgICAgICAgICAsIHRocm93X291dHNpZGUgPSBmdW5jdGlvbiAoZXgpIHtcclxuICAgICAgICAgICAgICAgICh2aWV3LnNldEltbWVkaWF0ZSB8fCB2aWV3LnNldFRpbWVvdXQpKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwgZm9yY2Vfc2F2ZWFibGVfdHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcclxuICAgICAgICAgICAgLy8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICAgICAgICAsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCA9IDEwMDAgKiA0MCAvLyBpbiBtc1xyXG4gICAgICAgICAgICAsIHJldm9rZSA9IGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV2b2tlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09IFwic3RyaW5nXCIpIHsgLy8gZmlsZSBpcyBhbiBvYmplY3QgVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldF9VUkwoKS5yZXZva2VPYmplY3RVUkwoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXZva2VyLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwgZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50X3R5cGVzID0gW10uY29uY2F0KGV2ZW50X3R5cGVzKTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZpbGVzYXZlcltcIm9uXCIgKyBldmVudF90eXBlc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGZpbGVzYXZlciwgZXZlbnQgfHwgZmlsZXNhdmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93X291dHNpZGUoZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwgYXV0b19ib20gPSBmdW5jdGlvbiAoYmxvYikge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcclxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXHJcbiAgICAgICAgICAgICAgICBpZiAoL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwgeyB0eXBlOiBibG9iLnR5cGUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAsIEZpbGVTYXZlciA9IGZ1bmN0aW9uIChibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub19hdXRvX2JvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBhdXRvX2JvbShibG9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXHJcbiAgICAgICAgICAgICAgICB2YXJcclxuICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIgPSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLCB0eXBlID0gYmxvYi50eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgLCBmb3JjZSA9IHR5cGUgPT09IGZvcmNlX3NhdmVhYmxlX3R5cGVcclxuICAgICAgICAgICAgICAgICAgICAsIG9iamVjdF91cmxcclxuICAgICAgICAgICAgICAgICAgICAsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goZmlsZXNhdmVyLCBcIndyaXRlc3RhcnQgcHJvZ3Jlc3Mgd3JpdGUgd3JpdGVlbmRcIi5zcGxpdChcIiBcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXHJcbiAgICAgICAgICAgICAgICAgICAgLCBmc19lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19jaHJvbWVfaW9zIHx8IChmb3JjZSAmJiBpc19zYWZhcmkpKSAmJiB2aWV3LkZpbGVSZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgdXJsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBpc19jaHJvbWVfaW9zID8gcmVhZGVyLnJlc3VsdCA6IHJlYWRlci5yZXN1bHQucmVwbGFjZSgvXmRhdGE6W147XSo7LywgJ2RhdGE6YXR0YWNobWVudC9maWxlOycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IHZpZXcub3Blbih1cmwsICdfYmxhbmsnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcHVwKSB2aWV3LmxvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkOyAvLyByZWxlYXNlIHJlZmVyZW5jZSBiZWZvcmUgZGlzcGF0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoX2FsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjcmVhdGUgbW9yZSBvYmplY3QgVVJMcyB0aGFuIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdF91cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuZWQgPSB2aWV3Lm9wZW4ob2JqZWN0X3VybCwgXCJfYmxhbmtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIGRvZXMgbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vVG9vbHMvQ29uY2VwdHVhbC9TYWZhcmlFeHRlbnNpb25HdWlkZS9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMuaHRtbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hfYWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldm9rZShvYmplY3RfdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuX3VzZV9zYXZlX2xpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZV9saW5rLmhyZWYgPSBvYmplY3RfdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlX2xpbmsuZG93bmxvYWQgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljayhzYXZlX2xpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaF9hbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2b2tlKG9iamVjdF91cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmc19lcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwgRlNfcHJvdG8gPSBGaWxlU2F2ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICAgICwgc2F2ZUFzID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgLy8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFub19hdXRvX2JvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBhdXRvX2JvbShibG9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcclxuICAgICAgICBGU19wcm90by5XUklUSU5HID0gMTtcclxuICAgICAgICBGU19wcm90by5ET05FID0gMjtcclxuXHJcbiAgICAgICAgRlNfcHJvdG8uZXJyb3IgPVxyXG4gICAgICAgICAgICBGU19wcm90by5vbndyaXRlc3RhcnQgPVxyXG4gICAgICAgICAgICBGU19wcm90by5vbnByb2dyZXNzID1cclxuICAgICAgICAgICAgRlNfcHJvdG8ub253cml0ZSA9XHJcbiAgICAgICAgICAgIEZTX3Byb3RvLm9uYWJvcnQgPVxyXG4gICAgICAgICAgICBGU19wcm90by5vbmVycm9yID1cclxuICAgICAgICAgICAgRlNfcHJvdG8ub253cml0ZWVuZCA9XHJcbiAgICAgICAgICAgIG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiBzYXZlQXM7XHJcbiAgICB9KFxyXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcclxuICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xyXG4gICAgICAgIHx8IHRoaXMuY29udGVudFxyXG4gICAgKSk7XHJcblxyXG5cclxuICAgIC8vIEV4cG9zZSBmaWxlIHNhdmVyIG9uIHRoZSBEYXRhVGFibGVzIEFQSS4gQ2FuJ3QgYXR0YWNoIHRvIGBEYXRhVGFibGVzLkJ1dHRvbnNgXHJcbiAgICAvLyBzaW5jZSB0aGlzIGZpbGUgY2FuIGJlIGxvYWRlZCBiZWZvcmUgQnV0dG9uJ3MgY29yZSFcclxuICAgIERhdGFUYWJsZS5maWxlU2F2ZSA9IF9zYXZlQXM7XHJcblxyXG5cclxuICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICogTG9jYWwgKHByaXZhdGUpIGZ1bmN0aW9uc1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNoZWV0IG5hbWUgZm9yIEV4Y2VsIGV4cG9ydHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9XHRjb25maWcgQnV0dG9uIGNvbmZpZ3VyYXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIF9zaGVldG5hbWUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHNoZWV0TmFtZSA9ICdTaGVldDEnO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnNoZWV0TmFtZSkge1xyXG4gICAgICAgICAgICBzaGVldE5hbWUgPSBjb25maWcuc2hlZXROYW1lLnJlcGxhY2UoL1tcXFtcXF1cXCpcXC9cXFxcXFw/XFw6XS9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2hlZXROYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmV3bGluZSBjaGFyYWN0ZXIocylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH1cdGNvbmZpZyBCdXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVx0XHRcdFx0TmV3bGluZSBjaGFyYWN0ZXJcclxuICAgICAqL1xyXG4gICAgdmFyIF9uZXdMaW5lID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBjb25maWcubmV3bGluZSA/XHJcbiAgICAgICAgICAgIGNvbmZpZy5uZXdsaW5lIDpcclxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvV2luZG93cy8pID9cclxuICAgICAgICAgICAgICAgICdcXHJcXG4nIDpcclxuICAgICAgICAgICAgICAgICdcXG4nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgdGhlIGRhdGEgZnJvbSB0aGUgYGJ1dHRvbnMuZXhwb3J0RGF0YWAgbWV0aG9kIGludG8gYSBzdHJpbmcgdGhhdFxyXG4gICAgICogd2lsbCBiZSB1c2VkIGluIHRoZSBleHBvcnQgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW1cdHtEYXRhVGFibGUuQXBpfSBkdFx0XHQgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbVx0e29iamVjdH1cdFx0XHRcdGNvbmZpZyBCdXR0b24gY29uZmlndXJhdGlvblxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fVx0XHRcdFx0XHRcdFx0IFRoZSBkYXRhIHRvIGV4cG9ydFxyXG4gICAgICovXHJcbiAgICB2YXIgX2V4cG9ydERhdGEgPSBmdW5jdGlvbiAoZHQsIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBuZXdMaW5lID0gX25ld0xpbmUoY29uZmlnKTtcclxuICAgICAgICB2YXIgZGF0YSA9IGR0LmJ1dHRvbnMuZXhwb3J0RGF0YShjb25maWcuZXhwb3J0T3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY29uZmlnLmZpZWxkQm91bmRhcnk7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGNvbmZpZy5maWVsZFNlcGFyYXRvcjtcclxuICAgICAgICB2YXIgcmVCb3VuZGFyeSA9IG5ldyBSZWdFeHAoYm91bmRhcnksICdnJyk7XHJcbiAgICAgICAgdmFyIGVzY2FwZUNoYXIgPSBjb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgY29uZmlnLmVzY2FwZUNoYXIgOlxyXG4gICAgICAgICAgICAnXFxcXCc7XHJcbiAgICAgICAgdmFyIGpvaW4gPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmaWVsZCBib3VuZGFyeSwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIGVzY2FwZSBpdCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgc291cmNlIGRhdGFcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgKz0gc2VwYXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHMgKz0gYm91bmRhcnkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ICsgKCcnICsgYVtpXSkucmVwbGFjZShyZUJvdW5kYXJ5LCBlc2NhcGVDaGFyICsgYm91bmRhcnkpICsgYm91bmRhcnkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBoZWFkZXIgPSBjb25maWcuaGVhZGVyID8gam9pbihkYXRhLmhlYWRlcikgKyBuZXdMaW5lIDogJyc7XHJcbiAgICAgICAgdmFyIGZvb3RlciA9IGNvbmZpZy5mb290ZXIgJiYgZGF0YS5mb290ZXIgPyBuZXdMaW5lICsgam9pbihkYXRhLmZvb3RlcikgOiAnJztcclxuICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5ib2R5Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZHkucHVzaChqb2luKGRhdGEuYm9keVtpXSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RyOiBoZWFkZXIgKyBib2R5LmpvaW4obmV3TGluZSkgKyBmb290ZXIsXHJcbiAgICAgICAgICAgIHJvd3M6IGJvZHkubGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgKHByaW9yIHRvIHRlY2ggcHJldmlldyAxOCkgZG9uJ3Qgc3VwcG9ydCB0aGVcclxuICAgICAqIGRvd25sb2FkIG9wdGlvbiByZXF1aXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgb2xkIFNhZmFyaVxyXG4gICAgICovXHJcbiAgICB2YXIgX2lzRHVmZlNhZmFyaSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSAhPT0gLTEgJiZcclxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcclxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPcGVyYScpID09PSAtMTtcclxuXHJcbiAgICAgICAgaWYgKCFzYWZhcmkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrXFwuXFxkKykvKTtcclxuICAgICAgICBpZiAodmVyc2lvbiAmJiB2ZXJzaW9uLmxlbmd0aCA+IDEgJiYgdmVyc2lvblsxXSAqIDEgPCA2MDMuMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGZyb20gbnVtZXJpYyBwb3NpdGlvbiB0byBsZXR0ZXIgZm9yIGNvbHVtbiBuYW1lcyBpbiBFeGNlbFxyXG4gICAgICogQHBhcmFtICB7aW50fSBuIENvbHVtbiBudW1iZXJcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sdW1uIGxldHRlcihzKSBuYW1lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNlbGxQb3Mobikge1xyXG4gICAgICAgIHZhciBvcmRBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgdmFyIG9yZFogPSAnWicuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB2YXIgbGVuID0gb3JkWiAtIG9yZEEgKyAxO1xyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuXHJcbiAgICAgICAgd2hpbGUgKG4gPj0gMCkge1xyXG4gICAgICAgICAgICBzID0gU3RyaW5nLmZyb21DaGFyQ29kZShuICUgbGVuICsgb3JkQSkgKyBzO1xyXG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vcihuIC8gbGVuKSAtIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBfc2VyaWFsaXNlciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XHJcbiAgICAgICAgdmFyIF9pZUV4Y2VsO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKHQpIHsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlbHkgYWRkIFhNTCBmaWxlcyBmcm9tIGFuIG9iamVjdCdzIHN0cnVjdHVyZSB0byBhIFpJUCBmaWxlLiBUaGlzXHJcbiAgICAgKiBhbGxvd3MgdGhlIFhTTFggZmlsZSB0byBiZSBlYXNpbHkgZGVmaW5lZCB3aXRoIGFuIG9iamVjdCdzIHN0cnVjdHVyZSBtYXRjaGluZ1xyXG4gICAgICogdGhlIGZpbGVzIHN0cnVjdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0pTWmlwfSB6aXAgWklQIHBhY2thZ2VcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGFkZCAocmVjdXJzaXZlKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfYWRkVG9aaXAoemlwLCBvYmopIHtcclxuICAgICAgICBpZiAoX2llRXhjZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBEZXRlY3QgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBJRSdzIF9hd2Z1bF8gc2VyaWFsaXNlciBieSBzZWVpbmcgaWYgaXRcclxuICAgICAgICAgICAgLy8gZHJvcCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIF9pZUV4Y2VsID0gX3NlcmlhbGlzZXJcclxuICAgICAgICAgICAgICAgIC5zZXJpYWxpemVUb1N0cmluZyhcclxuICAgICAgICAgICAgICAgICAgICAkLnBhcnNlWE1MKGV4Y2VsU3RyaW5nc1sneGwvd29ya3NoZWV0cy9zaGVldDEueG1sJ10pXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuaW5kZXhPZigneG1sbnM6cicpID09PSAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlyID0gemlwLmZvbGRlcihuYW1lKTtcclxuICAgICAgICAgICAgICAgIF9hZGRUb1ppcChuZXdEaXIsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2llRXhjZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJRSdzIFhNTCBzZXJpYWxpc2VyIHdpbGwgZHJvcCBzb21lIG5hbWUgc3BhY2UgYXR0cmlidXRlcyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgcm9vdCBub2RlLCBzbyB3ZSBuZWVkIHRvIHNhdmUgdGhlbS4gRG8gdGhpcyBieVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2luZyB0aGUgbmFtZXNwYWNlIG5vZGVzIHdpdGggYSByZWd1bGFyIGF0dHJpYnV0ZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY29udmVydCBiYWNrIHdoZW4gc2VyaWFsaXNlZC4gRWRnZSBkb2VzIG5vdCBoYXZlIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3b3Jrc2hlZXQgPSB2YWwuY2hpbGROb2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSB3b3Jrc2hlZXQuYXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB3b3Jrc2hlZXQuYXR0cmlidXRlc1tpXS5ub2RlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHdvcmtzaGVldC5hdHRyaWJ1dGVzW2ldLm5vZGVWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKHsgbmFtZTogYXR0ck5hbWUsIHZhbHVlOiBhdHRyVmFsdWUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya3NoZWV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdmFsLmNyZWF0ZUF0dHJpYnV0ZShhdHRyc1tpXS5uYW1lLnJlcGxhY2UoJzonLCAnX2R0X2JfbmFtZXNwYWNlX3Rva2VuXycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jrc2hlZXQuc2V0QXR0cmlidXRlTm9kZShhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IF9zZXJpYWxpc2VyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4IElFJ3MgWE1MXHJcbiAgICAgICAgICAgICAgICBpZiAoX2llRXhjZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJRSBkb2Vzbid0IGluY2x1ZGUgdGhlIFhNTCBkZWNsYXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZignPD94bWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIG5hbWVzcGFjZSBhdHRyaWJ1dGVzIHRvIGJlaW5nIGFzIHN1Y2hcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvX2R0X2JfbmFtZXNwYWNlX3Rva2VuXy9nLCAnOicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSwgSUUgYW5kIEVkZ2Ugd2lsbCBwdXQgZW1wdHkgbmFtZSBzcGFjZSBhdHRyaWJ1dGVzIG9udG9cclxuICAgICAgICAgICAgICAgIC8vIHZhcmlvdXMgZWxlbWVudHMgbWFraW5nIHRoZW0gdXNlbGVzcy4gVGhpcyBzdHJpcHMgdGhlbSBvdXRcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88KFtePD5dKj8pIHhtbG5zPVwiXCIoW148Pl0qPyk+L2csICc8JDEgJDI+Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgemlwLmZpbGUobmFtZSwgc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIFhNTCBub2RlIGFuZCBhZGQgYW55IGNoaWxkcmVuLCBhdHRyaWJ1dGVzLCBldGMgd2l0aG91dCBuZWVkaW5nIHRvXHJcbiAgICAgKiBiZSB2ZXJib3NlIGluIHRoZSBET00uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBkb2MgICAgICBYTUwgZG9jdW1lbnRcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbm9kZU5hbWUgTm9kZSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdHMgICAgIE9wdGlvbnMgLSBjYW4gYmUgYGF0dHJgIChhdHRyaWJ1dGVzKSwgYGNoaWxkcmVuYFxyXG4gICAgICogICAoY2hpbGQgbm9kZXMpIGFuZCBgdGV4dGAgKHRleHQgY29udGVudClcclxuICAgICAqIEByZXR1cm4ge25vZGV9ICAgICAgICAgICAgQ3JlYXRlZCBub2RlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVOb2RlKGRvYywgbm9kZU5hbWUsIG9wdHMpIHtcclxuICAgICAgICB2YXIgdGVtcE5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmF0dHIpIHtcclxuICAgICAgICAgICAgICAgICQodGVtcE5vZGUpLmF0dHIob3B0cy5hdHRyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICQuZWFjaChvcHRzLmNoaWxkcmVuLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBOb2RlLmFwcGVuZENoaWxkKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0cy50ZXh0ICE9PSBudWxsICYmIG9wdHMudGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wTm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUob3B0cy50ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW1wTm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgd2lkdGggZm9yIGFuIEV4Y2VsIGNvbHVtbiBiYXNlZCBvbiB0aGUgY29udGVudHMgb2YgdGhhdCBjb2x1bW5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSBEYXRhIGZvciBleHBvcnRcclxuICAgICAqIEBwYXJhbSAge2ludH0gICAgY29sICBDb2x1bW4gaW5kZXhcclxuICAgICAqIEByZXR1cm4ge2ludH0gICAgICAgICBDb2x1bW4gd2lkdGhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2V4Y2VsQ29sV2lkdGgoZGF0YSwgY29sKSB7XHJcbiAgICAgICAgdmFyIG1heCA9IGRhdGEuaGVhZGVyW2NvbF0ubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsZW4sIGxpbmVTcGxpdCwgc3RyO1xyXG5cclxuICAgICAgICBpZiAoZGF0YS5mb290ZXIgJiYgZGF0YS5mb290ZXJbY29sXS5sZW5ndGggPiBtYXgpIHtcclxuICAgICAgICAgICAgbWF4ID0gZGF0YS5mb290ZXJbY29sXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5ib2R5Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGRhdGEuYm9keVtpXVtjb2xdO1xyXG4gICAgICAgICAgICBzdHIgPSBwb2ludCAhPT0gbnVsbCAmJiBwb2ludCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHBvaW50LnRvU3RyaW5nKCkgOlxyXG4gICAgICAgICAgICAgICAgJyc7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG5ld2xpbmUgY2hhcmFjdGVyLCB3b3Jrb3V0IHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uXHJcbiAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBsb25nZXN0IGxpbmUgaW4gdGhlIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGluZVNwbGl0ID0gc3RyLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgICAgIGxpbmVTcGxpdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBsaW5lU3BsaXRbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlbiA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXggd2lkdGggcmF0aGVyIHRoYW4gaGF2aW5nIHBvdGVudGlhbGx5IG1hc3NpdmUgY29sdW1uIHdpZHRoc1xyXG4gICAgICAgICAgICBpZiAobWF4ID4gNDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA1MjsgLy8gNDAgKiAxLjNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF4ICo9IDEuMztcclxuXHJcbiAgICAgICAgLy8gQW5kIGEgbWluIHdpZHRoXHJcbiAgICAgICAgcmV0dXJuIG1heCA+IDYgPyBtYXggOiA2O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4Y2VsIC0gUHJlLWRlZmluZWQgc3RyaW5ncyB0byBidWlsZCBhIGJhc2ljIFhMU1ggZmlsZVxyXG4gICAgdmFyIGV4Y2VsU3RyaW5ncyA9IHtcclxuICAgICAgICBcIl9yZWxzLy5yZWxzXCI6XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXHJcbiAgICAgICAgICAgICc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicgK1xyXG4gICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiIFRhcmdldD1cInhsL3dvcmtib29rLnhtbFwiLz4nICtcclxuICAgICAgICAgICAgJzwvUmVsYXRpb25zaGlwcz4nLFxyXG5cclxuICAgICAgICBcInhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzXCI6XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXHJcbiAgICAgICAgICAgICc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicgK1xyXG4gICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy93b3Jrc2hlZXRcIiBUYXJnZXQ9XCJ3b3Jrc2hlZXRzL3NoZWV0MS54bWxcIi8+JyArXHJcbiAgICAgICAgICAgICc8UmVsYXRpb25zaGlwIElkPVwicklkMlwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3N0eWxlc1wiIFRhcmdldD1cInN0eWxlcy54bWxcIi8+JyArXHJcbiAgICAgICAgICAgICc8L1JlbGF0aW9uc2hpcHM+JyxcclxuXHJcbiAgICAgICAgXCJbQ29udGVudF9UeXBlc10ueG1sXCI6XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXHJcbiAgICAgICAgICAgICc8VHlwZXMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L2NvbnRlbnQtdHlwZXNcIj4nICtcclxuICAgICAgICAgICAgJzxEZWZhdWx0IEV4dGVuc2lvbj1cInhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCIgLz4nICtcclxuICAgICAgICAgICAgJzxEZWZhdWx0IEV4dGVuc2lvbj1cInJlbHNcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLnJlbGF0aW9uc2hpcHMreG1sXCIgLz4nICtcclxuICAgICAgICAgICAgJzxEZWZhdWx0IEV4dGVuc2lvbj1cImpwZWdcIiBDb250ZW50VHlwZT1cImltYWdlL2pwZWdcIiAvPicgK1xyXG4gICAgICAgICAgICAnPE92ZXJyaWRlIFBhcnROYW1lPVwiL3hsL3dvcmtib29rLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQubWFpbit4bWxcIiAvPicgK1xyXG4gICAgICAgICAgICAnPE92ZXJyaWRlIFBhcnROYW1lPVwiL3hsL3dvcmtzaGVldHMvc2hlZXQxLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbFwiIC8+JyArXHJcbiAgICAgICAgICAgICc8T3ZlcnJpZGUgUGFydE5hbWU9XCIveGwvc3R5bGVzLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc3R5bGVzK3htbFwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L1R5cGVzPicsXHJcblxyXG4gICAgICAgIFwieGwvd29ya2Jvb2sueG1sXCI6XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXHJcbiAgICAgICAgICAgICc8d29ya2Jvb2sgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiPicgK1xyXG4gICAgICAgICAgICAnPGZpbGVWZXJzaW9uIGFwcE5hbWU9XCJ4bFwiIGxhc3RFZGl0ZWQ9XCI1XCIgbG93ZXN0RWRpdGVkPVwiNVwiIHJ1cEJ1aWxkPVwiMjQ4MTZcIi8+JyArXHJcbiAgICAgICAgICAgICc8d29ya2Jvb2tQciBzaG93SW5rQW5ub3RhdGlvbj1cIjBcIiBhdXRvQ29tcHJlc3NQaWN0dXJlcz1cIjBcIi8+JyArXHJcbiAgICAgICAgICAgICc8Ym9va1ZpZXdzPicgK1xyXG4gICAgICAgICAgICAnPHdvcmtib29rVmlldyB4V2luZG93PVwiMFwiIHlXaW5kb3c9XCIwXCIgd2luZG93V2lkdGg9XCIyNTYwMFwiIHdpbmRvd0hlaWdodD1cIjE5MDIwXCIgdGFiUmF0aW89XCI1MDBcIi8+JyArXHJcbiAgICAgICAgICAgICc8L2Jvb2tWaWV3cz4nICtcclxuICAgICAgICAgICAgJzxzaGVldHM+JyArXHJcbiAgICAgICAgICAgICc8c2hlZXQgbmFtZT1cIlwiIHNoZWV0SWQ9XCIxXCIgcjppZD1cInJJZDFcIi8+JyArXHJcbiAgICAgICAgICAgICc8L3NoZWV0cz4nICtcclxuICAgICAgICAgICAgJzwvd29ya2Jvb2s+JyxcclxuXHJcbiAgICAgICAgXCJ4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWxcIjpcclxuICAgICAgICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nICtcclxuICAgICAgICAgICAgJzx3b3Jrc2hlZXQgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiIHhtbG5zOm1jPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDZcIiBtYzpJZ25vcmFibGU9XCJ4MTRhY1wiIHhtbG5zOngxNGFjPVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDA5LzkvYWNcIj4nICtcclxuICAgICAgICAgICAgJzxzaGVldERhdGEvPicgK1xyXG4gICAgICAgICAgICAnPG1lcmdlQ2VsbHMgY291bnQ9XCIwXCIvPicgK1xyXG4gICAgICAgICAgICAnPC93b3Jrc2hlZXQ+JyxcclxuXHJcbiAgICAgICAgXCJ4bC9zdHlsZXMueG1sXCI6XHJcbiAgICAgICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz4nICtcclxuICAgICAgICAgICAgJzxzdHlsZVNoZWV0IHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgeG1sbnM6bWM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiIG1jOklnbm9yYWJsZT1cIngxNGFjXCIgeG1sbnM6eDE0YWM9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMDkvOS9hY1wiPicgK1xyXG4gICAgICAgICAgICAnPG51bUZtdHMgY291bnQ9XCI2XCI+JyArXHJcbiAgICAgICAgICAgICc8bnVtRm10IG51bUZtdElkPVwiMTY0XCIgZm9ybWF0Q29kZT1cIiMsIyMwLjAwXy1cXCBbJCQtNDVDXVwiLz4nICtcclxuICAgICAgICAgICAgJzxudW1GbXQgbnVtRm10SWQ9XCIxNjVcIiBmb3JtYXRDb2RlPVwiJnF1b3Q7wqMmcXVvdDsjLCMjMC4wMFwiLz4nICtcclxuICAgICAgICAgICAgJzxudW1GbXQgbnVtRm10SWQ9XCIxNjZcIiBmb3JtYXRDb2RlPVwiWyTigqwtMl1cXCAjLCMjMC4wMFwiLz4nICtcclxuICAgICAgICAgICAgJzxudW1GbXQgbnVtRm10SWQ9XCIxNjdcIiBmb3JtYXRDb2RlPVwiMC4wJVwiLz4nICtcclxuICAgICAgICAgICAgJzxudW1GbXQgbnVtRm10SWQ9XCIxNjhcIiBmb3JtYXRDb2RlPVwiIywjIzA7KCMsIyMwKVwiLz4nICtcclxuICAgICAgICAgICAgJzxudW1GbXQgbnVtRm10SWQ9XCIxNjlcIiBmb3JtYXRDb2RlPVwiIywjIzAuMDA7KCMsIyMwLjAwKVwiLz4nICtcclxuICAgICAgICAgICAgJzwvbnVtRm10cz4nICtcclxuICAgICAgICAgICAgJzxmb250cyBjb3VudD1cIjVcIiB4MTRhYzprbm93bkZvbnRzPVwiMVwiPicgK1xyXG4gICAgICAgICAgICAnPGZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8c3ogdmFsPVwiMTFcIiAvPicgK1xyXG4gICAgICAgICAgICAnPG5hbWUgdmFsPVwiQ2FsaWJyaVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8Zm9udD4nICtcclxuICAgICAgICAgICAgJzxzeiB2YWw9XCIxMVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8bmFtZSB2YWw9XCJDYWxpYnJpXCIgLz4nICtcclxuICAgICAgICAgICAgJzxjb2xvciByZ2I9XCJGRkZGRkZGRlwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8Zm9udD4nICtcclxuICAgICAgICAgICAgJzxzeiB2YWw9XCIxMVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8bmFtZSB2YWw9XCJDYWxpYnJpXCIgLz4nICtcclxuICAgICAgICAgICAgJzxiIC8+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8Zm9udD4nICtcclxuICAgICAgICAgICAgJzxzeiB2YWw9XCIxMVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8bmFtZSB2YWw9XCJDYWxpYnJpXCIgLz4nICtcclxuICAgICAgICAgICAgJzxpIC8+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8Zm9udD4nICtcclxuICAgICAgICAgICAgJzxzeiB2YWw9XCIxMVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8bmFtZSB2YWw9XCJDYWxpYnJpXCIgLz4nICtcclxuICAgICAgICAgICAgJzx1IC8+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnQ+JyArXHJcbiAgICAgICAgICAgICc8L2ZvbnRzPicgK1xyXG4gICAgICAgICAgICAnPGZpbGxzIGNvdW50PVwiNlwiPicgK1xyXG4gICAgICAgICAgICAnPGZpbGw+JyArXHJcbiAgICAgICAgICAgICc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJub25lXCIgLz4nICtcclxuICAgICAgICAgICAgJzwvZmlsbD4nICtcclxuICAgICAgICAgICAgJzxmaWxsPicgKyAvLyBFeGNlbCBhcHBlYXJzIHRvIHVzZSB0aGlzIGFzIGEgZG90dGVkIGJhY2tncm91bmQgcmVnYXJkbGVzcyBvZiB2YWx1ZXMgYnV0XHJcbiAgICAgICAgICAgICc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJub25lXCIgLz4nICsgLy8gdG8gYmUgdmFsaWQgdG8gdGhlIHNjaGVtYSwgdXNlIGEgcGF0dGVybkZpbGxcclxuICAgICAgICAgICAgJzwvZmlsbD4nICtcclxuICAgICAgICAgICAgJzxmaWxsPicgK1xyXG4gICAgICAgICAgICAnPHBhdHRlcm5GaWxsIHBhdHRlcm5UeXBlPVwic29saWRcIj4nICtcclxuICAgICAgICAgICAgJzxmZ0NvbG9yIHJnYj1cIkZGRDlEOUQ5XCIgLz4nICtcclxuICAgICAgICAgICAgJzxiZ0NvbG9yIGluZGV4ZWQ9XCI2NFwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L3BhdHRlcm5GaWxsPicgK1xyXG4gICAgICAgICAgICAnPC9maWxsPicgK1xyXG4gICAgICAgICAgICAnPGZpbGw+JyArXHJcbiAgICAgICAgICAgICc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJzb2xpZFwiPicgK1xyXG4gICAgICAgICAgICAnPGZnQ29sb3IgcmdiPVwiRkZEOTk3OTVcIiAvPicgK1xyXG4gICAgICAgICAgICAnPGJnQ29sb3IgaW5kZXhlZD1cIjY0XCIgLz4nICtcclxuICAgICAgICAgICAgJzwvcGF0dGVybkZpbGw+JyArXHJcbiAgICAgICAgICAgICc8L2ZpbGw+JyArXHJcbiAgICAgICAgICAgICc8ZmlsbD4nICtcclxuICAgICAgICAgICAgJzxwYXR0ZXJuRmlsbCBwYXR0ZXJuVHlwZT1cInNvbGlkXCI+JyArXHJcbiAgICAgICAgICAgICc8ZmdDb2xvciByZ2I9XCJmZmM2ZWZjZVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8YmdDb2xvciBpbmRleGVkPVwiNjRcIiAvPicgK1xyXG4gICAgICAgICAgICAnPC9wYXR0ZXJuRmlsbD4nICtcclxuICAgICAgICAgICAgJzwvZmlsbD4nICtcclxuICAgICAgICAgICAgJzxmaWxsPicgK1xyXG4gICAgICAgICAgICAnPHBhdHRlcm5GaWxsIHBhdHRlcm5UeXBlPVwic29saWRcIj4nICtcclxuICAgICAgICAgICAgJzxmZ0NvbG9yIHJnYj1cImZmYzZjZmVmXCIgLz4nICtcclxuICAgICAgICAgICAgJzxiZ0NvbG9yIGluZGV4ZWQ9XCI2NFwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L3BhdHRlcm5GaWxsPicgK1xyXG4gICAgICAgICAgICAnPC9maWxsPicgK1xyXG4gICAgICAgICAgICAnPC9maWxscz4nICtcclxuICAgICAgICAgICAgJzxib3JkZXJzIGNvdW50PVwiMlwiPicgK1xyXG4gICAgICAgICAgICAnPGJvcmRlcj4nICtcclxuICAgICAgICAgICAgJzxsZWZ0IC8+JyArXHJcbiAgICAgICAgICAgICc8cmlnaHQgLz4nICtcclxuICAgICAgICAgICAgJzx0b3AgLz4nICtcclxuICAgICAgICAgICAgJzxib3R0b20gLz4nICtcclxuICAgICAgICAgICAgJzxkaWFnb25hbCAvPicgK1xyXG4gICAgICAgICAgICAnPC9ib3JkZXI+JyArXHJcbiAgICAgICAgICAgICc8Ym9yZGVyIGRpYWdvbmFsVXA9XCJmYWxzZVwiIGRpYWdvbmFsRG93bj1cImZhbHNlXCI+JyArXHJcbiAgICAgICAgICAgICc8bGVmdCBzdHlsZT1cInRoaW5cIj4nICtcclxuICAgICAgICAgICAgJzxjb2xvciBhdXRvPVwiMVwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L2xlZnQ+JyArXHJcbiAgICAgICAgICAgICc8cmlnaHQgc3R5bGU9XCJ0aGluXCI+JyArXHJcbiAgICAgICAgICAgICc8Y29sb3IgYXV0bz1cIjFcIiAvPicgK1xyXG4gICAgICAgICAgICAnPC9yaWdodD4nICtcclxuICAgICAgICAgICAgJzx0b3Agc3R5bGU9XCJ0aGluXCI+JyArXHJcbiAgICAgICAgICAgICc8Y29sb3IgYXV0bz1cIjFcIiAvPicgK1xyXG4gICAgICAgICAgICAnPC90b3A+JyArXHJcbiAgICAgICAgICAgICc8Ym90dG9tIHN0eWxlPVwidGhpblwiPicgK1xyXG4gICAgICAgICAgICAnPGNvbG9yIGF1dG89XCIxXCIgLz4nICtcclxuICAgICAgICAgICAgJzwvYm90dG9tPicgK1xyXG4gICAgICAgICAgICAnPGRpYWdvbmFsIC8+JyArXHJcbiAgICAgICAgICAgICc8L2JvcmRlcj4nICtcclxuICAgICAgICAgICAgJzwvYm9yZGVycz4nICtcclxuICAgICAgICAgICAgJzxjZWxsU3R5bGVYZnMgY291bnQ9XCIxXCI+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiAvPicgK1xyXG4gICAgICAgICAgICAnPC9jZWxsU3R5bGVYZnM+JyArXHJcbiAgICAgICAgICAgICc8Y2VsbFhmcyBjb3VudD1cIjY3XCI+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicgK1xyXG4gICAgICAgICAgICAnPGFsaWdubWVudCBob3Jpem9udGFsPVwibGVmdFwiLz4nICtcclxuICAgICAgICAgICAgJzwveGY+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlBbGlnbm1lbnQ9XCIxXCI+JyArXHJcbiAgICAgICAgICAgICc8YWxpZ25tZW50IGhvcml6b250YWw9XCJjZW50ZXJcIi8+JyArXHJcbiAgICAgICAgICAgICc8L3hmPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicgK1xyXG4gICAgICAgICAgICAnPGFsaWdubWVudCBob3Jpem9udGFsPVwicmlnaHRcIi8+JyArXHJcbiAgICAgICAgICAgICc8L3hmPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicgK1xyXG4gICAgICAgICAgICAnPGFsaWdubWVudCBob3Jpem9udGFsPVwiZmlsbFwiLz4nICtcclxuICAgICAgICAgICAgJzwveGY+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlBbGlnbm1lbnQ9XCIxXCI+JyArXHJcbiAgICAgICAgICAgICc8YWxpZ25tZW50IHRleHRSb3RhdGlvbj1cIjkwXCIvPicgK1xyXG4gICAgICAgICAgICAnPC94Zj4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseUFsaWdubWVudD1cIjFcIj4nICtcclxuICAgICAgICAgICAgJzxhbGlnbm1lbnQgd3JhcFRleHQ9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPC94Zj4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjlcIiAgIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2NFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2NVwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2NlwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2N1wiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2OFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjE2OVwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjNcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseU51bWJlckZvcm1hdD1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8eGYgbnVtRm10SWQ9XCI0XCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicgK1xyXG4gICAgICAgICAgICAnPHhmIG51bUZtdElkPVwiMVwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nICtcclxuICAgICAgICAgICAgJzx4ZiBudW1GbXRJZD1cIjJcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseU51bWJlckZvcm1hdD1cIjFcIi8+JyArXHJcbiAgICAgICAgICAgICc8L2NlbGxYZnM+JyArXHJcbiAgICAgICAgICAgICc8Y2VsbFN0eWxlcyBjb3VudD1cIjFcIj4nICtcclxuICAgICAgICAgICAgJzxjZWxsU3R5bGUgbmFtZT1cIk5vcm1hbFwiIHhmSWQ9XCIwXCIgYnVpbHRpbklkPVwiMFwiIC8+JyArXHJcbiAgICAgICAgICAgICc8L2NlbGxTdHlsZXM+JyArXHJcbiAgICAgICAgICAgICc8ZHhmcyBjb3VudD1cIjBcIiAvPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlU3R5bGVzIGNvdW50PVwiMFwiIGRlZmF1bHRUYWJsZVN0eWxlPVwiVGFibGVTdHlsZU1lZGl1bTlcIiBkZWZhdWx0UGl2b3RTdHlsZT1cIlBpdm90U3R5bGVNZWRpdW00XCIgLz4nICtcclxuICAgICAgICAgICAgJzwvc3R5bGVTaGVldD4nXHJcbiAgICB9O1xyXG4gICAgLy8gTm90ZSB3ZSBjb3VsZCB1c2UgMyBgZm9yYCBsb29wcyBmb3IgdGhlIHN0eWxlcywgYnV0IHdoZW4gZ3ppcHBlZCB0aGVyZSBpc1xyXG4gICAgLy8gdmlydHVhbGx5IG5vIGRpZmZlcmVuY2UgaW4gc2l6ZSwgc2luY2UgdGhlIGFib3ZlIGNhbiBiZSBlYXNpbHkgY29tcHJlc3NlZFxyXG5cclxuICAgIC8vIFBhdHRlcm4gbWF0Y2hpbmcgZm9yIHNwZWNpYWwgbnVtYmVyIGZvcm1hdHMuIFBlcmhhcHMgdGhpcyBzaG91bGQgYmUgZXhwb3NlZFxyXG4gICAgLy8gdmlhIGFuIEFQSSBpbiBmdXR1cmU/XHJcbiAgICAvLyBSZWY6IHNlY3Rpb24gMy44LjMwIC0gYnVpbHQgaW4gZm9ybWF0dGVycyBpbiBvcGVuIHNwcmVhZHNoZWV0XHJcbiAgICAvLyAgIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvbmV3cy9UQzQ1X2N1cnJlbnRfd29yay9PZmZpY2UlMjBPcGVuJTIwWE1MJTIwUGFydCUyMDQlMjAtJTIwTWFya3VwJTIwTGFuZ3VhZ2UlMjBSZWZlcmVuY2UucGRmXHJcbiAgICB2YXIgX2V4Y2VsU3BlY2lhbHMgPSBbXHJcbiAgICAgICAgeyBtYXRjaDogL15cXC0/XFxkK1xcLlxcZCUkLywgc3R5bGU6IDYwLCBmbXQ6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkIC8gMTAwOyB9IH0sIC8vIFByZWNlbnQgd2l0aCBkLnAuXHJcbiAgICAgICAgeyBtYXRjaDogL15cXC0/XFxkK1xcLj9cXGQqJSQvLCBzdHlsZTogNTYsIGZtdDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQgLyAxMDA7IH0gfSwgLy8gUGVyY2VudFxyXG4gICAgICAgIHsgbWF0Y2g6IC9eXFwtP1xcJFtcXGQsXSsuP1xcZCokLywgc3R5bGU6IDU3IH0sIC8vIERvbGxhcnNcclxuICAgICAgICB7IG1hdGNoOiAvXlxcLT/Co1tcXGQsXSsuP1xcZCokLywgc3R5bGU6IDU4IH0sIC8vIFBvdW5kc1xyXG4gICAgICAgIHsgbWF0Y2g6IC9eXFwtP+KCrFtcXGQsXSsuP1xcZCokLywgc3R5bGU6IDU5IH0sIC8vIEV1cm9zXHJcbiAgICAgICAgeyBtYXRjaDogL15cXC0/XFxkKyQvLCBzdHlsZTogNjUgfSwgLy8gTnVtYmVycyB3aXRob3V0IHRob3VzYW5kIHNlcGFyYXRvcnNcclxuICAgICAgICB7IG1hdGNoOiAvXlxcLT9cXGQrXFwuXFxkezJ9JC8sIHN0eWxlOiA2NiB9LCAvLyBOdW1iZXJzIDIgZC5wLiB3aXRob3V0IHRob3VzYW5kcyBzZXBhcmF0b3JzXHJcbiAgICAgICAgeyBtYXRjaDogL15cXChbXFxkLF0rXFwpJC8sIHN0eWxlOiA2MSwgZm10OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gLTEgKiBkLnJlcGxhY2UoL1tcXChcXCldL2csICcnKTsgfSB9LCAgLy8gTmVnYXRpdmUgbnVtYmVycyBpbmRpY2F0ZWQgYnkgYnJhY2tldHNcclxuICAgICAgICB7IG1hdGNoOiAvXlxcKFtcXGQsXStcXC5cXGR7Mn1cXCkkLywgc3R5bGU6IDYyLCBmbXQ6IGZ1bmN0aW9uIChkKSB7IHJldHVybiAtMSAqIGQucmVwbGFjZSgvW1xcKFxcKV0vZywgJycpOyB9IH0sICAvLyBOZWdhdGl2ZSBudW1iZXJzIGluZGljYXRlZCBieSBicmFja2V0cyAtIDJkLnAuXHJcbiAgICAgICAgeyBtYXRjaDogL15cXC0/W1xcZCxdKyQvLCBzdHlsZTogNjMgfSwgLy8gTnVtYmVycyB3aXRoIHRob3VzYW5kIHNlcGFyYXRvcnNcclxuICAgICAgICB7IG1hdGNoOiAvXlxcLT9bXFxkLF0rXFwuXFxkezJ9JC8sIHN0eWxlOiA2NCB9ICAvLyBOdW1iZXJzIHdpdGggMiBkLnAuIGFuZCB0aG91c2FuZHMgc2VwYXJhdG9yc1xyXG4gICAgXTtcclxuXHJcblxyXG5cclxuICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICogQnV0dG9uc1xyXG4gICAgICovXHJcblxyXG4gICAgLy9cclxuICAgIC8vIENvcHkgdG8gY2xpcGJvYXJkXHJcbiAgICAvL1xyXG4gICAgRGF0YVRhYmxlLmV4dC5idXR0b25zLmNvcHlIdG1sNSA9IHtcclxuICAgICAgICBjbGFzc05hbWU6ICdidXR0b25zLWNvcHkgYnV0dG9ucy1odG1sNScsXHJcblxyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZHQuaTE4bignYnV0dG9ucy5jb3B5JywgJ0NvcHknKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChlLCBkdCwgYnV0dG9uLCBjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZXhwb3J0RGF0YSA9IF9leHBvcnREYXRhKGR0LCBjb25maWcpO1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGR0LmJ1dHRvbnMuZXhwb3J0SW5mbyhjb25maWcpO1xyXG4gICAgICAgICAgICB2YXIgbmV3bGluZSA9IF9uZXdMaW5lKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBleHBvcnREYXRhLnN0cjtcclxuICAgICAgICAgICAgdmFyIGhpZGRlbkRpdiA9ICQoJzxkaXYvPicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBpbmZvLnRpdGxlICsgbmV3bGluZSArIG5ld2xpbmUgKyBvdXRwdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLm1lc3NhZ2VUb3ApIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGluZm8ubWVzc2FnZVRvcCArIG5ld2xpbmUgKyBuZXdsaW5lICsgb3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5mby5tZXNzYWdlQm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBuZXdsaW5lICsgbmV3bGluZSArIGluZm8ubWVzc2FnZUJvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jdXN0b21pemUpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGNvbmZpZy5jdXN0b21pemUob3V0cHV0LCBjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dGFyZWEgPSAkKCc8dGV4dGFyZWEgcmVhZG9ubHkvPicpXHJcbiAgICAgICAgICAgICAgICAudmFsKG91dHB1dClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhoaWRkZW5EaXYpO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0aGUgY29weSBleGVjQ29tbWFuZCwgdHJ5IHRvIHVzZSBpdFxyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKCdjb3B5JykpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5hcHBlbmRUbyhkdC50YWJsZSgpLmNvbnRhaW5lcigpKTtcclxuICAgICAgICAgICAgICAgIHRleHRhcmVhWzBdLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0YXJlYVswXS5zZWxlY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzZnVsID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcclxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZnVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR0LmJ1dHRvbnMuaW5mbyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0LmkxOG4oJ2J1dHRvbnMuY29weVRpdGxlJywgJ0NvcHkgdG8gY2xpcGJvYXJkJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdC5pMThuKCdidXR0b25zLmNvcHlTdWNjZXNzJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6ICdDb3BpZWQgb25lIHJvdyB0byBjbGlwYm9hcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF86ICdDb3BpZWQgJWQgcm93cyB0byBjbGlwYm9hcmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBleHBvcnREYXRhLnJvd3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjAwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoICh0KSB7IH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIHNob3cgdGhlIHRleHQgYm94IGFuZCBpbnN0cnVjdCB0aGUgdXNlciB0byB1c2UgaXRcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAkKCc8c3Bhbj4nICsgZHQuaTE4bignYnV0dG9ucy5jb3B5S2V5cycsXHJcbiAgICAgICAgICAgICAgICAnUHJlc3MgPGk+Y3RybDwvaT4gb3IgPGk+XFx1MjMxODwvaT4gKyA8aT5DPC9pPiB0byBjb3B5IHRoZSB0YWJsZSBkYXRhPGJyPnRvIHlvdXIgc3lzdGVtIGNsaXBib2FyZC48YnI+PGJyPicgK1xyXG4gICAgICAgICAgICAgICAgJ1RvIGNhbmNlbCwgY2xpY2sgdGhpcyBtZXNzYWdlIG9yIHByZXNzIGVzY2FwZS4nKSArICc8L3NwYW4+J1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGhpZGRlbkRpdik7XHJcblxyXG4gICAgICAgICAgICBkdC5idXR0b25zLmluZm8oZHQuaTE4bignYnV0dG9ucy5jb3B5VGl0bGUnLCAnQ29weSB0byBjbGlwYm9hcmQnKSwgbWVzc2FnZSwgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIHRleHQgc28gd2hlbiB0aGUgdXNlciBhY3RpdmF0ZXMgdGhlaXIgc3lzdGVtIGNsaXBib2FyZFxyXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGNvcHkgdGhhdCB0ZXh0XHJcbiAgICAgICAgICAgIHRleHRhcmVhWzBdLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIHRleHRhcmVhWzBdLnNlbGVjdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgdG8gaGlkZSB0aGUgbWVzc2FnZSB3aGVuIHRoZSB1c2VyIGlzIGRvbmVcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQobWVzc2FnZSkuY2xvc2VzdCgnLmR0LWJ1dHRvbi1pbmZvJyk7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5vZmYoJ2NsaWNrLmJ1dHRvbnMtY29weScpO1xyXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCcuYnV0dG9ucy1jb3B5Jyk7XHJcbiAgICAgICAgICAgICAgICBkdC5idXR0b25zLmluZm8oZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyLm9uKCdjbGljay5idXR0b25zLWNvcHknLCBjbG9zZSk7XHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQpXHJcbiAgICAgICAgICAgICAgICAub24oJ2tleWRvd24uYnV0dG9ucy1jb3B5JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykgeyAvLyBlc2NcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjb3B5LmJ1dHRvbnMtY29weSBjdXQuYnV0dG9ucy1jb3B5JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGV4cG9ydE9wdGlvbnM6IHt9LFxyXG5cclxuICAgICAgICBmaWVsZFNlcGFyYXRvcjogJ1xcdCcsXHJcblxyXG4gICAgICAgIGZpZWxkQm91bmRhcnk6ICcnLFxyXG5cclxuICAgICAgICBoZWFkZXI6IHRydWUsXHJcblxyXG4gICAgICAgIGZvb3RlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIHRpdGxlOiAnKicsXHJcblxyXG4gICAgICAgIG1lc3NhZ2VUb3A6ICcqJyxcclxuXHJcbiAgICAgICAgbWVzc2FnZUJvdHRvbTogJyonXHJcbiAgICB9O1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBDU1YgZXhwb3J0XHJcbiAgICAvL1xyXG4gICAgRGF0YVRhYmxlLmV4dC5idXR0b25zLmNzdkh0bWw1ID0ge1xyXG4gICAgICAgIGJvbTogZmFsc2UsXHJcblxyXG4gICAgICAgIGNsYXNzTmFtZTogJ2J1dHRvbnMtY3N2IGJ1dHRvbnMtaHRtbDUnLFxyXG5cclxuICAgICAgICBhdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5GaWxlUmVhZGVyICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkJsb2I7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdidXR0b25zLmNzdicsICdDU1YnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChlLCBkdCwgYnV0dG9uLCBjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSB0ZXh0XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfZXhwb3J0RGF0YShkdCwgY29uZmlnKS5zdHI7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gZHQuYnV0dG9ucy5leHBvcnRJbmZvKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gY29uZmlnLmNoYXJzZXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmN1c3RvbWl6ZSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gY29uZmlnLmN1c3RvbWl6ZShvdXRwdXQsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGFyc2V0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFyc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9IGRvY3VtZW50LmNoYXJhY3RlclNldCB8fCBkb2N1bWVudC5jaGFyc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGFyc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICc7Y2hhcnNldD0nICsgY2hhcnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5ib20pIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICdcXHVmZWZmJyArIG91dHB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3NhdmVBcyhcclxuICAgICAgICAgICAgICAgIG5ldyBCbG9iKFtvdXRwdXRdLCB7IHR5cGU6ICd0ZXh0L2NzdicgKyBjaGFyc2V0IH0pLFxyXG4gICAgICAgICAgICAgICAgaW5mby5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyhmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsZW5hbWU6ICcqJyxcclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uOiAnLmNzdicsXHJcblxyXG4gICAgICAgIGV4cG9ydE9wdGlvbnM6IHt9LFxyXG5cclxuICAgICAgICBmaWVsZFNlcGFyYXRvcjogJywnLFxyXG5cclxuICAgICAgICBmaWVsZEJvdW5kYXJ5OiAnXCInLFxyXG5cclxuICAgICAgICBlc2NhcGVDaGFyOiAnXCInLFxyXG5cclxuICAgICAgICBjaGFyc2V0OiBudWxsLFxyXG5cclxuICAgICAgICBoZWFkZXI6IHRydWUsXHJcblxyXG4gICAgICAgIGZvb3RlcjogZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgLy9cclxuICAgIC8vIEV4Y2VsICh4bHN4KSBleHBvcnRcclxuICAgIC8vXHJcbiAgICBEYXRhVGFibGUuZXh0LmJ1dHRvbnMuZXhjZWxIdG1sNSA9IHtcclxuICAgICAgICBjbGFzc05hbWU6ICdidXR0b25zLWV4Y2VsIGJ1dHRvbnMtaHRtbDUnLFxyXG5cclxuICAgICAgICBhdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5GaWxlUmVhZGVyICE9PSB1bmRlZmluZWQgJiYgX2pzWmlwKCkgIT09IHVuZGVmaW5lZCAmJiAhX2lzRHVmZlNhZmFyaSgpICYmIF9zZXJpYWxpc2VyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZHQuaTE4bignYnV0dG9ucy5leGNlbCcsICdFeGNlbCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKGUsIGR0LCBidXR0b24sIGNvbmZpZykge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciByb3dQb3MgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZ2V0WG1sID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBleGNlbFN0cmluZ3NbdHlwZV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zdHIgPSBzdHIucmVwbGFjZSggL3htbG5zOi9nLCAneG1sbnNfJyApLnJlcGxhY2UoIC9tYzovZywgJ21jXycgKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5wYXJzZVhNTChzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcmVscyA9IGdldFhtbCgneGwvd29ya3NoZWV0cy9zaGVldDEueG1sJyk7XHJcbiAgICAgICAgICAgIHZhciByZWxzR2V0ID0gcmVscy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0RGF0YVwiKVswXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4bHN4ID0ge1xyXG4gICAgICAgICAgICAgICAgX3JlbHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIi5yZWxzXCI6IGdldFhtbCgnX3JlbHMvLnJlbHMnKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHhsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3JlbHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JrYm9vay54bWwucmVsc1wiOiBnZXRYbWwoJ3hsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzJylcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwid29ya2Jvb2sueG1sXCI6IGdldFhtbCgneGwvd29ya2Jvb2sueG1sJyksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHlsZXMueG1sXCI6IGdldFhtbCgneGwvc3R5bGVzLnhtbCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwid29ya3NoZWV0c1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hlZXQxLnhtbFwiOiByZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIltDb250ZW50X1R5cGVzXS54bWxcIjogZ2V0WG1sKCdbQ29udGVudF9UeXBlc10ueG1sJylcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZHQuYnV0dG9ucy5leHBvcnREYXRhKGNvbmZpZy5leHBvcnRPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3csIHJvd05vZGU7XHJcbiAgICAgICAgICAgIHZhciBhZGRSb3cgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93ID0gcm93UG9zICsgMTtcclxuICAgICAgICAgICAgICAgIHJvd05vZGUgPSBfY3JlYXRlTm9kZShyZWxzLCBcInJvd1wiLCB7IGF0dHI6IHsgcjogY3VycmVudFJvdyB9IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSByb3cubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25jYXQgYm90aCB0aGUgQ2VsbCBDb2x1bW5zIGFzIGEgbGV0dGVyIGFuZCB0aGUgUm93IG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsSWQgPSBjcmVhdGVDZWxsUG9zKGkpICsgJycgKyBjdXJyZW50Um93O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG51bGwsIHVuZGVmaW5lZCBvZiBibGFuayBjZWxsLCBjb250aW51ZSBzbyBpdCBkb2Vzbid0IGNyZWF0ZSB0aGUgX2NyZWF0ZU5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm93W2ldID09PSBudWxsIHx8IHJvd1tpXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tpXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jcmVhdGVFbXB0eUNlbGxzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dbaV0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByb3dbaV0gPSAkLnRyaW0ocm93W2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBudW1iZXIgZm9ybWF0dGluZyBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IF9leGNlbFNwZWNpYWxzLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsID0gX2V4Y2VsU3BlY2lhbHNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE5lZWQgdG8gcHJvdmlkZSB0aGUgYWJpbGl0eSBmb3IgdGhlIHNwZWNpYWxzIHRvIHNheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IGFyZSByZXR1cm5pbmcgYSBzdHJpbmcsIHNpbmNlIGF0IHRoZSBtb21lbnQgaXQgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lZCB0byBiZSBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93W2ldLm1hdGNoICYmICFyb3dbaV0ubWF0Y2goL14wXFxkKy8pICYmIHJvd1tpXS5tYXRjaChzcGVjaWFsLm1hdGNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHJvd1tpXS5yZXBsYWNlKC9bXlxcZFxcLlxcLV0vZywgJycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsLmZtdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHNwZWNpYWwuZm10KHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IF9jcmVhdGVOb2RlKHJlbHMsICdjJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogY2VsbElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOiBzcGVjaWFsLnN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3JlYXRlTm9kZShyZWxzLCAndicsIHsgdGV4dDogdmFsIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJvd1tpXSA9PT0gJ251bWJlcicgfHwgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93W2ldLm1hdGNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dbaV0ubWF0Y2goL14tP1xcZCsoXFwuXFxkKyk/JC8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcm93W2ldLm1hdGNoKC9eMFxcZCsvKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3QgbnVtYmVycyAtIGRvbid0IG1hdGNoIG51bWJlcnMgd2l0aCBsZWFkaW5nIHplcm9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBhIG5lZ2F0aXZlIGFueXdoZXJlIGJ1dCB0aGUgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSBfY3JlYXRlTm9kZShyZWxzLCAnYycsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6ICduJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogY2VsbElkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3JlYXRlTm9kZShyZWxzLCAndicsIHsgdGV4dDogcm93W2ldIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgb3V0cHV0IC0gcmVwbGFjZSBub24gc3RhbmRhcmQgY2hhcmFjdGVycyBmb3IgdGV4dCBvdXRwdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gIXJvd1tpXS5yZXBsYWNlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dbaV0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd1tpXS5yZXBsYWNlKC9bXFx4MDAtXFx4MDlcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgJycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSBfY3JlYXRlTm9kZShyZWxzLCAnYycsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6ICdpbmxpbmVTdHInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBjZWxsSWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogX2NyZWF0ZU5vZGUocmVscywgJ2lzJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IF9jcmVhdGVOb2RlKHJlbHMsICd0Jywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcm93Tm9kZS5hcHBlbmRDaGlsZChjZWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZWxzR2V0LmFwcGVuZENoaWxkKHJvd05vZGUpO1xyXG4gICAgICAgICAgICAgICAgcm93UG9zKys7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAkKCdzaGVldHMgc2hlZXQnLCB4bHN4LnhsWyd3b3JrYm9vay54bWwnXSkuYXR0cignbmFtZScsIF9zaGVldG5hbWUoY29uZmlnKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmN1c3RvbWl6ZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5jdXN0b21pemVEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWVyZ2VDZWxscyA9IGZ1bmN0aW9uIChyb3csIGNvbHNwYW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXJnZUNlbGxzID0gJCgnbWVyZ2VDZWxscycsIHJlbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1lcmdlQ2VsbHNbMF0uYXBwZW5kQ2hpbGQoX2NyZWF0ZU5vZGUocmVscywgJ21lcmdlQ2VsbCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogJ0EnICsgcm93ICsgJzonICsgY3JlYXRlQ2VsbFBvcyhjb2xzcGFuKSArIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIG1lcmdlQ2VsbHMuYXR0cignY291bnQnLCBwYXJzZUZsb2F0KG1lcmdlQ2VsbHMuYXR0cignY291bnQnKSkgKyAxKTtcclxuICAgICAgICAgICAgICAgICQoJ3JvdzplcSgnICsgKHJvdyAtIDEpICsgJykgYycsIHJlbHMpLmF0dHIoJ3MnLCAnNTEnKTsgLy8gY2VudHJlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBUaXRsZSBhbmQgdG9wIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgIHZhciBleHBvcnRJbmZvID0gZHQuYnV0dG9ucy5leHBvcnRJbmZvKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGlmIChleHBvcnRJbmZvLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRSb3coW2V4cG9ydEluZm8udGl0bGVdLCByb3dQb3MpO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VDZWxscyhyb3dQb3MsIGRhdGEuaGVhZGVyLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwb3J0SW5mby5tZXNzYWdlVG9wKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRSb3coW2V4cG9ydEluZm8ubWVzc2FnZVRvcF0sIHJvd1Bvcyk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUNlbGxzKHJvd1BvcywgZGF0YS5oZWFkZXIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRhYmxlIGl0c2VsZlxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgYWRkUm93KGRhdGEuaGVhZGVyLCByb3dQb3MpO1xyXG4gICAgICAgICAgICAgICAgJCgncm93Omxhc3QgYycsIHJlbHMpLmF0dHIoJ3MnLCAnMicpOyAvLyBib2xkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwLCBpZSA9IGRhdGEuYm9keS5sZW5ndGg7IG4gPCBpZTsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRSb3coZGF0YS5ib2R5W25dLCByb3dQb3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmZvb3RlciAmJiBkYXRhLmZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgYWRkUm93KGRhdGEuZm9vdGVyLCByb3dQb3MpO1xyXG4gICAgICAgICAgICAgICAgJCgncm93Omxhc3QgYycsIHJlbHMpLmF0dHIoJ3MnLCAnMicpOyAvLyBib2xkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEJlbG93IHRoZSB0YWJsZVxyXG4gICAgICAgICAgICBpZiAoZXhwb3J0SW5mby5tZXNzYWdlQm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRSb3coW2V4cG9ydEluZm8ubWVzc2FnZUJvdHRvbV0sIHJvd1Bvcyk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUNlbGxzKHJvd1BvcywgZGF0YS5oZWFkZXIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBjb2x1bW4gd2lkdGhzXHJcbiAgICAgICAgICAgIHZhciBjb2xzID0gX2NyZWF0ZU5vZGUocmVscywgJ2NvbHMnKTtcclxuICAgICAgICAgICAgJCgnd29ya3NoZWV0JywgcmVscykucHJlcGVuZChjb2xzKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmhlYWRlci5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29scy5hcHBlbmRDaGlsZChfY3JlYXRlTm9kZShyZWxzLCAnY29sJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBpICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBpICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF9leGNlbENvbFdpZHRoKGRhdGEsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21XaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGV0IHRoZSBkZXZlbG9wZXIgY3VzdG9taXNlIHRoZSBkb2N1bWVudCBpZiB0aGV5IHdhbnQgdG9cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jdXN0b21pemUpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5jdXN0b21pemUoeGxzeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEV4Y2VsIGRvZXNuJ3QgbGlrZSBhbiBlbXB0eSBtZXJnZUNlbGxzIHRhZ1xyXG4gICAgICAgICAgICBpZiAoJCgnbWVyZ2VDZWxscycsIHJlbHMpLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAkKCdtZXJnZUNlbGxzJywgcmVscykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBqc3ppcCA9IF9qc1ppcCgpO1xyXG4gICAgICAgICAgICB2YXIgemlwID0gbmV3IGpzemlwKCk7XHJcbiAgICAgICAgICAgIHZhciB6aXBDb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvYicsXHJcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0J1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgX2FkZFRvWmlwKHppcCwgeGxzeCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoemlwLmdlbmVyYXRlQXN5bmMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEpTWmlwIDMrXHJcbiAgICAgICAgICAgICAgICB6aXBcclxuICAgICAgICAgICAgICAgICAgICAuZ2VuZXJhdGVBc3luYyh6aXBDb25maWcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVBcyhibG9iLCBleHBvcnRJbmZvLmZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEpTWmlwIDIuNVxyXG4gICAgICAgICAgICAgICAgX3NhdmVBcyhcclxuICAgICAgICAgICAgICAgICAgICB6aXAuZ2VuZXJhdGUoemlwQ29uZmlnKSxcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRJbmZvLmZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGVuYW1lOiAnKicsXHJcblxyXG4gICAgICAgIGV4dGVuc2lvbjogJy54bHN4JyxcclxuXHJcbiAgICAgICAgZXhwb3J0T3B0aW9uczoge30sXHJcblxyXG4gICAgICAgIGhlYWRlcjogdHJ1ZSxcclxuXHJcbiAgICAgICAgZm9vdGVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgdGl0bGU6ICcqJyxcclxuXHJcbiAgICAgICAgbWVzc2FnZVRvcDogJyonLFxyXG5cclxuICAgICAgICBtZXNzYWdlQm90dG9tOiAnKicsXHJcblxyXG4gICAgICAgIGNyZWF0ZUVtcHR5Q2VsbHM6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBQREYgZXhwb3J0IC0gdXNpbmcgcGRmTWFrZSAtIGh0dHA6Ly9wZGZtYWtlLm9yZ1xyXG4gICAgLy9cclxuICAgIERhdGFUYWJsZS5leHQuYnV0dG9ucy5wZGZIdG1sNSA9IHtcclxuICAgICAgICBjbGFzc05hbWU6ICdidXR0b25zLXBkZiBidXR0b25zLWh0bWw1JyxcclxuXHJcbiAgICAgICAgYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuRmlsZVJlYWRlciAhPT0gdW5kZWZpbmVkICYmIF9wZGZNYWtlKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdidXR0b25zLnBkZicsICdQREYnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChlLCBkdCwgYnV0dG9uLCBjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGR0LmJ1dHRvbnMuZXhwb3J0RGF0YShjb25maWcuZXhwb3J0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gZHQuYnV0dG9ucy5leHBvcnRJbmZvKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKCQubWFwKGRhdGEuaGVhZGVyLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiBkICsgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGFibGVIZWFkZXInXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEuYm9keS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKCQubWFwKGRhdGEuYm9keVtpXSwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogZCArICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogaSAlIDIgPyAndGFibGVCb2R5RXZlbicgOiAndGFibGVCb2R5T2RkJ1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9vdGVyICYmIGRhdGEuZm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goJC5tYXAoZGF0YS5mb290ZXIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IGQgKyAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0YWJsZUZvb3RlcidcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZG9jID0ge1xyXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IGNvbmZpZy5wYWdlU2l6ZSxcclxuICAgICAgICAgICAgICAgIHBhZ2VPcmllbnRhdGlvbjogY29uZmlnLm9yaWVudGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclJvd3M6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiByb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogJ25vQm9yZGVycydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVIZWFkZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzJkNDE1NCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogJ2NlbnRlcidcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQm9keUV2ZW46IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQm9keU9kZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjZjNmM2YzJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVGb290ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzJkNDE1NCdcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZToge31cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLm1lc3NhZ2VUb3ApIHtcclxuICAgICAgICAgICAgICAgIGRvYy5jb250ZW50LnVuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGluZm8ubWVzc2FnZVRvcCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ21lc3NhZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsIDAsIDAsIDEyXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLm1lc3NhZ2VCb3R0b20pIHtcclxuICAgICAgICAgICAgICAgIGRvYy5jb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGluZm8ubWVzc2FnZUJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ21lc3NhZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsIDAsIDAsIDEyXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBkb2MuY29udGVudC51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpbmZvLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndGl0bGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogWzAsIDAsIDAsIDEyXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuY3VzdG9taXplKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuY3VzdG9taXplKGRvYywgY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBkZiA9IF9wZGZNYWtlKCkuY3JlYXRlUGRmKGRvYyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmRvd25sb2FkID09PSAnb3BlbicgJiYgIV9pc0R1ZmZTYWZhcmkoKSkge1xyXG4gICAgICAgICAgICAgICAgcGRmLm9wZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBkZi5kb3dubG9hZChpbmZvLmZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nKGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0aXRsZTogJyonLFxyXG5cclxuICAgICAgICBmaWxlbmFtZTogJyonLFxyXG5cclxuICAgICAgICBleHRlbnNpb246ICcucGRmJyxcclxuXHJcbiAgICAgICAgZXhwb3J0T3B0aW9uczoge30sXHJcblxyXG4gICAgICAgIG9yaWVudGF0aW9uOiAncG9ydHJhaXQnLFxyXG5cclxuICAgICAgICBwYWdlU2l6ZTogJ0E0JyxcclxuXHJcbiAgICAgICAgaGVhZGVyOiB0cnVlLFxyXG5cclxuICAgICAgICBmb290ZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBtZXNzYWdlVG9wOiAnKicsXHJcblxyXG4gICAgICAgIG1lc3NhZ2VCb3R0b206ICcqJyxcclxuXHJcbiAgICAgICAgY3VzdG9taXplOiBudWxsLFxyXG5cclxuICAgICAgICBkb3dubG9hZDogJ2Rvd25sb2FkJ1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcmV0dXJuIERhdGFUYWJsZS5CdXR0b25zO1xyXG59KSk7IiwiLyohIFJlc3BvbnNpdmUgMi4yLjFcclxuICogMjAxNC0yMDE3IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBzdW1tYXJ5ICAgICBSZXNwb25zaXZlXHJcbiAqIEBkZXNjcmlwdGlvbiBSZXNwb25zaXZlIHRhYmxlcyBwbHVnLWluIGZvciBEYXRhVGFibGVzXHJcbiAqIEB2ZXJzaW9uICAgICAyLjIuMVxyXG4gKiBAZmlsZSAgICAgICAgZGF0YVRhYmxlcy5yZXNwb25zaXZlLmpzXHJcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkICh3d3cuc3ByeW1lZGlhLmNvLnVrKVxyXG4gKiBAY29udGFjdCAgICAgd3d3LnNwcnltZWRpYS5jby51ay9jb250YWN0XHJcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAxNC0yMDE3IFNwcnlNZWRpYSBMdGQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcclxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxyXG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxyXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcclxuICovXHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRFxyXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoJCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCB3aW5kb3csIGRvY3VtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIENvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xyXG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSB3aW5kb3c7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghJCB8fCAhJC5mbi5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgICQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQsIHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyXHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG59KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNwb25zaXZlIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIERhdGFUYWJsZXMgbGlicmFyeSB0aGF0IG1ha2VzIHVzZSBvZlxyXG4gICAgICogRGF0YVRhYmxlcycgYWJpbGl0eSB0byBjaGFuZ2UgdGhlIHZpc2liaWxpdHkgb2YgY29sdW1ucywgY2hhbmdpbmcgdGhlXHJcbiAgICAgKiB2aXNpYmlsaXR5IG9mIGNvbHVtbnMgc28gdGhlIGRpc3BsYXllZCBjb2x1bW5zIGZpdCBpbnRvIHRoZSB0YWJsZSBjb250YWluZXIuXHJcbiAgICAgKiBUaGUgZW5kIHJlc3VsdCBpcyB0aGF0IGNvbXBsZXggdGFibGVzIHdpbGwgYmUgZHluYW1pY2FsbHkgYWRqdXN0ZWQgdG8gZml0XHJcbiAgICAgKiBpbnRvIHRoZSB2aWV3cG9ydCwgYmUgaXQgb24gYSBkZXNrdG9wLCB0YWJsZXQgb3IgbW9iaWxlIGJyb3dzZXIuXHJcbiAgICAgKlxyXG4gICAgICogUmVzcG9uc2l2ZSBmb3IgRGF0YVRhYmxlcyBoYXMgdHdvIG1vZGVzIG9mIG9wZXJhdGlvbiwgd2hpY2ggY2FuIHVzZWRcclxuICAgICAqIGluZGl2aWR1YWxseSBvciBjb21iaW5lZDpcclxuICAgICAqXHJcbiAgICAgKiAqIENsYXNzIG5hbWUgYmFzZWQgY29udHJvbCAtIGNvbHVtbnMgYXNzaWduZWQgY2xhc3MgbmFtZXMgdGhhdCBtYXRjaCB0aGVcclxuICAgICAqICAgYnJlYWtwb2ludCBsb2dpYyBjYW4gYmUgc2hvd24gLyBoaWRkZW4gYXMgcmVxdWlyZWQgZm9yIGVhY2ggYnJlYWtwb2ludC5cclxuICAgICAqICogQXV0b21hdGljIGNvbnRyb2wgLSBjb2x1bW5zIGFyZSBhdXRvbWF0aWNhbGx5IGhpZGRlbiB3aGVuIHRoZXJlIGlzIG5vXHJcbiAgICAgKiAgIHJvb20gbGVmdCB0byBkaXNwbGF5IHRoZW0uIENvbHVtbnMgcmVtb3ZlZCBmcm9tIHRoZSByaWdodC5cclxuICAgICAqXHJcbiAgICAgKiBJbiBhZGRpdGlvbmFsIHRvIGNvbHVtbiB2aXNpYmlsaXR5IGNvbnRyb2wsIFJlc3BvbnNpdmUgYWxzbyBoYXMgYnVpbHQgaW50b1xyXG4gICAgICogb3B0aW9ucyB0byB1c2UgRGF0YVRhYmxlcycgY2hpbGQgcm93IGRpc3BsYXkgdG8gc2hvdyAvIGhpZGUgdGhlIGluZm9ybWF0aW9uXHJcbiAgICAgKiBmcm9tIHRoZSB0YWJsZSB0aGF0IGhhcyBiZWVuIGhpZGRlbi4gVGhlcmUgYXJlIGFsc28gdHdvIG1vZGVzIG9mIG9wZXJhdGlvblxyXG4gICAgICogZm9yIHRoaXMgY2hpbGQgcm93IGRpc3BsYXk6XHJcbiAgICAgKlxyXG4gICAgICogKiBJbmxpbmUgLSB3aGVuIHRoZSBjb250cm9sIGVsZW1lbnQgdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRvIHNob3cgLyBoaWRlXHJcbiAgICAgKiAgIGNoaWxkIHJvd3MgaXMgZGlzcGxheWVkIGluc2lkZSB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cclxuICAgICAqICogQ29sdW1uIC0gd2hlcmUgYSB3aG9sZSBjb2x1bW4gaXMgZGVkaWNhdGVkIHRvIGJlIHRoZSBzaG93IC8gaGlkZSBjb250cm9sLlxyXG4gICAgICpcclxuICAgICAqIEluaXRpYWxpc2F0aW9uIG9mIFJlc3BvbnNpdmUgaXMgcGVyZm9ybWVkIGJ5OlxyXG4gICAgICpcclxuICAgICAqICogQWRkaW5nIHRoZSBjbGFzcyBgcmVzcG9uc2l2ZWAgb3IgYGR0LXJlc3BvbnNpdmVgIHRvIHRoZSB0YWJsZS4gSW4gdGhpcyBjYXNlXHJcbiAgICAgKiAgIFJlc3BvbnNpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGluaXRpYWxpc2VkIHdpdGggdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxyXG4gICAgICogICBvcHRpb25zIHdoZW4gdGhlIERhdGFUYWJsZSBpcyBjcmVhdGVkLlxyXG4gICAgICogKiBVc2luZyB0aGUgYHJlc3BvbnNpdmVgIG9wdGlvbiBpbiB0aGUgRGF0YVRhYmxlcyBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFRoaXNcclxuICAgICAqICAgY2FuIGFsc28gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMsIG9yIHNpbXBseSBzZXQgdG9cclxuICAgICAqICAgYHRydWVgIHRvIHVzZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKlxyXG4gICAgICogIEBjbGFzc1xyXG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcclxuICAgICAqICBAcGFyYW0ge29iamVjdH0gW29wdHNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xyXG4gICAgICogIEByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAuMytcclxuICAgICAqXHJcbiAgICAgKiAgQGV4YW1wbGVcclxuICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5EYXRhVGFibGUoIHtcclxuICAgICAqICAgICAgICByZXNwb25zaXZlOiB0cnVlXHJcbiAgICAgKiAgICAgIH0gKTtcclxuICAgICAqICAgIH0gKTtcclxuICAgICAqL1xyXG4gICAgdmFyIFJlc3BvbnNpdmUgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdHMpIHtcclxuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgdGhhdCB3ZSBhcmUgdXNpbmcgRGF0YVRhYmxlcyAxLjEwIG9yIG5ld2VyXHJcbiAgICAgICAgaWYgKCFEYXRhVGFibGUudmVyc2lvbkNoZWNrIHx8ICFEYXRhVGFibGUudmVyc2lvbkNoZWNrKCcxLjEwLjEwJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0RhdGFUYWJsZXMgUmVzcG9uc2l2ZSByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAuMTAgb3IgbmV3ZXInO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zID0ge1xyXG4gICAgICAgICAgICBkdDogbmV3IERhdGFUYWJsZS5BcGkoc2V0dGluZ3MpLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiBbXSxcclxuICAgICAgICAgICAgY3VycmVudDogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zaXZlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQgb24gdGhpcyB0YWJsZVxyXG4gICAgICAgIGlmICh0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5yZXNwb25zaXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRldGFpbHMgaXMgYW4gb2JqZWN0LCBidXQgZm9yIHNpbXBsaWNpdHkgdGhlIHVzZXIgY2FuIGdpdmUgaXQgYXMgYSBzdHJpbmdcclxuICAgICAgICAvLyBvciBhIGJvb2xlYW5cclxuICAgICAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cy5kZXRhaWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvcHRzLmRldGFpbHMgPSB7IHR5cGU6IG9wdHMuZGV0YWlscyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRzICYmIG9wdHMuZGV0YWlscyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgb3B0cy5kZXRhaWxzID0geyB0eXBlOiBmYWxzZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRzICYmIG9wdHMuZGV0YWlscyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcHRzLmRldGFpbHMgPSB7IHR5cGU6ICdpbmxpbmUnIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgUmVzcG9uc2l2ZS5kZWZhdWx0cywgRGF0YVRhYmxlLmRlZmF1bHRzLnJlc3BvbnNpdmUsIG9wdHMpO1xyXG4gICAgICAgIHNldHRpbmdzLnJlc3BvbnNpdmUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdG9yKCk7XHJcbiAgICB9O1xyXG5cclxuICAgICQuZXh0ZW5kKFJlc3BvbnNpdmUucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG4gICAgICAgICAqIENvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpc2UgdGhlIFJlc3BvbnNpdmUgaW5zdGFuY2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgZHRQcml2YXRlU2V0dGluZ3MgPSBkdC5zZXR0aW5ncygpWzBdO1xyXG4gICAgICAgICAgICB2YXIgb2xkV2luZG93V2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgIGR0LnNldHRpbmdzKClbMF0uX3Jlc3BvbnNpdmUgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIERhdGFUYWJsZXMnIHRocm90dGxlIGZ1bmN0aW9uIHRvIGF2b2lkIHByb2Nlc3NvciB0aHJhc2hpbmcgb25cclxuICAgICAgICAgICAgLy8gcmVzaXplXHJcbiAgICAgICAgICAgICQod2luZG93KS5vbigncmVzaXplLmR0ciBvcmllbnRhdGlvbmNoYW5nZS5kdHInLCBEYXRhVGFibGUudXRpbC50aHJvdHRsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpT1MgaGFzIGEgYnVnIHdoZXJlYnkgcmVzaXplIGNhbiBmaXJlIHdoZW4gb25seSBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84ODk4NDEyXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggIT09IG9sZFdpbmRvd1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkV2luZG93V2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyBkb2Vzbid0IGN1cnJlbnRseSB0cmlnZ2VyIGFuIGV2ZW50IHdoZW4gYSByb3cgaXMgYWRkZWQsIHNvXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaG9vayBpbnRvIGl0cyBwcml2YXRlIEFQSSB0byBlbmZvcmNlIHRoZSBoaWRkZW4gcm93cyB3aGVuXHJcbiAgICAgICAgICAgIC8vIG5ldyBkYXRhIGlzIGFkZGVkXHJcbiAgICAgICAgICAgIGR0UHJpdmF0ZVNldHRpbmdzLm9BcGkuX2ZuQ2FsbGJhY2tSZWcoZHRQcml2YXRlU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIGZ1bmN0aW9uICh0ciwgZGF0YSwgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGZhbHNlLCB0aGF0LnMuY3VycmVudCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnPnRkLCA+dGgnLCB0cikuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZHQuY29sdW1uLmluZGV4KCd0b0RhdGEnLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnMuY3VycmVudFtpZHhdID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVzdHJveSBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgICAgIGR0Lm9uKCdkZXN0cm95LmR0cicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGR0Lm9mZignLmR0cicpO1xyXG4gICAgICAgICAgICAgICAgJChkdC50YWJsZSgpLmJvZHkoKSkub2ZmKCcuZHRyJyk7XHJcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuZHRyIG9yaWVudGF0aW9uY2hhbmdlLmR0cicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGNvbHVtbnMgdGhhdCB3ZSd2ZSBoaWRkZW5cclxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGF0LnMuY3VycmVudCwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3NldENvbHVtblZpcyhpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW9yZGVyIHRoZSBicmVha3BvaW50cyBhcnJheSBoZXJlIGluIGNhc2UgdGhleSBoYXZlIGJlZW4gYWRkZWQgb3V0XHJcbiAgICAgICAgICAgIC8vIG9mIG9yZGVyXHJcbiAgICAgICAgICAgIHRoaXMuYy5icmVha3BvaW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS53aWR0aCA8IGIud2lkdGggPyAxIDpcclxuICAgICAgICAgICAgICAgICAgICBhLndpZHRoID4gYi53aWR0aCA/IC0xIDogMDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jbGFzc0xvZ2ljKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUF1dG8oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGFpbHMgaGFuZGxlclxyXG4gICAgICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMuYy5kZXRhaWxzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRldGFpbHMudHlwZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2RldGFpbHNJbml0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyB3aWxsIHRyaWdnZXIgdGhpcyBldmVudCBvbiBldmVyeSBjb2x1bW4gaXQgc2hvd3MgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBoaWRlcyBpbmRpdmlkdWFsbHlcclxuICAgICAgICAgICAgICAgIGR0Lm9uKCdjb2x1bW4tdmlzaWJpbGl0eS5kdHInLCBmdW5jdGlvbiAoZSwgY3R4LCBjb2wsIHZpcywgcmVjYWxjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2FsYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9jbGFzc0xvZ2ljKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3Jlc2l6ZUF1dG8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVkcmF3IHRoZSBkZXRhaWxzIGJveCBvbiBlYWNoIGRyYXcgd2hpY2ggd2lsbCBoYXBwZW4gaWYgdGhlIGRhdGFcclxuICAgICAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWQgdW50aWwgRGF0YVRhYmxlcyBpbXBsZW1lbnRzIGEgbmF0aXZlXHJcbiAgICAgICAgICAgICAgICAvLyBgdXBkYXRlZGAgZXZlbnQgZm9yIHJvd3NcclxuICAgICAgICAgICAgICAgIGR0Lm9uKCdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9yZWRyYXdDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgJChkdC50YWJsZSgpLm5vZGUoKSkuYWRkQ2xhc3MoJ2R0ci0nICsgZGV0YWlscy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZHQub24oJ2NvbHVtbi1yZW9yZGVyLmR0cicsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGV0YWlscykge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY2xhc3NMb2dpYygpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplQXV0bygpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhbmdlIGluIGNvbHVtbiBzaXplcyBtZWFucyB3ZSBuZWVkIHRvIGNhbGNcclxuICAgICAgICAgICAgZHQub24oJ2NvbHVtbi1zaXppbmcuZHRyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplQXV0bygpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gT24gQWpheCByZWxvYWQgd2Ugd2FudCB0byByZW9wZW4gYW55IGNoaWxkIHJvd3Mgd2hpY2ggYXJlIGRpc3BsYXllZFxyXG4gICAgICAgICAgICAvLyBieSByZXNwb25zaXZlXHJcbiAgICAgICAgICAgIGR0Lm9uKCdwcmVYaHIuZHRyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd0lkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZHQucm93cygpLmV2ZXJ5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZC5pc1Nob3duKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SWRzLnB1c2godGhpcy5pZCh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZHQub25lKCdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9yZXNpemVBdXRvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGR0LnJvd3Mocm93SWRzKS5ldmVyeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2RldGFpbHNEaXNwbGF5KHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGR0Lm9uKCdpbml0LmR0cicsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGV0YWlscykge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplQXV0bygpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgY29sdW1ucyB3ZXJlIGhpZGRlbiwgdGhlbiBEYXRhVGFibGVzIG5lZWRzIHRvIGFkanVzdCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNvbHVtbiBzaXppbmdcclxuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZmFsc2UsIHRoYXQucy5jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGR0LmNvbHVtbnMuYWRqdXN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlyc3QgcGFzcyAtIGRyYXcgdGhlIHRhYmxlIGZvciB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplXHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcbiAgICAgICAgICogUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgdmlzaWJpbGl0eSBmb3IgdGhlIGNvbHVtbnMgaW4gYSB0YWJsZSBmb3IgYSBnaXZlblxyXG4gICAgICAgICAqIGJyZWFrcG9pbnQuIFRoZSByZXN1bHQgaXMgcHJlLWRldGVybWluZWQgYmFzZWQgb24gdGhlIGNsYXNzIGxvZ2ljIGlmXHJcbiAgICAgICAgICogY2xhc3MgbmFtZXMgYXJlIHVzZWQgdG8gY29udHJvbCBhbGwgY29sdW1ucywgYnV0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGVcclxuICAgICAgICAgKiBpcyBhbHNvIHVzZWQgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2hpY2ggYXJlIHRvIGJlIGF1dG9tYXRpY2FsbHkgc2hvd25cclxuICAgICAgICAgKiBhbmQgaGlkZGVuLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZSB0byB1c2UgZm9yIHRoZSBjYWxjdWxhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiBib29sZWFuIHZhbHVlcyBpbml0aWF0aW5nIHRoZSB2aXNpYmlsaXR5IG9mIGVhY2hcclxuICAgICAgICAgKiAgIGNvbHVtbi5cclxuICAgICAgICAgKiAgQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY29sdW1uc1Zpc2libGl0eTogZnVuY3Rpb24gKGJyZWFrcG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMucy5jb2x1bW5zO1xyXG4gICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IHRoYXQgZGVmaW5lcyB0aGUgY29sdW1uIG9yZGVyaW5nIGJhc2VkIGZpcnN0IG9uIHRoZVxyXG4gICAgICAgICAgICAvLyBjb2x1bW4ncyBwcmlvcml0eSwgYW5kIHNlY29uZGx5IHRoZSBjb2x1bW4gaW5kZXguIFRoaXMgYWxsb3dzIHRoZVxyXG4gICAgICAgICAgICAvLyBjb2x1bW5zIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcmlnaHQgaWYgdGhlIHByaW9yaXR5IG1hdGNoZXNcclxuICAgICAgICAgICAgdmFyIG9yZGVyID0gY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29sLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JZHg6IGlkeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGNvbC5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5wcmlvcml0eSAhPT0gYi5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbHVtbklkeCAtIGIuY29sdW1uSWR4O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGFzcyBsb2dpYyAtIGRldGVybWluZSB3aGljaCBjb2x1bW5zIGFyZSBpbiB0aGlzIGJyZWFrcG9pbnQgYmFzZWRcclxuICAgICAgICAgICAgLy8gb24gdGhlIGNsYXNzZXMuIElmIG5vIGNsYXNzIGNvbnRyb2wgKGkuZS4gYGF1dG9gKSB0aGVuIGAtYCBpcyB1c2VkXHJcbiAgICAgICAgICAgIC8vIHRvIGluZGljYXRlIHRoaXMgdG8gdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gJC5tYXAoY29sdW1ucywgZnVuY3Rpb24gKGNvbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5hdXRvICYmIGNvbC5taW5XaWR0aCA9PT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbC5hdXRvID09PSB0cnVlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJy0nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pbkFycmF5KGJyZWFrcG9pbnQsIGNvbC5pbmNsdWRlSW4pICE9PSAtMTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBdXRvIGNvbHVtbiBjb250cm9sIC0gZmlyc3QgcGFzczogaG93IG11Y2ggd2lkdGggaXMgdGFrZW4gYnkgdGhlXHJcbiAgICAgICAgICAgIC8vIG9uZXMgdGhhdCBtdXN0IGJlIGluY2x1ZGVkIGZyb20gdGhlIG5vbi1hdXRvIGNvbHVtbnNcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkV2lkdGggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBkaXNwbGF5Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheVtpXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggKz0gY29sdW1uc1tpXS5taW5XaWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2Vjb25kIHBhc3MsIHVzZSB1cCBhbnkgcmVtYWluaW5nIHdpZHRoIGZvciBvdGhlciBjb2x1bW5zLiBGb3JcclxuICAgICAgICAgICAgLy8gc2Nyb2xsaW5nIHRhYmxlcyB3ZSBuZWVkIHRvIHN1YnRyYWN0IHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLiBJdFxyXG4gICAgICAgICAgICAvLyBtYXkgbm90IGJlIHJlcXVpcmVzIHdoaWNoIG1ha2VzIHRoaXMgc3ViLW9wdGltYWwsIGJ1dCBpdCB3b3VsZFxyXG4gICAgICAgICAgICAvLyByZXF1aXJlIGFub3RoZXIgZnVsbCByZWRyYXcgdG8gbWFrZSBjb21wbGV0ZSB1c2Ugb2YgdGhvc2UgZXh0cmEgZmV3XHJcbiAgICAgICAgICAgIC8vIHBpeGVsc1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsaW5nID0gZHQuc2V0dGluZ3MoKVswXS5vU2Nyb2xsO1xyXG4gICAgICAgICAgICB2YXIgYmFyID0gc2Nyb2xsaW5nLnNZIHx8IHNjcm9sbGluZy5zWCA/IHNjcm9sbGluZy5pQmFyV2lkdGggOiAwO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGhBdmFpbGFibGUgPSBkdC50YWJsZSgpLmNvbnRhaW5lcigpLm9mZnNldFdpZHRoIC0gYmFyO1xyXG4gICAgICAgICAgICB2YXIgdXNlZFdpZHRoID0gd2lkdGhBdmFpbGFibGUgLSByZXF1aXJlZFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udHJvbCBjb2x1bW4gbmVlZHMgdG8gYWx3YXlzIGJlIGluY2x1ZGVkLiBUaGlzIG1ha2VzIGl0IHN1Yi1cclxuICAgICAgICAgICAgLy8gb3B0aW1hbCBpbiB0ZXJtcyBvZiB1c2luZyB0aGUgYXZhaWxhYmxlIHdpdGgsIGJ1dCB0byBzdG9wIGxheW91dFxyXG4gICAgICAgICAgICAvLyB0aHJhc2hpbmcgb3Igb3ZlcmZsb3cuIEFsc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGUgY29udHJvbCBjb2x1bW5cclxuICAgICAgICAgICAgLy8gd2lkdGggZmlyc3Qgc28gd2Uga25vdyBob3cgbXVjaCB3aWR0aCBpcyBhdmFpbGFibGUgZm9yIHRoZSBvdGhlclxyXG4gICAgICAgICAgICAvLyBjb2x1bW5zLCBzaW5jZSB0aGUgY29udHJvbCBjb2x1bW4gbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBvbmUgc2hvd25cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZGlzcGxheS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnNbaV0uY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZWRXaWR0aCAtPSBjb2x1bW5zW2ldLm1pbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBjb2x1bW5zIHRvIGJlIHNob3duIChjb3VudGluZyBieSBwcmlvcml0eSBhbmQgdGhlbiByaWdodCB0b1xyXG4gICAgICAgICAgICAvLyBsZWZ0KSB1bnRpbCB3ZSBydW4gb3V0IG9mIHJvb21cclxuICAgICAgICAgICAgdmFyIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IG9yZGVyLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gb3JkZXJbaV0uY29sdW1uSWR4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5W2NvbElkeF0gPT09ICctJyAmJiAhY29sdW1uc1tjb2xJZHhdLmNvbnRyb2wgJiYgY29sdW1uc1tjb2xJZHhdLm1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSB3ZSd2ZSBmb3VuZCBhIGNvbHVtbiB0aGF0IHdvbid0IGZpdCB3ZSBkb24ndCBsZXQgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJzIGRpc3BsYXkgZWl0aGVyLCBvciBjb2x1bW5zIG1pZ2h0IGRpc2FwcGVhciBpbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBtaWRkbGUgb2YgdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5IHx8IHVzZWRXaWR0aCAtIGNvbHVtbnNbY29sSWR4XS5taW5XaWR0aCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5W2NvbElkeF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlbY29sSWR4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1c2VkV2lkdGggLT0gY29sdW1uc1tjb2xJZHhdLm1pbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlICdjb250cm9sJyBjb2x1bW4gc2hvdWxkIGJlIHNob3duIChpZiB0aGVyZSBpcyBvbmUpLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBoaWRkZW4gY29sdW1uICh0aGF0IGlzIG5vdCB0aGVcclxuICAgICAgICAgICAgLy8gY29udHJvbCBjb2x1bW4pLiBUaGUgdHdvIGxvb3BzIGxvb2sgaW5lZmZpY2llbnQgaGVyZSwgYnV0IHRoZXkgYXJlXHJcbiAgICAgICAgICAgIC8vIHRyaXZpYWwgYW5kIHdpbGwgZmx5IHRocm91Z2guIFdlIG5lZWQgdG8ga25vdyB0aGUgb3V0Y29tZSBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBmaXJzdCAsIGJlZm9yZSB0aGUgYWN0aW9uIGluIHRoZSBzZWNvbmQgY2FuIGJlIHRha2VuXHJcbiAgICAgICAgICAgIHZhciBzaG93Q29udHJvbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5zW2ldLmNvbnRyb2wgJiYgIWNvbHVtbnNbaV0ubmV2ZXIgJiYgIWRpc3BsYXlbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG93Q29udHJvbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zW2ldLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5W2ldID0gc2hvd0NvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHkgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY29sdW1uIHRoYXRcclxuICAgICAgICAgICAgLy8gaXMgdmlzaWJsZVxyXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsIGRpc3BsYXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheVswXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5O1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIGludGVybmFsIGBjb2x1bW5zYCBhcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2x1bW5zXHJcbiAgICAgICAgICogZm9yIHRoZSB0YWJsZS4gVGhpcyBpbmNsdWRlcyBkZXRlcm1pbmluZyB3aGljaCBicmVha3BvaW50cyB0aGUgY29sdW1uXHJcbiAgICAgICAgICogd2lsbCBhcHBlYXIgaW4sIGJhc2VkIHVwb24gY2xhc3MgbmFtZXMgaW4gdGhlIGNvbHVtbiwgd2hpY2ggbWFrZXMgdXAgdGhlXHJcbiAgICAgICAgICogdmFzdCBtYWpvcml0eSBvZiB0aGlzIG1ldGhvZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NsYXNzTG9naWM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY2FsYyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgYnJlYWtwb2ludHMgPSB0aGlzLmMuYnJlYWtwb2ludHM7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBkdC5jb2x1bW5zKCkuZXEoMCkubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW4oaSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY29sdW1uLmhlYWRlcigpLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IGR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW2ldLnJlc3BvbnNpdmVQcmlvcml0eTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhUHJpb3JpdHkgPSAkKGNvbHVtbi5oZWFkZXIoKSkuZGF0YSgncHJpb3JpdHknKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBkYXRhUHJpb3JpdHkgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcmlvcml0eSAqIDEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVJbjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0bzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV2ZXI6IGNsYXNzTmFtZS5tYXRjaCgvXFxibmV2ZXJcXGIvKSA/IHRydWUgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU2ltcGx5IGFkZCBhIGJyZWFrcG9pbnQgdG8gYGluY2x1ZGVJbmAgYXJyYXksIGVuc3VyaW5nIHRoYXQgdGhlcmUgYXJlXHJcbiAgICAgICAgICAgIC8vIG5vIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChjb2xJZHgsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlSW4gPSBjb2x1bW5zW2NvbElkeF0uaW5jbHVkZUluO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkobmFtZSwgaW5jbHVkZUluKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlSW4ucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBmdW5jdGlvbiAoY29sSWR4LCBuYW1lLCBvcGVyYXRvciwgbWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUsIGksIGllbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tjb2xJZHhdLmluY2x1ZGVJbi5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtYXgtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGJyZWFrcG9pbnQgYW5kIGFsbCBzbWFsbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHRoYXQuX2ZpbmQobmFtZSkud2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGJyZWFrcG9pbnRzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmVha3BvaW50c1tpXS53aWR0aCA8PSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQoY29sSWR4LCBicmVha3BvaW50c1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbWluLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBicmVha3BvaW50IGFuZCBhbGwgbGFyZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHRoYXQuX2ZpbmQobmFtZSkud2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGJyZWFrcG9pbnRzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmVha3BvaW50c1tpXS53aWR0aCA+PSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQoY29sSWR4LCBicmVha3BvaW50c1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90LScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIGJ1dCB0aGlzIGJyZWFrcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBicmVha3BvaW50cy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJlYWtwb2ludHNbaV0ubmFtZS5pbmRleE9mKG1hdGNoZWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSBpZiBpdCBoYXMgYSByZXNwb25zaXZlIGNvbnRyb2xcclxuICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgY29sdW1ucy5lYWNoKGZ1bmN0aW9uIChjb2wsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gY29sLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0NsYXNzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGNsYXNzIG5hbWUgdXAgc28gbXVsdGlwbGUgcnVsZXMgY2FuIGJlIGFwcGxpZWQgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2VuID0gY2xhc3NOYW1lcy5sZW5ndGg7IGsgPCBrZW47IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAkLnRyaW0oY2xhc3NOYW1lc1trXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgaW4gYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sLmluY2x1ZGVJbiA9ICQubWFwKGJyZWFrcG9pbnRzLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnbm9uZScgfHwgY29sLm5ldmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgaW4gbm9uZSAoZGVmYXVsdCkgYW5kIG5vIGF1dG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ2NvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY29sdW1uIHRoYXQgaXMgb25seSB2aXNpYmxlLCB3aGVuIG9uZSBvZiB0aGUgb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sdW1ucyBpcyBoaWRkZW4uIFRoaXMgaXMgdXNlZCBmb3IgdGhlIGRldGFpbHMgY29udHJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5jb250cm9sID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGJyZWFrcG9pbnRzLCBmdW5jdGlvbiAoaiwgYnJlYWtwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIHRoaXMgY29sdW1uIGhhdmUgYSBjbGFzcyB0aGF0IG1hdGNoZXMgdGhpcyBicmVha3BvaW50P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJva2VuUG9pbnQgPSBicmVha3BvaW50Lm5hbWUuc3BsaXQoJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKG1pblxcXFwtfG1heFxcXFwtfG5vdFxcXFwtKT8oJyArIGJyb2tlblBvaW50WzBdICsgJykoXFxcXC1bX2EtekEtWjAtOV0pPycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBjbGFzc05hbWUubWF0Y2gocmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09PSBicm9rZW5Qb2ludFswXSAmJiBtYXRjaFszXSA9PT0gJy0nICsgYnJva2VuUG9pbnRbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFzcyBuYW1lIG1hdGNoZXMgYnJlYWtwb2ludCBuYW1lIGZ1bGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uKGksIGJyZWFrcG9pbnQubmFtZSwgbWF0Y2hbMV0sIG1hdGNoWzJdICsgbWF0Y2hbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hbMl0gPT09IGJyb2tlblBvaW50WzBdICYmICFtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYXNzIG5hbWUgbWF0Y2hlZCBwcmltYXJ5IGJyZWFrcG9pbnQgbmFtZSB3aXRoIG5vIHF1YWxpZmllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbihpLCBicmVha3BvaW50Lm5hbWUsIG1hdGNoWzFdLCBtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gY29udHJvbCBjbGFzcywgdGhlbiBhdXRvbWF0aWMgc2l6aW5nIGlzIHVzZWRcclxuICAgICAgICAgICAgICAgIGlmICghaGFzQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2wuYXV0byA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zLmNvbHVtbnMgPSBjb2x1bW5zO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBkZXRhaWxzIGZvciB0aGUgY2hpbGQgcm93XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gIHtEYXRhVGFibGVzLkFwaX0gcm93ICAgIEFQSSBpbnN0YW5jZSBmb3IgdGhlIHJvd1xyXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICB1cGRhdGUgVXBkYXRlIGZsYWdcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9kZXRhaWxzRGlzcGxheTogZnVuY3Rpb24gKHJvdywgdXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMuYy5kZXRhaWxzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy50eXBlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGRldGFpbHMuZGlzcGxheShyb3csIHVwZGF0ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXRhaWxzLnJlbmRlcmVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdCwgcm93WzBdLCB0aGF0Ll9kZXRhaWxzT2JqKHJvd1swXSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoJ3Jlc3BvbnNpdmUtZGlzcGxheS5kdCcsIFtkdCwgcm93LCByZXMsIHVwZGF0ZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpc2F0aW9uIGZvciB0aGUgZGV0YWlscyBoYW5kbGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9kZXRhaWxzSW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuICAgICAgICAgICAgdmFyIGRldGFpbHMgPSB0aGlzLmMuZGV0YWlscztcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBpbmxpbmUgdHlwZSBhbHdheXMgdXNlcyB0aGUgZmlyc3QgY2hpbGQgYXMgdGhlIHRhcmdldFxyXG4gICAgICAgICAgICBpZiAoZGV0YWlscy50eXBlID09PSAnaW5saW5lJykge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscy50YXJnZXQgPSAndGQ6Zmlyc3QtY2hpbGQsIHRoOmZpcnN0LWNoaWxkJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gS2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxyXG4gICAgICAgICAgICBkdC5vbignZHJhdy5kdHInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll90YWJJbmRleGVzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGF0Ll90YWJJbmRleGVzKCk7IC8vIEluaXRpYWwgZHJhdyBoYXMgYWxyZWFkeSBoYXBwZW5lZFxyXG5cclxuICAgICAgICAgICAgJChkdC50YWJsZSgpLmJvZHkoKSkub24oJ2tleXVwLmR0cicsICd0ZCwgdGgnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgJCh0aGlzKS5kYXRhKCdkdHIta2V5Ym9hcmQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyB0eXBlLnRhcmdldCBjYW4gYmUgYSBzdHJpbmcgalF1ZXJ5IHNlbGVjdG9yIG9yIGEgY29sdW1uIGluZGV4XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBkZXRhaWxzLnRhcmdldDtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiAndGQsIHRoJztcclxuXHJcbiAgICAgICAgICAgIC8vIENsaWNrIGhhbmRsZXIgdG8gc2hvdyAvIGhpZGUgdGhlIGRldGFpbHMgcm93cyB3aGVuIHRoZXkgYXJlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAkKGR0LnRhYmxlKCkuYm9keSgpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljay5kdHIgbW91c2Vkb3duLmR0ciBtb3VzZXVwLmR0cicsIHNlbGVjdG9yLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YWJsZSBpcyBub3QgY29sbGFwc2VkIChpLmUuIHRoZXJlIGlzIG5vIGhpZGRlbiBjb2x1bW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGFrZSBubyBhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoISQoZHQudGFibGUoKS5ub2RlKCkpLmhhc0NsYXNzKCdjb2xsYXBzZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByb3cgaXMgYWN0dWFsbHkgYSBEYXRhVGFibGUncyBjb250cm9sbGVkIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KCQodGhpcykuY2xvc2VzdCgndHInKS5nZXQoMCksIGR0LnJvd3MoKS5ub2RlcygpLnRvQXJyYXkoKSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBjb2x1bW4gaW5kZXgsIHdlIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWN0IG9yIG5vdCBpbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVyIC0gb3RoZXJ3aXNlIGl0IGlzIGFscmVhZHkgb2theVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SWR4ID0gdGFyZ2V0IDwgMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdC5jb2x1bW5zKCkuZXEoMCkubGVuZ3RoICsgdGFyZ2V0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdC5jZWxsKHRoaXMpLmluZGV4KCkuY29sdW1uICE9PSB0YXJnZXRJZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJCgpLmNsb3Nlc3QoKSBpbmNsdWRlcyBpdHNlbGYgaW4gaXRzIGNoZWNrXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGR0LnJvdygkKHRoaXMpLmNsb3Nlc3QoJ3RyJykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBldmVudCB0eXBlIHRvIGRvIGFuIGFjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbmRlcmVyIGlzIGdpdmVuIGFzIGEgZnVuY3Rpb24gc28gdGhlIGNhbGxlciBjYW4gZXhlY3V0ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdoZW4gdGhleSBuZWVkIChpLmUuIGlmIGhpZGluZyB0aGVyZSBpcyBubyBwb2ludCBpcyBydW5uaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZW5kZXJlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGV0YWlsc0Rpc3BsYXkocm93LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG1vdXNlIHVzZXJzLCBwcmV2ZW50IHRoZSBmb2N1cyByaW5nIGZyb20gc2hvd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcygnb3V0bGluZScsICdub25lJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCB0aGVuIHJlLWFsbG93IGF0IHRoZSBlbmQgb2YgdGhlIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYmx1cigpLmNzcygnb3V0bGluZScsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBkZXRhaWxzIHRvIHBhc3MgdG8gYSByZW5kZXJlciBmb3IgYSByb3dcclxuICAgICAgICAgKiBAcGFyYW0gIHtpbnR9IHJvd0lkeCBSb3cgaW5kZXhcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9kZXRhaWxzT2JqOiBmdW5jdGlvbiAocm93SWR4KSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICQubWFwKHRoaXMucy5jb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZXZlciBhbmQgY29udHJvbCBjb2x1bW5zIHNob3VsZCBub3QgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbC5uZXZlciB8fCBjb2wuY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1tpXS5zVGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZHQuY2VsbChyb3dJZHgsIGkpLnJlbmRlcih0aGF0LmMub3J0aG9nb25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBkdC5jb2x1bW4oaSkudmlzaWJsZSgpICYmICF0aGF0LnMuY3VycmVudFtpXSxcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogcm93SWR4XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCBhIGJyZWFrcG9pbnQgb2JqZWN0IGZyb20gYSBuYW1lXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgQnJlYWtwb2ludCBuYW1lIHRvIGZpbmRcclxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgQnJlYWtwb2ludCBkZXNjcmlwdGlvbiBvYmplY3RcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9maW5kOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgYnJlYWtwb2ludHMgPSB0aGlzLmMuYnJlYWtwb2ludHM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYnJlYWtwb2ludHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChicmVha3BvaW50c1tpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlLWNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGNoaWxkIHJvd3MgYXMgdGhlIGRpc3BsYXkgaGFzIGNoYW5nZWQgaW5cclxuICAgICAgICAgKiBzb21lIHdheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3JlZHJhd0NoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG5cclxuICAgICAgICAgICAgZHQucm93cyh7IHBhZ2U6ICdjdXJyZW50JyB9KS5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkdC5yb3coaWR4KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9kZXRhaWxzRGlzcGxheShkdC5yb3coaWR4KSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbHRlciB0aGUgdGFibGUgZGlzcGxheSBmb3IgYSByZXNpemVkIHZpZXdwb3J0LiBUaGlzIGludm9sdmVzIGZpcnN0XHJcbiAgICAgICAgICogZGV0ZXJtaW5pbmcgd2hhdCBicmVha3BvaW50IHRoZSB3aW5kb3cgY3VycmVudGx5IGlzIGluLCBnZXR0aW5nIHRoZVxyXG4gICAgICAgICAqIGNvbHVtbiB2aXNpYmlsaXRpZXMgdG8gYXBwbHkgYW5kIHRoZW4gc2V0dGluZyB0aGVtLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfcmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIGJyZWFrcG9pbnRzID0gdGhpcy5jLmJyZWFrcG9pbnRzO1xyXG4gICAgICAgICAgICB2YXIgYnJlYWtwb2ludCA9IGJyZWFrcG9pbnRzWzBdLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5zLmNvbHVtbnM7XHJcbiAgICAgICAgICAgIHZhciBpLCBpZW47XHJcbiAgICAgICAgICAgIHZhciBvbGRWaXMgPSB0aGlzLnMuY3VycmVudC5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoYXQgYnJlYWtwb2ludCB3ZSBhcmUgY3VycmVudGx5IGF0XHJcbiAgICAgICAgICAgIGZvciAoaSA9IGJyZWFrcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gYnJlYWtwb2ludHNbaV0ud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha3BvaW50ID0gYnJlYWtwb2ludHNbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgY29sdW1ucyBmb3IgdGhhdCBicmVhayBwb2ludFxyXG4gICAgICAgICAgICB2YXIgY29sdW1uc1ZpcyA9IHRoaXMuX2NvbHVtbnNWaXNpYmxpdHkoYnJlYWtwb2ludCk7XHJcbiAgICAgICAgICAgIHRoaXMucy5jdXJyZW50ID0gY29sdW1uc1ZpcztcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgY2xhc3MgYmVmb3JlIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBpcyBjaGFuZ2VkIHNvIGV2ZW50XHJcbiAgICAgICAgICAgIC8vIGxpc3RlbmVycyBrbm93IHdoYXQgdGhlIHN0YXRlIGlzLiBOZWVkIHRvIGRldGVybWluZSBpZiB0aGVyZSBhcmVcclxuICAgICAgICAgICAgLy8gYW55IGNvbHVtbnMgdGhhdCBhcmUgbm90IHZpc2libGUgYnV0IGNhbiBiZSBzaG93blxyXG4gICAgICAgICAgICB2YXIgY29sbGFwc2VkQ2xhc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnNWaXNbaV0gPT09IGZhbHNlICYmICFjb2x1bW5zW2ldLm5ldmVyICYmICFjb2x1bW5zW2ldLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWRDbGFzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICQoZHQudGFibGUoKS5ub2RlKCkpLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCBjb2xsYXBzZWRDbGFzcyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgdmlzaWJsZSA9IDA7XHJcblxyXG4gICAgICAgICAgICBkdC5jb2x1bW5zKCkuZXEoMCkuZWFjaChmdW5jdGlvbiAoY29sSWR4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uc1Zpc1tpXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uc1Zpc1tpXSAhPT0gb2xkVmlzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2V0Q29sdW1uVmlzKGNvbElkeCwgY29sdW1uc1Zpc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZHJhd0NoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtIGxpc3RlbmVycyBvZiB0aGUgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VyKCdyZXNwb25zaXZlLXJlc2l6ZS5kdCcsIFtkdCwgdGhpcy5zLmN1cnJlbnRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBubyByZWNvcmRzLCB1cGRhdGUgdGhlIFwiTm8gcmVjb3Jkc1wiIGRpc3BsYXkgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGR0LnBhZ2UuaW5mbygpLnJlY29yZHNEaXNwbGF5ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgndGQnLCBkdC50YWJsZSgpLmJvZHkoKSkuZXEoMCkuYXR0cignY29sc3BhbicsIHZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIHRhYmxlIHNvIHRoZSBhdXRvIGNvbHVtbiBoaWRpbmdcclxuICAgICAgICAgKiBoYXMgdGhhdCBpbmZvcm1hdGlvbiB0byB3b3JrIHdpdGguIFRoaXMgbWV0aG9kIGlzIG5ldmVyIGdvaW5nIHRvIGJlIDEwMCVcclxuICAgICAgICAgKiBwZXJmZWN0IHNpbmNlIGNvbHVtbiB3aWR0aHMgY2FuIGNoYW5nZSBzbGlnaHRseSBwZXIgcGFnZSwgYnV0IHdpdGhvdXRcclxuICAgICAgICAgKiBzZXJpb3VzbHkgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHRoaXMgaXMgcXVpdGUgZWZmZWN0aXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfcmVzaXplQXV0bzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZHQgPSB0aGlzLnMuZHQ7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5zLmNvbHVtbnM7XHJcblxyXG4gICAgICAgICAgICAvLyBBcmUgd2UgYWxsb3dlZCB0byBkbyBhdXRvIHNpemluZz9cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmMuYXV0bykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IGNvbHVtbnMgdGhhdCBhY3R1YWxseSBuZWVkIGF1dG8tc2l6aW5nLCBvciBkbyB0aGV5IGFsbFxyXG4gICAgICAgICAgICAvLyBoYXZlIGNsYXNzZXMgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmF1dG87IH0pKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byByZXN0b3JlIGFsbCBjaGlsZHJlbi4gVGhleSB3aWxsIGJlIHJlaW5zdGF0ZWQgYnkgYSByZS1yZW5kZXJcclxuICAgICAgICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QoX2NoaWxkTm9kZVN0b3JlKSkge1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKF9jaGlsZE5vZGVTdG9yZSwgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBrZXkuc3BsaXQoJy0nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2NoaWxkTm9kZXNSZXN0b3JlKGR0LCBpZHhbMF0gKiAxLCBpZHhbMV0gKiAxKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgdGFibGUgd2l0aCB0aGUgY3VycmVudCBkYXRhIGluIGl0XHJcbiAgICAgICAgICAgIHZhciB0YWJsZVdpZHRoID0gZHQudGFibGUoKS5ub2RlKCkub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aHMgPSBkdC5jb2x1bW5zO1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkVGFibGUgPSBkdC50YWJsZSgpLm5vZGUoKS5jbG9uZU5vZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkSGVhZGVyID0gJChkdC50YWJsZSgpLmhlYWRlcigpLmNsb25lTm9kZShmYWxzZSkpLmFwcGVuZFRvKGNsb25lZFRhYmxlKTtcclxuICAgICAgICAgICAgdmFyIGNsb25lZEJvZHkgPSAkKGR0LnRhYmxlKCkuYm9keSgpKS5jbG9uZShmYWxzZSwgZmFsc2UpLmVtcHR5KCkuYXBwZW5kVG8oY2xvbmVkVGFibGUpOyAvLyB1c2UgalF1ZXJ5IGJlY2F1c2Ugb2YgSUU4XHJcblxyXG4gICAgICAgICAgICAvLyBIZWFkZXJcclxuICAgICAgICAgICAgdmFyIGhlYWRlckNlbGxzID0gZHQuY29sdW1ucygpXHJcbiAgICAgICAgICAgICAgICAuaGVhZGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5jb2x1bW4oaWR4KS52aXNpYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRvJCgpXHJcbiAgICAgICAgICAgICAgICAuY2xvbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywgJ3RhYmxlLWNlbGwnKVxyXG4gICAgICAgICAgICAgICAgLmNzcygnbWluLXdpZHRoJywgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBCb2R5IHJvd3MgLSB3ZSBkb24ndCBuZWVkIHRvIHRha2UgYWNjb3VudCBvZiBEYXRhVGFibGVzJyBjb2x1bW5cclxuICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBzaW5jZSB3ZSBpbXBsZW1lbnQgb3VyIG93biBoZXJlIChoZW5jZSB0aGUgYGRpc3BsYXlgIHNldClcclxuICAgICAgICAgICAgJChjbG9uZWRCb2R5KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgkKGR0LnJvd3MoeyBwYWdlOiAnY3VycmVudCcgfSkubm9kZXMoKSkuY2xvbmUoZmFsc2UpKVxyXG4gICAgICAgICAgICAgICAgLmZpbmQoJ3RoLCB0ZCcpLmNzcygnZGlzcGxheScsICcnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvb3RlclxyXG4gICAgICAgICAgICB2YXIgZm9vdGVyID0gZHQudGFibGUoKS5mb290ZXIoKTtcclxuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZEZvb3RlciA9ICQoZm9vdGVyLmNsb25lTm9kZShmYWxzZSkpLmFwcGVuZFRvKGNsb25lZFRhYmxlKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb290ZXJDZWxscyA9IGR0LmNvbHVtbnMoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5mb290ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuY29sdW1uKGlkeCkudmlzaWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvJCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNsb25lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAndGFibGUtY2VsbCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICQoJzx0ci8+JylcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGZvb3RlckNlbGxzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhjbG9uZWRGb290ZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkKCc8dHIvPicpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGhlYWRlckNlbGxzKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNsb25lZEhlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBJbiB0aGUgaW5saW5lIGNhc2UgZXh0cmEgcGFkZGluZyBpcyBhcHBsaWVkIHRvIHRoZSBmaXJzdCBjb2x1bW4gdG9cclxuICAgICAgICAgICAgLy8gZ2l2ZSBzcGFjZSBmb3IgdGhlIHNob3cgLyBoaWRlIGljb24uIFdlIG5lZWQgdG8gdXNlIHRoaXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmMuZGV0YWlscy50eXBlID09PSAnaW5saW5lJykge1xyXG4gICAgICAgICAgICAgICAgJChjbG9uZWRUYWJsZSkuYWRkQ2xhc3MoJ2R0ci1pbmxpbmUgY29sbGFwc2VkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEl0IGlzIHVuc2FmZSB0byBpbnNlcnQgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lIGludG8gdGhlIERPTVxyXG4gICAgICAgICAgICAvLyBtdWx0aXBsZSB0aW1lcy4gRm9yIGV4YW1wbGUsIGNsb25pbmcgYW5kIGluc2VydGluZyBhIGNoZWNrZWQgcmFkaW9cclxuICAgICAgICAgICAgLy8gY2xlYXJzIHRoZSBjaGNlY2tlZCBzdGF0ZSBvZiB0aGUgb3JpZ2luYWwgcmFkaW8uXHJcbiAgICAgICAgICAgICQoY2xvbmVkVGFibGUpLmZpbmQoJ1tuYW1lXScpLnJlbW92ZUF0dHIoJ25hbWUnKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9ICQoJzxkaXYvPicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyOiAnYm90aCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGNsb25lZFRhYmxlKTtcclxuXHJcbiAgICAgICAgICAgIGluc2VydGVkLmluc2VydEJlZm9yZShkdC50YWJsZSgpLm5vZGUoKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgY2xvbmVkIGhlYWRlciBub3cgY29udGFpbnMgdGhlIHNtYWxsZXN0IHRoYXQgZWFjaCBjb2x1bW4gY2FuIGJlXHJcbiAgICAgICAgICAgIGhlYWRlckNlbGxzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBkdC5jb2x1bW4uaW5kZXgoJ2Zyb21WaXNpYmxlJywgaSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2lkeF0ubWluV2lkdGggPSB0aGlzLm9mZnNldFdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaW5zZXJ0ZWQucmVtb3ZlKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGEgY29sdW1uJ3MgdmlzaWJpbGl0eS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdlIGRvbid0IHVzZSBEYXRhVGFibGVzJyBjb2x1bW4gdmlzaWJpbGl0eSBjb250cm9scyBpbiBvcmRlciB0byBlbnN1cmVcclxuICAgICAgICAgKiB0aGF0IGNvbHVtbiB2aXNpYmlsaXR5IGNhbiBSZXNwb25zaXZlIGNhbiBuby1leGlzdC4gU2luY2Ugb25seSBJRTgrIGlzXHJcbiAgICAgICAgICogc3VwcG9ydGVkIChhbmQgYWxsIGV2ZXJncmVlbiBicm93c2VycyBvZiBjb3Vyc2UpIHRoZSBjb250cm9sIG9mIHRoZVxyXG4gICAgICAgICAqIGRpc3BsYXkgYXR0cmlidXRlIHdvcmtzIHdlbGwuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbCAgICAgIENvbHVtbiBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0hpZGUgU2hvdyBvciBoaWRlICh0cnVlIG9yIGZhbHNlKVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3NldENvbHVtblZpczogZnVuY3Rpb24gKGNvbCwgc2hvd0hpZGUpIHtcclxuICAgICAgICAgICAgdmFyIGR0ID0gdGhpcy5zLmR0O1xyXG4gICAgICAgICAgICB2YXIgZGlzcGxheSA9IHNob3dIaWRlID8gJycgOiAnbm9uZSc7IC8vIGVtcHR5IHN0cmluZyB3aWxsIHJlbW92ZSB0aGUgYXR0clxyXG5cclxuICAgICAgICAgICAgJChkdC5jb2x1bW4oY29sKS5oZWFkZXIoKSkuY3NzKCdkaXNwbGF5JywgZGlzcGxheSk7XHJcbiAgICAgICAgICAgICQoZHQuY29sdW1uKGNvbCkuZm9vdGVyKCkpLmNzcygnZGlzcGxheScsIGRpc3BsYXkpO1xyXG4gICAgICAgICAgICBkdC5jb2x1bW4oY29sKS5ub2RlcygpLnRvJCgpLmNzcygnZGlzcGxheScsIGRpc3BsYXkpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGFyZSBjaGlsZCBub2RlcyBzdG9yZWQsIHdlIG1pZ2h0IG5lZWQgdG8gcmVpbnNlcnQgdGhlbVxyXG4gICAgICAgICAgICBpZiAoISQuaXNFbXB0eU9iamVjdChfY2hpbGROb2RlU3RvcmUpKSB7XHJcbiAgICAgICAgICAgICAgICBkdC5jZWxscyhudWxsLCBjb2wpLmluZGV4ZXMoKS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2hpbGROb2Rlc1Jlc3RvcmUoZHQsIGlkeC5yb3csIGlkeC5jb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIHRoZSBjZWxsIHRhYiBpbmRleGVzIGZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LiBUaGlzIGlzIGNhbGxlZCBvblxyXG4gICAgICAgICAqIGV2ZXJ5IHRhYmxlIGRyYXcgLSB0aGF0IGlzIHBvdGVudGlhbGx5IGluZWZmaWNpZW50LCBidXQgYWxzbyB0aGUgbGVhc3RcclxuICAgICAgICAgKiBjb21wbGV4IG9wdGlvbiBnaXZlbiB0aGF0IGNvbHVtbiB2aXNpYmlsaXR5IGNhbiBjaGFuZ2Ugb24gdGhlIGZseS4gSXRzIGFcclxuICAgICAgICAgKiBzaGFtZSB1c2VyLWZvY3VzIHdhcyByZW1vdmVkIGZyb20gQ1NTIDMgVUksIGFzIGl0IHdvdWxkIGhhdmUgc29sdmVkIHRoaXNcclxuICAgICAgICAgKiBpc3N1ZSB3aXRoIGEgc2luZ2xlIENTUyBzdGF0ZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90YWJJbmRleGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHRoaXMucy5kdDtcclxuICAgICAgICAgICAgdmFyIGNlbGxzID0gZHQuY2VsbHMoeyBwYWdlOiAnY3VycmVudCcgfSkubm9kZXMoKS50byQoKTtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmMuZGV0YWlscy50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICBjZWxscy5maWx0ZXIoJ1tkYXRhLWR0ci1rZXlib2FyZF0nKS5yZW1vdmVEYXRhKCdbZGF0YS1kdHIta2V5Ym9hcmRdJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICAgICAgICAnOmVxKCcgKyB0YXJnZXQgKyAnKScgOlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgLSB3ZSBuZWVkIHRvIGxpbWl0IHRoZSBzZWxlY3RlZCBub2RlcyB0byBqdXN0XHJcbiAgICAgICAgICAgIC8vIHRob3NlIG9mIHRoaXMgdGFibGVcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAndGQ6Zmlyc3QtY2hpbGQsIHRoOmZpcnN0LWNoaWxkJykge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnPnRkOmZpcnN0LWNoaWxkLCA+dGg6Zmlyc3QtY2hpbGQnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkKHNlbGVjdG9yLCBkdC5yb3dzKHsgcGFnZTogJ2N1cnJlbnQnIH0pLm5vZGVzKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGFiSW5kZXgnLCBjdHguaVRhYkluZGV4KVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoJ2R0ci1rZXlib2FyZCcsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2YgZGVmYXVsdCBicmVha3BvaW50cy4gRWFjaCBpdGVtIGluIHRoZSBhcnJheSBpcyBhbiBvYmplY3Qgd2l0aCB0d29cclxuICAgICAqIHByb3BlcnRpZXM6XHJcbiAgICAgKlxyXG4gICAgICogKiBgbmFtZWAgLSB0aGUgYnJlYWtwb2ludCBuYW1lLlxyXG4gICAgICogKiBgd2lkdGhgIC0gdGhlIGJyZWFrcG9pbnQgd2lkdGhcclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBSZXNwb25zaXZlLmJyZWFrcG9pbnRzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIFJlc3BvbnNpdmUuYnJlYWtwb2ludHMgPSBbXHJcbiAgICAgICAgeyBuYW1lOiAnZGVza3RvcCcsIHdpZHRoOiBJbmZpbml0eSB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3RhYmxldC1sJywgd2lkdGg6IDEwMjQgfSxcclxuICAgICAgICB7IG5hbWU6ICd0YWJsZXQtcCcsIHdpZHRoOiA3NjggfSxcclxuICAgICAgICB7IG5hbWU6ICdtb2JpbGUtbCcsIHdpZHRoOiA0ODAgfSxcclxuICAgICAgICB7IG5hbWU6ICdtb2JpbGUtcCcsIHdpZHRoOiAzMjAgfVxyXG4gICAgXTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5IG1ldGhvZHMgLSBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lIGhvdyB0aGUgaGlkZGVuIGRhdGEgc2hvdWxkIGJlIHNob3duXHJcbiAgICAgKiBpbiB0aGUgdGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBSZXNwb25zaXZlLmRpc3BsYXkgPSB7XHJcbiAgICAgICAgY2hpbGRSb3c6IGZ1bmN0aW9uIChyb3csIHVwZGF0ZSwgcmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkKHJvdy5ub2RlKCkpLmhhc0NsYXNzKCdwYXJlbnQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5jaGlsZChyZW5kZXIoKSwgJ2NoaWxkJykuc2hvdygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghcm93LmNoaWxkLmlzU2hvd24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5jaGlsZChyZW5kZXIoKSwgJ2NoaWxkJykuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICQocm93Lm5vZGUoKSkuYWRkQ2xhc3MoJ3BhcmVudCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5jaGlsZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJChyb3cubm9kZSgpKS5yZW1vdmVDbGFzcygncGFyZW50Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNoaWxkUm93SW1tZWRpYXRlOiBmdW5jdGlvbiAocm93LCB1cGRhdGUsIHJlbmRlcikge1xyXG4gICAgICAgICAgICBpZiAoKCF1cGRhdGUgJiYgcm93LmNoaWxkLmlzU2hvd24oKSkgfHwgIXJvdy5yZXNwb25zaXZlLmhhc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGludGVyYWN0aW9uIGFuZCB0aGUgcm93IGlzIHNob3csIG9yIG5vdGhpbmcgdG8gc2hvd1xyXG4gICAgICAgICAgICAgICAgcm93LmNoaWxkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICQocm93Lm5vZGUoKSkucmVtb3ZlQ2xhc3MoJ3BhcmVudCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERpc3BsYXlcclxuICAgICAgICAgICAgICAgIHJvdy5jaGlsZChyZW5kZXIoKSwgJ2NoaWxkJykuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgJChyb3cubm9kZSgpKS5hZGRDbGFzcygncGFyZW50Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBzbyB0aGUgbW9kYWwgb3B0aW9ucyBmb3IgQm9vdHN0cmFwIGFuZCBqUXVlcnkgVUkgY2FuXHJcbiAgICAgICAgLy8gaGF2ZSBvcHRpb25zIHBhc3NlZCBpbnRvIHRoZW0uIFRoaXMgc3BlY2lmaWMgb25lIGRvZXNuJ3QgbmVlZCB0byBiZSBhXHJcbiAgICAgICAgLy8gZnVuY3Rpb24gYnV0IGl0IGlzIGZvciBjb25zaXN0ZW5jeSBpbiB0aGUgYG1vZGFsYCBuYW1lXHJcbiAgICAgICAgbW9kYWw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocm93LCB1cGRhdGUsIHJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGEgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpOyAvLyB3aWxsIHRpZHkgZXZlbnRzIGZvciB1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2tleXByZXNzLmR0cicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWxcIi8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWRpc3BsYXlcIi8+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cImR0ci1tb2RhbC1jb250ZW50XCIvPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChyZW5kZXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cImR0ci1tb2RhbC1jbG9zZVwiPiZ0aW1lczs8L2Rpdj4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWwtYmFja2dyb3VuZFwiLz4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2tleXVwLmR0cicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbXB0eSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQocmVuZGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnZGl2LmR0ci1tb2RhbC1jb250ZW50JykucHJlcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxoMj4nICsgb3B0aW9ucy5oZWFkZXIocm93KSArICc8L2gyPidcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBfY2hpbGROb2RlU3RvcmUgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBfY2hpbGROb2RlcyhkdCwgcm93LCBjb2wpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHJvdyArICctJyArIGNvbDtcclxuXHJcbiAgICAgICAgaWYgKF9jaGlsZE5vZGVTdG9yZVtuYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoaWxkTm9kZVN0b3JlW25hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2NoaWxkbm9kZXMtYXJyYXktc2xpY2UtdnMtbG9vcFxyXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGR0LmNlbGwocm93LCBjb2wpLm5vZGUoKS5jaGlsZE5vZGVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jaGlsZE5vZGVTdG9yZVtuYW1lXSA9IG5vZGVzO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NoaWxkTm9kZXNSZXN0b3JlKGR0LCByb3csIGNvbCkge1xyXG4gICAgICAgIHZhciBuYW1lID0gcm93ICsgJy0nICsgY29sO1xyXG5cclxuICAgICAgICBpZiAoIV9jaGlsZE5vZGVTdG9yZVtuYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9kZSA9IGR0LmNlbGwocm93LCBjb2wpLm5vZGUoKTtcclxuICAgICAgICB2YXIgc3RvcmUgPSBfY2hpbGROb2RlU3RvcmVbbmFtZV07XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHN0b3JlWzBdLnBhcmVudE5vZGU7XHJcbiAgICAgICAgdmFyIHBhcmVudENoaWxkcmVuID0gcGFyZW50LmNoaWxkTm9kZXM7XHJcbiAgICAgICAgdmFyIGEgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHBhcmVudENoaWxkcmVuLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChwYXJlbnRDaGlsZHJlbltpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamVuID0gYS5sZW5ndGg7IGogPCBqZW47IGorKykge1xyXG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGFbal0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NoaWxkTm9kZVN0b3JlW25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXkgbWV0aG9kcyAtIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmUgaG93IHRoZSBoaWRkZW4gZGF0YSBzaG91bGQgYmUgc2hvd25cclxuICAgICAqIGluIHRoZSB0YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbmFtZSBSZXNwb25zaXZlLmRlZmF1bHRzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIFJlc3BvbnNpdmUucmVuZGVyZXIgPSB7XHJcbiAgICAgICAgbGlzdEhpZGRlbk5vZGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXBpLCByb3dJZHgsIGNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1bCA9ICQoJzx1bCBkYXRhLWR0ci1pbmRleD1cIicgKyByb3dJZHggKyAnXCIgY2xhc3M9XCJkdHItZGV0YWlsc1wiLz4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJC5lYWNoKGNvbHVtbnMsIGZ1bmN0aW9uIChpLCBjb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sLmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxsaSBkYXRhLWR0ci1pbmRleD1cIicgKyBjb2wuY29sdW1uSW5kZXggKyAnXCIgZGF0YS1kdC1yb3c9XCInICsgY29sLnJvd0luZGV4ICsgJ1wiIGRhdGEtZHQtY29sdW1uPVwiJyArIGNvbC5jb2x1bW5JbmRleCArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImR0ci10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnRpdGxlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3NwYW4+ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvbGk+J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIi8+JykuYXBwZW5kKF9jaGlsZE5vZGVzKGFwaSwgY29sLnJvd0luZGV4LCBjb2wuY29sdW1uSW5kZXgpKSkvLyBhcGkuY2VsbCggY29sLnJvd0luZGV4LCBjb2wuY29sdW1uSW5kZXggKS5ub2RlKCkuY2hpbGROb2RlcyApIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh1bCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID9cclxuICAgICAgICAgICAgICAgICAgICB1bCA6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbGlzdEhpZGRlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFwaSwgcm93SWR4LCBjb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sLmhpZGRlbiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8bGkgZGF0YS1kdHItaW5kZXg9XCInICsgY29sLmNvbHVtbkluZGV4ICsgJ1wiIGRhdGEtZHQtcm93PVwiJyArIGNvbC5yb3dJbmRleCArICdcIiBkYXRhLWR0LWNvbHVtbj1cIicgKyBjb2wuY29sdW1uSW5kZXggKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImR0ci10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wudGl0bGUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sLmRhdGEgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9saT4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnPHVsIGRhdGEtZHRyLWluZGV4PVwiJyArIHJvd0lkeCArICdcIiBjbGFzcz1cImR0ci1kZXRhaWxzXCIvPicpLmFwcGVuZChkYXRhKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0YWJsZUFsbDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3M6ICcnXHJcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcGksIHJvd0lkeCwgY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8dHIgZGF0YS1kdC1yb3c9XCInICsgY29sLnJvd0luZGV4ICsgJ1wiIGRhdGEtZHQtY29sdW1uPVwiJyArIGNvbC5jb2x1bW5JbmRleCArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgY29sLnRpdGxlICsgJzonICsgJzwvdGQ+ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyBjb2wuZGF0YSArICc8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJzx0YWJsZSBjbGFzcz1cIicgKyBvcHRpb25zLnRhYmxlQ2xhc3MgKyAnIGR0ci1kZXRhaWxzXCIgd2lkdGg9XCIxMDAlXCIvPicpLmFwcGVuZChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNwb25zaXZlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGluaXRpYWxpc2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBSZXNwb25zaXZlLmRlZmF1bHRzID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgYnJlYWtwb2ludHMgZm9yIHRoZSBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhhdCBlYWNoXHJcbiAgICAgICAgICogaW5zdGFuY2UgY2FuIGhhdmUgaXRzIG93biBicmVha3BvaW50cy4gQWRkaXRpb25hbGx5LCB0aGUgYnJlYWtwb2ludHNcclxuICAgICAgICAgKiBjYW5ub3QgYmUgY2hhbmdlZCBvbmNlIGFuIGluc3RhbmNlIGhhcyBiZWVuIGNyZWFzZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICogQGRlZmF1bHQgVGFrZXMgdGhlIHZhbHVlIG9mIGBSZXNwb25zaXZlLmJyZWFrcG9pbnRzYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBSZXNwb25zaXZlLmJyZWFrcG9pbnRzLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG8gaGlkaW5nIGNhbGN1bGF0aW9ucy4gSXQgY2FuIGhlbHAgdG8gaW5jcmVhc2VcclxuICAgICAgICAgKiBwZXJmb3JtYW5jZSBzbGlnaHRseSBpZiB5b3UgZGlzYWJsZSB0aGlzIG9wdGlvbiwgYnV0IGFsbCBjb2x1bW5zIHdvdWxkXHJcbiAgICAgICAgICogbmVlZCB0byBoYXZlIGJyZWFrcG9pbnQgY2xhc3NlcyBhc3NpZ25lZCB0byB0aGVtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAgYHRydWVgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXV0bzogdHJ1ZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0YWlscyBjb250cm9sLiBJZiBnaXZlbiBhcyBhIHN0cmluZyB2YWx1ZSwgdGhlIGB0eXBlYCBwcm9wZXJ0eSBvZiB0aGVcclxuICAgICAgICAgKiBkZWZhdWx0IG9iamVjdCBpcyBzZXQgdG8gdGhhdCB2YWx1ZSwgYW5kIHRoZSBkZWZhdWx0cyB1c2VkIGZvciB0aGUgcmVzdFxyXG4gICAgICAgICAqIG9mIHRoZSBvYmplY3QgLSB0aGlzIGlzIGZvciBlYXNlIG9mIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIG9iamVjdCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqIGBkaXNwbGF5YCAtIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNob3cgYW5kIGhpZGUgdGhlIGhpZGRlbiBkZXRhaWxzXHJcbiAgICAgICAgICogKiBgcmVuZGVyZXJgIC0gZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGRpc3BsYXkgb2YgdGhlIGNoaWxkIHJvdyBkYXRhLlxyXG4gICAgICAgICAqICAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gd2lsbCBzaG93IHRoZSBkYXRhIGZyb20gdGhlIGhpZGRlbiBjb2x1bW5zXHJcbiAgICAgICAgICogKiBgdGFyZ2V0YCAtIFVzZWQgYXMgdGhlIHNlbGVjdG9yIGZvciB3aGF0IG9iamVjdHMgdG8gYXR0YWNoIHRoZSBjaGlsZFxyXG4gICAgICAgICAqICAgb3BlbiAvIGNsb3NlIHRvXHJcbiAgICAgICAgICogKiBgdHlwZWAgLSBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGRldGFpbHMgZGlzcGxheSwgYGlubGluZWAgb3IgYGNvbHVtbmBcclxuICAgICAgICAgKiAgIGZvciB0aGUgdHdvIGNvbnRyb2wgdHlwZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R8c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogUmVzcG9uc2l2ZS5kaXNwbGF5LmNoaWxkUm93LFxyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXI6IFJlc3BvbnNpdmUucmVuZGVyZXIubGlzdEhpZGRlbigpLFxyXG5cclxuICAgICAgICAgICAgdGFyZ2V0OiAwLFxyXG5cclxuICAgICAgICAgICAgdHlwZTogJ2lubGluZSdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcnRob2dvbmFsIGRhdGEgcmVxdWVzdCBvcHRpb24uIFRoaXMgaXMgdXNlZCB0byBkZWZpbmUgdGhlIGRhdGEgdHlwZVxyXG4gICAgICAgICAqIHJlcXVlc3RlZCB3aGVuIFJlc3BvbnNpdmUgZ2V0cyB0aGUgZGF0YSB0byBzaG93IGluIHRoZSBjaGlsZCByb3cuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9ydGhvZ29uYWw6ICdkaXNwbGF5J1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIEFQSVxyXG4gICAgICovXHJcbiAgICB2YXIgQXBpID0gJC5mbi5kYXRhVGFibGUuQXBpO1xyXG5cclxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgLSB3b3JrIGFyb3VuZCBmb3IgYSBidWcgaW4gRFQuLi4gTm90IGRvY3VtZW50ZWRcclxuICAgIEFwaS5yZWdpc3RlcigncmVzcG9uc2l2ZSgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgQXBpLnJlZ2lzdGVyKCdyZXNwb25zaXZlLmluZGV4KCknLCBmdW5jdGlvbiAobGkpIHtcclxuICAgICAgICBsaSA9ICQobGkpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2x1bW46IGxpLmRhdGEoJ2R0ci1pbmRleCcpLFxyXG4gICAgICAgICAgICByb3c6IGxpLnBhcmVudCgpLmRhdGEoJ2R0ci1pbmRleCcpXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIEFwaS5yZWdpc3RlcigncmVzcG9uc2l2ZS5yZWJ1aWxkKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4Ll9yZXNwb25zaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguX3Jlc3BvbnNpdmUuX2NsYXNzTG9naWMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgQXBpLnJlZ2lzdGVyKCdyZXNwb25zaXZlLnJlY2FsYygpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5fcmVzcG9uc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgY3R4Ll9yZXNwb25zaXZlLl9yZXNpemVBdXRvKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguX3Jlc3BvbnNpdmUuX3Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBBcGkucmVnaXN0ZXIoJ3Jlc3BvbnNpdmUuaGFzSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGN0eC5fcmVzcG9uc2l2ZSA/XHJcbiAgICAgICAgICAgICQuaW5BcnJheShmYWxzZSwgY3R4Ll9yZXNwb25zaXZlLnMuY3VycmVudCkgIT09IC0xIDpcclxuICAgICAgICAgICAgZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICBBcGkucmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5yZXNwb25zaXZlSGlkZGVuKCknLCAnY29sdW1uKCkucmVzcG9uc2l2ZUhpZGRlbigpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuX3Jlc3BvbnNpdmUgP1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX3Jlc3BvbnNpdmUucy5jdXJyZW50W2NvbHVtbl0gOlxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJzaW9uIGluZm9ybWF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZS52ZXJzaW9uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIFJlc3BvbnNpdmUudmVyc2lvbiA9ICcyLjIuMSc7XHJcblxyXG5cclxuICAgICQuZm4uZGF0YVRhYmxlLlJlc3BvbnNpdmUgPSBSZXNwb25zaXZlO1xyXG4gICAgJC5mbi5EYXRhVGFibGUuUmVzcG9uc2l2ZSA9IFJlc3BvbnNpdmU7XHJcblxyXG4gICAgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlIGRvY3VtZW50IHdoaWNoIGxpc3RlbnMgZm9yIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb25cclxuICAgIC8vIGV2ZW50cyBzbyB3ZSBjYW4gYXV0b21hdGljYWxseSBpbml0aWFsaXNlXHJcbiAgICAkKGRvY3VtZW50KS5vbigncHJlSW5pdC5kdC5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcclxuICAgICAgICBpZiAoZS5uYW1lc3BhY2UgIT09ICdkdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCQoc2V0dGluZ3MublRhYmxlKS5oYXNDbGFzcygncmVzcG9uc2l2ZScpIHx8XHJcbiAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5oYXNDbGFzcygnZHQtcmVzcG9uc2l2ZScpIHx8XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm9Jbml0LnJlc3BvbnNpdmUgfHxcclxuICAgICAgICAgICAgRGF0YVRhYmxlLmRlZmF1bHRzLnJlc3BvbnNpdmVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIGluaXQgPSBzZXR0aW5ncy5vSW5pdC5yZXNwb25zaXZlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluaXQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgUmVzcG9uc2l2ZShzZXR0aW5ncywgJC5pc1BsYWluT2JqZWN0KGluaXQpID8gaW5pdCA6IHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gUmVzcG9uc2l2ZTtcclxufSkpOyJdfQ==
